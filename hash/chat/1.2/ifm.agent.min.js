
//============================================================================

// Copyright (c) Base Digitale Platform. All rights reserved.

//============================================================================

"use strict";
var global = global || window;
if (Object.defineProperty) {
  Object.defineProperty(global, "T0", {value: +new Date})
}
else {
  var T0 = +new Date
}
var dT = function() {
    return new Date - T0
  };
function defineEvents(names) {
  var eventbox = {};
  for (var i = 0; i < arguments.length; i++) {
    var name = arguments[i];
    if (!Ifm.Type.isString(name)) {
      throw Ifm.Diagnostics.Errors.arg("name");
    }
    createEventAccessors(eventbox, name)
  }
  return eventbox
}
function createEventAccessors(owner, name) {
  var evt = new Ifm.Event;
  Object.defineProperty(owner, name, {
    get: function() {
      return evt
    }, set: function(handler) {
        evt.addHandler(handler)
      }
  })
}
function inherits(ctorClass, ctorBase) {
  if (!Ifm.Type.isFunction(ctorClass))
    throw Ifm.Diagnostics.Errors.func("ctorClass");
  if (!Ifm.Type.isFunction(ctorBase))
    throw Ifm.Diagnostics.Errors.func("ctorBase");
  ctorClass.prototype = Object.create(ctorBase.prototype);
  ctorClass.prototype.constructor = ctorClass;
  return ctorBase.prototype
}
;
function namespace(globalNamespace, factory) {
  var ns = window,
    parts = globalNamespace.split('.');
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    ns[part] = ns[part] || {};
    ns = ns[part]
  }
  if (typeof factory === typeof namespace) {
    factory.call(ns)
  }
  else {
    for (var e in factory) {
      ns[e] = factory[e]
    }
  }
  return ns
}
function query(url) {
  var query = url || window.location.search,
    pairs = {};
  query.replace(/[?&#]([^=]+)=([^&]*)?/g, function(match, key, val) {
    if (key)
      pairs[key] = val || "";
    return ""
  });
  return pairs
}
Function.getName = function(func) {
  if (!Ifm.Type.isFunction(func))
    throw Ifm.Diagnostics.Errors.func("func");
  var res = /function\s+(\w+)/.exec(func);
  if (res && res.length === 2)
    return res[1];
  res = /(\w+)\s*=\s*function/.exec(func);
  if (res && res.length === 2)
    return res[1];
  return 'anonymous function'
};
Function.prototype.toShortString = function() {
  var body = this.toString().replace(/[\r|\n]/g, '').replace(/[\s]+/g, ' ');
  return body.substr(0, body.indexOf('{')).trim()
};
Array.pushArray = function(array1, array2) {
  if (!Ifm.Type.isArray(array1))
    throw Ifm.Diagnostics.Errors.arg("array1");
  if (!Ifm.Type.isArray(array2))
    throw Ifm.Diagnostics.Errors.arg("array2");
  return Array.prototype.push.apply(array1, array2)
};
if (!Array.prototype.find) {
  try {
    Object.defineProperty(Array.prototype, "find", {
      enumerable: false, value: function(func, thisArg) {
          if (!Ifm.Type.isFunction(func))
            throw Ifm.Diagnostics.Errors.func("func");
          for (var i = 0, len = this.length; i < len; i++) {
            if (i in this && func.call(thisArg, this[i], i, this)) {
              return this[i]
            }
          }
          return undefined
        }
    })
  }
  catch(e) {}
}
if (window.ArrayBuffer) {
  ArrayBuffer.fromBytes = function(bytes) {
    var len = bytes.length;
    var buffer = new ArrayBuffer(len);
    var bufView = new Uint8Array(buffer);
    for (var i = 0; i < len; i++) {
      bufView[i] = bytes[i]
    }
    return buffer
  };
  ArrayBuffer.prototype.getBytes = function() {
    var bufView = new Uint8Array(this);
    var bytes = [];
    for (var i = 0, l = bufView.length; i < l; i++) {
      bytes.push(bufView[i])
    }
    return bytes
  }
}
if (!Object.entries) {
  Object.entries = function(obj) {
    var e = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        e.push([i, obj[i]]);
    return e
  }
}
if (!Object.keys) {
  Object.keys = function(obj) {
    var k = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        k.push(i);
    return k
  }
}
if (!Object.values) {
  Object.values = function(obj) {
    var v = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        v.push(obj[i]);
    return v
  }
}
String.format = function(str, formatargs) {
  if (!str || !Ifm.Type.isString(str))
    return str;
  var args = Array.prototype.slice.call(arguments, 1);
  return str.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] !== 'undefined' ? args[number] : ''
    })
};
String.prototype.format = function(formatargs) {
  var args = [this];
  Array.prototype.push.apply(args, arguments);
  return String.format.apply(null, args)
};
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(str, position) {
    position = position || 0;
    return this.substr(position, str.length) === str
  }
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(str, position) {
    position = position || this.length;
    var start = Math.max(position - str.length, 0);
    return this.slice(start, position) === str
  }
}
if (!String.prototype.trim) {
  String.prototype.trim = function() {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
  }
}
String.prototype.indexAfter = function(str) {
  var p = this.indexOf(str);
  return p + (p < 0 ? 0 : str.length)
};
String.prototype.lastIndexAfter = function(str) {
  var p = this.lastIndexOf(str);
  return p + (p < 0 ? 0 : str.length)
};
if (!Date.now) {
  Date.now = function() {
    return +new Date
  }
}
if (!Date.prototype.toISOString) {
  (function() {
    function pad(number) {
      var r = String(number);
      if (r.length === 1) {
        r = '0' + r
      }
      return r
    }
    Date.prototype.toISOString = function() {
      return this.getUTCFullYear() + '-' + pad(this.getUTCMonth() + 1) + '-' + pad(this.getUTCDate()) + 'T' + pad(this.getUTCHours()) + ':' + pad(this.getUTCMinutes()) + ':' + pad(this.getUTCSeconds()) + '.' + String((this.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5) + 'Z'
    }
  })()
}
if (!Date.prototype.toISOLocaleDateString) {
  Date.prototype.toISOLocaleDateString = function() {
    var yyyy = '' + this.getFullYear(),
      mm = '' + (this.getMonth() + 1),
      dd = '' + this.getDate();
    if (mm.length < 2)
      mm = '0' + mm;
    if (dd.length < 2)
      dd = '0' + dd;
    return yyyy + '-' + mm + '-' + dd
  }
}
namespace("Ifm", function() {
  Ifm.version = "Ifm.js/1.0.92-4649";
  this.Objects = {deepMerge: function recursive(o1, o2, skipNullOrUndefined) {
      for (var i in o2) {
        if (typeof o2[i] === typeof{}) {
          if (o2[i] === null) {
            if (skipNullOrUndefined !== true) {
              o1[i] = null
            }
          }
          else if (typeof o1[i] !== typeof{} || o1[i] === null) {
            o1[i] = {}
          }
          recursive(o1[i], o2[i], skipNullOrUndefined)
        }
        else {
          if (o2[i] !== undefined || skipNullOrUndefined !== true) {
            o1[i] = o2[i]
          }
        }
      }
      return o1
    }};
  this.Enum = {};
  this.Enum.getName = function(enumObject, value) {
    var names = Object.getOwnPropertyNames(enumObject);
    for (var i = 0, l = names.length; i < l; i++) {
      var name = names[i];
      if (enumObject[name] === value) {
        return name
      }
    }
    return ''
  };
  this.Enum.getLength = function(enumObject) {
    return Object.getOwnPropertyNames(enumObject).length
  };
  this.Type = {};
  this.Type.getTypeName = function(o) {
    var ecmaname = Object.prototype.toString.call(o).slice(8, -1);
    if (ecmaname === 'Object') {
      var ctorname = o && o.constructor && o.constructor.toString().match(/function\s+([^\s]{1,})\s*\(/);
      if (ctorname)
        return ctorname[1]
    }
    return ecmaname
  };
  this.Type.isArray = function(o) {
    return Object.prototype.toString.call(o) === "[object Array]"
  };
  this.Type.isLikeArray = function(o) {
    return typeof o === 'object' && !Ifm.Type.isString(o) && typeof o.length === 'number' && !o.propertyIsEnumerable('length')
  };
  this.Type.isFunction = function(o) {
    return typeof o === 'function'
  };
  this.Type.isNumber = function(o) {
    return typeof o === 'number'
  };
  this.Type.isString = function(o) {
    return typeof o === 'string' || o instanceof String
  };
  this.Event = function() {
    if (!(this instanceof Ifm.Event))
      throw Ifm.Diagnostics.Errors.ctor();
    var handlers = [];
    return {
        constructor: Ifm.Event, addHandler: function(func, owner = null, once = false) {
            if (!Ifm.Type.isFunction(func))
              return;
            handlers.push({
              func, owner, once
            })
          }, hasHandlers: function() {
            return handlers.length > 0
          }, removeAllHandlers: function() {
            handlers.length = 0
          }, removeHandler: function(func) {
            var len = handlers.length;
            while (len--) {
              if (handlers[len].func === func) {
                handlers.splice(len, 1)
              }
            }
          }, raise: function(args) {
            var len = handlers.length;
            while (len--) {
              var h = handlers[len];
              h.func.apply(h.owner, arguments);
              if (h.once) {
                handlers.splice(len, 1)
              }
            }
          }
      }
  }
});
namespace("Ifm.Diagnostics", function() {
  this.Debug = {};
  this.Debug.onprint = new Ifm.Event;
  this.Debug.enabled = false;
  this.Debug.popupAssertions = false;
  this.Debug.assert = function __assert(condition, message) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    if (Ifm.Type.isString(condition)) {
      try {
        var tester = new Function("return " + condition);
        Ifm.Diagnostics.Debug.assert(tester(), condition + ' ' + message)
      }
      catch(e) {
        Ifm.Diagnostics.Debug.fail("Invalid assert condition '" + condition + "' : " + e.message)
      }
      return
    }
    if (!condition)
      Ifm.Diagnostics.Debug.fail(message)
  };
  this.Debug.fail = function __fail(message) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    var st = arguments[1];
    var fn = arguments[2] || __fail;
    if (!st) {
      try {
        throw new Error("Assertion failed");
      }
      catch(e) {
        st = e.stack || "[Callstack not available]"
      }
    }
    window.console && console.error && console.error(message, st);
    Ifm.Diagnostics.Debug.popupAssertions && alert(message + "\n\n----Stack----\n\n" + st)
  };
  this.Debug.clear = function() {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    window.console && console.clear && console.clear();
    var conview = document.getElementById("consoleview");
    if (conview) {
      conview.innerHTML = ''
    }
  };
  this.Debug.print = function(str) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    var line = arguments.length > 1 ? Array.prototype.slice.call(arguments).join(' ') : str && str.toString() || null;
    if (line === null) {
      return
    }
    window.console && console.log && console.log(line);
    Ifm.Diagnostics.Debug.onprint.raise(line);
    var conview = document.getElementById("consoleview");
    if (conview) {
      conview.innerHTML += line + "<br>";
      conview.scrollTop = conview.scrollHeight
    }
  };
  this.Debug.printf = function(format, args) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    Ifm.Diagnostics.Debug.print(String.format.apply(null, arguments))
  };
  this.Errors = (function() {
    var instance = {};
    instance.arg = function(name) {
      return _error("Invalid function argument", name)
    };
    instance.argsno = function(num) {
      return _error("Invalid number of function arguments", num)
    };
    instance.browser = function() {
      return _error("Browser not supported")
    };
    instance.ctor = function(name) {
      return _error("Invalid constructor call", name)
    };
    instance.func = function(name) {
      return _error("Function argument expected", name)
    };
    instance.miss = function(name) {
      return _error("Missing type or module", name)
    };
    instance.notimpl = function(name) {
      return _error("Feature not implemented", name)
    };
    instance.notsup = function(name) {
      return _error("Feature not supported", name)
    };
    instance.op = function(state) {
      return _error("Invalid operation", state)
    };
    function _error(error, name) {
      return new Error(error + (name ? ": '" + name + "'" : ""))
    }
    return instance
  })()
});
;
namespace("Ifm.Messaging");
(function() {
  this.FMessage = {
    HeaderLength: 18, LengthPosition: 16, ExtLenPosition: 12, DataPosition: 20, MessageHeaderId: 0x55555555
  };
  this.FMessageReader = function(messageBuffer) {
    if (!messageBuffer) {
      throw new Error("FMessageReader() -> Invalid message buffer");
    }
    this._bytes = [];
    this._readingpos = 0;
    if (messageBuffer instanceof ArrayBuffer) {
      this._bytes = messageBuffer.getBytes()
    }
    else if (messageBuffer instanceof Array) {
      this._bytes = messageBuffer
    }
    else {
      throw new Error("FMessageReader() -> Unsupported message data format: " + typeof messageBuffer);
    }
    if (this._bytes.length < Ifm.Messaging.FMessage.DataPosition) {
      throw new Error("FMessageReader() -> Invalid message length: " + this._bytes.length);
    }
    var headerId = this.nextInt32();
    if (headerId !== Ifm.Messaging.FMessage.MessageHeaderId) {
      throw new Error("FMessageReader() -> Invalid FMessage signature: " + headerId.toString(16));
    }
    this._readingpos = Ifm.Messaging.FMessage.LengthPosition;
    this.length = this.nextInt16();
    if (this.length === 0) {
      this._readingpos = Ifm.Messaging.FMessage.ExtLenPosition;
      this.length = this.nextInt32();
      if (this.length === 0) {
        throw new Error("FMessageReader() -> Invalid FMessage length");
      }
    }
    this._readingpos = Ifm.Messaging.FMessage.HeaderLength;
    this.code = this.nextInt16()
  };
  this.FMessageReader.prototype.remainingBytes = function() {
    return this.length + Ifm.Messaging.FMessage.HeaderLength - this._readingpos
  };
  this.FMessageReader.prototype.nextByte = function() {
    if (this._readingpos < this._bytes.length) {
      return this._bytes[this._readingpos++]
    }
    throw new Error("FMessageReader.nextByte() -> No more bytes to read: " + this._readingpos);
  };
  this.FMessageReader.prototype.nextBool = function() {
    return this.nextByte() === 0 ? false : true
  };
  this.FMessageReader.prototype.nextBool32 = function() {
    return this.nextInt32() === 0 ? false : true
  };
  this.FMessageReader.prototype.nextInt16 = function() {
    return (this.nextByte() << 8) + this.nextByte()
  };
  this.FMessageReader.prototype.nextInt32 = function() {
    return (this.nextInt16() << 16) + this.nextInt16()
  };
  this.FMessageReader.prototype.nextInt64 = function() {
    return (this.nextInt32() << 32) + this.nextInt32()
  };
  this.FMessageReader.prototype.nextString = function() {
    var strlen = this.nextInt16();
    var bytes = [];
    for (var i = 0; i < strlen; i++) {
      bytes.push(this.nextByte())
    }
    return String.fromCharCode.apply(null, bytes)
  };
  this.FMessageReader.prototype.nextUniString = function() {
    var strlen = this.nextInt16();
    var bytes = [];
    for (var i = 0; i < strlen; i++) {
      bytes.push(this.nextByte());
      bytes.push(this.nextByte() << 8)
    }
    return String.fromCharCode.apply(null, bytes)
  };
  this.FMessageWriter = function(code) {
    this._bytes = [];
    this._len = 0;
    this.addInt32(Ifm.Messaging.FMessage.MessageHeaderId);
    this.addInt32(0);
    this.addInt32(0);
    this.addInt32(0);
    this.addInt16(0);
    this._len = 0;
    this.addInt16(code);
    this.code = code
  };
  this.FMessageWriter.prototype.addByte = function(byte) {
    this._bytes.push(byte);
    this._len++;
    return this
  };
  this.FMessageWriter.prototype.addBool = function(bool) {
    this.addByte(bool ? 1 : 0);
    return this
  };
  this.FMessageWriter.prototype.addBool32 = function(bool) {
    this.addInt32(bool ? 1 : 0);
    return this
  };
  this.FMessageWriter.prototype.addInt16 = function(short) {
    this.addByte((0xFF00 & short) >> 8);
    this.addByte(0x00FF & short);
    return this
  };
  this.FMessageWriter.prototype.addInt32 = function(int) {
    this.addInt16((0xFFFF0000 & int) >> 16);
    this.addInt16(0x0000FFFF & int);
    return this
  };
  this.FMessageWriter.prototype.addInt64 = function(long) {
    this.addInt32((0xFFFFFFFF00000000 & long) >> 32);
    this.addInt32(0x00000000FFFFFFFF & long);
    return this
  };
  this.FMessageWriter.prototype.addString = function(str) {
    var strlen = (str && str.length) || 0;
    this.addInt16(strlen);
    for (var i = 0; i < strlen; i++) {
      this.addByte(str.charCodeAt(i))
    }
    return this
  };
  this.FMessageWriter.prototype.addUniString = function(str) {
    var strlen = (str && str.length) || 0;
    this.addInt16(strlen);
    for (var i = 0; i < strlen; i++) {
      this.addByte(0x00FF & str.charCodeAt(i));
      this.addByte((0xFF00 & str.charCodeAt(i)) >> 8)
    }
    return this
  };
  this.FMessageWriter.prototype.end = function() {
    this._bytes[Ifm.Messaging.FMessage.LengthPosition] = (0xFF00 & this._len) >> 8;
    this._bytes[Ifm.Messaging.FMessage.LengthPosition + 1] = 0x00FF & this._len
  };
  this.FMessageWriter.prototype.toArrayBuffer = function() {
    return ArrayBuffer.fromBytes(this._bytes)
  }
}).call(Ifm.Messaging);
;
namespace("Ifm.Messaging");
(function(ns) {
  ns.FStringMessage = {
    MessageHeaderV1: "*begin*", MessageTypeDelV1: "%%%", MessageFieldDelV1: "###", MessageFooterV1: "\xA7end\xA7", MessageHeaderV2: "\x7Cbegin\x7C", MessageTypeDelV2: "\x7C%\x7C", MessageFieldDelV2: "\x7C#\x7C", MessageFooterV2: "\x7Cend\x7C", MinValidLength: 16, ProtocolVersion: "V1"
  };
  ns.FStringMessageReader = function(messageBuffer) {
    if (!(this instanceof Ifm.Messaging.FStringMessageReader)) {
      throw Ifm.Diagnostics.Errors.ctor("Ifm.Messaging.FStringMessageReader");
    }
    if (!messageBuffer) {
      throw Ifm.Diagnostics.Errors.arg("messageBuffer");
    }
    this._message = '';
    this._readingpos = 0;
    if (Ifm.Type.isString(messageBuffer)) {
      this._message = messageBuffer
    }
    else {
      throw new Error("FStringMessageReader() -> Unsupported message data format: " + typeof messageBuffer);
    }
    if (this._message.length < ns.FStringMessage.MinValidLength) {
      throw new Error("FStringMessageReader() -> Invalid message length: " + this._message.length);
    }
    if (this._message.startsWith(ns.FStringMessage.MessageHeaderV1)) {
      var matches = this._message.match(/^\*begin\*([A-z0-9]*)%{3}/);
      if (matches && matches.length == 2) {
        this.type = matches[1]
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage type format");
      }
      matches = this._message.match(/%{3}(.*)[\xA7|$]end[\xA7|$]/);
      if (matches && matches.length == 2) {
        this.data = matches[1].split(ns.FStringMessage.MessageFieldDelV1)
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage data format");
      }
    }
    else if (this._message.startsWith(ns.FStringMessage.MessageHeaderV2)) {
      var matches = this._message.match(/^\x7Cbegin\x7C([A-z0-9]*)\x7C%\x7C/);
      if (matches && matches.length == 2) {
        this.type = matches[1]
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage type format");
      }
      matches = this._message.match(/\x7C%\x7C(.*)[\x7C]end[\x7C]/);
      if (matches && matches.length == 2) {
        this.data = matches[1].split(ns.FStringMessage.MessageFieldDelV2)
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage data format");
      }
    }
    else {
      throw new Error("FStringMessageReader() -> Invalid FStringMessage signature");
    }
  };
  ns.FStringMessageWriter = function FStringMessageWriter(type, protocolVersion) {
    if (!(this instanceof Ifm.Messaging.FStringMessageWriter)) {
      throw Ifm.Diagnostics.Errors.ctor("Ifm.Messaging.FStringMessageWriter");
    }
    if (!Ifm.Type.isString(type)) {
      throw Ifm.Diagnostics.Errors.arg("type");
    }
    this._dataAdded = false;
    this.type = type;
    if (protocolVersion === "V2") {
      ns.FStringMessage.protocolVersion = protocolVersion;
      this._message = ns.FStringMessage.MessageHeaderV2 + type + ns.FStringMessage.MessageTypeDelV2
    }
    else {
      ns.FStringMessage.protocolVersion = "V1";
      this._message = ns.FStringMessage.MessageHeaderV1 + type + ns.FStringMessage.MessageTypeDelV1
    }
  };
  ns.FStringMessageWriter.prototype.add = function(str) {
    if (str === undefined || str === null) {
      throw Ifm.Diagnostics.Errors.arg("str");
    }
    if (ns.FStringMessage.protocolVersion === 'V1') {
      if (this._dataAdded) {
        this._message += ns.FStringMessage.MessageFieldDelV1
      }
      this._message += str;
      this._dataAdded = true
    }
    else {
      if (this._dataAdded) {
        this._message += ns.FStringMessage.MessageFieldDelV2
      }
      this._message += str;
      this._dataAdded = true
    }
    return this
  };
  ns.FStringMessageWriter.prototype.end = function() {
    if (ns.FStringMessage.protocolVersion === 'V1') {
      this._message += ns.FStringMessage.MessageFooterV1
    }
    else {
      this._message += ns.FStringMessage.MessageFooterV2
    }
    return this
  };
  ns.FStringMessageWriter.prototype.toString = function() {
    return this._message
  }
})(Ifm.Messaging);
namespace("Ifm.Messaging");
(function() {
  this.FMessageBuilder = function() {
    if (!window.ArrayBuffer) {
      throw new Error("FMessageBuilder() -> ArrayBuffer not supported");
    }
    this.message = new Ifm.Event;
    this._buffer = [];
    this.toString = function() {
      return "[object FMessageBuilder]"
    }
  };
  this.FMessageBuilder.isSupported = function() {
    return (window.ArrayBuffer) ? true : false
  };
  this.FMessageBuilder.prototype.append = function(buffer) {
    if (!buffer) {
      throw new Error("FMessageBuilder.append() -> Invalid message buffer");
    }
    else if (buffer instanceof ArrayBuffer) {
      Array.pushArray(this._buffer, buffer.getBytes())
    }
    else if (buffer instanceof Array) {
      Array.pushArray(this._buffer, buffer)
    }
    else {
      throw new Error("FMessageBuilder.append() -> Unsupported message data format: " + typeof buffer);
    }
    while (this._buffer.length > Ifm.Messaging.FMessage.HeaderLength) {
      var message = new Ifm.Messaging.FMessageReader(this._buffer);
      if ((Ifm.Messaging.FMessage.HeaderLength + message.length) <= this._buffer.length) {
        try {
          this.message.raise(this, {message: message})
        }
        catch(e) {
          console.error(e);
          Ifm.Diagnostics.Debug.print(this, "Error dispatching or processing message:", e.message);
          Ifm.Diagnostics.Debug.print(e.stack)
        }
        this._buffer.splice(0, Ifm.Messaging.FMessage.HeaderLength + message.length)
      }
    }
  }
}).call(Ifm.Messaging);
;
(function() {
  var ns = namespace("Ifm.Messaging");
  var This = ns.FPort = function FPort() {
      if (!(this instanceof FPort))
        throw Ifm.Diagnostics.Errors.ctor();
      this.opened = new Ifm.Event;
      this.closed = new Ifm.Event;
      this.message = new Ifm.Event
    };
  This.isSupported = function() {
    return global.WebSocket && global.ArrayBuffer ? true : false
  };
  var proto = This.prototype;
  proto.isClosed = function() {
    return (this._websocket && this._websocket.readyState === WebSocket.CLOSED) || true
  };
  proto.isOpen = function() {
    return (this._websocket && this._websocket.readyState === WebSocket.OPEN) || false
  };
  proto.open = function(address, opt_protocol) {
    if (!This.isSupported())
      throw Ifm.Diagnostics.Errors.notsup("FPort");
    if (!address)
      throw Ifm.Diagnostics.Errors.arg("address");
    if (this.isOpen())
      throw Ifm.Diagnostics.Errors.op("port open");
    var port = this;
    var msgBuilder = new Ifm.Messaging.FMessageBuilder;
    msgBuilder.message.addHandler(function(sender, e) {
      this.message.raise(port, {reader: e.message})
    }, this);
    this._closedhere = false;
    this._wasconnected = false;
    this._gateway = false;
    this._localPort = null;
    Ifm.Diagnostics.Debug.print("[FPort] connecting to " + address);
    try {
      if (opt_protocol) {
        this._websocket = new WebSocket(address, opt_protocol)
      }
      else {
        this._websocket = new WebSocket(address)
      }
      this._websocket.binaryType = 'arraybuffer';
      this._remoteAddress = address
    }
    catch(err) {
      Ifm.Diagnostics.Debug.print("[FPort] connection failed: " + err.message);
      port.closed.raise(port, {
        clean: false, failed: true, lost: false, reason: err.message
      });
      return
    }
    this._websocket.onmessage = function(e) {
      if (Ifm.Type.isString(e.data)) {
        var parts = e.data.split("|");
        switch (parts[0]) {
          case"#ready":
            Ifm.Diagnostics.Debug.print("[FPort] ready");
            port._websocket.send("#qlp");
            port._wasconnected = true;
            port.opened.raise(port, {
              address: address, gateway: port._gateway
            });
            return;
          case"#qlp":
            port._localPort = Number(parts[1]);
            return;
          case"#close":
            var code = parts.length > 1 ? parts[1] : "0";
            var reason = code + getCloseReason(code);
            Ifm.Diagnostics.Debug.printf("[FPort] closed ({0})", reason);
            return;
          default:
            if (parts[0].startsWith('#')) {
              return
            }
            break
        }
        var reader;
        try {
          reader = new Ifm.Messaging.FStringMessageReader(e.data)
        }
        catch(err) {
          Ifm.Diagnostics.Debug.printf("[FPort] invalid message {0}", e.data);
          Ifm.Diagnostics.Debug.print(err);
          return
        }
        port.message.raise(port, {reader: reader})
      }
      else if (e.data instanceof ArrayBuffer) {
        msgBuilder.append(e.data)
      }
      else {
        Ifm.Diagnostics.Debug.printf("[FPort] unknown message {0}", e.data)
      }
    };
    this._websocket.onclose = function(e) {
      Ifm.Diagnostics.Debug.print("[FPort] closed" + (!port._wasconnected ? " (connection failed)" : (!port._closedhere ? " (connection lost)" : "")));
      port.closed.raise(port, {
        clean: port._closedhere, failed: !port._wasconnected, lost: port._wasconnected && !port._closedhere, reason: port._closedhere ? "" : "Connection to " + address + " " + (!port._wasconnected ? "failed" : (e.reason ? e.reason : "lost"))
      });
      delete port._localPort;
      delete port._remoteAddress;
      delete port._websocket
    }
  };
  proto.close = function() {
    if (!this.isClosed())
      return;
    this._closedhere = true;
    this._websocket.close()
  };
  proto.send = function(message) {
    if (!message || !this.isOpen())
      return;
    if (message instanceof Ifm.Messaging.FMessageWriter) {
      this._websocket.send(message.toArrayBuffer())
    }
    else if (message instanceof Ifm.Messaging.FStringMessageWriter) {
      this._websocket.send(message.toString())
    }
    else {
      throw Error("Unsupported message format: " + message + " (" + Ifm.Type.getTypeName(message) + ")");
    }
  };
  function getCloseReason(code) {
    switch (code) {
      case"403":
        return ": no destination for protocol";
      case"500":
        return ": client-gateway protocol error";
      case"502":
        return ": gateway-server protocol error";
      case"503":
        return ": no destination reachable";
      default:
        return ""
    }
  }
})();
(function() {
  var ns = namespace("Ifm.Messaging");
  ns.FConnection = function() {
    if (!(this instanceof Ifm.Messaging.FConnection))
      throw Ifm.Diagnostics.Errors.ctor();
    var port = null;
    var disconnectionCause = null;
    return {
        constructor: ns.FConnection, events: defineEvents("connecting", "connected", "disconnecting", "disconnected", "binarymessage", "stringmessage"), isSupported: function() {
            return !!(port && port.isSupported())
          }, isClosed: function() {
            return !!(port && port.isClosed())
          }, isConnected: function() {
            return !!(port && port.isOpen())
          }, getAddress: function() {
            return port && port._remoteAddress || ""
          }, getLocalPort: function() {
            return port && port._localPort || null
          }, connect: function(address, protocol, onconnected) {
            if (this.isConnected())
              return true;
            if (!address || Ifm.Type.isArray(address) && address.length === 0)
              throw Ifm.Diagnostics.Errors.arg("address");
            port = new Ifm.Messaging.FPort;
            port.opened.addHandler(function(sender, e) {
              this.events.connected.raise(this);
              if (Ifm.Type.isFunction(onconnected))
                onconnected()
            }, this);
            port.closed.addHandler(function(sender, e) {
              if (e.failed && Ifm.Type.isArray(address) && address.length > 1) {
                this.connect(address.slice().splice(1), protocol, onconnected);
                return
              }
              this.events.disconnected.raise(this, disconnectionCause || e);
              disconnectionCause = null
            }, this);
            port.message.addHandler(function(sender, e) {
              if (e.reader instanceof Ifm.Messaging.FStringMessageReader) {
                this.events.stringmessage.raise(this, e)
              }
              else if (e.reader instanceof Ifm.Messaging.FMessageReader) {
                this.events.binarymessage.raise(this, e)
              }
              else {
                Ifm.Diagnostics.Debug.fail("Invalid messageReader");
                return
              }
            }, this);
            this.events.connecting.raise(this, {address: address});
            if (Ifm.Type.isArray(address)) {
              port.open(address[0], protocol)
            }
            else {
              port.open(address, protocol)
            }
          }, disconnect: function(opt_cause) {
            if (!this.isConnected())
              return true;
            disconnectionCause = opt_cause || null;
            this.events.disconnecting.raise(this);
            port.close()
          }, send: function(message) {
            if (!message)
              throw Ifm.Diagnostics.Errors.arg("message");
            if (!this.isConnected()) {
              console.warn("[Ifm.Messaging.FConnection] Can't send, not connected");
              return
            }
            port.send(message)
          }
      }
  }
})();
;
namespace("Ifm.Messaging").FPropertyList = function(pliststr) {
  if (!(this instanceof Ifm.Messaging.FPropertyList)) {
    throw Ifm.Diagnostics.Errors.ctor();
  }
  if (!pliststr || !Ifm.Type.isString(pliststr)) {
    throw Ifm.Diagnostics.Errors.arg("pliststr");
  }
  pliststr = pliststr.trim();
  var list = {},
    sort = [],
    match;
  var re = /{\s*([^\s{]*)\s*=\s*([^}]*)}/g;
  while (match = re.exec(pliststr)) {
    list[match[1]] = match[2];
    sort.push(match[1])
  }
  this.events = defineEvents("changed");
  this.originalString = pliststr;
  this.get = function(key) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    return list[key]
  };
  this.keys = function() {
    var properties = [];
    for (var p in list) {
      properties.push(p)
    }
    return properties
  };
  this.remove = function(key) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    if (list.hasOwnProperty(key)) {
      delete list[key];
      var len = sort.length;
      while (len--) {
        if (sort[len] === key) {
          sort.splice(len, 1);
          this.events.changed.raise(this, {
            key: key, value: undefined
          })
        }
      }
    }
  };
  this.set = function(key, value) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    if (value !== undefined) {
      if (!list.hasOwnProperty(key)) {
        sort.push(key)
      }
      if (list[key] !== value) {
        list[key] = value;
        this.events.changed.raise(this, {
          key: key, value: value
        })
      }
    }
  };
  this.toString = function() {
    var pliststr = "{";
    for (var i = 0; i < sort.length; i++) {
      pliststr += "{" + sort[i] + " = " + list[sort[i]] + "}"
    }
    return pliststr + "}"
  }
};
;
namespace("Ifm.Net").WebSocket = (function() {
  var factory = {};
  factory.ErrorReasons = {
    Failed: "Connection failed", Lost: "Connection lost", Refused: "Connection refused"
  };
  factory.MessageType = {
    BINARY: "Binary", OBJECT: "Object", TEXT: "Text"
  };
  factory.isSupported = function() {
    return (global && global.Ifm && global.WebSocket) ? true : false
  };
  factory.create = function(url, protocol) {
    if (!factory.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("WebSocket");
    }
    if (!Ifm.Type.isString(url)) {
      throw Ifm.Diagnostics.Errors.arg("url");
    }
    var instance = {};
    instance.events = defineEvents("connecting", "open", "closing", "closed", "error", "receive");
    instance.id = (function() {
      return id += 1
    })();
    instance.connect = function() {
      if (ws && ws.readyState < WebSocket.CLOSING) {
        return
      }
      instance.events.connecting.raise(instance, {});
      try {
        if (protocol) {
          ws = new WebSocket(url, protocol)
        }
        else {
          ws = new WebSocket(url)
        }
      }
      catch(err) {
        instance.events.error.raise(instance, {error: err});
        instance.events.closed.raise(instance, {
          clean: false, reason: Ifm.Net.WebSocket.ErrorReasons.Failed
        });
        return
      }
      function open() {
        if (!wasOpen) {
          console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s", id, url, protocol, "onopen");
          wasOpen = true;
          instance.events.open.raise(instance, {})
        }
      }
      ;
      ws.onmessage = function(e) {
        if (Ifm.Type.isString(e.data)) {
          var s = e.data;
          if (s.startsWith("#close")) {
            var parts = s.split("|"),
              code = parts.length > 1 ? parts[1] : "0",
              reason = code + getCloseReason(code);
            console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s (%s)", id, url, protocol, "close notification", reason);
            return
          }
          open();
          if (s.startsWith("{") && s.endsWith("}")) {
            var o = null;
            try {
              o = JSON.parse(s)
            }
            catch(err) {}
            ;
            if (o !== null) {
              instance.events.receive.raise(instance, {
                type: factory.MessageType.OBJECT, message: o
              });
              return
            }
          }
          instance.events.receive.raise(instance, {
            type: factory.MessageType.TEXT, message: s
          })
        }
        else {
          open();
          instance.events.receive.raise(instance, {
            type: factory.MessageType.BINARY, message: e.data
          })
        }
      };
      ws.onclose = function(e) {
        console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s (code: %d)", id, url, protocol, "onclose", e.code);
        instance.events.closed.raise(instance, {
          clean: e.wasClean, reason: (e.wasClean ? "" : (wasOpen ? Ifm.Net.WebSocket.ErrorReasons.Lost : Ifm.Net.WebSocket.ErrorReasons.Refused))
        });
        wasOpen = false;
        ws = null
      };
      ws.onerror = function(e) {
        instance.events.error.raise(instance, e)
      }
    };
    instance.close = function() {
      console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s", id, url, protocol, "close");
      if (!ws || ws.readyState === WebSocket.CLOSED) {
        return
      }
      instance.events.closing.raise(instance, {});
      ws.close()
    };
    instance.send = function(message) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        throw Ifm.Diagnostics.Errors.op("WebSocket not open");
      }
      ws.send(message)
    };
    Object.defineProperties(instance, {
      isOpen: {get: function() {
          return instance.state === WebSocket.OPEN
        }}, state: {get: function() {
            return ws ? ws.readyState : WebSocket.CLOSED
          }}
    });
    var ws = null;
    var wasOpen = false;
    return instance
  };
  function getCloseReason(code) {
    switch (code) {
      case"403":
        return ": no destination for protocol";
      case"500":
        return ": client-gateway protocol error";
      case"502":
        return ": gateway-server protocol error";
      case"503":
        return ": no destination reachable";
      default:
        return ""
    }
  }
  var id = 0;
  return factory
})();
;
namespace("Ifm.Net").Peer = (function() {
  var factory = {};
  factory.isSupported = function() {
    return (Ifm && Ifm.Net && Ifm.Net.WebSocket && Ifm.Net.WebSocket.isSupported()) ? true : false
  };
  factory.query = function(url, protocol, query, callback) {
    factory.create(url, protocol, function(peer) {
      if (peer) {
        peer.query(query, function(response) {
          callback(response);
          peer.close()
        })
      }
      else {
        callback(null)
      }
    })
  };
  factory.create = function(url, protocol, callback) {
    if (!factory.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("Peer");
    }
    if (!Ifm.Type.isFunction(callback)) {
      throw Ifm.Diagnostics.Errors.func("callback");
    }
    var instance = {};
    instance.query = function(query, callback) {
      if (!Ifm.Type.isString(query)) {
        throw Ifm.Diagnostics.Errors.arg("query");
      }
      if (!Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      resetEvents();
      ws.events.closed = function(ws, e) {
        resetEvents();
        callback(null)
      };
      ws.events.receive = function(ws, e) {
        resetEvents();
        callback(e)
      };
      if (ws.isOpen) {
        ws.send(query)
      }
      else {
        callback(null)
      }
    };
    instance.receive = function(callback) {
      if (!Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      resetEvents();
      ws.events.closed = function(ws, e) {
        callback(null)
      };
      ws.events.receive = function(ws, e) {
        callback(e)
      }
    };
    instance.send = function(message) {
      if (ws.isOpen) {
        ws.send(message)
      }
    };
    instance.close = function() {
      resetEvents();
      ws.close()
    };
    function resetEvents() {
      ws.events.closed.removeAllHandlers();
      ws.events.receive.removeAllHandlers()
    }
    var ws = Ifm.Net.WebSocket.create(url, protocol);
    ws.events.closed = function(ws, e) {
      resetEvents();
      callback(null)
    };
    ws.events.receive = function(ws, e) {
      resetEvents();
      if (e.type === Ifm.Net.WebSocket.MessageType.TEXT) {
        var parts = e.message.split("|");
        switch (parts[0]) {
          case"#ready":
            callback(instance);
            return;
          case"#close":
            console.warn(parts[1] || "Forcibly closed by server");
            ws.close();
            callback(null);
            return
        }
      }
      console.warn("[Ifm.Net.Services.Peer] Unexpected message from server", e.message);
      ws.close();
      callback(null)
    };
    ws.connect();
    return instance
  };
  return factory
})();
;
namespace("Ifm.Net").TimeProvider = (function() {
  function TimeProvider(urls) {
    if (!(this instanceof TimeProvider))
      throw Ifm.Diagnostics.Errors.ctor('TimeProvider');
    if (!Ifm.Net.WebSocket)
      throw Ifm.Diagnostics.Errors.miss('Ifm.Net.WebSocket');
    if (!urls || Ifm.Type.isArray(urls) && urls.length === 0)
      throw Ifm.Diagnostics.Errors.arg('urls');
    urls = Ifm.Type.isArray(urls) ? urls : [urls];
    setTimeout(_connect.bind(this, urls, 0))
  }
  TimeProvider.getDefault = function() {
    if (Ifm.Net.timeProvider instanceof TimeProvider) {
      return Ifm.Net.timeProvider
    }
    if (TimeProvider.settings) {
      var urls = TimeProvider.settings.service;
      if (urls) {
        Ifm.Net.timeProvider = new TimeProvider(urls);
        return Ifm.Net.timeProvider
      }
    }
    return window
  };
  var I = TimeProvider.prototype;
  I.close = function() {
    this._closed = true;
    this._ws.close()
  };
  I.clearInterval = function(id) {
    _removeTimer.call(this, id)
  };
  I.clearTimeout = function(id) {
    _removeTimer.call(this, id)
  };
  I.setInterval = function(fn, delay, args) {
    if (!Ifm.Type.isFunction(fn))
      throw Ifm.Diagnostics.Errors.func('fn');
    args = skip(2, arguments);
    return _createTimer.call(this, TYPE_INTERVAL, delay, fn, args)
  };
  I.setTimeout = function(fn, delay, args) {
    if (!Ifm.Type.isFunction(fn))
      throw Ifm.Diagnostics.Errors.func('fn');
    args = skip(2, arguments);
    return _createTimer.call(this, TYPE_TIMEOUT, delay, fn, args)
  };
  function _connect(urls, index) {
    var url = index < urls.length ? urls[index] : urls[index = 0];
    if (url.startsWith('*')) {
      console.debug(THIS + ' Skipping unsupported url: ' + url);
      urls.splice(index, 1);
      if (urls.length > 0) {
        _connectNext.call(this, urls, index)
      }
      else {
        console.debug(THIS + ' No valid url to connect to, using native timers')
      }
      return
    }
    console.debug(THIS + ' Connecting to ' + url);
    var ws = Ifm.Net.WebSocket.create(url, 'itp');
    this._ws = ws;
    var self = this;
    ws.events.open = function(ws, e) {
      console.debug(THIS + ' Connected, using remote timers')
    };
    ws.events.closed = function(ws, e) {
      console.debug(THIS + ' ' + (e.reason || 'Disconnected'));
      _disconnectAllTimers.call(self);
      _connectNext.call(self, urls, index + 1)
    };
    ws.events.receive = function(ws, e) {
      console.assert(e.type === Ifm.Net.WebSocket.MessageType.TEXT);
      _receive.call(self, e.message)
    };
    ws.connect()
  }
  function _connectNext(urls, index) {
    if (!this._closed) {
      setTimeout(_connect.bind(this, urls, index + 1), 5000)
    }
  }
  function _createTimer(type, delay, fn, argArray) {
    var id = getNextId();
    timers[id] = {
      callback: fn.bind.apply(fn, [window].concat(argArray)), type: type, delay: delay, owner: this
    };
    if (this._ws && this._ws.isOpen) {
      _send.call(this, COMMAND_SET, id, type, delay > 0 ? delay : 0)
    }
    else {
      var nativeFn = type === TYPE_TIMEOUT ? setTimeout : setInterval;
      timers[id].nativeId = nativeFn(_tickTimer.bind(this, id), delay)
    }
    return id
  }
  function _disconnectAllTimers() {
    for (var id in timers) {
      if (!timers[id].nativeId && timers[id].owner === this) {
        if (timers[id].type === TYPE_TIMEOUT) {
          console.debug(THIS + ' Invoking immediate tick for timer ' + id);
          _tickTimer.call(this, id)
        }
        else if (timers[id].type === TYPE_INTERVAL) {
          console.debug(THIS + ' Converting remote to native timer ' + id);
          timers[id].nativeId = setInterval(timers[id].callback, timers[id].delay)
        }
      }
    }
  }
  function _removeTimer(id) {
    if (!id || !(id in timers))
      return;
    if (timers[id].nativeId) {
      clearTimeout(timers[id].nativeId)
    }
    else {
      _send.call(this, COMMAND_CLEAR, id)
    }
    delete timers[id]
  }
  function _receive(message) {
    var parts = message.split(MSG_SEP);
    console.assert(parts[0].startsWith(MSG_HDR));
    var event = parts[0].substr(1);
    if (event === EVENT_TICK) {
      var id = Number(parts[1]);
      _tickTimer.call(this, id)
    }
  }
  function _send(action, id, type, delay) {
    var args = [action, id];
    if (type !== undefined)
      args.push(type);
    if (delay !== undefined)
      args.push(delay);
    var message = MSG_HDR + args.join(MSG_SEP);
    this._ws.send(message)
  }
  function _tickTimer(id) {
    if (id && id in timers) {
      var timer = timers[id];
      timer.callback();
      if (timer.type === TYPE_TIMEOUT) {
        delete timers[id]
      }
    }
  }
  function skip(num, items) {
    return items.length > num ? Array.prototype.splice.call(items, num) : []
  }
  function getNextId() {
    nextId += 1;
    return nextId
  }
  var THIS = '[Ifm.Net.TimeProvider]';
  var COMMAND_CLEAR = 'clear';
  var COMMAND_SET = 'set';
  var EVENT_TICK = 'tick';
  var TYPE_INTERVAL = '0';
  var TYPE_TIMEOUT = '1';
  var MSG_HDR = '#';
  var MSG_SEP = '|';
  var nextId = 0;
  var timers = {};
  return TimeProvider
})();
;
namespace("Ifm.Net.Services").FileTransfer = (function() {
  var factory = {};
  factory.ErrorReasons = {
    Unavailable: "Service unavailable", RequestRefused: "Request refused", InvalidToken: "Invalid token", FileCorrupted: "File corrupted", FileReadError: "File read error", SecurityError: "Security error: {err}"
  };
  factory.isSupported = function() {
    return global && global.Ifm && Ifm.Net.Peer && Ifm.Net.Peer.isSupported() && global.File && global.FileList && global.FileReader && global.Blob ? true : false
  };
  factory.create = function(url) {
    if (!factory.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("FileTransfer");
    }
    var instance = {};
    instance.events = defineEvents("waiting", "started", "progress", "finished", "canceled", "error");
    instance.id = (function() {
      return id += 1
    })();
    instance.isSender = undefined;
    instance.enabled = function(callback) {
      if (!Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      Ifm.Net.Peer.query(url, protocol, "#enabled", function(e) {
        callback(e && e.message || false)
      })
    };
    instance.receive = function(token) {
      if (!Ifm.Type.isString(token)) {
        throw Ifm.Diagnostics.Errors.arg("token");
      }
      if (instance.isSender !== undefined) {
        throw Ifm.Diagnostics.Errors.op("FileTransfer instance already in use");
      }
      instance.isSender = false;
      var BIN = Ifm.Net.WebSocket.MessageType.BINARY;
      var OBJ = Ifm.Net.WebSocket.MessageType.OBJECT;
      var TXT = Ifm.Net.WebSocket.MessageType.TEXT;
      var errors = Ifm.Net.Services.FileTransfer.ErrorReasons;
      var blobs = [],
        name,
        size,
        type;
      var offset = 0;
      Ifm.Net.Peer.create(url, protocol, function(peer) {
        if (!peer) {
          instance.events.error.raise(instance, {reason: errors.Unavailable});
          return
        }
        instance.accept = function() {
          instance.accept = function(){};
          peer.send("#start")
        };
        instance.cancel = function() {
          instance.cancel = function(){};
          peer.send("#cancel");
          peer.close();
          instance.events.canceled.raise(instance, {})
        };
        peer.receive(function(e) {
          if (!e) {
            instance.events.error.raise(instance, {reason: errors.RequestRefused});
            return
          }
          if (e.type === TXT) {
            var parts = e.message.split("|");
            switch (parts[0]) {
              case"#invalidtoken":
                peer.close();
                instance.events.error.raise(instance, {reason: errors.InvalidToken});
                break;
              case"#cancel":
                instance.cancel();
                break;
              case"#paired":
                instance.events.waiting.raise(instance, {token: token});
                break;
              case"#info":
                name = parts[1];
                size = Number(parts[2]);
                type = parts[3];
                instance.events.started.raise(instance, {});
                break;
              case"#finished":
                instance.cancel = function(){};
                peer.close();
                var blob = new Blob(blobs, {type: type});
                if (blob.size !== size) {
                  instance.events.error.raise(instance, {reason: errors.FileCorrupted});
                  return
                }
                instance.events.finished.raise(instance, {
                  fileBlob: blob, openOrSaveFunc: function() {
                      if (Ifm.Type.isFunction(window.navigator.msSaveOrOpenBlob)) {
                        window.navigator.msSaveOrOpenBlob(blob, name)
                      }
                      else {
                        var a = document.createElement("a");
                        a.href = URL.createObjectURL(blob);
                        a.download = name;
                        a.target = "_blank";
                        a.style.cssText = "display:none!important;";
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a)
                      }
                      return false
                    }
                });
                break;
              default:
                console.warn("[Ifm.Net.Services.FileTransfer] %s Unexpected message: %s", "receive()", e.message);
                break
            }
          }
          else if (e.type === BIN) {
            blobs.push(e.message);
            instance.events.progress.raise(instance, {percentage: Math.ceil(blobs.length * chunkSize * 100 / size)})
          }
        });
        peer.send("#receive" + "|" + token)
      })
    };
    instance.transfer = function(file) {
      if (!(file instanceof File)) {
        throw Ifm.Diagnostics.Errors.arg("file");
      }
      if (instance.isSender !== undefined) {
        throw Ifm.Diagnostics.Errors.op("FileTransfer instance already in use");
      }
      instance.isSender = true;
      var BIN = Ifm.Net.WebSocket.MessageType.BINARY;
      var OBJ = Ifm.Net.WebSocket.MessageType.OBJECT;
      var TXT = Ifm.Net.WebSocket.MessageType.TEXT;
      var errors = Ifm.Net.Services.FileTransfer.ErrorReasons;
      var offset = 0,
        iscanceled = false;
      Ifm.Net.Peer.create(url, protocol, function(peer) {
        if (!peer) {
          instance.events.error.raise(instance, {reason: errors.Unavailable});
          return
        }
        instance.cancel = function() {
          instance.cancel = function(){};
          iscanceled = true;
          if (reader) {
            reader.onloadend = function(){};
            reader.onerror = function(){};
            reader.abort();
            reader = null
          }
          peer.send("#cancel");
          peer.close();
          instance.events.canceled.raise(instance, {})
        };
        var reader = new FileReader;
        reader.onloadend = function(e) {
          if (iscanceled)
            return;
          if (reader.readyState === FileReader.DONE) {
            peer.send(reader.result);
            offset += chunkSize;
            var end = offset + Math.min(chunkSize, file.size - offset);
            if (offset < file.size) {
              instance.events.progress.raise(instance, {percentage: Math.ceil(offset * 100 / file.size)});
              var blob = file.slice(offset, end);
              reader.readAsArrayBuffer(blob)
            }
            else {
              instance.cancel = function(){};
              peer.send("#finished");
              peer.close();
              instance.events.finished.raise(instance, {
                fileBlob: file, openOrSaveFunc: null
              })
            }
          }
        };
        reader.onerror = function(e) {
          peer.close();
          instance.events.error.raise(instance, {reason: errors.FileReadError})
        };
        peer.receive(function(e) {
          if (!e) {
            instance.events.error.raise(instance, {reason: errors.RequestRefused});
            return
          }
          if (e.type === TXT) {
            var parts = e.message.split("|");
            switch (parts[0]) {
              case"#denied":
                peer.close();
                instance.events.error.raise(instance, {reason: errors.SecurityError.replace("{err}", parts[1])});
                break;
              case"#cancel":
                instance.cancel();
                break;
              case"#token":
                instance.events.waiting.raise(instance, {token: parts[1]});
                break;
              case"#paired":
                break;
              case"#start":
                peer.send("#info" + "|" + file.name + "|" + file.size + "|" + file.type);
                instance.events.started.raise(instance, {});
                var blob = file.slice(offset, Math.min(chunkSize, file.size));
                reader.readAsArrayBuffer(blob);
                break;
              default:
                console.warn("[Ifm.Net.Services.FileTransfer] %s Unexpected message: %s", "transfer()", e.message);
                break
            }
          }
        });
        peer.send("#transfer" + "|" + file.name + "|" + file.size + "|" + file.type)
      })
    };
    instance.accept = function(){};
    instance.cancel = function(){};
    return instance
  };
  var protocol = "ift";
  var chunkSize = 32 * 1024;
  var id = 0;
  return factory
})();
;
namespace("Ifm.Net.Services").NetworkDiscovery = (function() {
  var instance = {};
  instance.isSupported = function() {
    return (Ifm && Ifm.Net && Ifm.Net.Peer && Ifm.Net.Peer.isSupported()) ? true : false
  };
  instance.queryLocalAddress = function(url, callback) {
    if (!instance.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("NetworkDiscovery");
    }
    Ifm.Net.Peer.query(url, protocol, "#addr", function(e) {
      callback((e && e.message) || null)
    })
  };
  var protocol = "ind";
  return instance
})();
;
namespace("Ifm.PhoneBar.Messages");
(function() {
  this.PhonesToPhoneBarMessages = {
    AssignmentRequest: 0x3004, KeepAliveRequest: 0x30FF, LoginReply: 0x5000, LogoutReply: 0x5001, ReadyReply: 0x5002, PauseReply: 0x5003, NewCallReply: 0x5005, TransferCallReply: 0x5006, CampaignListReply: 0x5007, AgentListReply: 0x5008, CampaignQueueInfoReply: 0x5009, SetCampaignStatusReply: 0x500A, AbortCallReply: 0x500E, RetrieveCallReply: 0x500F, ReadyEvent: 0x9002, PauseEvent: 0x9003, AlertingEvent: 0x9800, AnsweredEvent: 0x9801, TerminatedEvent: 0x9802, CallFailureEvent: 0x9803, OtherCallEvent: 0x9804, PostCallWorkEvent: 0x9805, SupervisorMessageEvent: 0x9807, ReadyForTransferEvent: 0x9808, ReadyForDetachEvent: 0x9809, BookedEvent: 0x980C, AudioRecordingStartedEvent: 0x9815, AudioRecordingMutedEvent: 0x9816, AudioRecordingCompletedEvent: 0x9817, MaskedDigitReceivedEvent: 0x9818, MaskedPayloadReceivedEvent: 0x9819
  };
  this.AssignmentRequest = function(message) {
    this.callId = message.nextInt32();
    this.rejectable = message.nextByte();
    this.campaignName = message.nextString();
    this.scriptName = message.nextString();
    this.scriptParameters = message.nextString();
    this.callDataStr = message.nextString();
    this.dummy = message.nextByte();
    this.cfgVersion = message.nextString();
    this.serviceId = message.nextString();
    this.campaignId = message.nextString();
    this.recordingState = message.remainingBytes() >= 1 ? message.nextByte() : 0;
    this.recordingFileName = message.remainingBytes() >= 2 ? message.nextString() : '';
    this.recordingSettings = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.mediatype = message.remainingBytes() >= 4 ? message.nextInt32() : 0
  };
  this.KeepAliveRequest = function(message){};
  this.LoginReply = function(message) {
    this.accepted = message.nextByte();
    if (message.remainingBytes()) {
      this.agentId = message.nextString();
      message.nextString();
      this.failureCause = message.nextByte();
      this.extension = message.remainingBytes() >= 2 ? message.nextString() : null
    }
    if (message.remainingBytes()) {
      this.firstName = message.nextString();
      this.lastName = message.nextString();
      this.username = message.nextString()
    }
  };
  this.LogoutReply = function(message) {
    this.accepted = message.nextByte()
  };
  this.ReadyReply = function(message) {
    this.accepted = message.nextByte();
    this.callId = message.remainingBytes() >= 4 ? message.nextInt32() : null
  };
  this.PauseReply = function(message) {
    this.accepted = message.nextByte();
    if (this.accepted < 3 && message.remainingBytes()) {
      this.reasonId = message.nextInt32();
      this.reasonText = message.nextString()
    }
    else if (this.accepted === 3) {
      var number = message.nextInt32();
      this.reasons = [];
      for (var i = 0; i < number; i++) {
        var id = message.nextInt32();
        var text = message.nextString();
        this.reasons.push({
          id: id, text: text
        })
      }
    }
  };
  this.NewCallReply = function(message) {
    this.callId = message.nextInt32();
    this.accepted = message.nextByte()
  };
  this.TransferCallReply = function(message) {
    this.callId = message.nextInt32();
    this.accepted = message.nextByte()
  };
  this.CampaignListReply = function(message) {
    function unpack(c) {
      c.name = c.serviceName + '/' + c.campaignName;
      c.active = !!(mask & 0x2);
      c.status = mask & (0x1 | 0x2 | 0x4);
      c.boundness = mask & 0x8 ? "Inbound" : "Outbound";
      c.assigned = !!(mask & 0x40);
      c.transfer = !!(mask & 0x100);
      return c
    }
    var number = message.nextInt16();
    this.campaigns = [];
    for (var i = 0; i < number; i++) {
      var name = message.nextString();
      var mask = message.nextInt32() & 0x8000001F;
      if (mask & 0x80000000) {
        var names = name.split('\t');
        for (var j = 1; j < names.length; j++) {
          name = names[j].slice(0, -1);
          var m = names[j].slice(-1).charCodeAt(0) * 2;
          this.campaigns.push(unpack({
            campaignName: name, serviceName: names[0], flags: m + (mask & ~0x80000000)
          }))
        }
      }
      else {
        this.campaigns.push(unpack({
          campaignName: name.split("/")[1], serviceName: name.split("/")[0], flags: mask
        }))
      }
    }
    this.campaigns.sort(function compare(a, b) {
      var aName = a.name.toUpperCase(),
        bName = b.name.toUpperCase();
      if (aName < bName)
        return -1;
      if (aName > bName)
        return +1;
      return 0
    })
  };
  this.AgentListReply = function(message) {
    var number = message.nextInt16();
    this.agents = [];
    for (var i = 0; i < number; i++) {
      var first = message.nextString(),
        last = message.nextString();
      this.agents.push({
        firstName: first, lastName: last, name: first + ' ' + last, campaignName: message.nextString(), state: message.remainingBytes() >= 4 ? message.nextInt32() : 0, time: message.remainingBytes() >= 4 ? message.nextInt32() : 0
      })
    }
    this.agents.sort(function compare(a, b) {
      var aLF = (a.lastName + ' ' + a.firstName).toUpperCase(),
        bLF = (b.lastName + ' ' + b.firstName).toUpperCase();
      if (aLF < bLF)
        return -1;
      if (aLF > bLF)
        return +1;
      return 0
    })
  };
  this.CampaignQueueInfoReply = function(message) {
    var number = message.nextInt16();
    this.calls = 0;
    this.avgTime = 0;
    this.maxTime = 0;
    this.campaigns = [];
    for (var i = 0; i < number; i++) {
      var name = message.nextString(),
        calls = message.nextInt32(),
        maxTime = message.nextInt32(),
        avgTime = message.nextInt32();
      this.campaigns.push({
        name: name, calls: calls, avgTime: avgTime, maxTime: maxTime
      });
      if (this.calls + calls > 0) {
        this.avgTime = (this.avgTime * this.calls + avgTime * calls) / (this.calls + calls)
      }
      if (maxTime > this.maxTime) {
        this.maxTime = maxTime
      }
      this.calls += calls
    }
  };
  this.SetCampaignStatusReply = function(message){};
  this.AbortCallReply = function(message) {
    this.callId = message.nextInt32();
    this.accepted = message.nextByte()
  };
  this.RetrieveCallReply = function(message){};
  this.ReadyEvent = function(message){};
  this.PauseEvent = function(message) {
    if (message.remainingBytes()) {
      this.reasonId = message.nextInt32();
      this.reasonText = message.nextString()
    }
    else {
      this.reasonId = 0;
      this.reasonText = ''
    }
  };
  this.AlertingEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.AnsweredEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.TerminatedEvent = function(message) {
    this.callId = message.nextInt32();
    this.postCallWork = message.nextByte()
  };
  this.CallFailureEvent = function(message) {
    this.callId = message.nextInt32();
    this.cause = message.nextByte();
    this.protocolTerminationCause = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.protocolTerminationDescription = message.remainingBytes() >= 2 ? message.nextString() : "";
    this.detectedContentCode = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.detectedContentDescription = message.remainingBytes() >= 2 ? message.nextString() : ""
  };
  this.OtherCallEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.PostCallWorkEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.SupervisorMessageEvent = function(message) {
    this.severity = message.nextInt16();
    this.message = message.nextString()
  };
  this.ReadyForTransferEvent = function(message) {
    this.callId = message.nextInt32();
    this.campaignName = message.nextString();
    this.agentFirstName = message.nextString();
    this.agentLastName = message.nextString()
  };
  this.ReadyForDetachEvent = function(message) {
    this.callId = message.nextInt32();
    this.callTerminated = message.remainingBytes() >= 1 ? (message.nextByte() !== 0 ? true : false) : undefined;
    this.protocolTerminationCause = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.protocolTerminationDescription = message.remainingBytes() >= 2 ? message.nextString() : "";
    this.detectedContentCode = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.detectedContentDescription = message.remainingBytes() >= 2 ? message.nextString() : ""
  };
  this.BookedEvent = function(message) {
    this.campaignName = message.nextString();
    this.mediatype = message.remainingBytes() >= 4 ? message.nextInt32() : 0
  };
  this.AudioRecordingStartedEvent = function(message) {
    this.callId = message.nextInt32();
    this.fileName = message.nextString()
  };
  this.AudioRecordingMutedEvent = function(message) {
    this.callId = message.nextInt32();
    this.txChannelMuted = message.nextByte() !== 0 ? true : false;
    this.rxChannelMuted = message.nextByte() !== 0 ? true : false
  };
  this.AudioRecordingCompletedEvent = function(message) {
    this.callId = message.nextInt32();
    this.result = message.nextInt32()
  };
  this.MaskedDigitReceivedEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.MaskedPayloadReceivedEvent = function(message) {
    this.callId = message.nextInt32();
    this.payload = message.nextString();
    this.result = message.nextInt32()
  };
  this.PhoneBarToPhonesMessages = {
    LoginRequest: 0x2000, LogoutRequest: 0x2001, ReadyRequest: 0x2002, PauseRequest: 0x2003, NewCallRequest: 0x2005, TransferCallRequest: 0x2006, CampaignListRequest: 0x2007, AgentListRequest: 0x2008, CampaignQueueInfoRequest: 0x2009, SetCampaignStatusRequest: 0x200A, LoginExRequest: 0x200C, AbortCallRequest: 0x200E, RetrieveCallRequest: 0x200F, AssignmentReply: 0x4004, KeepAliveReply: 0x40FF, AgentPanicEvent: 0x800B, SetAgentScriptStateEvent: 0x880A, SetCallResultEvent: 0x880B, AgentNewCallEvent: 0x880D, RemoteOffHookEvent: 0x880E, RemoteOnHookEvent: 0x880F, RemoteRingingEvent: 0x8810, RemoteManualHangUpEvent: 0x8813, DelcoTunnelMessageEvent: 0x8814
  };
  this.DelcoTunnelMessages = {
    ConsultationCallControlRequest: 0x2402, StartAudioRecordingRequest: 0x2403, StopAudioRecordingRequest: 0x2404, SetAudioRecordingMuteRequest: 0x2405, AppendCueSheetEntryRequest: 0x2406, StartDTMFMaskingRequest: 0x2407, StopDTMFMaskingRequest: 0x2408
  };
  this.LoginRequest = function(firstName, lastName, password, extension, flags) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.LoginRequest);
    message.addString(firstName).addString(lastName).addString(password).addString(extension).addByte(flags || 0).end();
    return message
  };
  this.LogoutRequest = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.LogoutRequest);
    message.end();
    return message
  };
  this.ReadyRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.ReadyRequest);
    message.addInt32(callId !== undefined ? callId : -1).end();
    return message
  };
  this.PauseRequest = function(reasonId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.PauseRequest);
    if (reasonId) {
      message.addByte(1).addInt32(reasonId)
    }
    message.end();
    return message
  };
  this.PauseReasonsRequest = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.PauseRequest);
    message.addByte(3).addInt32(0).end();
    return message
  };
  this.NewCallRequest = function(phoneNumber, campaignName, callingNumber) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.NewCallRequest);
    message.addString(phoneNumber).addString(campaignName).addString(callingNumber).end();
    return message
  };
  this.TransferCallRequest = function(callId, mode, campaignName, callDataStr, firstName, lastName, mandatory) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.TransferCallRequest);
    message.addInt32(callId).addInt32(mode).addString(campaignName).addString(callDataStr).addString(firstName).addString(lastName).addByte(mandatory ? 1 : 0).end();
    return message
  };
  this.CampaignListRequest = function(mask, callId, mediatype) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.CampaignListRequest);
    message.addInt32(mask | 0x80000000).addInt32(mediatype).addInt32(callId).end();
    return message
  };
  this.AgentListRequest = function(campaignName, mask) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AgentListRequest);
    message.addString(campaignName).addInt32(mask).end();
    return message
  };
  this.CampaignQueueInfoRequest = function(campaignName) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.CampaignQueueInfoRequest);
    message.addString(campaignName).addInt32(campaignName ? 0 : 0x2).end();
    return message
  };
  this.SetCampaignStatusRequest = function(){};
  this.LoginExRequest = function(firstName, lastName, oldPassword, newPassword, extension, flags) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.LoginExRequest);
    message.addString(firstName).addString(lastName).addString(oldPassword).addString(newPassword).addString(extension).addByte(flags || 0).end();
    return message
  };
  this.AbortCallRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AbortCallRequest);
    message.addInt32(callId).end();
    return message
  };
  this.RetrieveCallRequest = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.RetrieveCallRequest);
    message.addInt32(callId).end();
    return message
  };
  this.AssignmentReply = function(callId, accept) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AssignmentReply);
    message.addInt32(callId).addByte(accept).end();
    return message
  };
  this.KeepAliveReply = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.KeepAliveReply);
    message.end();
    return message
  };
  this.AgentPanicEvent = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AgentPanicEvent);
    message.addByte(1).end();
    return message
  };
  this.SetAgentScriptStateEvent = function(callId, scriptState) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.SetAgentScriptStateEvent);
    message.addInt32(callId).addString((scriptState || 0) + 255).end();
    return message
  };
  this.SetCallResultEvent = function(callId, callDataStr) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.SetCallResultEvent);
    message.addInt32(callId).addString(callDataStr).end();
    return message
  };
  this.AgentNewCallEvent = function(){};
  this.RemoteOffHookEvent = function(){};
  this.RemoteOnHookEvent = function(){};
  this.RemoteRingingEvent = function(){};
  this.RemoteManualHangUpEvent = function(){};
  this.ConsultationCallControlRequest = function(callId, action) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(12).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.ConsultationCallControlRequest).addByte(1).addByte(1).addInt32(4).addInt32(action).end();
    return message
  };
  this.StartAudioRecordingRequest = function(callId, fileName, settings) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(19 + fileName.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StartAudioRecordingRequest).addByte(1).addByte(1).addInt32(2 + fileName.length * 2).addUniString(fileName).addByte(1).addInt32(4).addInt32(settings).end();
    return message
  };
  this.StopAudioRecordingRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(3).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StopAudioRecordingRequest).addByte(1).end();
    return message
  };
  this.SetAudioRecordingMuteRequest = function(callId, muteTxChannel, muteRxChannel, appendCueSheetEntry, cueSheetEntry) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(37 + cueSheetEntry.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.SetAudioRecordingMuteRequest).addByte(1).addByte(1).addInt32(4).addBool32(muteTxChannel).addByte(1).addInt32(4).addBool32(muteRxChannel).addByte(1).addInt32(4).addBool32(appendCueSheetEntry).addByte(1).addInt32(2 + cueSheetEntry.length * 2).addUniString(cueSheetEntry).end();
    return message
  };
  this.AppendCueSheetEntryRequest = function(callId, cueSheetEntry) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(10 + cueSheetEntry.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.AppendCueSheetEntryRequest).addByte(1).addByte(1).addInt32(2 + cueSheetEntry.length * 2).addUniString(cueSheetEntry).end();
    return message
  };
  this.StartDTMFMaskingRequest = function(callId, numberOfDigits, terminationDigit) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(18).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StartDTMFMaskingRequest).addByte(1).addByte(1).addInt32(4).addInt32(numberOfDigits).addByte(1).addInt32(1).addByte(terminationDigit).end();
    return message
  };
  this.StopDTMFMaskingRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(3).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StopDTMFMaskingRequest).addByte(1).end();
    return message
  }
}).call(Ifm.PhoneBar.Messages);
;
/*!
 * BDP Strophe bundle 1.3.1-4672
 * Copyright (c) Base Digitale Platform. All rights reserved.
 */
;
(function(callback) {
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-base64', function() {
        return factory()
      })
    }
    else {
      root.Base64 = factory()
    }
  }(globalThis, function() {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var obj = {
        encode: function(input) {
          var output = "";
          var chr1,
            chr2,
            chr3;
          var enc1,
            enc2,
            enc3,
            enc4;
          var i = 0;
          do {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc2 = ((chr1 & 3) << 4);
              enc3 = enc4 = 64
            }
            else if (isNaN(chr3)) {
              enc4 = 64
            }
            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4)
          } while (i < input.length);
          return output
        }, decode: function(input) {
            var output = "";
            var chr1,
              chr2,
              chr3;
            var enc1,
              enc2,
              enc3,
              enc4;
            var i = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
              enc1 = keyStr.indexOf(input.charAt(i++));
              enc2 = keyStr.indexOf(input.charAt(i++));
              enc3 = keyStr.indexOf(input.charAt(i++));
              enc4 = keyStr.indexOf(input.charAt(i++));
              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;
              output = output + String.fromCharCode(chr1);
              if (enc3 != 64) {
                output = output + String.fromCharCode(chr2)
              }
              if (enc4 != 64) {
                output = output + String.fromCharCode(chr3)
              }
            } while (i < input.length);
            return output
          }
      };
    return obj
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-sha1', function() {
        return factory()
      })
    }
    else {
      root.SHA1 = factory()
    }
  }(globalThis, function() {
    function core_sha1(x, len) {
      x[len >> 5] |= 0x80 << (24 - len % 32);
      x[((len + 64 >> 9) << 4) + 15] = len;
      var w = new Array(80);
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      var e = -1009589776;
      var i,
        j,
        t,
        olda,
        oldb,
        oldc,
        oldd,
        olde;
      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        olde = e;
        for (j = 0; j < 80; j++) {
          if (j < 16) {
            w[j] = x[i + j]
          }
          else {
            w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1)
          }
          t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
          e = d;
          d = c;
          c = rol(b, 30);
          b = a;
          a = t
        }
        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde)
      }
      return [a, b, c, d, e]
    }
    function sha1_ft(t, b, c, d) {
      if (t < 20) {
        return (b & c) | ((~b) & d)
      }
      if (t < 40) {
        return b ^ c ^ d
      }
      if (t < 60) {
        return (b & c) | (b & d) | (c & d)
      }
      return b ^ c ^ d
    }
    function sha1_kt(t) {
      return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514
    }
    function core_hmac_sha1(key, data) {
      var bkey = str2binb(key);
      if (bkey.length > 16) {
        bkey = core_sha1(bkey, key.length * 8)
      }
      var ipad = new Array(16),
        opad = new Array(16);
      for (var i = 0; i < 16; i++) {
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C
      }
      var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
      return core_sha1(opad.concat(hash), 512 + 160)
    }
    function safe_add(x, y) {
      var lsw = (x & 0xFFFF) + (y & 0xFFFF);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return (msw << 16) | (lsw & 0xFFFF)
    }
    function rol(num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt))
    }
    function str2binb(str) {
      var bin = [];
      var mask = 255;
      for (var i = 0; i < str.length * 8; i += 8) {
        bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << (24 - i % 32)
      }
      return bin
    }
    function binb2str(bin) {
      var str = "";
      var mask = 255;
      for (var i = 0; i < bin.length * 32; i += 8) {
        str += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & mask)
      }
      return str
    }
    function binb2b64(binarray) {
      var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var str = "";
      var triplet,
        j;
      for (var i = 0; i < binarray.length * 4; i += 3) {
        triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) | (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) | ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
        for (j = 0; j < 4; j++) {
          if (i * 8 + j * 6 > binarray.length * 32) {
            str += "="
          }
          else {
            str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F)
          }
        }
      }
      return str
    }
    return {
        b64_hmac_sha1: function(key, data) {
          return binb2b64(core_hmac_sha1(key, data))
        }, b64_sha1: function(s) {
            return binb2b64(core_sha1(str2binb(s), s.length * 8))
          }, binb2str: binb2str, core_hmac_sha1: core_hmac_sha1, str_hmac_sha1: function(key, data) {
            return binb2str(core_hmac_sha1(key, data))
          }, str_sha1: function(s) {
            return binb2str(core_sha1(str2binb(s), s.length * 8))
          }
      }
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-md5', function() {
        return factory()
      })
    }
    else {
      root.MD5 = factory()
    }
  }(globalThis, function(b) {
    var safe_add = function(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF)
      };
    var bit_rol = function(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt))
      };
    var str2binl = function(str) {
        var bin = [];
        for (var i = 0; i < str.length * 8; i += 8) {
          bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << (i % 32)
        }
        return bin
      };
    var binl2str = function(bin) {
        var str = "";
        for (var i = 0; i < bin.length * 32; i += 8) {
          str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & 255)
        }
        return str
      };
    var binl2hex = function(binarray) {
        var hex_tab = "0123456789abcdef";
        var str = "";
        for (var i = 0; i < binarray.length * 4; i++) {
          str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 0xF) + hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 0xF)
        }
        return str
      };
    var md5_cmn = function(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
      };
    var md5_ff = function(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
      };
    var md5_gg = function(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
      };
    var md5_hh = function(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t)
      };
    var md5_ii = function(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
      };
    var core_md5 = function(x, len) {
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        var olda,
          oldb,
          oldc,
          oldd;
        for (var i = 0; i < x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;
          a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
          d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
          a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
          c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
          d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safe_add(a, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd)
        }
        return [a, b, c, d]
      };
    var obj = {
        hexdigest: function(s) {
          return binl2hex(core_md5(str2binl(s), s.length * 8))
        }, hash: function(s) {
            return binl2str(core_md5(str2binl(s), s.length * 8))
          }
      };
    return obj
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-utils', function() {
        return factory()
      })
    }
    else {
      root.stropheUtils = factory()
    }
  }(globalThis, function() {
    var utils = {
        utf16to8: function(str) {
          var i,
            c;
          var out = "";
          var len = str.length;
          for (i = 0; i < len; i++) {
            c = str.charCodeAt(i);
            if ((c >= 0x0000) && (c <= 0x007F)) {
              out += str.charAt(i)
            }
            else if (c > 0x07FF) {
              out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
              out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));
              out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F))
            }
            else {
              out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));
              out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F))
            }
          }
          return out
        }, addCookies: function(cookies) {
            var cookieName,
              cookieObj,
              isObj,
              cookieValue,
              expires,
              domain,
              path;
            for (cookieName in(cookies || {})) {
              expires = '';
              domain = '';
              path = '';
              cookieObj = cookies[cookieName];
              isObj = typeof cookieObj == "object";
              cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
              if (isObj) {
                expires = cookieObj.expires ? ";expires=" + cookieObj.expires : '';
                domain = cookieObj.domain ? ";domain=" + cookieObj.domain : '';
                path = cookieObj.path ? ";path=" + cookieObj.path : ''
              }
              document.cookie = cookieName + '=' + cookieValue + expires + domain + path
            }
          }
      };
    return utils
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-polyfill', [], function() {
        return factory()
      })
    }
    else {
      return factory()
    }
  }(globalThis, function() {
    if (!Function.prototype.bind) {
      Function.prototype.bind = function(obj) {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        return function() {
            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)))
          }
      }
    }
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
      }
    }
    if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function(elt) {
        var len = this.length;
        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) {
          from += len
        }
        for (; from < len; from++) {
          if (from in this && this[from] === elt) {
            return from
          }
        }
        return -1
      }
    }
  }));
  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
      var T,
        k;
      if (this === null) {
        throw new TypeError(' this is null or not defined');
      }
      var O = Object(this);
      var len = O.length >>> 0;
      if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function');
      }
      if (arguments.length > 1) {
        T = thisArg
      }
      k = 0;
      while (k < len) {
        var kValue;
        if (k in O) {
          kValue = O[k];
          callback.call(T, kValue, k, O)
        }
        k++
      }
    }
  }
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-core', ['strophe-sha1', 'strophe-base64', 'strophe-md5', 'strophe-utils', "strophe-polyfill"], function() {
        return factory.apply(this, arguments)
      })
    }
    else {
      var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
      window.Strophe = o.Strophe;
      window.$build = o.$build;
      window.$iq = o.$iq;
      window.$msg = o.$msg;
      window.$pres = o.$pres;
      window.SHA1 = o.SHA1;
      window.Base64 = o.Base64;
      window.MD5 = o.MD5;
      window.b64_hmac_sha1 = o.SHA1.b64_hmac_sha1;
      window.b64_sha1 = o.SHA1.b64_sha1;
      window.str_hmac_sha1 = o.SHA1.str_hmac_sha1;
      window.str_sha1 = o.SHA1.str_sha1
    }
  }(globalThis, function(SHA1, Base64, MD5, utils) {
    var Strophe;
    function $build(name, attrs) {
      return new Strophe.Builder(name, attrs)
    }
    function $msg(attrs) {
      return new Strophe.Builder("message", attrs)
    }
    function $iq(attrs) {
      return new Strophe.Builder("iq", attrs)
    }
    function $pres(attrs) {
      return new Strophe.Builder("presence", attrs)
    }
    Strophe = {
      VERSION: "1.2.9", NS: {
          HTTPBIND: "http://jabber.org/protocol/httpbind", BOSH: "urn:xmpp:xbosh", CLIENT: "jabber:client", AUTH: "jabber:iq:auth", ROSTER: "jabber:iq:roster", PROFILE: "jabber:iq:profile", DISCO_INFO: "http://jabber.org/protocol/disco#info", DISCO_ITEMS: "http://jabber.org/protocol/disco#items", MUC: "http://jabber.org/protocol/muc", SASL: "urn:ietf:params:xml:ns:xmpp-sasl", STREAM: "http://etherx.jabber.org/streams", FRAMING: "urn:ietf:params:xml:ns:xmpp-framing", BIND: "urn:ietf:params:xml:ns:xmpp-bind", SESSION: "urn:ietf:params:xml:ns:xmpp-session", VERSION: "jabber:iq:version", STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas", XHTML_IM: "http://jabber.org/protocol/xhtml-im", XHTML: "http://www.w3.org/1999/xhtml"
        }, XHTML: {
          tags: ['a', 'blockquote', 'br', 'cite', 'em', 'img', 'li', 'ol', 'p', 'span', 'strong', 'ul', 'body'], attributes: {
              a: ['href'], blockquote: ['style'], br: [], cite: ['style'], em: [], img: ['src', 'alt', 'style', 'height', 'width'], li: ['style'], ol: ['style'], p: ['style'], span: ['style'], strong: [], ul: ['style'], body: []
            }, css: ['background-color', 'color', 'font-family', 'font-size', 'font-style', 'font-weight', 'margin-left', 'margin-right', 'text-align', 'text-decoration'], validTag: function(tag) {
              for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                if (tag == Strophe.XHTML.tags[i]) {
                  return true
                }
              }
              return false
            }, validAttribute: function(tag, attribute) {
              if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                  if (attribute == Strophe.XHTML.attributes[tag][i]) {
                    return true
                  }
                }
              }
              return false
            }, validCSS: function(style) {
              for (var i = 0; i < Strophe.XHTML.css.length; i++) {
                if (style == Strophe.XHTML.css[i]) {
                  return true
                }
              }
              return false
            }
        }, Status: {
          ERROR: 0, CONNECTING: 1, CONNFAIL: 2, AUTHENTICATING: 3, AUTHFAIL: 4, CONNECTED: 5, DISCONNECTED: 6, DISCONNECTING: 7, ATTACHED: 8, REDIRECT: 9, CONNTIMEOUT: 10
        }, LogLevel: {
          DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, FATAL: 4
        }, ElementType: {
          NORMAL: 1, TEXT: 3, CDATA: 4, FRAGMENT: 11
        }, TIMEOUT: 1.1, SECONDARY_TIMEOUT: 0.1, addNamespace: function(name, value) {
          Strophe.NS[name] = value
        }, forEachChild: function(elem, elemName, func) {
          var i,
            childNode;
          for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
              func(childNode)
            }
          }
        }, isTagEqual: function(el, name) {
          return el.tagName == name
        }, _xmlGenerator: null, _makeGenerator: function() {
          var doc;
          if (document.implementation.createDocument === undefined || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'))
          }
          else {
            doc = document.implementation.createDocument('jabber:client', 'strophe', null)
          }
          return doc
        }, xmlGenerator: function() {
          if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator()
          }
          return Strophe._xmlGenerator
        }, _getIEXmlDom: function() {
          var doc = null;
          var docStrings = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];
          for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
              try {
                doc = new ActiveXObject(docStrings[d])
              }
              catch(e) {
                doc = null
              }
            }
            else {
              break
            }
          }
          return doc
        }, xmlElement: function(name) {
          if (!name) {
            return null
          }
          var node = Strophe.xmlGenerator().createElement(name);
          var a,
            i,
            k;
          for (a = 1; a < arguments.length; a++) {
            var arg = arguments[a];
            if (!arg) {
              continue
            }
            if (typeof(arg) == "string" || typeof(arg) == "number") {
              node.appendChild(Strophe.xmlTextNode(arg))
            }
            else if (typeof(arg) == "object" && typeof(arg.sort) == "function") {
              for (i = 0; i < arg.length; i++) {
                var attr = arg[i];
                if (typeof(attr) == "object" && typeof(attr.sort) == "function" && attr[1] !== undefined && attr[1] !== null) {
                  node.setAttribute(attr[0], attr[1])
                }
              }
            }
            else if (typeof(arg) == "object") {
              for (k in arg) {
                if (arg.hasOwnProperty(k)) {
                  if (arg[k] !== undefined && arg[k] !== null) {
                    node.setAttribute(k, arg[k])
                  }
                }
              }
            }
          }
          return node
        }, xmlescape: function(text) {
          text = text.replace(/\&/g, "&amp;");
          text = text.replace(/</g, "&lt;");
          text = text.replace(/>/g, "&gt;");
          text = text.replace(/'/g, "&apos;");
          text = text.replace(/"/g, "&quot;");
          return text
        }, xmlunescape: function(text) {
          text = text.replace(/\&amp;/g, "&");
          text = text.replace(/&lt;/g, "<");
          text = text.replace(/&gt;/g, ">");
          text = text.replace(/&apos;/g, "'");
          text = text.replace(/&quot;/g, "\"");
          return text
        }, xmlTextNode: function(text) {
          return Strophe.xmlGenerator().createTextNode(text)
        }, xmlHtmlNode: function(html) {
          var node;
          if (window.DOMParser) {
            var parser = new DOMParser;
            node = parser.parseFromString(html, "text/xml")
          }
          else {
            node = new ActiveXObject("Microsoft.XMLDOM");
            node.async = "false";
            node.loadXML(html)
          }
          return node
        }, getText: function(elem) {
          if (!elem) {
            return null
          }
          var str = "";
          if (elem.childNodes.length === 0 && elem.nodeType == Strophe.ElementType.TEXT) {
            str += elem.nodeValue
          }
          for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
              str += elem.childNodes[i].nodeValue
            }
          }
          return Strophe.xmlescape(str)
        }, copyElement: function(elem) {
          var i,
            el;
          if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);
            for (i = 0; i < elem.attributes.length; i++) {
              el.setAttribute(elem.attributes[i].nodeName, elem.attributes[i].value)
            }
            for (i = 0; i < elem.childNodes.length; i++) {
              el.appendChild(Strophe.copyElement(elem.childNodes[i]))
            }
          }
          else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue)
          }
          return el
        }, createHtml: function(elem) {
          var i,
            el,
            j,
            tag,
            attribute,
            value,
            css,
            cssAttrs,
            attr,
            cssName,
            cssValue;
          if (elem.nodeType == Strophe.ElementType.NORMAL) {
            tag = elem.nodeName.toLowerCase();
            if (Strophe.XHTML.validTag(tag)) {
              try {
                el = Strophe.xmlElement(tag);
                for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                  attribute = Strophe.XHTML.attributes[tag][i];
                  value = elem.getAttribute(attribute);
                  if (typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                    continue
                  }
                  if (attribute == 'style' && typeof value == 'object') {
                    if (typeof value.cssText != 'undefined') {
                      value = value.cssText
                    }
                  }
                  if (attribute == 'style') {
                    css = [];
                    cssAttrs = value.split(';');
                    for (j = 0; j < cssAttrs.length; j++) {
                      attr = cssAttrs[j].split(':');
                      cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                      if (Strophe.XHTML.validCSS(cssName)) {
                        cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                        css.push(cssName + ': ' + cssValue)
                      }
                    }
                    if (css.length > 0) {
                      value = css.join('; ');
                      el.setAttribute(attribute, value)
                    }
                  }
                  else {
                    el.setAttribute(attribute, value)
                  }
                }
                for (i = 0; i < elem.childNodes.length; i++) {
                  el.appendChild(Strophe.createHtml(elem.childNodes[i]))
                }
              }
              catch(e) {
                el = Strophe.xmlTextNode('')
              }
            }
            else {
              el = Strophe.xmlGenerator().createDocumentFragment();
              for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.createHtml(elem.childNodes[i]))
              }
            }
          }
          else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
            el = Strophe.xmlGenerator().createDocumentFragment();
            for (i = 0; i < elem.childNodes.length; i++) {
              el.appendChild(Strophe.createHtml(elem.childNodes[i]))
            }
          }
          else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlTextNode(elem.nodeValue)
          }
          return el
        }, escapeNode: function(node) {
          if (typeof node !== "string") {
            return node
          }
          return node.replace(/^\s+|\s+$/g, '').replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
        }, unescapeNode: function(node) {
          if (typeof node !== "string") {
            return node
          }
          return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
        }, getNodeFromJid: function(jid) {
          if (jid.indexOf("@") < 0) {
            return null
          }
          return jid.split("@")[0]
        }, getDomainFromJid: function(jid) {
          var bare = Strophe.getBareJidFromJid(jid);
          if (bare.indexOf("@") < 0) {
            return bare
          }
          else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@')
          }
        }, getResourceFromJid: function(jid) {
          var s = jid.split("/");
          if (s.length < 2) {
            return null
          }
          s.splice(0, 1);
          return s.join('/')
        }, getBareJidFromJid: function(jid) {
          return jid ? jid.split("/")[0] : null
        }, _handleError: function(e) {
          if (typeof e.stack !== "undefined") {
            Strophe.fatal(e.stack)
          }
          if (e.sourceURL) {
            Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message)
          }
          else if (e.fileName) {
            Strophe.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message)
          }
          else {
            Strophe.fatal("error: " + e.message)
          }
        }, log: function(level, msg) {
          return
        }, debug: function(msg) {
          this.log(this.LogLevel.DEBUG, msg)
        }, info: function(msg) {
          this.log(this.LogLevel.INFO, msg)
        }, warn: function(msg) {
          this.log(this.LogLevel.WARN, msg)
        }, error: function(msg) {
          this.log(this.LogLevel.ERROR, msg)
        }, fatal: function(msg) {
          this.log(this.LogLevel.FATAL, msg)
        }, serialize: function(elem) {
          var result;
          if (!elem) {
            return null
          }
          if (typeof(elem.tree) === "function") {
            elem = elem.tree()
          }
          var nodeName = elem.nodeName;
          var i,
            child;
          if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname")
          }
          result = "<" + nodeName;
          for (i = 0; i < elem.attributes.length; i++) {
            if (elem.attributes[i].nodeName != "_realname") {
              result += " " + elem.attributes[i].nodeName + "='" + Strophe.xmlescape(elem.attributes[i].value) + "'"
            }
          }
          if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
              child = elem.childNodes[i];
              switch (child.nodeType) {
                case Strophe.ElementType.NORMAL:
                  result += Strophe.serialize(child);
                  break;
                case Strophe.ElementType.TEXT:
                  result += Strophe.xmlescape(child.nodeValue);
                  break;
                case Strophe.ElementType.CDATA:
                  result += "<![CDATA[" + child.nodeValue + "]]>"
              }
            }
            result += "</" + nodeName + ">"
          }
          else {
            result += "/>"
          }
          return result
        }, _requestId: 0, _connectionPlugins: {}, addConnectionPlugin: function(name, ptype) {
          Strophe._connectionPlugins[name] = ptype
        }
    };
    Strophe.Builder = function(name, attrs) {
      if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
          attrs.xmlns = Strophe.NS.CLIENT
        }
        else if (!attrs) {
          attrs = {xmlns: Strophe.NS.CLIENT}
        }
      }
      this.nodeTree = Strophe.xmlElement(name, attrs);
      this.node = this.nodeTree
    };
    Strophe.Builder.prototype = {
      tree: function() {
        return this.nodeTree
      }, toString: function() {
          return Strophe.serialize(this.nodeTree)
        }, up: function() {
          this.node = this.node.parentNode;
          return this
        }, root: function() {
          this.node = this.nodeTree;
          return this
        }, attrs: function(moreattrs) {
          for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
              if (moreattrs[k] === undefined) {
                this.node.removeAttribute(k)
              }
              else {
                this.node.setAttribute(k, moreattrs[k])
              }
            }
          }
          return this
        }, c: function(name, attrs, text) {
          var child = Strophe.xmlElement(name, attrs, text);
          this.node.appendChild(child);
          if (typeof text !== "string" && typeof text !== "number") {
            this.node = child
          }
          return this
        }, cnode: function(elem) {
          var impNode;
          var xmlGen = Strophe.xmlGenerator();
          try {
            impNode = (xmlGen.importNode !== undefined)
          }
          catch(e) {
            impNode = false
          }
          var newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);
          this.node.appendChild(newElem);
          this.node = newElem;
          return this
        }, t: function(text) {
          var child = Strophe.xmlTextNode(text);
          this.node.appendChild(child);
          return this
        }, h: function(html) {
          var fragment = document.createElement('body');
          fragment.innerHTML = html;
          var xhtml = Strophe.createHtml(fragment);
          while (xhtml.childNodes.length > 0) {
            this.node.appendChild(xhtml.childNodes[0])
          }
          return this
        }
    };
    Strophe.Handler = function(handler, ns, name, type, id, from, options) {
      this.handler = handler;
      this.ns = ns;
      this.name = name;
      this.type = type;
      this.id = id;
      this.options = options || {
        matchBareFromJid: false, ignoreNamespaceFragment: false
      };
      if (this.options.matchBare) {
        Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
        this.options.matchBareFromJid = this.options.matchBare;
        delete this.options.matchBare
      }
      if (this.options.matchBareFromJid) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null
      }
      else {
        this.from = from
      }
      this.user = true
    };
    Strophe.Handler.prototype = {
      getNamespace: function(elem) {
        var elNamespace = elem.getAttribute("xmlns");
        if (elNamespace && this.options.ignoreNamespaceFragment) {
          elNamespace = elNamespace.split('#')[0]
        }
        return elNamespace
      }, namespaceMatch: function(elem) {
          var nsMatch = false;
          if (!this.ns) {
            return true
          }
          else {
            var that = this;
            Strophe.forEachChild(elem, null, function(elem) {
              if (that.getNamespace(elem) === that.ns) {
                nsMatch = true
              }
            });
            nsMatch = nsMatch || this.getNamespace(elem) === this.ns
          }
          return nsMatch
        }, isMatch: function(elem) {
          var from = elem.getAttribute('from');
          if (this.options.matchBareFromJid) {
            from = Strophe.getBareJidFromJid(from)
          }
          var elem_type = elem.getAttribute("type");
          if (this.namespaceMatch(elem) && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) && (!this.id || elem.getAttribute("id") == this.id) && (!this.from || from == this.from)) {
            return true
          }
          return false
        }, run: function(elem) {
          var result = null;
          try {
            result = this.handler(elem)
          }
          catch(e) {
            Strophe._handleError(e);
            throw e;
          }
          return result
        }, toString: function() {
          return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
        }
    };
    Strophe.TimedHandler = function(period, handler) {
      this.period = period;
      this.handler = handler;
      this.lastCalled = (new Date).getTime();
      this.user = true
    };
    Strophe.TimedHandler.prototype = {
      run: function() {
        this.lastCalled = (new Date).getTime();
        return this.handler()
      }, reset: function() {
          this.lastCalled = (new Date).getTime()
        }, toString: function() {
          return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
        }
    };
    Strophe.Connection = function(service, options) {
      this.service = service;
      this.options = options || {};
      var proto = this.options.protocol || "";
      if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
        this._proto = new Strophe.Websocket(this)
      }
      else {
        this._proto = new Strophe.Bosh(this)
      }
      this._timeProvider = Strophe.timeProvider || window;
      this.jid = "";
      this.domain = null;
      this.features = null;
      this._sasl_data = {};
      this.do_session = false;
      this.do_bind = false;
      this.timedHandlers = [];
      this.handlers = [];
      this.removeTimeds = [];
      this.removeHandlers = [];
      this.addTimeds = [];
      this.addHandlers = [];
      this.protocolErrorHandlers = {
        HTTP: {}, websocket: {}
      };
      this._idleTimeout = null;
      this._disconnectTimeout = null;
      this.authenticated = false;
      this.connected = false;
      this.disconnecting = false;
      this.do_authentication = true;
      this.paused = false;
      this.restored = false;
      this._data = [];
      this._uniqueId = 0;
      this._sasl_success_handler = null;
      this._sasl_failure_handler = null;
      this._sasl_challenge_handler = null;
      this.maxRetries = 5;
      this._idleTimeout = this._timeProvider.setTimeout(function() {
        this._onIdle()
      }.bind(this), 100);
      utils.addCookies(this.options.cookies);
      this.registerSASLMechanisms(this.options.mechanisms);
      for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
          var ptype = Strophe._connectionPlugins[k];
          var F = function(){};
          F.prototype = ptype;
          this[k] = new F;
          this[k].init(this)
        }
      }
    };
    Strophe.Connection.prototype = {
      reset: function() {
        if (!this.jid)
          return;
        this._proto._reset();
        this.do_session = false;
        this.do_bind = false;
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];
        this.authenticated = false;
        this.connected = false;
        this.disconnecting = false;
        this.restored = false;
        this._data = [];
        this._requests = [];
        this._uniqueId = 0
      }, pause: function() {
          this.paused = true
        }, resume: function() {
          this.paused = false
        }, getUniqueId: function(suffix) {
          var partid = Strophe.getNodeFromJid(this.jid),
            partri = (Math.floor(Math.random() * 0xF0000000) + 0x10000000).toString(16);
          if (typeof suffix == "string" || typeof suffix == "number") {
            return ++this._uniqueId + ":" + partid + "-" + partri + ":" + suffix
          }
          else {
            return ++this._uniqueId + ":" + partid + "-" + partri
          }
        }, addProtocolErrorHandler: function(protocol, status_code, callback) {
          this.protocolErrorHandlers[protocol][status_code] = callback
        }, connect: function(jid, pass, callback, wait, hold, route, authcid) {
          this.jid = jid;
          this.authzid = Strophe.getBareJidFromJid(this.jid);
          this.authcid = authcid || Strophe.getNodeFromJid(this.jid);
          this.pass = pass;
          this.servtype = "xmpp";
          this.connect_callback = callback;
          this.disconnecting = false;
          this.connected = false;
          this.authenticated = false;
          this.restored = false;
          this.domain = Strophe.getDomainFromJid(this.jid);
          this._changeConnectStatus(Strophe.Status.CONNECTING, null);
          this._proto._connect(wait, hold, route)
        }, attach: function(jid, sid, rid, callback, wait, hold, wind) {
          if (this._proto instanceof Strophe.Bosh) {
            this._proto._attach(jid, sid, rid, callback, wait, hold, wind)
          }
          else {
            throw{
              name: 'StropheSessionError', message: 'The "attach" method can only be used with a BOSH connection.'
            };
          }
        }, isRestoreSupported: function() {
          return this._sessionCachingSupported()
        }, isRestorable: function(jid, maxAge) {
          if (this._sessionCachingSupported()) {
            var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
            if (this._proto._isRestorable(session, jid)) {
              if (typeof maxAge === typeof undefined) {
                return true
              }
              else {
                return (typeof session.cts !== typeof undefined && (Date.now() - Number(session.cts)) < (maxAge * 1000))
              }
            }
          }
          return false
        }, restore: function(jid, callback, wait, hold, wind) {
          if (this._sessionCachingSupported()) {
            return this._proto._restore(jid, callback, wait, hold, wind)
          }
          else {
            throw{
              name: 'StropheSessionError', message: 'The "restore" method can only be used with a BOSH connection.'
            };
          }
        }, _sessionCachingSupported: function() {
          if (this._proto instanceof Strophe.Bosh) {
            if (!JSON) {
              return false
            }
            try {
              window.sessionStorage.setItem('_strophe_', '_strophe_');
              window.sessionStorage.removeItem('_strophe_')
            }
            catch(e) {
              return false
            }
            return true
          }
          return false
        }, xmlInput: function(elem) {
          return
        }, xmlOutput: function(elem) {
          return
        }, rawInput: function(data) {
          return
        }, rawOutput: function(data) {
          return
        }, nextValidRid: function(rid) {
          return
        }, send: function(elem) {
          if (elem === null) {
            return
          }
          if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
              this._queueData(elem[i])
            }
          }
          else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree())
          }
          else {
            this._queueData(elem)
          }
          this._proto._send()
        }, flush: function() {
          this._timeProvider.clearTimeout(this._idleTimeout);
          this._onIdle()
        }, sendIQ: function(elem, callback, errback, timeout) {
          var timeoutHandler = null;
          var that = this;
          if (typeof(elem.tree) === "function") {
            elem = elem.tree()
          }
          var id = elem.getAttribute('id');
          if (!id) {
            id = this.getUniqueId("sendIQ");
            elem.setAttribute("id", id)
          }
          var expectedFrom = elem.getAttribute("to");
          var fulljid = this.jid;
          var handler = this.addHandler(function(stanza) {
              if (timeoutHandler) {
                that.deleteTimedHandler(timeoutHandler)
              }
              var acceptable = false;
              var from = stanza.getAttribute("from");
              if (from === expectedFrom || (!expectedFrom && (from === Strophe.getBareJidFromJid(fulljid) || from === Strophe.getDomainFromJid(fulljid) || from === fulljid))) {
                acceptable = true
              }
              if (!acceptable) {
                throw{
                  name: "StropheError", message: "Got answer to IQ from wrong jid:" + from + "\nExpected jid: " + expectedFrom
                };
              }
              var iqtype = stanza.getAttribute('type');
              if (iqtype == 'result') {
                if (callback) {
                  callback(stanza)
                }
              }
              else if (iqtype == 'error') {
                if (errback) {
                  errback(stanza)
                }
              }
              else {
                throw{
                  name: "StropheError", message: "Got bad IQ type of " + iqtype
                };
              }
            }, null, 'iq', ['error', 'result'], id);
          if (timeout) {
            timeoutHandler = this.addTimedHandler(timeout, function() {
              that.deleteHandler(handler);
              if (errback) {
                errback(null)
              }
              return false
            })
          }
          this.send(elem);
          return id
        }, _queueData: function(element) {
          if (element === null || !element.tagName || !element.childNodes) {
            throw{
              name: "StropheError", message: "Cannot queue non-DOMElement."
            };
          }
          this._data.push(element)
        }, _sendRestart: function() {
          this._data.push("restart");
          this._proto._sendRestart();
          this._idleTimeout = this._timeProvider.setTimeout(function() {
            this._onIdle()
          }.bind(this), 100)
        }, addTimedHandler: function(period, handler) {
          var thand = new Strophe.TimedHandler(period, handler);
          this.addTimeds.push(thand);
          return thand
        }, deleteTimedHandler: function(handRef) {
          this.removeTimeds.push(handRef)
        }, addHandler: function(handler, ns, name, type, id, from, options) {
          var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
          this.addHandlers.push(hand);
          return hand
        }, deleteHandler: function(handRef) {
          this.removeHandlers.push(handRef);
          var i = this.addHandlers.indexOf(handRef);
          if (i >= 0) {
            this.addHandlers.splice(i, 1)
          }
        }, registerSASLMechanisms: function(mechanisms) {
          this.mechanisms = {};
          mechanisms = mechanisms || [Strophe.SASLAnonymous, Strophe.SASLExternal, Strophe.SASLMD5, Strophe.SASLOAuthBearer, Strophe.SASLPlain, Strophe.SASLSHA1];
          mechanisms.forEach(this.registerSASLMechanism.bind(this))
        }, registerSASLMechanism: function(mechanism) {
          this.mechanisms[mechanism.prototype.name] = mechanism
        }, disconnect: function(reason) {
          this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
          Strophe.info("Disconnect was called because: " + reason);
          if (this.connected) {
            var pres = false;
            this.disconnecting = true;
            if (this.authenticated) {
              pres = $pres({
                xmlns: Strophe.NS.CLIENT, type: 'unavailable'
              })
            }
            this._disconnectTimeout = this._addSysTimedHandler(3000, this._onDisconnectTimeout.bind(this));
            this._proto._disconnect(pres)
          }
          else {
            Strophe.info("Disconnect was called before Strophe connected to the server");
            this._proto._abortAllRequests()
          }
        }, _changeConnectStatus: function(status, condition) {
          for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
              var plugin = this[k];
              if (plugin.statusChanged) {
                try {
                  plugin.statusChanged(status, condition)
                }
                catch(err) {
                  Strophe.error("" + k + " plugin caused an exception " + "changing status: " + err)
                }
              }
            }
          }
          if (this.connect_callback) {
            try {
              this.connect_callback(status, condition)
            }
            catch(e) {
              Strophe._handleError(e);
              Strophe.error("User connection callback caused an " + "exception: " + e)
            }
          }
        }, _doDisconnect: function(condition) {
          if (typeof this._idleTimeout == "number") {
            this._timeProvider.clearTimeout(this._idleTimeout)
          }
          if (this._disconnectTimeout !== null) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null
          }
          Strophe.debug("_doDisconnect was called");
          this._proto._doDisconnect();
          this.authenticated = false;
          this.disconnecting = false;
          this.restored = false;
          this.handlers = [];
          this.timedHandlers = [];
          this.removeTimeds = [];
          this.removeHandlers = [];
          this.addTimeds = [];
          this.addHandlers = [];
          this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
          this.connected = false
        }, _dataRecv: function(req, raw) {
          var elem = this._proto._reqToData(req);
          if (elem === null) {
            return
          }
          if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
              this.xmlInput(elem.childNodes[0])
            }
            else {
              this.xmlInput(elem)
            }
          }
          if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
              this.rawInput(raw)
            }
            else {
              this.rawInput(Strophe.serialize(elem))
            }
          }
          var i,
            hand;
          while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
              this.handlers.splice(i, 1)
            }
          }
          while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop())
          }
          if (this.disconnecting && this._proto._emptyQueue()) {
            this._doDisconnect();
            return
          }
          var type = elem.getAttribute("type");
          var cond,
            conflict;
          if (type !== null && type == "terminate") {
            if (this.disconnecting) {
              return
            }
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
              if (cond == "remote-stream-error" && conflict.length > 0) {
                cond = "conflict"
              }
              this._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
            }
            else {
              this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
            }
            this._doDisconnect(cond);
            return
          }
          var that = this;
          Strophe.forEachChild(elem, null, function(child) {
            var i,
              newList;
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
              var hand = newList[i];
              try {
                if (hand.isMatch(child) && (that.authenticated || !hand.user)) {
                  if (hand.run(child)) {
                    that.handlers.push(hand)
                  }
                }
                else {
                  that.handlers.push(hand)
                }
              }
              catch(e) {
                Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message)
              }
            }
          })
        }, mechanisms: {}, _connect_cb: function(req, _callback, raw) {
          Strophe.debug("_connect_cb was called");
          this.connected = true;
          var bodyWrap;
          try {
            bodyWrap = this._proto._reqToData(req)
          }
          catch(e) {
            if (e != "badformat") {
              throw e;
            }
            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
            this._doDisconnect('bad-format')
          }
          if (!bodyWrap) {
            return
          }
          if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
              this.xmlInput(bodyWrap.childNodes[0])
            }
            else {
              this.xmlInput(bodyWrap)
            }
          }
          if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
              this.rawInput(raw)
            }
            else {
              this.rawInput(Strophe.serialize(bodyWrap))
            }
          }
          var conncheck = this._proto._connect_cb(bodyWrap);
          if (conncheck === Strophe.Status.CONNFAIL) {
            return
          }
          var hasFeatures;
          if (bodyWrap.getElementsByTagNameNS) {
            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0
          }
          else {
            hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0
          }
          if (!hasFeatures) {
            this._proto._no_auth_received(_callback);
            return
          }
          var matched = [],
            i,
            mech;
          var mechanisms = bodyWrap.getElementsByTagName("mechanism");
          if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
              mech = Strophe.getText(mechanisms[i]);
              if (this.mechanisms[mech])
                matched.push(this.mechanisms[mech])
            }
          }
          if (matched.length === 0) {
            if (bodyWrap.getElementsByTagName("auth").length === 0) {
              this._proto._no_auth_received(_callback);
              return
            }
          }
          if (this.do_authentication !== false) {
            this.authenticate(matched)
          }
        }, sortMechanismsByPriority: function(mechanisms) {
          var i,
            j,
            higher,
            swap;
          for (i = 0; i < mechanisms.length - 1; ++i) {
            higher = i;
            for (j = i + 1; j < mechanisms.length; ++j) {
              if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {
                higher = j
              }
            }
            if (higher != i) {
              swap = mechanisms[i];
              mechanisms[i] = mechanisms[higher];
              mechanisms[higher] = swap
            }
          }
          return mechanisms
        }, _attemptSASLAuth: function(mechanisms) {
          mechanisms = this.sortMechanismsByPriority(mechanisms || []);
          var i = 0,
            mechanism_found = false;
          for (i = 0; i < mechanisms.length; ++i) {
            if (!mechanisms[i].prototype.test(this)) {
              continue
            }
            this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
            this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null);
            this._sasl_mechanism = new mechanisms[i];
            this._sasl_mechanism.onStart(this);
            var request_auth_exchange = $build("auth", {
                xmlns: Strophe.NS.SASL, mechanism: this._sasl_mechanism.name
              });
            if (this._sasl_mechanism.isClientFirst) {
              var response = this._sasl_mechanism.onChallenge(this, null);
              request_auth_exchange.t(Base64.encode(response))
            }
            this.send(request_auth_exchange.tree());
            mechanism_found = true;
            break
          }
          return mechanism_found
        }, _attemptLegacyAuth: function() {
          if (Strophe.getNodeFromJid(this.jid) === null) {
            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'x-strophe-bad-non-anon-jid');
            this.disconnect('x-strophe-bad-non-anon-jid')
          }
          else {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(this._auth1_cb.bind(this), null, null, null, "_auth_1");
            this.send($iq({
              type: "get", to: this.domain, id: "_auth_1"
            }).c("query", {xmlns: Strophe.NS.AUTH}).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree())
          }
        }, authenticate: function(matched) {
          if (!this._attemptSASLAuth(matched)) {
            this._attemptLegacyAuth()
          }
        }, _sasl_challenge_cb: function(elem) {
          var challenge = Base64.decode(Strophe.getText(elem));
          var response = this._sasl_mechanism.onChallenge(this, challenge);
          var stanza = $build('response', {xmlns: Strophe.NS.SASL});
          if (response !== "") {
            stanza.t(Base64.encode(response))
          }
          this.send(stanza.tree());
          return true
        }, _auth1_cb: function(elem) {
          var iq = $iq({
              type: "set", id: "_auth_2"
            }).c('query', {xmlns: Strophe.NS.AUTH}).c('username', {}).t(Strophe.getNodeFromJid(this.jid)).up().c('password').t(this.pass);
          if (!Strophe.getResourceFromJid(this.jid)) {
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe'
          }
          iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));
          this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
          this.send(iq.tree());
          return false
        }, _sasl_success_cb: function(elem) {
          if (this._sasl_data["server-signature"]) {
            var serverSignature;
            var success = Base64.decode(Strophe.getText(elem));
            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
            var matches = success.match(attribMatch);
            if (matches[1] == "v") {
              serverSignature = matches[2]
            }
            if (serverSignature != this._sasl_data["server-signature"]) {
              this.deleteHandler(this._sasl_failure_handler);
              this._sasl_failure_handler = null;
              if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null
              }
              this._sasl_data = {};
              return this._sasl_failure_cb(null)
            }
          }
          Strophe.info("SASL authentication succeeded.");
          if (this._sasl_mechanism) {
            this._sasl_mechanism.onSuccess()
          }
          this.deleteHandler(this._sasl_failure_handler);
          this._sasl_failure_handler = null;
          if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null
          }
          var streamfeature_handlers = [];
          var wrapper = function(handlers, elem) {
              while (handlers.length) {
                this.deleteHandler(handlers.pop())
              }
              this._sasl_auth1_cb.bind(this)(elem);
              return false
            };
          streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem)
          }.bind(this), null, "stream:features", null, null));
          streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem)
          }.bind(this), Strophe.NS.STREAM, "features", null, null));
          this._sendRestart();
          return false
        }, _sasl_auth1_cb: function(elem) {
          this.features = elem;
          var i,
            child;
          for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
              this.do_bind = true
            }
            if (child.nodeName == 'session') {
              this.do_session = true
            }
          }
          if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
          }
          else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, "_bind_auth_2");
            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
              this.send($iq({
                type: "set", id: "_bind_auth_2"
              }).c('bind', {xmlns: Strophe.NS.BIND}).c('resource', {}).t(resource).tree())
            }
            else {
              this.send($iq({
                type: "set", id: "_bind_auth_2"
              }).c('bind', {xmlns: Strophe.NS.BIND}).tree())
            }
          }
          return false
        }, _sasl_bind_cb: function(elem) {
          if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            var conflict = elem.getElementsByTagName("conflict"),
              condition;
            if (conflict.length > 0) {
              condition = 'conflict'
            }
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
            return false
          }
          var bind = elem.getElementsByTagName("bind");
          var jidNode;
          if (bind.length > 0) {
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
              this.jid = Strophe.getText(jidNode[0]);
              if (this.do_session) {
                this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, "_session_auth_2");
                this.send($iq({
                  type: "set", id: "_session_auth_2"
                }).c('session', {xmlns: Strophe.NS.SESSION}).tree())
              }
              else {
                this.authenticated = true;
                this._changeConnectStatus(Strophe.Status.CONNECTED, null)
              }
            }
          }
          else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
          }
        }, _sasl_session_cb: function(elem) {
          if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null)
          }
          else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
          }
          return false
        }, _sasl_failure_cb: function(elem) {
          if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null
          }
          if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null
          }
          if (this._sasl_mechanism)
            this._sasl_mechanism.onFailure();
          this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
          return false
        }, _auth2_cb: function(elem) {
          if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null)
          }
          else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect('authentication failed')
          }
          return false
        }, _addSysTimedHandler: function(period, handler) {
          var thand = new Strophe.TimedHandler(period, handler);
          thand.user = false;
          this.addTimeds.push(thand);
          return thand
        }, _addSysHandler: function(handler, ns, name, type, id) {
          var hand = new Strophe.Handler(handler, ns, name, type, id);
          hand.user = false;
          this.addHandlers.push(hand);
          return hand
        }, _onDisconnectTimeout: function() {
          Strophe.info("_onDisconnectTimeout was called");
          this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);
          this._proto._onDisconnectTimeout();
          this._doDisconnect();
          return false
        }, _onIdle: function() {
          var i,
            thand,
            since,
            newList;
          while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop())
          }
          while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
              this.timedHandlers.splice(i, 1)
            }
          }
          var now = (new Date).getTime();
          newList = [];
          for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
              since = thand.lastCalled + thand.period;
              if (since - now <= 0) {
                if (thand.run()) {
                  newList.push(thand)
                }
              }
              else {
                newList.push(thand)
              }
            }
          }
          this.timedHandlers = newList;
          this._timeProvider.clearTimeout(this._idleTimeout);
          this._proto._onIdle();
          if (this.connected) {
            this._idleTimeout = this._timeProvider.setTimeout(function() {
              this._onIdle()
            }.bind(this), 100)
          }
        }
    };
    Strophe.SASLMechanism = function(name, isClientFirst, priority) {
      this.name = name;
      this.isClientFirst = isClientFirst;
      this.priority = priority
    };
    Strophe.SASLMechanism.prototype = {
      test: function(connection) {
        return true
      }, onStart: function(connection) {
          this._connection = connection
        }, onChallenge: function(connection, challenge) {
          throw new Error("You should implement challenge handling!");
        }, onFailure: function() {
          this._connection = null
        }, onSuccess: function() {
          this._connection = null
        }
    };
    Strophe.SASLAnonymous = function(){};
    Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);
    Strophe.SASLAnonymous.prototype.test = function(connection) {
      return connection.authcid === null
    };
    Strophe.SASLPlain = function(){};
    Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);
    Strophe.SASLPlain.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLPlain.prototype.onChallenge = function(connection) {
      var auth_str = connection.authzid;
      auth_str = auth_str + "\u0000";
      auth_str = auth_str + connection.authcid;
      auth_str = auth_str + "\u0000";
      auth_str = auth_str + connection.pass;
      return utils.utf16to8(auth_str)
    };
    Strophe.SASLSHA1 = function(){};
    Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);
    Strophe.SASLSHA1.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
      var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
      var auth_str = "n=" + utils.utf16to8(connection.authcid);
      auth_str += ",r=";
      auth_str += cnonce;
      connection._sasl_data.cnonce = cnonce;
      connection._sasl_data["client-first-message-bare"] = auth_str;
      auth_str = "n,," + auth_str;
      this.onChallenge = function(connection, challenge) {
        var nonce,
          salt,
          iter,
          Hi,
          U,
          U_old,
          i,
          k,
          pass;
        var clientKey,
          serverKey,
          clientSignature;
        var responseText = "c=biws,";
        var authMessage = connection._sasl_data["client-first-message-bare"] + "," + challenge + ",";
        var cnonce = connection._sasl_data.cnonce;
        var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
        while (challenge.match(attribMatch)) {
          var matches = challenge.match(attribMatch);
          challenge = challenge.replace(matches[0], "");
          switch (matches[1]) {
            case"r":
              nonce = matches[2];
              break;
            case"s":
              salt = matches[2];
              break;
            case"i":
              iter = matches[2];
              break
          }
        }
        if (nonce.substr(0, cnonce.length) !== cnonce) {
          connection._sasl_data = {};
          return connection._sasl_failure_cb()
        }
        responseText += "r=" + nonce;
        authMessage += responseText;
        salt = Base64.decode(salt);
        salt += "\x00\x00\x00\x01";
        pass = utils.utf16to8(connection.pass);
        Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
        for (i = 1; i < iter; i++) {
          U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
          for (k = 0; k < 5; k++) {
            Hi[k] ^= U[k]
          }
          U_old = U
        }
        Hi = SHA1.binb2str(Hi);
        clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
        serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
        clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
        connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);
        for (k = 0; k < 5; k++) {
          clientKey[k] ^= clientSignature[k]
        }
        responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
        return responseText
      }.bind(this);
      return auth_str
    };
    Strophe.SASLMD5 = function(){};
    Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);
    Strophe.SASLMD5.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLMD5.prototype._quote = function(str) {
      return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
    };
    Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
      var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
      var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
      var realm = "";
      var host = null;
      var nonce = "";
      var qop = "";
      var matches;
      while (challenge.match(attribMatch)) {
        matches = challenge.match(attribMatch);
        challenge = challenge.replace(matches[0], "");
        matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
        switch (matches[1]) {
          case"realm":
            realm = matches[2];
            break;
          case"nonce":
            nonce = matches[2];
            break;
          case"qop":
            qop = matches[2];
            break;
          case"host":
            host = matches[2];
            break
        }
      }
      var digest_uri = connection.servtype + "/" + connection.domain;
      if (host !== null) {
        digest_uri = digest_uri + "/" + host
      }
      var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
      var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
      var A2 = 'AUTHENTICATE:' + digest_uri;
      var responseText = "";
      responseText += 'charset=utf-8,';
      responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
      responseText += 'realm=' + this._quote(realm) + ',';
      responseText += 'nonce=' + this._quote(nonce) + ',';
      responseText += 'nc=00000001,';
      responseText += 'cnonce=' + this._quote(cnonce) + ',';
      responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
      responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" + nonce + ":00000001:" + cnonce + ":auth:" + MD5.hexdigest(A2)) + ",";
      responseText += 'qop=auth';
      this.onChallenge = function() {
        return ""
      };
      return responseText
    };
    Strophe.SASLOAuthBearer = function(){};
    Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism("OAUTHBEARER", true, 50);
    Strophe.SASLOAuthBearer.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {
      var auth_str = 'n,a=';
      auth_str = auth_str + connection.authzid;
      auth_str = auth_str + ',';
      auth_str = auth_str + "\u0001";
      auth_str = auth_str + 'auth=Bearer ';
      auth_str = auth_str + connection.pass;
      auth_str = auth_str + "\u0001";
      auth_str = auth_str + "\u0001";
      return utils.utf16to8(auth_str)
    };
    Strophe.SASLExternal = function(){};
    Strophe.SASLExternal.prototype = new Strophe.SASLMechanism("EXTERNAL", true, 60);
    Strophe.SASLExternal.prototype.onChallenge = function(connection) {
      return connection.authcid === connection.authzid ? '' : connection.authzid
    };
    return {
        Strophe: Strophe, $build: $build, $msg: $msg, $iq: $iq, $pres: $pres, SHA1: SHA1, Base64: Base64, MD5: MD5
      }
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-bosh', ['strophe-core'], function(core) {
        return factory(core.Strophe, core.$build)
      })
    }
    else {
      return factory(Strophe, $build)
    }
  }(globalThis, function(Strophe, $build) {
    Strophe.Request = function(elem, func, rid, sends) {
      this.id = ++Strophe._requestId;
      this.xmlData = elem;
      this.data = Strophe.serialize(elem);
      this.origFunc = func;
      this.func = func;
      this.rid = rid;
      this.date = NaN;
      this.sends = sends || 0;
      this.abort = false;
      this.dead = null;
      this.age = function() {
        if (!this.date) {
          return 0
        }
        var now = new Date;
        return (now - this.date) / 1000
      };
      this.timeDead = function() {
        if (!this.dead) {
          return 0
        }
        var now = new Date;
        return (now - this.dead) / 1000
      };
      this.xhr = this._newXHR()
    };
    Strophe.Request.prototype = {
      getResponse: function() {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
          node = this.xhr.responseXML.documentElement;
          if (node.tagName == "parsererror") {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML));
            throw"parsererror";
          }
        }
        else if (this.xhr.responseText) {
          Strophe.error("invalid response received");
          Strophe.error("responseText: " + this.xhr.responseText);
          throw"badformat";
        }
        return node
      }, _newXHR: function() {
          var xhr = null;
          if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest;
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType("text/xml; charset=utf-8")
            }
          }
          else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP")
          }
          xhr.onreadystatechange = this.func.bind(null, this);
          return xhr
        }
    };
    Strophe.Bosh = function(connection) {
      this._conn = connection;
      this.rid = Math.floor(Math.random() * 4294967295);
      this.sid = null;
      this.hold = 1;
      this.wait = 60;
      this.window = 5;
      this.errors = 0;
      this._requests = []
    };
    Strophe.Bosh.prototype = {
      strip: null, _buildBody: function() {
          var bodyWrap = $build('body', {
              rid: this.rid++, xmlns: Strophe.NS.HTTPBIND
            });
          if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid})
          }
          if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
            this._cacheSession()
          }
          return bodyWrap
        }, _reset: function() {
          this.rid = Math.floor(Math.random() * 4294967295);
          this.sid = null;
          this.errors = 0;
          if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session')
          }
          this._conn.nextValidRid(this.rid)
        }, _connect: function(wait, hold, route) {
          this.wait = wait || this.wait;
          this.hold = hold || this.hold;
          this.errors = 0;
          var body = this._buildBody().attrs({
              to: this._conn.domain, "xml:lang": "en", wait: this.wait, hold: this.hold, content: "text/xml; charset=utf-8", ver: "1.6", "xmpp:version": "1.0", "xmlns:xmpp": Strophe.NS.BOSH
            });
          if (route) {
            body.attrs({route: route})
          }
          var _connect_cb = this._conn._connect_cb;
          this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)), body.tree().getAttribute("rid")));
          this._throttledRequestHandler()
        }, _attach: function(jid, sid, rid, callback, wait, hold, wind) {
          this._conn.jid = jid;
          this.sid = sid;
          this.rid = rid;
          this._conn.connect_callback = callback;
          this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);
          this._conn.authenticated = true;
          this._conn.connected = true;
          this.wait = wait || this.wait;
          this.hold = hold || this.hold;
          this.window = wind || this.window;
          this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null)
        }, _isRestorable: function(session, jid) {
          return (typeof session !== "undefined" && session !== null && session.rid && session.sid && session.jid && (typeof jid === "undefined" || jid === null || Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid)))
        }, _restore: function(jid, callback, wait, hold, wind) {
          var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
          if (this._isRestorable(session, jid)) {
            this._conn.restored = true;
            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
            return session
          }
          else {
            throw{
              name: "StropheSessionError", message: "_restore: no restorable session."
            };
          }
        }, _cacheSession: function() {
          if (this._conn.authenticated) {
            if (this._conn.jid && this.rid && this.sid) {
              window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                jid: this._conn.jid, rid: this.rid, sid: this.sid, cts: Date.now()
              }))
            }
          }
          else {
            window.sessionStorage.removeItem('strophe-bosh-session')
          }
        }, _connect_cb: function(bodyWrap) {
          var typ = bodyWrap.getAttribute("type");
          var cond,
            conflict;
          if (typ !== null && typ == "terminate") {
            cond = bodyWrap.getAttribute("condition");
            Strophe.error("BOSH-Connection failed: " + cond);
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
              if (cond == "remote-stream-error" && conflict.length > 0) {
                cond = "conflict"
              }
              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
            }
            else {
              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
            }
            this._conn._doDisconnect(cond);
            return Strophe.Status.CONNFAIL
          }
          if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid")
          }
          var wind = bodyWrap.getAttribute('requests');
          if (wind) {
            this.window = parseInt(wind, 10)
          }
          var hold = bodyWrap.getAttribute('hold');
          if (hold) {
            this.hold = parseInt(hold, 10)
          }
          var wait = bodyWrap.getAttribute('wait');
          if (wait) {
            this.wait = parseInt(wait, 10)
          }
        }, _disconnect: function(pres) {
          this._sendTerminate(pres)
        }, _doDisconnect: function() {
          this.sid = null;
          this.rid = Math.floor(Math.random() * 4294967295);
          if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session')
          }
          this._conn.nextValidRid(this.rid)
        }, _emptyQueue: function() {
          return this._requests.length === 0
        }, _callProtocolErrorHandlers: function(req) {
          var reqStatus = this._getRequestStatus(req),
            err_callback;
          err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
          if (err_callback) {
            err_callback.call(this, reqStatus)
          }
        }, _hitError: function(reqStatus) {
          this.errors++;
          Strophe.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
          if (this.errors > 4) {
            this._conn._onDisconnectTimeout()
          }
        }, _no_auth_received: function(_callback) {
          if (_callback) {
            _callback = _callback.bind(this._conn)
          }
          else {
            _callback = this._conn._connect_cb.bind(this._conn)
          }
          var body = this._buildBody();
          this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _callback.bind(this._conn)), body.tree().getAttribute("rid")));
          this._throttledRequestHandler()
        }, _onDisconnectTimeout: function() {
          this._abortAllRequests()
        }, _abortAllRequests: function _abortAllRequests() {
          var req;
          while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            req.xhr.onreadystatechange = function(){}
          }
        }, _onIdle: function() {
          var data = this._conn._data;
          if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
            Strophe.debug("no requests during idle cycle, sending " + "blank request");
            data.push(null)
          }
          if (this._conn.paused) {
            return
          }
          if (this._requests.length < 2 && data.length > 0) {
            var body = this._buildBody();
            for (var i = 0; i < data.length; i++) {
              if (data[i] !== null) {
                if (data[i] === "restart") {
                  body.attrs({
                    to: this._conn.domain, "xml:lang": "en", "xmpp:restart": "true", "xmlns:xmpp": Strophe.NS.BOSH
                  })
                }
                else {
                  body.cnode(data[i]).up()
                }
              }
            }
            delete this._conn._data;
            this._conn._data = [];
            this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid")));
            this._throttledRequestHandler()
          }
          if (this._requests.length > 0) {
            var time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
              if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                this._throttledRequestHandler()
              }
            }
            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
              Strophe.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) + " seconds since last activity");
              this._throttledRequestHandler()
            }
          }
        }, _getRequestStatus: function(req, def) {
          var reqStatus;
          if (req.xhr.readyState == 4) {
            try {
              reqStatus = req.xhr.status
            }
            catch(e) {
              Strophe.error("Caught an error while retrieving a request's status, " + "reqStatus: " + reqStatus)
            }
          }
          if (typeof(reqStatus) == "undefined") {
            reqStatus = typeof def === 'number' ? def : 0
          }
          return reqStatus
        }, _onRequestStateChange: function(func, req) {
          Strophe.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
          if (req.abort) {
            req.abort = false;
            return
          }
          if (req.xhr.readyState !== 4) {
            return
          }
          var reqStatus = this._getRequestStatus(req);
          if (this.disconnecting && reqStatus >= 400) {
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            return
          }
          if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            this._removeRequest(req);
            Strophe.debug("request id " + req.id + " should now be removed")
          }
          if (reqStatus == 200) {
            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);
            if (reqIs1 || (reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
              this._restartRequest(0)
            }
            this._conn.nextValidRid(Number(req.rid) + 1);
            Strophe.debug("request id " + req.id + "." + req.sends + " got 200");
            func(req);
            this.errors = 0
          }
          else if (reqStatus === 0 || (reqStatus >= 400 && reqStatus < 600) || reqStatus >= 12000) {
            Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            if (reqStatus >= 400 && reqStatus < 500) {
              this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
              this._conn._doDisconnect()
            }
          }
          else {
            Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened")
          }
          if (!(reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            this._throttledRequestHandler()
          }
        }, _processRequest: function(i) {
          var self = this;
          var req = this._requests[i];
          var reqStatus = this._getRequestStatus(req, -1);
          if (req.sends > this._conn.maxRetries) {
            this._conn._onDisconnectTimeout();
            return
          }
          var time_elapsed = req.age();
          var primaryTimeout = (!isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
          var secondaryTimeout = (req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
          var requestCompletedWithServerError = (req.xhr.readyState == 4 && (reqStatus < 1 || reqStatus >= 500));
          if (primaryTimeout || secondaryTimeout || requestCompletedWithServerError) {
            if (secondaryTimeout) {
              Strophe.error("Request " + this._requests[i].id + " timed out (secondary), restarting")
            }
            req.abort = true;
            req.xhr.abort();
            req.xhr.onreadystatechange = function(){};
            this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);
            req = this._requests[i]
          }
          if (req.xhr.readyState === 0) {
            Strophe.debug("request id " + req.id + "." + req.sends + " posting");
            try {
              var contentType = this._conn.options.contentType || "text/xml; charset=utf-8";
              req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
              if (typeof req.xhr.setRequestHeader !== 'undefined') {
                req.xhr.setRequestHeader("Content-Type", contentType)
              }
              if (this._conn.options.withCredentials) {
                req.xhr.withCredentials = true
              }
            }
            catch(e2) {
              Strophe.error("XHR open failed.");
              if (!this._conn.connected) {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "bad-service")
              }
              this._conn.disconnect();
              return
            }
            var sendFunc = function() {
                req.date = new Date;
                if (self._conn.options.customHeaders) {
                  var headers = self._conn.options.customHeaders;
                  for (var header in headers) {
                    if (headers.hasOwnProperty(header)) {
                      req.xhr.setRequestHeader(header, headers[header])
                    }
                  }
                }
                req.xhr.send(req.data)
              };
            if (req.sends > 1) {
              var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait), Math.pow(req.sends, 3)) * 1000;
              this._conn._timeProvider.setTimeout(function() {
                sendFunc()
              }, backoff)
            }
            else {
              sendFunc()
            }
            req.sends++;
            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
              if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                this._conn.xmlOutput(req.xmlData.childNodes[0])
              }
              else {
                this._conn.xmlOutput(req.xmlData)
              }
            }
            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
              this._conn.rawOutput(req.data)
            }
          }
          else {
            Strophe.debug("_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState)
          }
        }, _removeRequest: function(req) {
          Strophe.debug("removing request");
          var i;
          for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
              this._requests.splice(i, 1)
            }
          }
          req.xhr.onreadystatechange = function(){};
          this._throttledRequestHandler()
        }, _restartRequest: function(i) {
          var req = this._requests[i];
          if (req.dead === null) {
            req.dead = new Date
          }
          this._processRequest(i)
        }, _reqToData: function(req) {
          try {
            return req.getResponse()
          }
          catch(e) {
            if (e != "parsererror") {
              throw e;
            }
            this._conn.disconnect("strophe-parsererror")
          }
        }, _sendTerminate: function(pres) {
          Strophe.debug("_sendTerminate was called");
          var body = this._buildBody().attrs({type: "terminate"});
          if (pres) {
            body.cnode(pres.tree())
          }
          var req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid"));
          this._requests.push(req);
          this._throttledRequestHandler()
        }, _send: function() {
          this._conn._timeProvider.clearTimeout(this._conn._idleTimeout);
          this._throttledRequestHandler();
          this._conn._idleTimeout = this._conn._timeProvider.setTimeout(function() {
            this._onIdle()
          }.bind(this._conn), 100)
        }, _sendRestart: function() {
          this._throttledRequestHandler();
          this._conn._timeProvider.clearTimeout(this._conn._idleTimeout)
        }, _throttledRequestHandler: function() {
          if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " + "undefined requests")
          }
          else {
            Strophe.debug("_throttledRequestHandler called with " + this._requests.length + " requests")
          }
          if (!this._requests || this._requests.length === 0) {
            return
          }
          if (this._requests.length > 0) {
            this._processRequest(0)
          }
          if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
            this._processRequest(1)
          }
        }
    };
    return Strophe
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-websocket', ['strophe-core'], function(core) {
        return factory(core.Strophe, core.$build)
      })
    }
    else {
      return factory(Strophe, $build)
    }
  }(globalThis, function(Strophe, $build) {
    Strophe.Websocket = function(connection) {
      this._conn = connection;
      this.strip = "wrapper";
      var service = connection.service;
      if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
        var new_service = "";
        if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
          new_service += "ws"
        }
        else {
          new_service += "wss"
        }
        new_service += "://" + window.location.host;
        if (service.indexOf("/") !== 0) {
          new_service += window.location.pathname + service
        }
        else {
          new_service += service
        }
        connection.service = new_service
      }
    };
    Strophe.Websocket.prototype = {
      _buildStream: function() {
        return $build("open", {
            xmlns: Strophe.NS.FRAMING, to: this._conn.domain, version: '1.0'
          })
      }, _check_streamerror: function(bodyWrap, connectstatus) {
          var errors;
          if (bodyWrap.getElementsByTagNameNS) {
            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error")
          }
          else {
            errors = bodyWrap.getElementsByTagName("stream:error")
          }
          if (errors.length === 0) {
            return false
          }
          var error = errors[0];
          var condition = "";
          var text = "";
          var ns = "urn:ietf:params:xml:ns:xmpp-streams";
          for (var i = 0; i < error.childNodes.length; i++) {
            var e = error.childNodes[i];
            if (e.getAttribute("xmlns") !== ns) {
              break
            }
            if (e.nodeName === "text") {
              text = e.textContent
            }
            else {
              condition = e.nodeName
            }
          }
          var errorString = "WebSocket stream error: ";
          if (condition) {
            errorString += condition
          }
          else {
            errorString += "unknown"
          }
          if (text) {
            errorString += " - " + condition
          }
          Strophe.error(errorString);
          this._conn._changeConnectStatus(connectstatus, condition);
          this._conn._doDisconnect();
          return true
        }, _reset: function() {
          return
        }, _connect: function() {
          this._closeSocket();
          this.socket = new WebSocket(this._conn.service, "xmpp");
          this.socket.onopen = this._onOpen.bind(this);
          this.socket.onerror = this._onError.bind(this);
          this.socket.onclose = this._onClose.bind(this);
          this.socket.onmessage = this._connect_cb_wrapper.bind(this)
        }, _connect_cb: function(bodyWrap) {
          var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
          if (error) {
            return Strophe.Status.CONNFAIL
          }
        }, _handleStreamStart: function(message) {
          var error = false;
          var ns = message.getAttribute("xmlns");
          if (typeof ns !== "string") {
            error = "Missing xmlns in <open />"
          }
          else if (ns !== Strophe.NS.FRAMING) {
            error = "Wrong xmlns in <open />: " + ns
          }
          var ver = message.getAttribute("version");
          if (typeof ver !== "string") {
            error = "Missing version in <open />"
          }
          else if (ver !== "1.0") {
            error = "Wrong version in <open />: " + ver
          }
          if (error) {
            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
            this._conn._doDisconnect();
            return false
          }
          return true
        }, _connect_cb_wrapper: function(message) {
          if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
            var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
            if (data === '')
              return;
            var streamStart = (new DOMParser).parseFromString(data, "text/xml").documentElement;
            this._conn.xmlInput(streamStart);
            this._conn.rawInput(message.data);
            if (this._handleStreamStart(streamStart)) {
              this._connect_cb(streamStart)
            }
          }
          else if (message.data.indexOf("<close ") === 0) {
            this._conn.rawInput(message.data);
            this._conn.xmlInput(message);
            var see_uri = message.getAttribute("see-other-uri");
            if (see_uri) {
              this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
              this._conn.reset();
              this._conn.service = see_uri;
              this._connect()
            }
            else {
              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
              this._conn._doDisconnect()
            }
          }
          else {
            var string = this._streamWrap(message.data);
            var elem = (new DOMParser).parseFromString(string, "text/xml").documentElement;
            this.socket.onmessage = this._onMessage.bind(this);
            this._conn._connect_cb(elem, null, message.data)
          }
        }, _disconnect: function(pres) {
          if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
            if (pres) {
              this._conn.send(pres)
            }
            var close = $build("close", {xmlns: Strophe.NS.FRAMING});
            this._conn.xmlOutput(close);
            var closeString = Strophe.serialize(close);
            this._conn.rawOutput(closeString);
            try {
              this.socket.send(closeString)
            }
            catch(e) {
              Strophe.info("Couldn't send <close /> tag.")
            }
          }
          this._conn._doDisconnect()
        }, _doDisconnect: function() {
          Strophe.debug("WebSockets _doDisconnect was called");
          this._closeSocket()
        }, _streamWrap: function(stanza) {
          return "<wrapper>" + stanza + '</wrapper>'
        }, _closeSocket: function() {
          if (this.socket) {
            try {
              this.socket.close()
            }
            catch(e) {}
          }
          this.socket = null
        }, _emptyQueue: function() {
          return true
        }, _onClose: function() {
          if (this._conn.connected && !this._conn.disconnecting) {
            Strophe.error("Websocket closed unexpectedly");
            this._conn._doDisconnect()
          }
          else {
            Strophe.info("Websocket closed")
          }
        }, _no_auth_received: function(_callback) {
          Strophe.error("Server did not send any auth methods");
          this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
          if (_callback) {
            _callback = _callback.bind(this._conn);
            _callback()
          }
          this._conn._doDisconnect()
        }, _onDisconnectTimeout: function(){}, _abortAllRequests: function(){}, _onError: function(error) {
          Strophe.error("Websocket error " + error);
          this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");
          this._disconnect()
        }, _onIdle: function() {
          var data = this._conn._data;
          if (data.length > 0 && !this._conn.paused) {
            for (var i = 0; i < data.length; i++) {
              if (data[i] !== null) {
                var stanza,
                  rawStanza;
                if (data[i] === "restart") {
                  stanza = this._buildStream().tree()
                }
                else {
                  stanza = data[i]
                }
                rawStanza = Strophe.serialize(stanza);
                this._conn.xmlOutput(stanza);
                this._conn.rawOutput(rawStanza);
                this.socket.send(rawStanza)
              }
            }
            this._conn._data = []
          }
        }, _onMessage: function(message) {
          var elem,
            data;
          var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
          if (message.data === close) {
            this._conn.rawInput(close);
            this._conn.xmlInput(message);
            if (!this._conn.disconnecting) {
              this._conn._doDisconnect()
            }
            return
          }
          else if (message.data.search("<open ") === 0) {
            elem = (new DOMParser).parseFromString(message.data, "text/xml").documentElement;
            if (!this._handleStreamStart(elem)) {
              return
            }
          }
          else {
            data = this._streamWrap(message.data);
            elem = (new DOMParser).parseFromString(data, "text/xml").documentElement
          }
          if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
            return
          }
          if (this._conn.disconnecting && elem.firstChild.nodeName === "presence" && elem.firstChild.getAttribute("type") === "unavailable") {
            this._conn.xmlInput(elem);
            this._conn.rawInput(Strophe.serialize(elem));
            return
          }
          this._conn._dataRecv(elem, message.data)
        }, _onOpen: function() {
          Strophe.info("Websocket open");
          var start = this._buildStream();
          this._conn.xmlOutput(start.tree());
          var startString = Strophe.serialize(start);
          this._conn.rawOutput(startString);
          this.socket.send(startString)
        }, _reqToData: function(stanza) {
          return stanza
        }, _send: function() {
          this._conn.flush()
        }, _sendRestart: function() {
          this._conn._timeProvider.clearTimeout(this._conn._idleTimeout);
          this._conn._onIdle.bind(this._conn)()
        }
    };
    return Strophe
  }));
  (function(root) {
    if (typeof define === 'function' && define.amd) {
      define("strophe", ["strophe-core", "strophe-bosh", "strophe-websocket"], function(wrapper) {
        return wrapper
      })
    }
  })(this);
  if (callback) {
    if (typeof define === 'function' && define.amd) {
      var n_callback = callback;
      if (typeof requirejs === 'function') {
        requirejs(["strophe"], function(o) {
          n_callback(o.Strophe, o.$build, o.$msg, o.$iq, o.$pres)
        })
      }
      else {
        require(["strophe"], function(o) {
          n_callback(o.Strophe, o.$build, o.$msg, o.$iq, o.$pres)
        })
      }
    }
    else {
      return callback(Strophe, $build, $msg, $iq, $pres)
    }
  }
})(function(Strophe, build, msg, iq, pres) {
  window.Strophe = Strophe;
  window.$build = build;
  window.$msg = msg;
  window.$iq = iq;
  window.$pres = pres
});
;
var Occupant,
  RoomConfig,
  XmppRoom,
  __bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments)
      }
  };
Strophe.addConnectionPlugin('muc', {
  _connection: null, rooms: {}, roomNames: [], init: function(conn) {
      this._connection = conn;
      this._muc_handler = null;
      Strophe.addNamespace('MUC_OWNER', Strophe.NS.MUC + "#owner");
      Strophe.addNamespace('MUC_ADMIN', Strophe.NS.MUC + "#admin");
      Strophe.addNamespace('MUC_USER', Strophe.NS.MUC + "#user");
      return Strophe.addNamespace('MUC_ROOMCONF', Strophe.NS.MUC + "#roomconfig")
    }, join: function(room, nick, msg_handler_cb, pres_handler_cb, roster_cb, password, history_attrs) {
      var msg,
        room_nick,
        _ref,
        _this = this;
      room_nick = this.test_append_nick(room, nick);
      msg = $pres({
        from: this._connection.jid, to: room_nick
      }).c("x", {xmlns: Strophe.NS.MUC});
      if (history_attrs != null) {
        msg = msg.c("history", history_attrs)
      }
      if (password != null) {
        msg.cnode(Strophe.xmlElement("password", [], password))
      }
      if ((_ref = this._muc_handler) == null) {
        this._muc_handler = this._connection.addHandler(function(stanza) {
          var from,
            handler,
            handlers,
            id,
            roomname,
            x,
            xmlns,
            xquery,
            _i,
            _len;
          from = stanza.getAttribute('from');
          if (!from) {
            return true
          }
          roomname = from.split("/")[0];
          if (!_this.rooms[roomname]) {
            return true
          }
          room = _this.rooms[roomname];
          handlers = {};
          if (stanza.nodeName === "message") {
            handlers = room._message_handlers
          }
          else if (stanza.nodeName === "presence") {
            xquery = stanza.getElementsByTagName("x");
            if (xquery.length > 0) {
              for (_i = 0, _len = xquery.length; _i < _len; _i++) {
                x = xquery[_i];
                xmlns = x.getAttribute("xmlns");
                if (xmlns && xmlns.match(Strophe.NS.MUC)) {
                  handlers = room._presence_handlers;
                  break
                }
              }
            }
          }
          for (id in handlers) {
            handler = handlers[id];
            if (!handler(stanza, room)) {
              delete handlers[id]
            }
          }
          return true
        })
      }
      if (!this.rooms.hasOwnProperty(room)) {
        this.rooms[room] = new XmppRoom(this, room, nick, password);
        this.roomNames.push(room)
      }
      if (pres_handler_cb) {
        this.rooms[room].addHandler('presence', pres_handler_cb)
      }
      if (msg_handler_cb) {
        this.rooms[room].addHandler('message', msg_handler_cb)
      }
      if (roster_cb) {
        this.rooms[room].addHandler('roster', roster_cb)
      }
      return this._connection.send(msg)
    }, leave: function(room, nick, handler_cb, exit_msg) {
      var id,
        presence,
        presenceid,
        room_nick;
      id = this.roomNames.indexOf(room);
      delete this.rooms[room];
      if (id >= 0) {
        this.roomNames.splice(id, 1);
        if (this.roomNames.length === 0) {
          this._connection.deleteHandler(this._muc_handler);
          this._muc_handler = null
        }
      }
      room_nick = this.test_append_nick(room, nick);
      presenceid = this._connection.getUniqueId();
      presence = $pres({
        type: "unavailable", id: presenceid, from: this._connection.jid, to: room_nick
      });
      if (exit_msg != null) {
        presence.c("status", exit_msg)
      }
      if (handler_cb != null) {
        this._connection.addHandler(handler_cb, null, "presence", null, presenceid)
      }
      this._connection.send(presence);
      return presenceid
    }, message: function(room, nick, message, html_message, type, source) {
      var msg,
        msgid,
        parent,
        room_nick;
      room_nick = this.test_append_nick(room, nick);
      type = type || (nick != null ? "chat" : "groupchat");
      msgid = this._connection.getUniqueId();
      msg = $msg({
        to: room_nick, from: this._connection.jid, type: type, id: msgid, __Source__: source
      }).c("body", {xmlns: Strophe.NS.CLIENT}).t(message);
      msg.up();
      if (html_message != null) {
        msg.c("html", {xmlns: Strophe.NS.XHTML_IM}).c("body", {xmlns: Strophe.NS.XHTML}).t(html_message);
        if (msg.node.childNodes.length === 0) {
          parent = msg.node.parentNode;
          msg.up().up();
          msg.node.removeChild(parent)
        }
        else {
          msg.up().up()
        }
      }
      msg.c("x", {xmlns: "jabber:x:event"}).c("composing");
      this._connection.send(msg);
      return msgid
    }, groupchat: function(room, message, html_message) {
      return this.message(room, null, message, html_message)
    }, invite: function(room, receiver, reason) {
      var invitation,
        msgid;
      msgid = this._connection.getUniqueId();
      invitation = $msg({
        from: this._connection.jid, to: room, id: msgid
      }).c('x', {xmlns: Strophe.NS.MUC_USER}).c('invite', {to: receiver});
      if (reason != null) {
        invitation.c('reason', reason)
      }
      this._connection.send(invitation);
      return msgid
    }, directInvite: function(room, receiver, reason, password) {
      var attrs,
        invitation,
        msgid;
      msgid = this._connection.getUniqueId();
      attrs = {
        xmlns: 'jabber:x:conference', jid: room
      };
      if (reason != null) {
        attrs.reason = reason
      }
      if (password != null) {
        attrs.password = password
      }
      invitation = $msg({
        from: this._connection.jid, to: receiver, id: msgid
      }).c('x', attrs);
      this._connection.send(invitation);
      return msgid
    }, queryOccupants: function(room, success_cb, error_cb) {
      var attrs,
        info;
      attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
      info = $iq({
        from: this._connection.jid, to: room, type: 'get'
      }).c('query', attrs);
      return this._connection.sendIQ(info, success_cb, error_cb)
    }, configure: function(room, handler_cb, error_cb) {
      var config,
        stanza;
      config = $iq({
        to: room, type: "get"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER});
      stanza = config.tree();
      return this._connection.sendIQ(stanza, handler_cb, error_cb)
    }, cancelConfigure: function(room) {
      var config,
        stanza;
      config = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER}).c("x", {
        xmlns: "jabber:x:data", type: "cancel"
      });
      stanza = config.tree();
      return this._connection.sendIQ(stanza)
    }, saveConfiguration: function(room, config, success_cb, error_cb) {
      var conf,
        iq,
        stanza,
        _i,
        _len;
      iq = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER});
      if (config instanceof Form) {
        config.type = "submit";
        iq.cnode(config.toXML())
      }
      else {
        iq.c("x", {
          xmlns: "jabber:x:data", type: "submit"
        });
        for (_i = 0, _len = config.length; _i < _len; _i++) {
          conf = config[_i];
          iq.cnode(conf).up()
        }
      }
      stanza = iq.tree();
      return this._connection.sendIQ(stanza, success_cb, error_cb)
    }, createInstantRoom: function(room, success_cb, error_cb) {
      var roomiq;
      roomiq = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER}).c("x", {
        xmlns: "jabber:x:data", type: "submit"
      });
      return this._connection.sendIQ(roomiq.tree(), success_cb, error_cb)
    }, setTopic: function(room, topic) {
      var msg;
      msg = $msg({
        to: room, from: this._connection.jid, type: "groupchat"
      }).c("subject", {xmlns: "jabber:client"}).t(topic);
      return this._connection.send(msg.tree())
    }, _modifyPrivilege: function(room, item, reason, handler_cb, error_cb) {
      var iq;
      iq = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_ADMIN}).cnode(item.node);
      if (reason != null) {
        iq.c("reason", reason)
      }
      return this._connection.sendIQ(iq.tree(), handler_cb, error_cb)
    }, modifyRole: function(room, nick, role, reason, handler_cb, error_cb) {
      var item;
      item = $build("item", {
        nick: nick, role: role
      });
      return this._modifyPrivilege(room, item, reason, handler_cb, error_cb)
    }, kick: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'none', reason, handler_cb, error_cb)
    }, voice: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'participant', reason, handler_cb, error_cb)
    }, mute: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'visitor', reason, handler_cb, error_cb)
    }, op: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'moderator', reason, handler_cb, error_cb)
    }, deop: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'participant', reason, handler_cb, error_cb)
    }, modifyAffiliation: function(room, jid, affiliation, reason, handler_cb, error_cb) {
      var item;
      item = $build("item", {
        jid: jid, affiliation: affiliation
      });
      return this._modifyPrivilege(room, item, reason, handler_cb, error_cb)
    }, ban: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'outcast', reason, handler_cb, error_cb)
    }, member: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'member', reason, handler_cb, error_cb)
    }, revoke: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'none', reason, handler_cb, error_cb)
    }, owner: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'owner', reason, handler_cb, error_cb)
    }, admin: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'admin', reason, handler_cb, error_cb)
    }, changeNick: function(room, user) {
      var presence,
        room_nick;
      room_nick = this.test_append_nick(room, user);
      presence = $pres({
        from: this._connection.jid, to: room_nick, id: this._connection.getUniqueId()
      });
      return this._connection.send(presence.tree())
    }, setStatus: function(room, user, show, status) {
      var presence,
        room_nick;
      room_nick = this.test_append_nick(room, user);
      presence = $pres({
        from: this._connection.jid, to: room_nick
      });
      if (show != null) {
        presence.c('show', show).up()
      }
      if (status != null) {
        presence.c('status', status)
      }
      return this._connection.send(presence.tree())
    }, listRooms: function(server, handle_cb, error_cb) {
      var iq;
      iq = $iq({
        to: server, from: this._connection.jid, type: "get"
      }).c("query", {xmlns: Strophe.NS.DISCO_ITEMS});
      return this._connection.sendIQ(iq, handle_cb, error_cb)
    }, test_append_nick: function(room, nick) {
      return room + (nick != null ? "/" + (Strophe.escapeNode(nick)) : "")
    }
});
XmppRoom = (function() {
  function XmppRoom(client, name, nick, password) {
    this.client = client;
    this.name = name;
    this.nick = nick;
    this.password = password;
    this._roomRosterHandler = __bind(this._roomRosterHandler, this);
    this._addOccupant = __bind(this._addOccupant, this);
    this.roster = {};
    this._message_handlers = {};
    this._presence_handlers = {};
    this._roster_handlers = {};
    this._handler_ids = 0;
    if (client.muc) {
      this.client = client.muc
    }
    this.name = Strophe.getBareJidFromJid(name);
    this.addHandler('presence', this._roomRosterHandler)
  }
  XmppRoom.prototype.join = function(msg_handler_cb, pres_handler_cb, roster_cb) {
    return this.client.join(this.name, this.nick, msg_handler_cb, pres_handler_cb, roster_cb, this.password)
  };
  XmppRoom.prototype.leave = function(handler_cb, message) {
    this.client.leave(this.name, this.nick, handler_cb, message);
    return delete this.client.rooms[this.name]
  };
  XmppRoom.prototype.message = function(nick, message, html_message, type) {
    return this.client.message(this.name, nick, message, html_message, type)
  };
  XmppRoom.prototype.groupchat = function(message, html_message) {
    return this.client.groupchat(this.name, message, html_message)
  };
  XmppRoom.prototype.invite = function(receiver, reason) {
    return this.client.invite(this.name, receiver, reason)
  };
  XmppRoom.prototype.directInvite = function(receiver, reason) {
    return this.client.directInvite(this.name, receiver, reason, this.password)
  };
  XmppRoom.prototype.configure = function(handler_cb) {
    return this.client.configure(this.name, handler_cb)
  };
  XmppRoom.prototype.cancelConfigure = function() {
    return this.client.cancelConfigure(this.name)
  };
  XmppRoom.prototype.saveConfiguration = function(config) {
    return this.client.saveConfiguration(this.name, config)
  };
  XmppRoom.prototype.queryOccupants = function(success_cb, error_cb) {
    return this.client.queryOccupants(this.name, success_cb, error_cb)
  };
  XmppRoom.prototype.setTopic = function(topic) {
    return this.client.setTopic(this.name, topic)
  };
  XmppRoom.prototype.modifyRole = function(nick, role, reason, success_cb, error_cb) {
    return this.client.modifyRole(this.name, nick, role, reason, success_cb, error_cb)
  };
  XmppRoom.prototype.kick = function(nick, reason, handler_cb, error_cb) {
    return this.client.kick(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.voice = function(nick, reason, handler_cb, error_cb) {
    return this.client.voice(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.mute = function(nick, reason, handler_cb, error_cb) {
    return this.client.mute(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.op = function(nick, reason, handler_cb, error_cb) {
    return this.client.op(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.deop = function(nick, reason, handler_cb, error_cb) {
    return this.client.deop(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.modifyAffiliation = function(jid, affiliation, reason, success_cb, error_cb) {
    return this.client.modifyAffiliation(this.name, jid, affiliation, reason, success_cb, error_cb)
  };
  XmppRoom.prototype.ban = function(jid, reason, handler_cb, error_cb) {
    return this.client.ban(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.member = function(jid, reason, handler_cb, error_cb) {
    return this.client.member(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.revoke = function(jid, reason, handler_cb, error_cb) {
    return this.client.revoke(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.owner = function(jid, reason, handler_cb, error_cb) {
    return this.client.owner(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.admin = function(jid, reason, handler_cb, error_cb) {
    return this.client.admin(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.changeNick = function(nick) {
    this.nick = nick;
    return this.client.changeNick(this.name, nick)
  };
  XmppRoom.prototype.setStatus = function(show, status) {
    return this.client.setStatus(this.name, this.nick, show, status)
  };
  XmppRoom.prototype.addHandler = function(handler_type, handler) {
    var id;
    id = this._handler_ids++;
    switch (handler_type) {
      case'presence':
        this._presence_handlers[id] = handler;
        break;
      case'message':
        this._message_handlers[id] = handler;
        break;
      case'roster':
        this._roster_handlers[id] = handler;
        break;
      default:
        this._handler_ids--;
        return null
    }
    return id
  };
  XmppRoom.prototype.removeHandler = function(id) {
    delete this._presence_handlers[id];
    delete this._message_handlers[id];
    return delete this._roster_handlers[id]
  };
  XmppRoom.prototype._addOccupant = function(data) {
    var occ;
    occ = new Occupant(data, this);
    this.roster[occ.nick] = occ;
    return occ
  };
  XmppRoom.prototype._roomRosterHandler = function(pres) {
    var data,
      handler,
      id,
      newnick,
      nick,
      _ref;
    data = XmppRoom._parsePresence(pres);
    nick = data.nick;
    newnick = data.newnick || null;
    switch (data.type) {
      case'error':
        return;
      case'unavailable':
        if (newnick) {
          data.nick = newnick;
          if (this.roster[nick] && this.roster[newnick]) {
            this.roster[nick].update(this.roster[newnick]);
            this.roster[newnick] = this.roster[nick]
          }
          if (this.roster[nick] && !this.roster[newnick]) {
            this.roster[newnick] = this.roster[nick].update(data)
          }
        }
        delete this.roster[nick];
        break;
      default:
        if (this.roster[nick]) {
          this.roster[nick].update(data)
        }
        else {
          this._addOccupant(data)
        }
    }
    _ref = this._roster_handlers;
    for (id in _ref) {
      handler = _ref[id];
      if (!handler(this.roster, this)) {
        delete this._roster_handlers[id]
      }
    }
    return true
  };
  XmppRoom._parsePresence = function(pres) {
    var a,
      c,
      c2,
      data,
      _i,
      _j,
      _len,
      _len1,
      _ref,
      _ref1,
      _ref2,
      _ref3,
      _ref4,
      _ref5,
      _ref6,
      _ref7;
    data = {};
    a = pres.attributes;
    data.nick = Strophe.getResourceFromJid(a.from.textContent);
    data.type = ((_ref = a.type) != null ? _ref.textContent : void 0) || null;
    data.states = [];
    _ref1 = pres.childNodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      switch (c.nodeName) {
        case"status":
          data.status = c.textContent || null;
          break;
        case"show":
          data.show = c.textContent || null;
          break;
        case"x":
          a = c.attributes;
          if (((_ref2 = a.xmlns) != null ? _ref2.textContent : void 0) === Strophe.NS.MUC_USER) {
            _ref3 = c.childNodes;
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              c2 = _ref3[_j];
              switch (c2.nodeName) {
                case"item":
                  a = c2.attributes;
                  data.affiliation = ((_ref4 = a.affiliation) != null ? _ref4.textContent : void 0) || null;
                  data.role = ((_ref5 = a.role) != null ? _ref5.textContent : void 0) || null;
                  data.jid = ((_ref6 = a.jid) != null ? _ref6.textContent : void 0) || null;
                  data.newnick = ((_ref7 = a.nick) != null ? _ref7.textContent : void 0) || null;
                  break;
                case"status":
                  if (c2.attributes.code) {
                    data.states.push(c2.attributes.code.textContent)
                  }
              }
            }
          }
      }
    }
    return data
  };
  return XmppRoom
})();
RoomConfig = (function() {
  function RoomConfig(info) {
    this.parse = __bind(this.parse, this);
    if (info != null) {
      this.parse(info)
    }
  }
  RoomConfig.prototype.parse = function(result) {
    var attr,
      attrs,
      child,
      field,
      identity,
      query,
      _i,
      _j,
      _k,
      _len,
      _len1,
      _len2,
      _ref;
    query = result.getElementsByTagName("query")[0].childNodes;
    this.identities = [];
    this.features = [];
    this.x = [];
    for (_i = 0, _len = query.length; _i < _len; _i++) {
      child = query[_i];
      attrs = child.attributes;
      switch (child.nodeName) {
        case"identity":
          identity = {};
          for (_j = 0, _len1 = attrs.length; _j < _len1; _j++) {
            attr = attrs[_j];
            identity[attr.name] = attr.textContent
          }
          this.identities.push(identity);
          break;
        case"feature":
          this.features.push(attrs["var"].textContent);
          break;
        case"x":
          attrs = child.childNodes[0].attributes;
          if ((!attrs["var"].textContent === 'FORM_TYPE') || (!attrs.type.textContent === 'hidden')) {
            break
          }
          _ref = child.childNodes;
          for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
            field = _ref[_k];
            if (!(!field.attributes.type)) {
              continue
            }
            attrs = field.attributes;
            this.x.push({
              "var": attrs["var"].textContent, label: attrs.label.textContent || "", value: field.firstChild.textContent || ""
            })
          }
      }
    }
    return {
        identities: this.identities, features: this.features, x: this.x
      }
  };
  return RoomConfig
})();
Occupant = (function() {
  function Occupant(data, room) {
    this.room = room;
    this.update = __bind(this.update, this);
    this.admin = __bind(this.admin, this);
    this.owner = __bind(this.owner, this);
    this.revoke = __bind(this.revoke, this);
    this.member = __bind(this.member, this);
    this.ban = __bind(this.ban, this);
    this.modifyAffiliation = __bind(this.modifyAffiliation, this);
    this.deop = __bind(this.deop, this);
    this.op = __bind(this.op, this);
    this.mute = __bind(this.mute, this);
    this.voice = __bind(this.voice, this);
    this.kick = __bind(this.kick, this);
    this.modifyRole = __bind(this.modifyRole, this);
    this.update(data)
  }
  Occupant.prototype.modifyRole = function(role, reason, success_cb, error_cb) {
    return this.room.modifyRole(this.nick, role, reason, success_cb, error_cb)
  };
  Occupant.prototype.kick = function(reason, handler_cb, error_cb) {
    return this.room.kick(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.voice = function(reason, handler_cb, error_cb) {
    return this.room.voice(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.mute = function(reason, handler_cb, error_cb) {
    return this.room.mute(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.op = function(reason, handler_cb, error_cb) {
    return this.room.op(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.deop = function(reason, handler_cb, error_cb) {
    return this.room.deop(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.modifyAffiliation = function(affiliation, reason, success_cb, error_cb) {
    return this.room.modifyAffiliation(this.jid, affiliation, reason, success_cb, error_cb)
  };
  Occupant.prototype.ban = function(reason, handler_cb, error_cb) {
    return this.room.ban(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.member = function(reason, handler_cb, error_cb) {
    return this.room.member(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.revoke = function(reason, handler_cb, error_cb) {
    return this.room.revoke(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.owner = function(reason, handler_cb, error_cb) {
    return this.room.owner(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.admin = function(reason, handler_cb, error_cb) {
    return this.room.admin(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.update = function(data) {
    this.nick = data.nick || null;
    this.affiliation = data.affiliation || null;
    this.role = data.role || null;
    this.jid = data.jid || null;
    this.status = data.status || null;
    this.show = data.show || null;
    return this
  };
  return Occupant
})();
Strophe.addConnectionPlugin('disco', {
  _connection: null, _identities: [], _features: [], _items: [], init: function(conn) {
      this._connection = conn;
      this._identities = [];
      this._features = [];
      this._items = [];
      conn.addHandler(this._onDiscoInfo.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'get', null, null);
      conn.addHandler(this._onDiscoItems.bind(this), Strophe.NS.DISCO_ITEMS, 'iq', 'get', null, null)
    }, addIdentity: function(category, type, name, lang) {
      if (typeof name === 'undefined') {
        name = ''
      }
      if (typeof lang === 'undefined') {
        lang = ''
      }
      for (var i = 0; i < this._identities.length; i++) {
        if (this._identities[i].category == category && this._identities[i].type == type && this._identities[i].name == name && this._identities[i].lang == lang) {
          return false
        }
      }
      this._identities.push({
        category: category, type: type, name: name, lang: lang
      });
      return true
    }, addFeature: function(var_name) {
      for (var i = 0; i < this._features.length; i++) {
        if (this._features[i] == var_name)
          return false
      }
      this._features.push(var_name);
      return true
    }, removeFeature: function(var_name) {
      for (var i = 0; i < this._features.length; i++) {
        if (this._features[i] === var_name) {
          this._features.splice(i, 1);
          return true
        }
      }
      return false
    }, addItem: function(jid, name, node, call_back) {
      if (node && !call_back)
        return false;
      this._items.push({
        jid: jid, name: name, node: node, call_back: call_back
      });
      return true
    }, info: function(jid, node, success, error, timeout) {
      var attrs = {xmlns: Strophe.NS.DISCO_INFO};
      if (node)
        attrs.node = node;
      var info = $iq({
          from: this._connection.jid, to: jid, type: 'get'
        }).c('query', attrs);
      this._connection.sendIQ(info, success, error, timeout)
    }, items: function(jid, node, success, error, timeout) {
      var attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
      if (node)
        attrs.node = node;
      var items = $iq({
          from: this._connection.jid, to: jid, type: 'get'
        }).c('query', attrs);
      this._connection.sendIQ(items, success, error, timeout)
    }, _buildIQResult: function(stanza, query_attrs) {
      var id = stanza.getAttribute('id');
      var from = stanza.getAttribute('from');
      var iqresult = $iq({
          type: 'result', id: id
        });
      if (from !== null) {
        iqresult.attrs({to: from})
      }
      return iqresult.c('query', query_attrs)
    }, _onDiscoInfo: function(stanza) {
      var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
      var attrs = {xmlns: Strophe.NS.DISCO_INFO};
      var i;
      if (node) {
        attrs.node = node
      }
      var iqresult = this._buildIQResult(stanza, attrs);
      for (i = 0; i < this._identities.length; i++) {
        attrs = {
          category: this._identities[i].category, type: this._identities[i].type
        };
        if (this._identities[i].name)
          attrs.name = this._identities[i].name;
        if (this._identities[i].lang)
          attrs['xml:lang'] = this._identities[i].lang;
        iqresult.c('identity', attrs).up()
      }
      for (i = 0; i < this._features.length; i++) {
        iqresult.c('feature', {'var': this._features[i]}).up()
      }
      this._connection.send(iqresult.tree());
      return true
    }, _onDiscoItems: function(stanza) {
      var query_attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
      var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
      var items,
        i;
      if (node) {
        query_attrs.node = node;
        items = [];
        for (i = 0; i < this._items.length; i++) {
          if (this._items[i].node == node) {
            items = this._items[i].call_back(stanza);
            break
          }
        }
      }
      else {
        items = this._items
      }
      var iqresult = this._buildIQResult(stanza, query_attrs);
      for (i = 0; i < items.length; i++) {
        var attrs = {jid: items[i].jid};
        if (items[i].name)
          attrs.name = items[i].name;
        if (items[i].node)
          attrs.node = items[i].node;
        iqresult.c('item', attrs).up()
      }
      this._connection.send(iqresult.tree());
      return true
    }
});
Strophe.addConnectionPlugin('caps', {
  HASH: 'sha-1', node: 'http://strophe.im/strophejs/', _ver: '', _connection: null, _knownCapabilities: {}, _jidVerIndex: {}, init: function(conn) {
      this._connection = conn;
      Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');
      if (!this._connection.disco) {
        throw"Caps plugin requires the disco plugin to be installed.";
      }
      this._connection.disco.addFeature(Strophe.NS.CAPS);
      this._connection.addHandler(this._delegateCapabilities.bind(this), Strophe.NS.CAPS)
    }, generateCapsAttrs: function() {
      return {
          xmlns: Strophe.NS.CAPS, hash: this.HASH, node: this.node, ver: this.generateVer()
        }
    }, generateVer: function() {
      if (this._ver !== "") {
        return this._ver
      }
      var ver = "",
        identities = this._connection.disco._identities.sort(this._sortIdentities),
        identitiesLen = identities.length,
        features = this._connection.disco._features.sort(),
        featuresLen = features.length;
      for (var i = 0; i < identitiesLen; i++) {
        var curIdent = identities[i];
        ver += curIdent.category + "/" + curIdent.type + "/" + curIdent.lang + "/" + curIdent.name + "<"
      }
      for (var i = 0; i < featuresLen; i++) {
        ver += features[i] + '<'
      }
      this._ver = b64_sha1(ver);
      return this._ver
    }, getCapabilitiesByJid: function(jid) {
      if (this._jidVerIndex[jid]) {
        return this._knownCapabilities[this._jidVerIndex[jid]]
      }
      return null
    }, _delegateCapabilities: function(stanza) {
      var from = stanza.getAttribute('from'),
        c = stanza.getElementsByTagName('c')[0],
        ver = c.getAttribute('ver'),
        node = c.getAttribute('node');
      if (!this._knownCapabilities[ver]) {
        return this._requestCapabilities(from, node, ver)
      }
      else {
        this._jidVerIndex[from] = ver
      }
      if (!this._jidVerIndex[from] || !this._jidVerIndex[from] !== ver) {
        this._jidVerIndex[from] = ver
      }
      return true
    }, _requestCapabilities: function(to, node, ver) {
      if (to !== this._connection.jid) {
        var id = this._connection.disco.info(to, node + '#' + ver);
        this._connection.addHandler(this._handleDiscoInfoReply.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'result', id, to)
      }
      return true
    }, _handleDiscoInfoReply: function(stanza) {
      var query = stanza.getElementsByTagName('query')[0],
        node = query.getAttribute('node').split('#'),
        ver = node[1],
        from = stanza.getAttribute('from');
      if (!this._knownCapabilities[ver]) {
        var childNodes = query.childNodes,
          childNodesLen = childNodes.length;
        this._knownCapabilities[ver] = [];
        for (var i = 0; i < childNodesLen; i++) {
          var node = childNodes[i];
          this._knownCapabilities[ver].push({
            name: node.nodeName, attributes: node.attributes
          })
        }
        this._jidVerIndex[from] = ver
      }
      else if (!this._jidVerIndex[from] || !this._jidVerIndex[from] !== ver) {
        this._jidVerIndex[from] = ver
      }
      return false
    }, _sortIdentities: function(a, b) {
      if (a.category > b.category) {
        return 1
      }
      if (a.category < b.category) {
        return -1
      }
      if (a.type > b.type) {
        return 1
      }
      if (a.type < b.type) {
        return -1
      }
      if (a.lang > b.lang) {
        return 1
      }
      if (a.lang < b.lang) {
        return -1
      }
      return 0
    }
});
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define("strophe.rsm", ["strophe"], function(Strophe) {
      factory(Strophe.Strophe, Strophe.$build, Strophe.$iq, Strophe.$msg, Strophe.$pres);
      return Strophe
    })
  }
  else {
    factory(root.Strophe, root.$build, root.$iq, root.$msg, root.$pres)
  }
}(this, function(Strophe, $build, $iq, $msg, $pres) {
  Strophe.addNamespace('RSM', 'http://jabber.org/protocol/rsm');
  Strophe.RSM = function(options) {
    this.attribs = ['max', 'first', 'last', 'after', 'before', 'index', 'count'];
    if (typeof options.xml != 'undefined') {
      this.fromXMLElement(options.xml)
    }
    else {
      for (var ii = 0; ii < this.attribs.length; ii++) {
        var attrib = this.attribs[ii];
        this[attrib] = options[attrib]
      }
    }
  };
  Strophe.RSM.prototype = {
    toXML: function() {
      var xml = $build('set', {xmlns: Strophe.NS.RSM});
      for (var ii = 0; ii < this.attribs.length; ii++) {
        var attrib = this.attribs[ii];
        if (typeof this[attrib] != 'undefined') {
          xml = xml.c(attrib).t(this[attrib].toString()).up()
        }
      }
      return xml.tree()
    }, next: function(max) {
        var newSet = new Strophe.RSM({
            max: max, after: this.last
          });
        return newSet
      }, previous: function(max) {
        var newSet = new Strophe.RSM({
            max: max, before: this.first
          });
        return newSet
      }, fromXMLElement: function(xmlElement) {
        for (var ii = 0; ii < this.attribs.length; ii++) {
          var attrib = this.attribs[ii];
          var elem = xmlElement.getElementsByTagName(attrib)[0];
          if (typeof elem != 'undefined' && elem !== null) {
            this[attrib] = Strophe.getText(elem);
            if (attrib == 'first') {
              this.index = elem.getAttribute('index')
            }
          }
        }
      }
  }
}));
(function() {
  Strophe.addConnectionPlugin('mam', {
    _c: null, _p: ['with', 'start', 'end'], init: function(conn) {
        this._c = conn;
        Strophe.addNamespace('MAM', 'urn:xmpp:mam:2')
      }, query: function(jid, options) {
        var _p = this._p;
        var attr = {
            type: 'set', to: jid
          };
        options = options || {};
        var mamAttr = {xmlns: Strophe.NS.MAM};
        if (!!options.queryid) {
          mamAttr.queryid = options.queryid;
          delete options.queryid
        }
        var iq = $iq(attr).c('query', mamAttr).c('x', {
            xmlns: 'jabber:x:data', type: 'submit'
          });
        iq.c('field', {
          var: 'FORM_TYPE', type: 'hidden'
        }).c('value').t(Strophe.NS.MAM).up().up();
        var i;
        for (i = 0; i < this._p.length; i++) {
          var pn = _p[i];
          var p = options[pn];
          delete options[pn];
          if (!!p) {
            iq.c('field', {var: pn}).c('value').t(p).up().up()
          }
        }
        iq.up();
        var onMessage = options.onMessage;
        delete options.onMessage;
        var onComplete = options.onComplete;
        delete options.onComplete;
        iq.cnode(new Strophe.RSM(options).toXML());
        var _c = this._c;
        var handler = _c.addHandler(onMessage, Strophe.NS.MAM, 'message', null);
        return this._c.sendIQ(iq, function() {
            _c.deleteHandler(handler);
            onComplete.apply(this, arguments)
          })
      }
  })
})();
var Mustache = function() {
    var Renderer = function(){};
    Renderer.prototype = {
      otag: "{{", ctag: "}}", pragmas: {}, buffer: [], pragmas_implemented: {"IMPLICIT-ITERATOR": true}, context: {}, render: function(template, context, partials, in_recursion) {
          if (!in_recursion) {
            this.context = context;
            this.buffer = []
          }
          if (!this.includes("", template)) {
            if (in_recursion) {
              return template
            }
            else {
              this.send(template);
              return
            }
          }
          template = this.render_pragmas(template);
          var html = this.render_section(template, context, partials);
          if (in_recursion) {
            return this.render_tags(html, context, partials, in_recursion)
          }
          this.render_tags(html, context, partials, in_recursion)
        }, send: function(line) {
          if (line != "") {
            this.buffer.push(line)
          }
        }, render_pragmas: function(template) {
          if (!this.includes("%", template)) {
            return template
          }
          var that = this;
          var regex = new RegExp(this.otag + "%([\\w-]+) ?([\\w]+=[\\w]+)?" + this.ctag);
          return template.replace(regex, function(match, pragma, options) {
              if (!that.pragmas_implemented[pragma]) {
                throw({message: "This implementation of mustache doesn't understand the '" + pragma + "' pragma"});
              }
              that.pragmas[pragma] = {};
              if (options) {
                var opts = options.split("=");
                that.pragmas[pragma][opts[0]] = opts[1]
              }
              return ""
            })
        }, render_partial: function(name, context, partials) {
          name = this.trim(name);
          if (!partials || partials[name] === undefined) {
            throw({message: "unknown_partial '" + name + "'"});
          }
          if (typeof(context[name]) != "object") {
            return this.render(partials[name], context, partials, true)
          }
          return this.render(partials[name], context[name], partials, true)
        }, render_section: function(template, context, partials) {
          if (!this.includes("#", template) && !this.includes("^", template)) {
            return template
          }
          var that = this;
          var regex = new RegExp(this.otag + "(\\^|\\#)\\s*(.+)\\s*" + this.ctag + "\n*([\\s\\S]+?)" + this.otag + "\\/\\s*\\2\\s*" + this.ctag + "\\s*", "mg");
          return template.replace(regex, function(match, type, name, content) {
              var value = that.find(name, context);
              if (type == "^") {
                if (!value || that.is_array(value) && value.length === 0) {
                  return that.render(content, context, partials, true)
                }
                else {
                  return ""
                }
              }
              else if (type == "#") {
                if (that.is_array(value)) {
                  return that.map(value, function(row) {
                      return that.render(content, that.create_context(row), partials, true)
                    }).join("")
                }
                else if (that.is_object(value)) {
                  return that.render(content, that.create_context(value), partials, true)
                }
                else if (typeof value === "function") {
                  return value.call(context, content, function(text) {
                      return that.render(text, context, partials, true)
                    })
                }
                else if (value) {
                  return that.render(content, context, partials, true)
                }
                else {
                  return ""
                }
              }
            })
        }, render_tags: function(template, context, partials, in_recursion) {
          var that = this;
          var new_regex = function() {
              return new RegExp(that.otag + "(=|!|>|\\{|%)?([^\\/#\\^]+?)\\1?" + that.ctag + "+", "g")
            };
          var regex = new_regex();
          var tag_replace_callback = function(match, operator, name) {
              switch (operator) {
                case"!":
                  return "";
                case"=":
                  that.set_delimiters(name);
                  regex = new_regex();
                  return "";
                case">":
                  return that.render_partial(name, context, partials);
                case"{":
                  return that.find(name, context);
                default:
                  return that.escape(that.find(name, context))
              }
            };
          var lines = template.split("\n");
          for (var i = 0; i < lines.length; i++) {
            lines[i] = lines[i].replace(regex, tag_replace_callback, this);
            if (!in_recursion) {
              this.send(lines[i])
            }
          }
          if (in_recursion) {
            return lines.join("\n")
          }
        }, set_delimiters: function(delimiters) {
          var dels = delimiters.split(" ");
          this.otag = this.escape_regex(dels[0]);
          this.ctag = this.escape_regex(dels[1])
        }, escape_regex: function(text) {
          if (!arguments.callee.sRE) {
            var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
            arguments.callee.sRE = new RegExp('(\\' + specials.join('|\\') + ')', 'g')
          }
          return text.replace(arguments.callee.sRE, '\\$1')
        }, find: function(name, context) {
          name = this.trim(name);
          function is_kinda_truthy(bool) {
            return bool === false || bool === 0 || bool
          }
          var value;
          if (is_kinda_truthy(context[name])) {
            value = context[name]
          }
          else if (is_kinda_truthy(this.context[name])) {
            value = this.context[name]
          }
          if (typeof value === "function") {
            return value.apply(context)
          }
          if (value !== undefined) {
            return value
          }
          return ""
        }, includes: function(needle, haystack) {
          return haystack.indexOf(this.otag + needle) != -1
        }, escape: function(s) {
          s = String(s === null ? "" : s);
          return s.replace(/&(?!\w+;)|["<>\\]/g, function(s) {
              switch (s) {
                case"&":
                  return "&amp;";
                case"\\":
                  return "\\\\";
                case'"':
                  return '\"';
                case"<":
                  return "&lt;";
                case">":
                  return "&gt;";
                default:
                  return s
              }
            })
        }, create_context: function(_context) {
          if (this.is_object(_context)) {
            return _context
          }
          else {
            var iterator = ".";
            if (this.pragmas["IMPLICIT-ITERATOR"]) {
              iterator = this.pragmas["IMPLICIT-ITERATOR"].iterator
            }
            var ctx = {};
            ctx[iterator] = _context;
            return ctx
          }
        }, is_object: function(a) {
          return a && typeof a == "object"
        }, is_array: function(a) {
          return Object.prototype.toString.call(a) === '[object Array]'
        }, trim: function(s) {
          return s.replace(/^\s*|\s*$/g, "")
        }, map: function(array, fn) {
          if (typeof array.map == "function") {
            return array.map(fn)
          }
          else {
            var r = [];
            var l = array.length;
            for (var i = 0; i < l; i++) {
              r.push(fn(array[i]))
            }
            return r
          }
        }
    };
    return ({
        name: "mustache.js", version: "0.3.0", to_html: function(template, view, partials, send_fun) {
            var renderer = new Renderer;
            if (send_fun) {
              renderer.send = send_fun
            }
            renderer.render(template, view, partials);
            if (!send_fun) {
              return renderer.buffer.join("\n")
            }
          }
      })
  }();
(function($) {
  var __slice = Array.prototype.slice;
  var i18n = {
      dict: null, missingPattern: null, load: function(i18nDict, missingPattern) {
          if (this.dict !== null) {
            $.extend(this.dict, i18nDict)
          }
          else {
            this.dict = i18nDict
          }
          if (missingPattern) {
            this.missingPattern = missingPattern
          }
        }, unload: function() {
          this.dict = null;
          this.missingPattern = null
        }, _: function(str) {
          var dict = this.dict;
          if (dict && dict.hasOwnProperty(str)) {
            str = dict[str]
          }
          else if (this.missingPattern !== null) {
            return this.printf(this.missingPattern, str)
          }
          var args = __slice.call(arguments);
          args[0] = str;
          return this.printf.apply(this, args)
        }, printf: function(str, args) {
          if (arguments.length < 2)
            return str;
          args = $.isArray(args) ? args : __slice.call(arguments, 1);
          return str.replace(/([^%]|^)%(?:(\d+)\$)?s/g, function(p0, p, position) {
              if (position) {
                return p + args[parseInt(position) - 1]
              }
              return p + args.shift()
            }).replace(/%%s/g, '%s')
        }
    };
  $.fn._t = function(str, params) {
    return $(this).html(i18n._.apply(i18n, arguments))
  };
  $.i18n = i18n
})(jQuery);
var dateFormat = function() {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
      timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
      timezoneClip = /[^-+\dA-Z]/g,
      pad = function(val, len) {
        val = String(val);
        len = len || 2;
        while (val.length < len)
          val = "0" + val;
        return val
      };
    return function(date, mask, utc) {
        var dF = dateFormat;
        if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
          mask = date;
          date = undefined
        }
        date = date ? new Date(date) : new Date;
        if (isNaN(date))
          throw SyntaxError("invalid date");
        mask = String(dF.masks[mask] || mask || dF.masks["default"]);
        if (mask.slice(0, 4) == "UTC:") {
          mask = mask.slice(4);
          utc = true
        }
        var _ = utc ? "getUTC" : "get",
          d = date[_ + "Date"](),
          D = date[_ + "Day"](),
          m = date[_ + "Month"](),
          y = date[_ + "FullYear"](),
          H = date[_ + "Hours"](),
          M = date[_ + "Minutes"](),
          s = date[_ + "Seconds"](),
          L = date[_ + "Milliseconds"](),
          o = utc ? 0 : date.getTimezoneOffset(),
          flags = {
            d: d, dd: pad(d), ddd: dF.i18n.dayNames[D], dddd: dF.i18n.dayNames[D + 7], m: m + 1, mm: pad(m + 1), mmm: dF.i18n.monthNames[m], mmmm: dF.i18n.monthNames[m + 12], yy: String(y).slice(2), yyyy: y, h: H % 12 || 12, hh: pad(H % 12 || 12), H: H, HH: pad(H), M: M, MM: pad(M), s: s, ss: pad(s), l: pad(L, 3), L: pad(L > 99 ? Math.round(L / 10) : L), t: H < 12 ? "a" : "p", tt: H < 12 ? "am" : "pm", T: H < 12 ? "A" : "P", TT: H < 12 ? "AM" : "PM", Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""), o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4), S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
          };
        return mask.replace(token, function($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
          })
      }
  }();
dateFormat.masks = {
  "default": "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:ss", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};
dateFormat.i18n = {
  dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
Date.prototype.format = function(mask, utc) {
  return dateFormat(this, mask, utc)
};
/*!
 * BDP Candy bundle 1.3.3-4695
 * Copyright (c) Base Digitale Platform. All rights reserved.
 */
;
function buildCandy(jQueryCandyInstance = jQuery) {
  ;
  window.jQueryCandyInstance = window.jQueryCandyInstance || jQuery;
  var Candy = (function(self, $) {
      self.about = {
        name: 'Candy', version: '1.10.0'
      };
      self.init = function(service, options, chatContainer = '#candy') {
        if (!options.viewClass) {
          options.viewClass = self.View
        }
        options.viewClass.init($(chatContainer), options.view);
        self.Core.init(service, options.core)
      };
      return self
    }(Candy || {}, jQueryCandyInstance));
  Candy.Core = (function(self, Strophe, $) {
    var _connection = null,
      _service = null,
      _user = null,
      _rooms = {},
      _anonymousConnection = false,
      _status,
      _options = {
        autojoin: undefined, disconnectWithoutTabs: true, debug: false, disableWindowUnload: false, presencePriority: 1, resource: Candy.about.name
      },
      _addNamespace = function(name, value) {
        Strophe.addNamespace(name, value)
      },
      _addNamespaces = function() {
        _addNamespace('PRIVATE', 'jabber:iq:private');
        _addNamespace('BOOKMARKS', 'storage:bookmarks');
        _addNamespace('PRIVACY', 'jabber:iq:privacy');
        _addNamespace('DELAY', 'jabber:x:delay');
        _addNamespace('PUBSUB', 'http://jabber.org/protocol/pubsub')
      },
      _getEscapedJidFromJid = function(jid) {
        var node = Strophe.getNodeFromJid(jid),
          domain = Strophe.getDomainFromJid(jid);
        return node ? Strophe.escapeNode(node) + '@' + domain : domain
      },
      _clearCache = function() {
        var jid = Candy.Core.getConnection().jid;
        if (jid) {
          window.sessionStorage.removeItem('candy-cache-' + jid)
        }
      },
      _updateCache = function() {
        var jid = Candy.Core.getConnection().jid;
        if (jid && _user) {
          window.sessionStorage.setItem('candy-cache-' + jid, JSON.stringify({
            nick: _user.getNick(), rooms: _rooms
          }))
        }
      };
    self.init = function(service, options) {
      _service = service;
      $.extend(true, _options, options);
      if (_options.debug) {
        if (_options.debug.toString().indexOf("verbose") > -1) {
          self.debug = function(message) {
            var args = [];
            args.push('[Debug]');
            args.push('[Candy]');
            Array.prototype.push.apply(args, arguments);
            console.debug.apply(console, args)
          }
        }
        else {
          self.debug = function(message){}
        }
        if (_options.debug.toString().indexOf("xml") > -1) {
          self.xml = function(info, data) {
            data = $.parseXML(data);
            if (info) {
              console.debug(info, data)
            }
            else {
              console.debug(data)
            }
          }
        }
        else {
          self.xml = function(info, data){}
        }
        self.log = function(message) {
          var args = [];
          args.push('[Info]');
          args.push('[Candy]');
          Array.prototype.push.apply(args, arguments);
          console.log.apply(console, args)
        };
        Strophe.log = function(level, message) {
          var level_name,
            console_level;
          switch (level) {
            case Strophe.LogLevel.DEBUG:
              if (_options.debug.toString().indexOf("http") >= 0) {
                level_name = "Debug";
                console_level = "debug"
              }
              else
                return;
              break;
            case Strophe.LogLevel.INFO:
              level_name = "Info";
              console_level = "log";
              break;
            case Strophe.LogLevel.WARN:
              level_name = "WARN";
              console_level = "warn";
              break;
            case Strophe.LogLevel.ERROR:
              level_name = "ERROR";
              console_level = "error";
              break;
            case Strophe.LogLevel.FATAL:
              level_name = "FATAL";
              console_level = "error";
              break
          }
          var args = Array.prototype.slice.call(arguments, 1);
          args.unshift('[Strophe]', '[' + level_name + ']');
          try {
            console[console_level].apply(console, args)
          }
          catch(error) {}
        };
        self.debug('[Init] Debugging enabled')
      }
      _addNamespaces();
      _connection = new Strophe.Connection(_service, {
        keepalive: true, mechanisms: [Strophe.SASLAnonymous]
      });
      _connection.rawInput = self.rawInput.bind(self);
      _connection.rawOutput = self.rawOutput.bind(self);
      _connection.caps.node = 'https://candy-chat.github.io/candy/';
      if (!_options.disableWindowUnload) {
        window.onbeforeunload = self.onWindowUnload
      }
    };
    self.registerEventHandlers = function() {
      self.addHandler(self.Event.Jabber.Version, Strophe.NS.VERSION, 'iq');
      self.addHandler(self.Event.Jabber.Presence, null, 'presence');
      self.addHandler(self.Event.Jabber.Message, null, 'message');
      self.addHandler(self.Event.Jabber.Bookmarks, Strophe.NS.PRIVATE, 'iq');
      self.addHandler(self.Event.Jabber.Room.Disco, Strophe.NS.DISCO_INFO, 'iq', 'result')
    };
    self.connect = function(jidOrHost, password, nick) {
      _connection.reset();
      self.registerEventHandlers();
      $(Candy).triggerHandler('candy:core.before-connect', {connection: _connection});
      if (_connection.isRestoreSupported()) {
        if (_connection.isRestorable(null, 90)) {
          this.debug("Restoring session");
          var session = _connection.restore(null, Candy.Core.Event.Strophe.Connect);
          this.debug("Restoring cache");
          try {
            var cache = JSON.parse(window.sessionStorage.getItem('candy-cache-' + session.jid));
            if (typeof cache !== typeof undefined && cache !== null) {
              _user = new self.ChatUser(session.jid, cache.nick || nick || Strophe.getNodeFromJid(session.jid));
              for (var roomJid in cache.rooms) {
                var room = new Candy.Core.ChatRoom(roomJid);
                room.setUser(Candy.Core.getUser());
                _rooms[roomJid] = room;
                Candy.Core.Action.Jabber.Room.Disco(roomJid);
                Candies.getRoomHistory(roomJid)
              }
            }
            else {
              this.log("No restorable cache")
            }
          }
          catch(e) {
            this.log("Invalid cache content");
            this.log(e);
            _clearCache()
          }
          return
        }
        else {
          this.log("No restorable session");
          _clearCache()
        }
      }
      else {
        this.debug("Sessions not restorable in this configuration")
      }
      _anonymousConnection = !_anonymousConnection ? jidOrHost && jidOrHost.indexOf("@") < 0 : true;
      if (jidOrHost && password) {
        _connection.connect(_getEscapedJidFromJid(jidOrHost) + '/' + _options.resource, password, Candy.Core.Event.Strophe.Connect);
        if (nick) {
          _user = new self.ChatUser(jidOrHost, nick)
        }
        else {
          _user = new self.ChatUser(jidOrHost, Strophe.getNodeFromJid(jidOrHost))
        }
      }
      else if (jidOrHost && nick) {
        _connection.connect(_getEscapedJidFromJid(jidOrHost) + '/' + _options.resource, null, Candy.Core.Event.Strophe.Connect);
        _user = new self.ChatUser(null, nick)
      }
      else if (jidOrHost) {
        Candy.Core.Event.Login(jidOrHost)
      }
      else {
        Candy.Core.Event.Login()
      }
    };
    self.attach = function(jid, sid, rid) {
      _user = new self.ChatUser(jid, Strophe.getNodeFromJid(jid));
      self.registerEventHandlers();
      _connection.attach(jid, sid, rid, Candy.Core.Event.Strophe.Connect)
    };
    self.disconnect = function() {
      if (_connection.connected) {
        _clearCache();
        $.each(self.getRooms(), function() {
          Candy.Core.Action.Jabber.Room.Leave(this.getJid())
        });
        _connection.disconnect()
      }
    };
    self.addHandler = function(handler, ns, name, type, id, from, options) {
      return _connection.addHandler(handler, ns, name, type, id, from, options)
    };
    self.getUser = function() {
      return _user
    };
    self.setUser = function(user) {
      _user = user;
      _updateCache()
    };
    self.getConnection = function() {
      return _connection
    };
    self.removeRoom = function(roomJid) {
      delete _rooms[roomJid]
    };
    self.getRooms = function() {
      return _rooms
    };
    self.getStropheStatus = function() {
      return _status
    };
    self.setStropheStatus = function(status) {
      _status = status
    };
    self.isAnonymousConnection = function() {
      return _anonymousConnection
    };
    self.getOptions = function() {
      return _options
    };
    self.getRoom = function(roomJid) {
      if (_rooms[roomJid]) {
        return _rooms[roomJid]
      }
      return null
    };
    self.onWindowUnload = function() {
      return;
      var retry = false;
      _connection.options.sync = false;
      try {
        self.disconnect();
        _connection.flush()
      }
      catch(e) {
        retry = true
      }
      if (retry) {
        _connection.options.sync = true;
        try {
          self.disconnect();
          _connection.flush()
        }
        catch(e) {}
      }
    };
    self.rawInput = function(data) {
      this.xml('RECV:', data)
    };
    self.rawOutput = function(data) {
      this.xml('SENT:', data)
    };
    self.clearCache = function() {
      _clearCache()
    };
    self.updateCache = function() {
      _updateCache()
    };
    self.debug = function(message){};
    self.log = function(message){};
    self.xml = function(info, data){};
    return self
  }(Candy.Core || {}, Strophe, jQueryCandyInstance));
  Candy.View = (function(self, $) {
    var _current = {
        container: null, roomJid: null
      },
      _options = {
        language: 'en', assets: 'res/', messages: {
            limit: 2000, remove: 500
          }, crop: {
            message: {
              nickname: 15, body: 1000
            }, roster: {nickname: 15}
          }, enableXHTML: false
      },
      _setupTranslation = function(language) {
        $.i18n.load(self.Translation[language])
      },
      _registerObservers = function() {
        $(Candy).on('candy:core.chat.connection', self.Observer.Chat.Connection);
        $(Candy).on('candy:core.chat.message', self.Observer.Chat.Message);
        $(Candy).on('candy:core.login', self.Observer.Login);
        $(Candy).on('candy:core.autojoin-missing', self.Observer.AutojoinMissing);
        $(Candy).on('candy:core.presence', self.Observer.Presence.update);
        $(Candy).on('candy:core.presence.leave', self.Observer.Presence.update);
        $(Candy).on('candy:core.presence.room', self.Observer.Presence.update);
        $(Candy).on('candy:core.presence.error', self.Observer.PresenceError);
        $(Candy).on('candy:core.message', self.Observer.Message)
      },
      _registerWindowHandlers = function() {
        if (Candy.Util.getIeVersion() < 9) {
          $(document).focusin(Candy.View.Pane.Window.onFocus).focusout(Candy.View.Pane.Window.onBlur)
        }
        else {
          $(window).focus(Candy.View.Pane.Window.onFocus).blur(Candy.View.Pane.Window.onBlur)
        }
        $(window).resize(Candy.View.Pane.Chat.fitTabs)
      },
      _initToolbar = function() {
        self.Pane.Chat.Toolbar.init()
      },
      _delegateTooltips = function() {
        $('body').delegate('li[data-tooltip]', 'mouseenter', Candy.View.Pane.Chat.Tooltip.show)
      };
    self.init = function(container, options) {
      if (options.resources) {
        options.assets = options.resources;
        delete options.resources
      }
      $.extend(true, _options, options);
      _setupTranslation(_options.language);
      Candy.Util.Parser.setEmoticonPath('img/emoticons/');
      _current.container = container;
      _current.container.html(Mustache.to_html(Candy.View.Template.Chat.pane, {
        tooltipEmoticons: $.i18n._('tooltipEmoticons'), tooltipSound: $.i18n._('tooltipSound'), tooltipAutoscroll: $.i18n._('tooltipAutoscroll'), tooltipStatusmessage: $.i18n._('tooltipStatusmessage'), tooltipAdministration: $.i18n._('tooltipAdministration'), tooltipUsercount: $.i18n._('tooltipUsercount')
      }, {
        tabs: Candy.View.Template.Chat.tabs, rooms: Candy.View.Template.Chat.rooms, modal: Candy.View.Template.Chat.modal, toolbar: Candy.View.Template.Chat.toolbar
      }));
      _registerWindowHandlers();
      _initToolbar();
      _registerObservers();
      _delegateTooltips()
    };
    self.getCurrent = function() {
      return _current
    };
    self.getOptions = function() {
      return _options
    };
    return self
  }(Candy.View || {}, jQueryCandyInstance));
  Candy.Util = (function(self, $) {
    self.jidToId = function(jid) {
      return MD5.hexdigest(jid)
    };
    self.escapeJid = function(jid) {
      var node = Strophe.escapeNode(Strophe.getNodeFromJid(jid)),
        domain = Strophe.getDomainFromJid(jid),
        resource = Strophe.getResourceFromJid(jid);
      jid = node + '@' + domain;
      if (resource) {
        jid += '/' + resource
      }
      return jid
    };
    self.unescapeJid = function(jid) {
      var node = Strophe.unescapeNode(Strophe.getNodeFromJid(jid)),
        domain = Strophe.getDomainFromJid(jid),
        resource = Strophe.getResourceFromJid(jid);
      jid = node + '@' + domain;
      if (resource) {
        jid += '/' + resource
      }
      return jid
    };
    self.crop = function(str, len) {
      if (str.length > len) {
        str = str.substr(0, len - 3) + '...'
      }
      return str
    };
    self.getDisplayName = function(nick) {
      var name = Strophe.unescapeNode(nick);
      if (name.lastIndexOf('_') > 0) {
        return name.substring(0, name.lastIndexOf('_'))
      }
      return name
    };
    self.parseAndCropXhtml = function(str, len) {
      return $('<div/>').append(self.createHtml($(str).get(0), len)).html()
    };
    self.setCookie = function(name, value, lifetime_days) {
      var exp = new Date;
      exp.setDate(exp.getDate() + lifetime_days);
      document.cookie = name + '=' + value + ';expires=' + exp.toUTCString() + ';path=/'
    };
    self.cookieExists = function(name) {
      return document.cookie.indexOf(name) > -1
    };
    self.getCookie = function(name) {
      if (document.cookie) {
        var regex = new RegExp(escape(name) + '=([^;]*)', 'gm'),
          matches = regex.exec(document.cookie);
        if (matches) {
          return matches[1]
        }
      }
    };
    self.deleteCookie = function(name) {
      document.cookie = name + '=;expires=Thu, 01-Jan-70 00:00:01 GMT;path=/'
    };
    self.getPosLeftAccordingToWindowBounds = function(elem, pos) {
      var windowWidth = $(document).width(),
        elemWidth = elem.outerWidth(),
        marginDiff = elemWidth - elem.outerWidth(true),
        backgroundPositionAlignment = 'left',
        parentOffset = $(document).find("#candy").length > 0 ? $("#candy").offset().left : 0;
      if (pos + elemWidth >= windowWidth) {
        pos -= elemWidth - marginDiff;
        backgroundPositionAlignment = 'right'
      }
      return {
          px: pos - parentOffset, backgroundPositionAlignment: backgroundPositionAlignment
        }
    };
    self.getPosTopAccordingToWindowBounds = function(elem, pos) {
      var windowHeight = $(document).height(),
        elemHeight = elem.outerHeight(),
        marginDiff = elemHeight - elem.outerHeight(true),
        backgroundPositionAlignment = 'top',
        parentOffset = $(document).find("#candy").length > 0 ? $("#candy").offset().top : 0;
      if (pos + elemHeight >= windowHeight) {
        pos -= elemHeight - marginDiff;
        backgroundPositionAlignment = 'bottom'
      }
      return {
          px: pos - parentOffset, backgroundPositionAlignment: backgroundPositionAlignment
        }
    };
    self.localizedTime = function(dateTime) {
      if (dateTime === undefined) {
        return undefined
      }
      var date = self.iso8601toDate(dateTime);
      if (date.toDateString() === (new Date).toDateString()) {
        return date.format($.i18n._('timeFormat'))
      }
      else {
        return date.format($.i18n._('dateFormat'))
      }
    };
    self.iso8601toDate = function(date) {
      var timestamp = Date.parse(date);
      if (isNaN(timestamp)) {
        var struct = /^(\d{4}|[+\-]\d{6})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?))?/.exec(date);
        if (struct) {
          var minutesOffset = 0;
          if (struct[8] !== 'Z') {
            minutesOffset = +struct[10] * 60 + (+struct[11]);
            if (struct[9] === '+') {
              minutesOffset = -minutesOffset
            }
          }
          minutesOffset -= (new Date).getTimezoneOffset();
          return new Date(+struct[1], +struct[2] - 1, +struct[3], +struct[4], +struct[5] + minutesOffset, +struct[6], struct[7] ? +struct[7].substr(0, 3) : 0)
        }
        else {
          timestamp = Date.parse(date.replace(/^(\d{4})(\d{2})(\d{2})/, '$1-$2-$3') + 'Z')
        }
      }
      return new Date(timestamp)
    };
    self.isEmptyObject = function(obj) {
      var prop;
      for (prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false
        }
      }
      return true
    };
    self.forceRedraw = function(elem) {
      elem.css({display: 'none'});
      setTimeout(function() {
        this.css({display: 'block'})
      }.bind(elem), 1)
    };
    var ie = (function() {
        var undef,
          v = 3,
          div = document.createElement('div'),
          all = div.getElementsByTagName('i');
        while (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->', all[0]) {}
        return v > 4 ? v : undef
      }());
    self.getIeVersion = function() {
      return ie
    };
    self.Parser = {
      _emoticonPath: '', setEmoticonPath: function(path) {
          if (!Candy.View.getOptions().assets)
            return;
          this._emoticonPath = Candy.View.getOptions().assets + path
        }, emoticons: [{
            plain: ':)', regex: /((\s):-?\)|:-?\)(\s|$))/gm, image: 'Smiling.png'
          }, {
            plain: ';)', regex: /((\s);-?\)|;-?\)(\s|$))/gm, image: 'Winking.png'
          }, {
            plain: ':D', regex: /((\s):-?D|:-?D(\s|$))/gm, image: 'Grinning.png'
          }, {
            plain: 'XD', regex: /((\s)XD|XD(\s|$))/gm, image: 'Laughing.png'
          }, {
            plain: ':(', regex: /((\s):-?\(|:-?\((\s|$))/gm, image: 'Unhappy.png'
          }, {
            plain: '^^', regex: /((\s)\^\^|\^\^(\s|$))/gm, image: 'Happy.png'
          }, {
            plain: ':P', regex: /((\s):-?P|:-?P(\s|$))/igm, image: 'Tease.png'
          }, {
            plain: ';P', regex: /((\s);-?P|;-?P(\s|$))/igm, image: 'Tongue_Out_Winking.png'
          }, {
            plain: ':S', regex: /((\s):-?S|:-?S(\s|$))/igm, image: 'Confused.png'
          }, {
            plain: ':/', regex: /((\s):-?\/|:-?\/(\s|$))/gm, image: 'Uncertain.png'
          }, {
            plain: '8)', regex: /((\s)8-?\)|8-?\)(\s|$))/gm, image: 'Cool.png'
          }, {
            plain: ':OK:', regex: /((\s):OK:|:OK:(\s|$))/gm, image: 'Thumb_Up.png'
          }, {
            plain: 'oO', regex: /((\s)oO|oO(\s|$))/gm, image: 'Huh.png'
          }, {
            plain: ':x', regex: /((\s):x|:x(\s|$))/gm, image: 'Lips_Sealed.png'
          }, {
            plain: ':666:', regex: /((\s):666:|:666:(\s|$))/gm, image: 'Devil.png'
          }, {
            plain: '<3', regex: /((\s)&lt;3|&lt;3(\s|$))/gm, image: 'Heart.png'
          }], emotify: function(text) {
          if (!Candy.View.getOptions().assets)
            return text;
          var i;
          for (i = this.emoticons.length - 1; i >= 0; i--) {
            text = text.replace(this.emoticons[i].regex, '$2<img class="emoticon" alt="$1" src="' + this._emoticonPath + this.emoticons[i].image + '" />$3')
          }
          return text
        }, linkify: function(text) {
          text = text.replace(/(^|[^\/])(www\.[^\.]+\.[\S]+(\b|$))/gi, '$1http://$2');
          return text.replace(/(\b(https?|ftp|file):\/\/[\-A-Z0-9+&@#\/%?=~_|!:,.;]*[\-A-Z0-9+&@#\/%=~_|])/ig, '<a href="$1" target="_blank">$1</a>')
        }, escape: function(text) {
          return $('<div/>').text(text).html()
        }, nl2br: function(text) {
          return text.replace(/\r\n|\r|\n/g, '<br />')
        }, all: function(text) {
          if (text) {
            text = this.escape(text);
            text = this.linkify(text);
            text = this.emotify(text);
            text = this.nl2br(text)
          }
          return text
        }
    };
    self.createHtml = function(elem, maxLength, currentLength) {
      currentLength = currentLength || 0;
      var i,
        el,
        j,
        tag,
        attribute,
        value,
        css,
        cssAttrs,
        attr,
        cssName,
        cssValue;
      if (elem.nodeType === Strophe.ElementType.NORMAL) {
        tag = elem.nodeName.toLowerCase();
        if (Strophe.XHTML.validTag(tag)) {
          try {
            el = $('<' + tag + '/>');
            for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
              attribute = Strophe.XHTML.attributes[tag][i];
              value = elem.getAttribute(attribute);
              if (typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {
                continue
              }
              if (attribute === 'style' && typeof value === 'object') {
                if (typeof value.cssText !== 'undefined') {
                  value = value.cssText
                }
              }
              if (attribute === 'style') {
                css = [];
                cssAttrs = value.split(';');
                for (j = 0; j < cssAttrs.length; j++) {
                  attr = cssAttrs[j].split(':');
                  cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                  if (Strophe.XHTML.validCSS(cssName)) {
                    cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                    css.push(cssName + ': ' + cssValue)
                  }
                }
                if (css.length > 0) {
                  value = css.join('; ');
                  el.attr(attribute, value)
                }
              }
              else {
                el.attr(attribute, value)
              }
            }
            for (i = 0; i < elem.childNodes.length; i++) {
              el.append(self.createHtml(elem.childNodes[i], maxLength, currentLength))
            }
          }
          catch(e) {
            Candy.Core.log("[Util:createHtml] Error while parsing XHTML:");
            Candy.Core.log(e);
            el = Strophe.xmlTextNode('')
          }
        }
        else {
          el = Strophe.xmlGenerator().createDocumentFragment();
          for (i = 0; i < elem.childNodes.length; i++) {
            el.appendChild(self.createHtml(elem.childNodes[i], maxLength, currentLength))
          }
        }
      }
      else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {
        el = Strophe.xmlGenerator().createDocumentFragment();
        for (i = 0; i < elem.childNodes.length; i++) {
          el.appendChild(self.createHtml(elem.childNodes[i], maxLength, currentLength))
        }
      }
      else if (elem.nodeType === Strophe.ElementType.TEXT) {
        var text = elem.nodeValue;
        currentLength += text.length;
        if (maxLength && currentLength > maxLength) {
          text = text.substring(0, maxLength)
        }
        text = Candy.Util.Parser.all(text);
        el = $.parseHTML(text)
      }
      return el
    };
    return self
  }(Candy.Util || {}, jQueryCandyInstance));
  Candy.Core.Action = (function(self, Strophe, $) {
    self.Jabber = {
      Version: function(msg) {
        Candy.Core.getConnection().sendIQ($iq({
          type: 'result', to: Candy.Util.escapeJid(msg.attr('from')), from: Candy.Util.escapeJid(msg.attr('to')), id: msg.attr('id')
        }).c('query', {
          name: Candy.about.name, version: Candy.about.version, os: navigator.userAgent
        }))
      }, SetNickname: function(nickname, rooms) {
          rooms = rooms instanceof Array ? rooms : Candy.Core.getRooms();
          var roomNick,
            presence,
            conn = Candy.Core.getConnection();
          $.each(rooms, function(roomJid) {
            roomNick = Candy.Util.escapeJid(roomJid + '/' + nickname);
            presence = $pres({
              to: roomNick, from: conn.jid, id: 'pres:' + conn.getUniqueId()
            });
            Candy.Core.getConnection().send(presence)
          })
        }, Roster: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'get', xmlns: Strophe.NS.CLIENT
          }).c('query', {xmlns: Strophe.NS.ROSTER}).tree())
        }, Presence: function(attr, el) {
          var conn = Candy.Core.getConnection();
          attr = attr || {};
          if (!attr.id) {
            attr.id = 'pres:' + conn.getUniqueId()
          }
          var pres = $pres(attr).c('priority').t(Candy.Core.getOptions().presencePriority.toString()).up().c('c', conn.caps.generateCapsAttrs()).up();
          if (el) {
            pres.node.appendChild(el.node)
          }
          conn.send(pres.tree())
        }, Services: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'get', xmlns: Strophe.NS.CLIENT
          }).c('query', {xmlns: Strophe.NS.DISCO_ITEMS}).tree())
        }, Autojoin: function() {
          if (Candy.Core.getOptions().autojoin === true) {
            Candy.Core.getConnection().sendIQ($iq({
              type: 'get', xmlns: Strophe.NS.CLIENT
            }).c('query', {xmlns: Strophe.NS.PRIVATE}).c('storage', {xmlns: Strophe.NS.BOOKMARKS}).tree());
            var pubsubBookmarkRequest = Candy.Core.getConnection().getUniqueId('pubsub');
            Candy.Core.addHandler(Candy.Core.Event.Jabber.Bookmarks, Strophe.NS.PUBSUB, 'iq', 'result', pubsubBookmarkRequest);
            Candy.Core.getConnection().sendIQ($iq({
              type: 'get', id: pubsubBookmarkRequest
            }).c('pubsub', {xmlns: Strophe.NS.PUBSUB}).c('items', {node: Strophe.NS.BOOKMARKS}).tree())
          }
          else if ($.isArray(Candy.Core.getOptions().autojoin)) {
            $.each(Candy.Core.getOptions().autojoin, function() {
              self.Jabber.Room.Join.apply(null, this.valueOf().split(':', 2))
            })
          }
          else {
            $(Candy).triggerHandler('candy:core.autojoin-missing')
          }
        }, ResetIgnoreList: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'set', from: Candy.Core.getUser().getEscapedJid()
          }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('list', {name: 'ignore'}).c('item', {
            action: 'allow', order: '0'
          }).tree())
        }, RemoveIgnoreList: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'set', from: Candy.Core.getUser().getEscapedJid()
          }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('list', {name: 'ignore'}).tree())
        }, GetIgnoreList: function() {
          var iq = $iq({
              type: 'get', from: Candy.Core.getUser().getEscapedJid()
            }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('list', {name: 'ignore'}).tree();
          var iqId = Candy.Core.getConnection().sendIQ(iq);
          Candy.Core.addHandler(Candy.Core.Event.Jabber.PrivacyList, null, 'iq', null, iqId)
        }, SetIgnoreListActive: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'set', from: Candy.Core.getUser().getEscapedJid()
          }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('active', {name: 'ignore'}).tree())
        }, GetJidIfAnonymous: function() {
          if (!Candy.Core.getUser().getJid()) {
            Candy.Core.debug("[Jabber] Anonymous login");
            Candy.Core.getUser().data.jid = Candy.Core.getConnection().jid
          }
        }, Room: {
          Join: function(roomJid, password) {
            self.Jabber.Room.Disco(roomJid);
            roomJid = Candy.Util.escapeJid(roomJid);
            var conn = Candy.Core.getConnection(),
              roomNick = roomJid + '/' + Candy.Core.getUser().getNick(),
              pres = $pres({
                to: roomNick, id: 'pres:' + conn.getUniqueId()
              }).c('x', {xmlns: Strophe.NS.MUC});
            if (password) {
              pres.c('password').t(password)
            }
            pres.up().c('c', conn.caps.generateCapsAttrs());
            conn.send(pres.tree())
          }, Leave: function(roomJid) {
              var room = Candy.Core.getRoom(roomJid);
              if (room) {
                var user = room.getUser();
                if (user) {
                  roomJid = Candy.Util.escapeJid(roomJid);
                  Candy.Core.getConnection().muc.leave(roomJid, user.getNick(), function(){})
                }
              }
            }, Disco: function(roomJid) {
              Candy.Core.getConnection().sendIQ($iq({
                type: 'get', from: Candy.Core.getUser().getEscapedJid(), to: Candy.Util.escapeJid(roomJid)
              }).c('query', {xmlns: Strophe.NS.DISCO_INFO}).tree())
            }, Message: function(roomJid, msg, type, xhtmlMsg, source) {
              msg = $.trim(msg);
              if (msg === '') {
                return false
              }
              var nick = null;
              if (type === 'chat') {
                nick = Strophe.getResourceFromJid(roomJid);
                roomJid = Strophe.getBareJidFromJid(roomJid)
              }
              Candy.Core.getConnection().muc.message(roomJid, nick, msg, xhtmlMsg, type, source);
              return true
            }, Invite: function(roomJid, invitees, reason, password) {
              reason = $.trim(reason);
              var message = $msg({to: roomJid});
              var x = message.c('x', {xmlns: Strophe.NS.MUC_USER});
              $.each(invitees, function(i, invitee) {
                invitee = Strophe.getBareJidFromJid(invitee);
                x.c('invite', {to: invitee});
                if (typeof reason !== 'undefined' && reason !== '') {
                  x.c('reason', reason)
                }
              });
              if (typeof password !== 'undefined' && password !== '') {
                x.c('password', password)
              }
              Candy.Core.getConnection().send(message)
            }, IgnoreUnignore: function(userJid) {
              Candy.Core.getUser().addToOrRemoveFromPrivacyList('ignore', userJid);
              Candy.Core.Action.Jabber.Room.UpdatePrivacyList()
            }, UpdatePrivacyList: function() {
              var currentUser = Candy.Core.getUser(),
                iq = $iq({
                  type: 'set', from: currentUser.getEscapedJid()
                }).c('query', {xmlns: 'jabber:iq:privacy'}).c('list', {name: 'ignore'}),
                privacyList = currentUser.getPrivacyList('ignore');
              if (privacyList.length > 0) {
                $.each(privacyList, function(index, jid) {
                  iq.c('item', {
                    type: 'jid', value: Candy.Util.escapeJid(jid), action: 'deny', order: index
                  }).c('message').up().up()
                })
              }
              else {
                iq.c('item', {
                  action: 'allow', order: '0'
                })
              }
              Candy.Core.getConnection().sendIQ(iq.tree())
            }, Admin: {
              UserAction: function(roomJid, userJid, type, reason) {
                roomJid = Candy.Util.escapeJid(roomJid);
                userJid = Candy.Util.escapeJid(userJid);
                var itemObj = {nick: Strophe.getResourceFromJid(userJid)};
                switch (type) {
                  case'kick':
                    itemObj.role = 'none';
                    break;
                  case'ban':
                    itemObj.affiliation = 'outcast';
                    break;
                  default:
                    return false
                }
                Candy.Core.getConnection().sendIQ($iq({
                  type: 'set', from: Candy.Core.getUser().getEscapedJid(), to: roomJid
                }).c('query', {xmlns: Strophe.NS.MUC_ADMIN}).c('item', itemObj).c('reason').t(reason).tree());
                return true
              }, SetSubject: function(roomJid, subject) {
                  Candy.Core.getConnection().muc.setTopic(Candy.Util.escapeJid(roomJid), subject)
                }
            }
        }
    };
    return self
  }(Candy.Core.Action || {}, Strophe, jQueryCandyInstance));
  Candy.Core.ChatRoom = function(roomJid) {
    this.room = {
      jid: roomJid, name: Strophe.getNodeFromJid(roomJid)
    };
    this.user = null;
    this.roster = new Candy.Core.ChatRoster;
    this.setUser = function(user) {
      this.user = user;
      Candy.Core.updateCache()
    };
    this.getUser = function() {
      return this.user
    };
    this.getJid = function() {
      return this.room.jid
    };
    this.setName = function(name) {
      this.room.name = name;
      Candy.Core.updateCache()
    };
    this.getName = function() {
      return this.room.name
    };
    this.setRoster = function(roster) {
      this.roster = roster;
      Candy.Core.updateCache()
    };
    this.getRoster = function() {
      return this.roster
    }
  };
  Candy.Core.ChatRoster = function() {
    this.items = {};
    this.add = function(user) {
      this.items[user.getJid()] = user
    };
    this.remove = function(jid) {
      delete this.items[jid]
    };
    this.get = function(jid) {
      return this.items[jid]
    };
    this.getAll = function() {
      return this.items
    }
  };
  Candy.Core.ChatUser = function(jid, nick, affiliation, role) {
    this.ROLE_MODERATOR = 'moderator';
    this.AFFILIATION_OWNER = 'owner';
    this.data = {
      jid: jid, nick: Strophe.unescapeNode(nick), affiliation: affiliation, role: role, privacyLists: {}, customData: {}, previousNick: undefined
    };
    this.getJid = function() {
      if (this.data.jid) {
        return Candy.Util.unescapeJid(this.data.jid)
      }
      return
    };
    this.getEscapedJid = function() {
      return Candy.Util.escapeJid(this.data.jid)
    };
    this.setJid = function(jid) {
      this.data.jid = jid
    };
    this.getNick = function(display) {
      var name = Strophe.unescapeNode(this.data.nick);
      if (display && name.lastIndexOf('_') > 0) {
        return name.substring(0, name.lastIndexOf('_'))
      }
      return name
    };
    this.setNick = function(nick) {
      this.data.nick = nick
    };
    this.getRole = function() {
      return this.data.role
    };
    this.setRole = function(role) {
      this.data.role = role
    };
    this.setAffiliation = function(affiliation) {
      this.data.affiliation = affiliation
    };
    this.getAffiliation = function() {
      return this.data.affiliation
    };
    this.isModerator = function() {
      return this.getRole() === this.ROLE_MODERATOR || this.getAffiliation() === this.AFFILIATION_OWNER
    };
    this.addToOrRemoveFromPrivacyList = function(list, jid) {
      if (!this.data.privacyLists[list]) {
        this.data.privacyLists[list] = []
      }
      var index = -1;
      if ((index = this.data.privacyLists[list].indexOf(jid)) !== -1) {
        this.data.privacyLists[list].splice(index, 1)
      }
      else {
        this.data.privacyLists[list].push(jid)
      }
      return this.data.privacyLists[list]
    };
    this.getPrivacyList = function(list) {
      if (!this.data.privacyLists[list]) {
        this.data.privacyLists[list] = []
      }
      return this.data.privacyLists[list]
    };
    this.setPrivacyLists = function(lists) {
      this.data.privacyLists = lists
    };
    this.isInPrivacyList = function(list, jid) {
      if (!this.data.privacyLists[list]) {
        return false
      }
      return this.data.privacyLists[list].indexOf(jid) !== -1
    };
    this.setCustomData = function(data) {
      this.data.customData = data
    };
    this.getCustomData = function() {
      return this.data.customData
    };
    this.setPreviousNick = function(previousNick) {
      this.data.previousNick = previousNick
    };
    this.getPreviousNick = function() {
      return this.data.previousNick
    }
  };
  Candy.Core.Event = (function(self, Strophe, $) {
    self.Login = function(presetJid) {
      $(Candy).triggerHandler('candy:core.login', {presetJid: presetJid})
    };
    self.Strophe = {Connect: function(status) {
        Candy.Core.setStropheStatus(status);
        switch (status) {
          case Strophe.Status.CONNECTED:
            Candy.Core.log('[Connection] Connected');
            Candy.Core.Action.Jabber.GetJidIfAnonymous();
            Candy.Core.updateCache();
          case Strophe.Status.ATTACHED:
            Candy.Core.log('[Connection] Attached');
            Candy.Core.Action.Jabber.Presence();
            break;
          case Strophe.Status.DISCONNECTED:
            Candy.Core.log('[Connection] Disconnected');
            break;
          case Strophe.Status.AUTHFAIL:
            Candy.Core.log('[Connection] Authentication failed');
            Candy.Core.clearCache();
            break;
          case Strophe.Status.CONNECTING:
            Candy.Core.log('[Connection] Connecting');
            break;
          case Strophe.Status.DISCONNECTING:
            Candy.Core.log('[Connection] Disconnecting');
            Candy.Core.clearCache();
            break;
          case Strophe.Status.AUTHENTICATING:
            Candy.Core.log('[Connection] Authenticating');
            break;
          case Strophe.Status.ERROR:
          case Strophe.Status.CONNFAIL:
            Candy.Core.log('[Connection] Failed (' + status + ')');
            Candy.Core.clearCache();
            break;
          default:
            Candy.Core.log('[Connection] What?!');
            Candy.Core.clearCache();
            break
        }
        $(Candy).triggerHandler('candy:core.chat.connection', {status: status})
      }};
    self.Jabber = {
      Version: function(msg) {
        Candy.Core.debug('[Jabber] Version');
        Candy.Core.Action.Jabber.Version($(msg));
        return true
      }, Presence: function(msg) {
          Candy.Core.debug('[Jabber] Presence');
          msg = $(msg);
          if (msg.children('x[xmlns^="' + Strophe.NS.MUC + '"]').length > 0) {
            if (msg.attr('type') === 'error') {
              self.Jabber.Room.PresenceError(msg)
            }
            else {
              self.Jabber.Room.Presence(msg)
            }
          }
          else {
            $(Candy).triggerHandler('candy:core.presence', {
              from: msg.attr('from'), stanza: msg
            })
          }
          return true
        }, Bookmarks: function(msg) {
          Candy.Core.debug('[Jabber] Bookmarks');
          $('conference', msg).each(function() {
            var item = $(this);
            if (item.attr('autojoin')) {
              Candy.Core.Action.Jabber.Room.Join(item.attr('jid'))
            }
          });
          return true
        }, PrivacyList: function(msg) {
          Candy.Core.debug('[Jabber] PrivacyList');
          var currentUser = Candy.Core.getUser();
          msg = $(msg);
          if (msg.attr('type') === 'result') {
            $('list[name="ignore"] item', msg).each(function() {
              var item = $(this);
              if (item.attr('action') === 'deny') {
                currentUser.addToOrRemoveFromPrivacyList('ignore', item.attr('value'))
              }
            });
            Candy.Core.Action.Jabber.SetIgnoreListActive();
            return false
          }
          return self.Jabber.PrivacyListError(msg)
        }, PrivacyListError: function(msg) {
          if ($('error[code="503"][type="cancel"] service-unavailable', msg)) {
            return false
          }
          Candy.Core.log('[Jabber] PrivacyListError');
          if ($('error[code="404"][type="cancel"] item-not-found', msg)) {
            Candy.Core.Action.Jabber.ResetIgnoreList();
            Candy.Core.Action.Jabber.SetIgnoreListActive()
          }
          return false
        }, Message: function(msg) {
          Candy.Core.debug('[Jabber] Message');
          msg = $(msg);
          var fromJid = msg.attr('from'),
            type = msg.attr('type') || 'undefined',
            toJid = msg.attr('to');
          if (type === 'normal' || type === 'undefined') {
            var mediatedInvite = msg.find('invite'),
              directInvite = msg.find('x[xmlns="jabber:x:conference"]');
            if (mediatedInvite.length > 0) {
              var passwordNode = msg.find('password'),
                password = null,
                continueNode = mediatedInvite.find('continue'),
                continuedThread = null;
              if (passwordNode) {
                password = passwordNode.text()
              }
              if (continueNode) {
                continuedThread = continueNode.attr('thread')
              }
              $(Candy).triggerHandler('candy:core:chat:invite', {
                roomJid: fromJid, from: mediatedInvite.attr('from') || 'undefined', reason: mediatedInvite.find('reason') || '', password: password, continuedThread: continuedThread, inviteType: "MediatedInvite"
              })
            }
            if (directInvite.length > 0) {
              $(Candy).triggerHandler('candy:core:chat:invite', {
                roomJid: directInvite.attr('jid'), from: fromJid, reason: directInvite.attr('reason') || '', password: directInvite.attr('password'), continuedThread: directInvite.attr('thread'), inviteType: "DirectInvite"
              })
            }
            $(Candy).triggerHandler('candy:core:chat:message:normal', {
              type: (type || 'normal'), message: msg
            });
            return true
          }
          else if (type !== 'groupchat' && type !== 'chat' && type !== 'error' && type !== 'headline') {
            $(Candy).triggerHandler('candy:core:chat:message:other', {
              type: type, message: msg
            });
            return true
          }
          if (fromJid !== Strophe.getDomainFromJid(fromJid) && (type === 'groupchat' || type === 'chat' || type === 'error')) {
            self.Jabber.Room.Message(msg)
          }
          else if (!toJid && fromJid === Strophe.getDomainFromJid(fromJid)) {
            $(Candy).triggerHandler('candy:core.chat.message.admin', {
              type: (type || 'message'), message: msg.children('body').text()
            })
          }
          else if (toJid && fromJid === Strophe.getDomainFromJid(fromJid)) {
            $(Candy).triggerHandler('candy:core.chat.message.server', {
              type: (type || 'message'), subject: msg.children('subject').text(), message: msg.children('body').text()
            })
          }
          return true
        }, Room: {
          Leave: function(msg) {
            Candy.Core.debug('[Jabber:Room] Leave');
            msg = $(msg);
            var from = Candy.Util.unescapeJid(msg.attr('from')),
              roomJid = Strophe.getBareJidFromJid(from);
            if (!Candy.Core.getRoom(roomJid)) {
              return true
            }
            var roomName = Candy.Core.getRoom(roomJid).getName(),
              item = msg.find('item'),
              type = 'leave',
              reason,
              actor;
            delete Candy.Core.getRooms()[roomJid];
            Candy.Core.updateCache();
            if (item.attr('role') === 'none') {
              var code = msg.find('status').attr('code');
              if (code === '307') {
                type = 'kick'
              }
              else if (code === '301') {
                type = 'ban'
              }
              reason = item.find('reason').text();
              actor = item.find('actor').attr('jid')
            }
            var user = new Candy.Core.ChatUser(from, Strophe.getResourceFromJid(from), item.attr('affiliation'), item.attr('role'));
            $(Candy).triggerHandler('candy:core.presence.leave', {
              roomJid: roomJid, roomName: roomName, type: type, reason: reason, actor: actor, user: user
            });
            return true
          }, Disco: function(msg) {
              Candy.Core.debug('[Jabber:Room] Disco');
              msg = $(msg);
              if (!msg.find('identity[category="conference"]').length) {
                return true
              }
              var roomJid = Strophe.getBareJidFromJid(Candy.Util.unescapeJid(msg.attr('from')));
              if (!Candy.Core.getRooms()[roomJid]) {
                Candy.Core.getRooms()[roomJid] = new Candy.Core.ChatRoom(roomJid)
              }
              var identity = msg.find('identity');
              if (identity.length) {
                var roomName = identity.attr('name'),
                  room = Candy.Core.getRoom(roomJid);
                if (room.getName() === null) {
                  room.setName(Strophe.unescapeNode(roomName))
                }
              }
              Candy.Core.updateCache();
              return true
            }, Presence: function(msg) {
              Candy.Core.debug('[Jabber:Room] Presence');
              var from = Candy.Util.unescapeJid(msg.attr('from')),
                roomJid = Strophe.getBareJidFromJid(from),
                presenceType = msg.attr('type'),
                status = msg.find('status'),
                nickAssign = false,
                nickChange = false;
              if (status.length) {
                for (var i = 0, l = status.length; i < l; i++) {
                  var $status = $(status[i]),
                    code = $status.attr('code');
                  if (code === '303') {
                    nickChange = true
                  }
                  else if (code === '210') {
                    nickAssign = true
                  }
                }
              }
              var room = Candy.Core.getRoom(roomJid);
              if (!room) {
                Candy.Core.getRooms()[roomJid] = new Candy.Core.ChatRoom(roomJid);
                room = Candy.Core.getRoom(roomJid)
              }
              var currentUser = room.getUser() ? room.getUser() : Candy.Core.getUser();
              if (Strophe.getResourceFromJid(from) === currentUser.getNick() && presenceType === 'unavailable' && nickChange === false) {
                self.Jabber.Room.Leave(msg);
                return true
              }
              var roster = room.getRoster(),
                action,
                user,
                nick,
                item = msg.find('item');
              if (presenceType !== 'unavailable') {
                if (roster.get(from)) {
                  user = roster.get(from);
                  var role = item.attr('role'),
                    affiliation = item.attr('affiliation');
                  user.setRole(role);
                  user.setAffiliation(affiliation);
                  action = 'join'
                }
                else {
                  nick = Strophe.getResourceFromJid(from);
                  user = new Candy.Core.ChatUser(from, nick, item.attr('affiliation'), item.attr('role'));
                  if (room.getUser() === null && (Candy.Core.getUser().getNick() === nick || nickAssign)) {
                    room.setUser(user);
                    currentUser = user
                  }
                  roster.add(user);
                  action = 'join'
                }
              }
              else {
                user = roster.get(from);
                roster.remove(from);
                if (nickChange) {
                  nick = item.attr('nick');
                  action = 'nickchange';
                  user.setPreviousNick(user.getNick());
                  user.setNick(nick);
                  user.setJid(Strophe.getBareJidFromJid(from) + '/' + nick);
                  roster.add(user)
                }
                else {
                  action = 'leave';
                  if (item.attr('role') === 'none') {
                    if (msg.find('status').attr('code') === '307') {
                      action = 'kick'
                    }
                    else if (msg.find('status').attr('code') === '301') {
                      action = 'ban'
                    }
                  }
                }
              }
              $(Candy).triggerHandler('candy:core.presence.room', {
                roomJid: roomJid, roomName: room.getName(), user: user, action: action, currentUser: currentUser
              });
              Candy.Core.updateCache();
              return true
            }, PresenceError: function(msg) {
              Candy.Core.log('[Jabber:Room] Presence Error');
              var from = Candy.Util.unescapeJid(msg.attr('from')),
                roomJid = Strophe.getBareJidFromJid(from),
                room = Candy.Core.getRooms()[roomJid],
                roomName = room && room.getName() || null;
              Candy.Core.removeRoom(roomJid);
              room = undefined;
              $(Candy).triggerHandler('candy:core.presence.error', {
                msg: msg, type: msg.children('error').children()[0].tagName.toLowerCase(), roomJid: roomJid, roomName: roomName
              });
              return true
            }, Message: function(msg) {
              Candy.Core.debug('[Jabber:Room] Message');
              var roomJid,
                message,
                name;
              if (msg.children('subject').length > 0 && msg.children('subject').text().length > 0 && msg.attr('type') === 'groupchat') {
                roomJid = Candy.Util.unescapeJid(Strophe.getBareJidFromJid(msg.attr('from')));
                message = {
                  name: Strophe.getNodeFromJid(roomJid), body: msg.children('subject').text(), type: 'subject'
                }
              }
              else if (msg.attr('type') === 'error') {
                var error = msg.children('error');
                if (error.children('text').length > 0) {
                  roomJid = msg.attr('from');
                  message = {
                    type: 'info', body: error.children('text').text()
                  }
                }
              }
              else if (msg.children('composing').length > 0 || msg.children('inactive').length > 0 || msg.children('paused').length > 0 || msg.children('gone').length > 0) {
                var from = Candy.Util.unescapeJid(msg.attr("from"));
                roomJid = Strophe.getBareJidFromJid(from);
                name = Strophe.getResourceFromJid(from);
                var chatstate;
                if (msg.children('active').length > 0) {
                  chatstate = 'active'
                }
                else if (msg.children('composing').length > 0) {
                  chatstate = 'composing'
                }
                else if (msg.children('paused').length > 0) {
                  chatstate = 'paused'
                }
                else if (msg.children('inactive').length > 0) {
                  chatstate = 'inactive'
                }
                else if (msg.children('gone').length > 0) {
                  chatstate = 'gone'
                }
                $(Candy).triggerHandler('candy:core.message.chatstate', {
                  name: name, displayName: Candy.Util.getDisplayName(name), roomJid: roomJid, chatstate: chatstate
                });
                return true
              }
              else if (msg.children('body').length >= 0) {
                if (msg.attr('type') === 'chat' || msg.attr('type') === 'normal') {
                  roomJid = Candy.Util.unescapeJid(msg.attr('from'));
                  var bareRoomJid = Strophe.getBareJidFromJid(roomJid),
                    isNoConferenceRoomJid = !Candy.Core.getRoom(bareRoomJid);
                  name = isNoConferenceRoomJid ? Strophe.getNodeFromJid(roomJid) : Strophe.getResourceFromJid(roomJid);
                  message = {
                    name: name, body: msg.children('body').text(), type: msg.attr('type'), isNoConferenceRoomJid: isNoConferenceRoomJid
                  }
                }
                else {
                  roomJid = Candy.Util.unescapeJid(Strophe.getBareJidFromJid(msg.attr('from')));
                  var resource = Strophe.getResourceFromJid(msg.attr('from'));
                  if (resource) {
                    resource = Strophe.unescapeNode(resource);
                    message = {
                      name: resource, body: msg.children('body').text(), type: msg.attr('type')
                    }
                  }
                  else {
                    if (!Candy.View.Pane.Chat.rooms[msg.attr('from')]) {
                      return true
                    }
                    message = {
                      name: '', body: msg.children('body').text(), type: 'info'
                    }
                  }
                }
                var a = [];
                for (var i = 0; i < msg[0].attributes.length; i++) {
                  a.push(msg[0].attributes[i])
                }
                message.attributes = {};
                for (var i = 0; i < a.length; i++) {
                  message.attributes[a[i].name] = a[i].value
                }
                var xhtmlChild = msg.children('html[xmlns="' + Strophe.NS.XHTML_IM + '"]');
                if (Candy.View.getOptions().enableXHTML === true && xhtmlChild.length > 0) {
                  var xhtmlMessage = xhtmlChild.children('body[xmlns="' + Strophe.NS.XHTML + '"]').first().html();
                  message.xhtmlMessage = xhtmlMessage
                }
              }
              else {
                return true
              }
              var delay = msg.children('delay') ? msg.children('delay') : msg.children('x[xmlns="' + Strophe.NS.DELAY + '"]'),
                timestamp = delay !== undefined ? delay.attr('stamp') : null;
              $(Candy).triggerHandler('candy:core.message', {
                roomJid: roomJid, message: message, timestamp: timestamp
              });
              return true
            }
        }
    };
    return self
  }(Candy.Core.Event || {}, Strophe, jQueryCandyInstance));
  Candy.View.Observer = (function(self, $) {
    var _showConnectedMessageModal = true;
    self.Chat = {
      Connection: function(event, args) {
        var eventName = 'candy:view.connection.status-' + args.status;
        if ($(Candy).triggerHandler(eventName) === false) {
          return false
        }
        switch (args.status) {
          case Strophe.Status.CONNECTING:
          case Strophe.Status.AUTHENTICATING:
            Candy.View.Pane.Chat.Modal.show($.i18n._('statusConnecting'), false, true);
            break;
          case Strophe.Status.ATTACHED:
          case Strophe.Status.CONNECTED:
            if (_showConnectedMessageModal === true) {
              Candy.View.Pane.Chat.Modal.show($.i18n._('statusConnected'));
              Candy.View.Pane.Chat.Modal.hide()
            }
            break;
          case Strophe.Status.DISCONNECTING:
            Candy.View.Pane.Chat.Modal.show($.i18n._('statusDisconnecting'), false, true);
            break;
          case Strophe.Status.DISCONNECTED:
            var presetJid = Candy.Core.isAnonymousConnection() ? Strophe.getDomainFromJid(Candy.Core.getUser().getJid()) : null;
            Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('statusDisconnected'), presetJid);
            break;
          case Strophe.Status.AUTHFAIL:
            Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('statusAuthfail'));
            break;
          default:
            Candy.View.Pane.Chat.Modal.show($.i18n._('status', args.status));
            break
        }
      }, Message: function(event, args) {
          if (args.type === 'message') {
            Candy.View.Pane.Chat.adminMessage((args.subject || ''), args.message)
          }
          else if (args.type === 'chat' || args.type === 'groupchat') {
            Candy.View.Pane.Chat.onInfoMessage(Candy.View.getCurrent().roomJid, (args.subject || ''), args.message)
          }
        }
    };
    self.Presence = {
      update: function(event, args) {
        if (args.type === 'leave' || args.type === 'kick' || args.type === 'ban') {
          var evtData = {
              type: args.type, reason: args.reason, roomJid: args.roomJid, user: args.user
            };
          $(Candy).triggerHandler('candy:view.presence', [evtData])
        }
        else if (args.roomJid) {
          if (!args.user)
            return false;
          args.roomJid = Candy.Util.unescapeJid(args.roomJid);
          if (!Candy.View.Pane.Chat.rooms[args.roomJid]) {
            if (Candy.View.Pane.Room.init(args.roomJid, args.roomName) === false) {
              return false
            }
            if ($('#chat-rooms').children().length === 1) {
              Candy.View.Pane.Room.show(args.roomJid)
            }
          }
          Candy.View.Pane.Roster.update(args.roomJid, args.user, args.action, args.currentUser);
          if (Candy.View.Pane.Chat.rooms[args.user.getJid()] && args.action !== 'nickchange') {
            Candy.View.Pane.Roster.update(args.user.getJid(), args.user, args.action, args.currentUser);
            Candy.View.Pane.PrivateRoom.setStatus(args.user.getJid(), args.action)
          }
        }
      }, notifyPrivateChats: function(user, type) {
          Candy.Core.log('[View:Observer] notify Private Chats');
          var roomJid;
          for (roomJid in Candy.View.Pane.Chat.rooms) {
            if (Candy.View.Pane.Chat.rooms.hasOwnProperty(roomJid) && Candy.View.Pane.Room.getUser(roomJid) && user.getJid() === Candy.View.Pane.Room.getUser(roomJid).getJid()) {
              Candy.View.Pane.Roster.update(roomJid, user, type, user);
              Candy.View.Pane.PrivateRoom.setStatus(roomJid, type)
            }
          }
        }
    };
    self.PresenceError = function(obj, args) {
      switch (args.type) {
        case'not-authorized':
          var message;
          if (args.msg.children('x').children('password').length > 0) {
            message = $.i18n._('passwordEnteredInvalid', [args.roomName])
          }
          Candy.View.Pane.Chat.Modal.showEnterPasswordForm(args.roomJid, args.roomName, message);
          break;
        case'conflict':
          Candy.View.Pane.Chat.Modal.showNicknameConflictForm(args.roomJid);
          break;
        case'registration-required':
          Candy.View.Pane.Chat.Modal.showError('errorMembersOnly', [args.roomName]);
          break;
        case'service-unavailable':
          Candy.View.Pane.Chat.Modal.showError('errorMaxOccupantsReached', [args.roomName]);
          break
      }
    };
    self.Message = function(event, args) {
      if (!Candy.View.Pane.Chat.rooms[args.roomJid]) {
        Candy.View.Pane.Room.init(args.roomJid, args.message.name);
        Candy.View.Pane.Room.setUser(args.roomJid, Candy.Core.getUser());
        Candy.View.Pane.Room.show(args.roomJid)
      }
      if (args.message.type === 'subject') {
        Candy.View.Pane.Room.setSubject(args.roomJid, args.message.body)
      }
      else if (args.message.type === 'info') {
        Candy.View.Pane.Chat.infoMessage(args.roomJid, args.message.body)
      }
      else {
        if (args.message.type === 'chat' && !Candy.View.Pane.Chat.rooms[args.roomJid]) {
          Candy.View.Pane.PrivateRoom.open(args.roomJid, args.message.name, false, args.message.isNoConferenceRoomJid)
        }
        Candy.View.Pane.Message.show(args.roomJid, args.message.name, args.message.body, args.message.xhtmlMessage, args.timestamp, args.message.attributes)
      }
    };
    self.Login = function(event, args) {
      Candy.View.Pane.Chat.Modal.showLoginForm(null, args.presetJid)
    };
    self.AutojoinMissing = function() {
      _showConnectedMessageModal = false;
      Candy.View.Pane.Chat.Modal.showError('errorAutojoinMissing')
    };
    return self
  }(Candy.View.Observer || {}, jQueryCandyInstance));
  Candy.View.Pane = (function(self, $) {
    self.Window = {
      _hasFocus: true, _plainTitle: document.title, _unreadMessagesCount: 0, autoscroll: true, hasFocus: function() {
          return self.Window._hasFocus
        }, increaseUnreadMessages: function() {
          self.Window.renderUnreadMessages(++self.Window._unreadMessagesCount)
        }, reduceUnreadMessages: function(num) {
          self.Window._unreadMessagesCount -= num;
          if (self.Window._unreadMessagesCount <= 0) {
            self.Window.clearUnreadMessages()
          }
          else {
            self.Window.renderUnreadMessages(self.Window._unreadMessagesCount)
          }
        }, clearUnreadMessages: function() {
          self.Window._unreadMessagesCount = 0;
          document.title = self.Window._plainTitle
        }, renderUnreadMessages: function(count) {
          document.title = Candy.View.Template.Window.unreadmessages.replace('{{count}}', count).replace('{{title}}', self.Window._plainTitle)
        }, onFocus: function() {
          self.Window._hasFocus = true;
          if (Candy.View.getCurrent().roomJid) {
            self.Room.setFocusToForm(Candy.View.getCurrent().roomJid);
            self.Chat.clearUnreadMessages(Candy.View.getCurrent().roomJid)
          }
        }, onBlur: function() {
          self.Window._hasFocus = false
        }
    };
    self.Chat = {
      rooms: [], addTab: function(roomJid, roomName, roomType) {
          var roomId = Candy.Util.jidToId(roomJid),
            html = Mustache.to_html(Candy.View.Template.Chat.tab, {
              roomJid: roomJid, roomId: roomId, name: roomName || Strophe.getNodeFromJid(roomJid), privateUserChat: function() {
                  return roomType === 'chat'
                }, roomType: roomType
            }),
            tab = $(html).appendTo('#chat-tabs');
          tab.click(self.Chat.tabClick);
          $('a.close', tab).click(self.Chat.tabClose);
          self.Chat.clearUnreadMessages(roomJid);
          self.Chat.fitTabs()
        }, getTab: function(roomJid) {
          return $('#chat-tabs').children('li[data-roomjid="' + roomJid + '"]')
        }, removeTab: function(roomJid) {
          self.Chat.getTab(roomJid).remove();
          self.Chat.fitTabs()
        }, setActiveTab: function(roomJid) {
          $('#chat-tabs').children().each(function() {
            var tab = $(this);
            if (tab.attr('data-roomjid') === roomJid) {
              tab.addClass('active')
            }
            else {
              tab.removeClass('active')
            }
          })
        }, increaseUnreadMessages: function(roomJid) {
          var unreadElem = this.getTab(roomJid).find('.unread');
          unreadElem.show().text(unreadElem.text() !== '' ? parseInt(unreadElem.text(), 10) + 1 : 1);
          if (self.Chat.rooms[roomJid].type === 'chat') {
            self.Window.increaseUnreadMessages()
          }
        }, clearUnreadMessages: function(roomJid) {
          var unreadElem = self.Chat.getTab(roomJid).find('.unread');
          self.Window.reduceUnreadMessages(unreadElem.text());
          unreadElem.hide().text('')
        }, tabClick: function(e) {
          var currentRoomJid = Candy.View.getCurrent().roomJid;
          self.Chat.rooms[currentRoomJid].scrollPosition = self.Room.getPane(currentRoomJid, '.message-pane-wrapper').scrollTop();
          self.Room.show($(this).attr('data-roomjid'));
          e.preventDefault()
        }, tabClose: function() {
          var roomJid = $(this).parent().attr('data-roomjid');
          if (self.Chat.rooms[roomJid].type === 'chat') {
            self.Room.close(roomJid)
          }
          else {
            Candy.Core.Action.Jabber.Room.Leave(roomJid)
          }
          return false
        }, allTabsClosed: function() {
          self.Chat.Toolbar.hide();
          if (Candy.Core.getOptions().disconnectWithoutTabs) {
            Candy.Core.disconnect()
          }
        }, fitTabs: function() {
          var availableWidth = $('#chat-tabs').innerWidth(),
            tabsWidth = 0,
            tabs = $('#chat-tabs').children();
          tabs.each(function() {
            tabsWidth += $(this).css({
              width: 'auto', overflow: 'visible'
            }).outerWidth(true)
          });
          if (tabsWidth > availableWidth) {
            var tabDiffToRealWidth = tabs.outerWidth(true) - tabs.width(),
              tabWidth = Math.floor((availableWidth) / tabs.length) - tabDiffToRealWidth;
            tabs.css({
              width: tabWidth, overflow: 'hidden'
            })
          }
        }, adminMessage: function(subject, message) {
          if (Candy.View.getCurrent().roomJid) {
            var html = Mustache.to_html(Candy.View.Template.Chat.adminMessage, {
                subject: subject, message: message, sender: $.i18n._('administratorMessageSubject'), time: Candy.Util.localizedTime((new Date).toGMTString())
              });
            $('#chat-rooms').children().each(function() {
              self.Room.appendToMessagePane($(this).attr('data-roomjid'), html)
            });
            $(Candy).triggerHandler('candy:view.chat.admin-message', {
              subject: subject, message: message
            })
          }
        }, infoMessage: function(roomJid, subject, message) {
          self.Chat.onInfoMessage(roomJid, subject, message)
        }, onInfoMessage: function(roomJid, subject, message) {
          if (Candy.View.Pane.Room.getPane(roomJid)) {
            var html = Mustache.to_html(Candy.View.Template.Chat.infoMessage, {
                subject: subject, message: $.i18n._(message), time: Candy.Util.localizedTime((new Date).toGMTString())
              });
            self.Room.appendToMessagePane(roomJid, html)
          }
        }, Toolbar: {
          _supportsNativeAudio: null, init: function() {
              $('#emoticons-icon').click(function(e) {
                self.Chat.Context.showEmoticonsMenu(e.currentTarget);
                e.stopPropagation()
              });
              $('#chat-autoscroll-control').click(self.Chat.Toolbar.onAutoscrollControlClick);
              try {
                if (!!document.createElement("audio").canPlayType) {
                  var a = document.createElement("audio");
                  if (!!a.canPlayType("audio/mpeg;").replace(/no/, "")) {
                    self.Chat.Toolbar._supportsNativeAudio = "mp3"
                  }
                  else if (!!a.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, "")) {
                    self.Chat.Toolbar._supportsNativeAudio = "ogg"
                  }
                  else if (!!a.canPlayType('audio/mp4; codecs="mp4a.40.2"').replace(/no/, "")) {
                    self.Chat.Toolbar._supportsNativeAudio = "m4a"
                  }
                }
              }
              catch(e) {
                Candy.Core.log("[View:Pane:Toolbar] init error:");
                Candy.Core.log(e)
              }
              $("#chat-sound-control").click(self.Chat.Toolbar.onSoundControlClick);
              if (Candy.Util.cookieExists("candy-nosound")) {
                $("#chat-sound-control").click()
              }
              $('#chat-statusmessage-control').click(self.Chat.Toolbar.onStatusMessageControlClick);
              if (Candy.Util.cookieExists('candy-nostatusmessages')) {
                $('#chat-statusmessage-control').click()
              }
            }, show: function() {
              $('#chat-toolbar').show()
            }, hide: function() {
              $('#chat-toolbar').hide()
            }, update: function(roomJid) {
              var context = $('#chat-toolbar').find('.context'),
                me = self.Room.getUser(roomJid);
              if (!me || !me.isModerator()) {
                context.hide()
              }
              else {
                context.show().click(function(e) {
                  self.Chat.Context.show(e.currentTarget, roomJid);
                  e.stopPropagation()
                })
              }
              self.Chat.Toolbar.updateUsercount(self.Chat.rooms[roomJid].usercount)
            }, playSound: function(resource) {
              self.Chat.Toolbar.onPlaySound(resource)
            }, onPlaySound: function(resource) {
              if (!Candy.View.getOptions().assets)
                return;
              var filename = resource || "new_message";
              try {
                if (self.Chat.Toolbar._supportsNativeAudio !== null) {
                  new Audio(Candy.View.getOptions().assets + "sfx/" + filename + '.' + self.Chat.Toolbar._supportsNativeAudio).play()
                }
                else {
                  $("#chat-sound-control bgsound").remove();
                  $("<bgsound/>").attr({
                    src: Candy.View.getOptions().assets + "sfx/" + filename + ".mp3", loop: 1, autostart: true
                  }).appendTo("#chat-sound-control")
                }
              }
              catch(e) {
                Candy.Core.log("[View:Pane:Toolbar] onPlaySound error:");
                Candy.Core.log(e)
              }
            }, onSoundControlClick: function() {
              var control = $('#chat-sound-control');
              if (control.hasClass('checked')) {
                self.Chat.Toolbar.playSound = function(resource){};
                Candy.Util.setCookie('candy-nosound', '1', 365)
              }
              else {
                self.Chat.Toolbar.playSound = function(resource) {
                  self.Chat.Toolbar.onPlaySound(resource)
                };
                Candy.Util.deleteCookie('candy-nosound');
                self.Chat.Toolbar.playSound("toggle_on")
              }
              control.toggleClass('checked')
            }, onAutoscrollControlClick: function() {
              var control = $('#chat-autoscroll-control');
              if (control.hasClass('checked')) {
                self.Room.scrollToBottom = function(roomJid) {
                  self.Room.onScrollToStoredPosition(roomJid)
                };
                self.Window.autoscroll = false
              }
              else {
                self.Room.scrollToBottom = function(roomJid) {
                  self.Room.onScrollToBottom(roomJid)
                };
                self.Room.scrollToBottom(Candy.View.getCurrent().roomJid);
                self.Window.autoscroll = true
              }
              control.toggleClass('checked')
            }, onStatusMessageControlClick: function() {
              var control = $('#chat-statusmessage-control');
              if (control.hasClass('checked')) {
                self.Chat.infoMessage = function(){};
                Candy.Util.setCookie('candy-nostatusmessages', '1', 365)
              }
              else {
                self.Chat.infoMessage = function(roomJid, subject, message) {
                  self.Chat.onInfoMessage(roomJid, subject, message)
                };
                Candy.Util.deleteCookie('candy-nostatusmessages')
              }
              control.toggleClass('checked')
            }, updateUsercount: function(count) {
              $('#chat-usercount').text(count)
            }
        }, Modal: {
          show: function(html, showCloseControl, showSpinner) {
            if (showCloseControl) {
              self.Chat.Modal.showCloseControl()
            }
            else {
              self.Chat.Modal.hideCloseControl()
            }
            if (showSpinner) {
              self.Chat.Modal.showSpinner()
            }
            else {
              self.Chat.Modal.hideSpinner()
            }
            $('#chat-modal').stop(false, true);
            $('#chat-modal-body').html(html);
            $('#chat-modal').fadeIn('fast');
            $('#chat-modal-overlay').show()
          }, hide: function(callback) {
              $('#chat-modal').fadeOut('fast', function() {
                $('#chat-modal-body').text('');
                $('#chat-modal-overlay').hide()
              });
              $(document).keydown(function(e) {
                if (e.which === 27) {
                  e.preventDefault()
                }
              });
              if (callback) {
                callback()
              }
            }, showSpinner: function() {
              $('#chat-modal-spinner').show()
            }, hideSpinner: function() {
              $('#chat-modal-spinner').hide()
            }, showCloseControl: function() {
              $('#admin-message-cancel').show().click(function(e) {
                self.Chat.Modal.hide();
                e.preventDefault()
              });
              $(document).keydown(function(e) {
                if (e.which === 27) {
                  self.Chat.Modal.hide();
                  e.preventDefault()
                }
              })
            }, hideCloseControl: function() {
              $('#admin-message-cancel').hide().click(function(){})
            }, showLoginForm: function(message, presetJid) {
              self.Chat.Modal.show((message ? message : '') + Mustache.to_html(Candy.View.Template.Login.form, {
                _labelNickname: $.i18n._('labelNickname'), _labelUsername: $.i18n._('labelUsername'), _labelPassword: $.i18n._('labelPassword'), _loginSubmit: $.i18n._('loginSubmit'), displayPassword: !Candy.Core.isAnonymousConnection(), displayUsername: !presetJid, displayNickname: Candy.Core.isAnonymousConnection(), presetJid: presetJid ? presetJid : false
              }));
              $('#login-form').children(':input:first').focus();
              $('#login-form').submit(function() {
                var username = $('#username').val(),
                  password = $('#password').val();
                if (!Candy.Core.isAnonymousConnection()) {
                  var jid = Candy.Core.getUser() && username.indexOf("@") < 0 ? username + '@' + Strophe.getDomainFromJid(Candy.Core.getUser().getJid()) : username;
                  if (jid.indexOf("@") < 0 && !Candy.Core.getUser()) {
                    Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('loginInvalid'))
                  }
                  else {
                    Candy.Core.connect(jid, password)
                  }
                }
                else {
                  Candy.Core.connect(presetJid, null, username)
                }
                return false
              })
            }, showEnterPasswordForm: function(roomJid, roomName, message) {
              self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.enterPasswordForm, {
                roomName: roomName, _labelPassword: $.i18n._('labelPassword'), _label: (message ? message : $.i18n._('enterRoomPassword', [roomName])), _joinSubmit: $.i18n._('enterRoomPasswordSubmit')
              }), true);
              $('#password').focus();
              $('#enter-password-form').submit(function() {
                var password = $('#password').val();
                self.Chat.Modal.hide(function() {
                  Candy.Core.Action.Jabber.Room.Join(roomJid, password)
                });
                return false
              })
            }, showNicknameConflictForm: function(roomJid) {
              self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.nicknameConflictForm, {
                _labelNickname: $.i18n._('labelNickname'), _label: $.i18n._('nicknameConflict'), _loginSubmit: $.i18n._('loginSubmit')
              }));
              $('#nickname').focus();
              $('#nickname-conflict-form').submit(function() {
                var nickname = $('#nickname').val();
                self.Chat.Modal.hide(function() {
                  Candy.Core.getUser().data.nick = nickname;
                  Candy.Core.Action.Jabber.Room.Join(roomJid)
                });
                return false
              })
            }, showError: function(message, replacements) {
              self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.displayError, {_error: $.i18n._(message, replacements)}), true)
            }
        }, Tooltip: {show: function(event, content) {
            var tooltip = $('#tooltip'),
              target = $(event.currentTarget);
            if (!content) {
              content = target.attr('data-tooltip')
            }
            if (tooltip.length === 0) {
              var html = Mustache.to_html(Candy.View.Template.Chat.tooltip);
              $('#chat-pane').append(html);
              tooltip = $('#tooltip')
            }
            $('#context-menu').hide();
            tooltip.stop(false, true);
            tooltip.children('div').html(content);
            var pos = target.offset(),
              posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(tooltip, pos.left),
              posTop = Candy.Util.getPosTopAccordingToWindowBounds(tooltip, pos.top);
            tooltip.css({
              left: posLeft.px, top: posTop.px
            }).removeClass('left-top left-bottom right-top right-bottom').addClass(posLeft.backgroundPositionAlignment + '-' + posTop.backgroundPositionAlignment).fadeIn('fast');
            target.mouseleave(function(event) {
              event.stopPropagation();
              $('#tooltip').stop(false, true).fadeOut('fast', function() {
                $(this).css({
                  top: 0, left: 0
                })
              })
            })
          }}, Context: {
          init: function() {
            if ($('#context-menu').length === 0) {
              var html = Mustache.to_html(Candy.View.Template.Chat.Context.menu);
              $('#chat-pane').append(html);
              $('#context-menu').mouseleave(function() {
                $(this).fadeOut('fast')
              })
            }
          }, show: function(elem, roomJid, user) {
              elem = $(elem);
              var roomId = self.Chat.rooms[roomJid].id,
                menu = $('#context-menu'),
                links = $('ul li', menu);
              $('#tooltip').hide();
              if (!user) {
                user = Candy.Core.getUser()
              }
              links.remove();
              var menulinks = this.getMenuLinks(roomJid, user, elem),
                id,
                clickHandler = function(roomJid, user) {
                  return function(event) {
                      event.data.callback(event, roomJid, user);
                      $('#context-menu').hide()
                    }
                };
              for (id in menulinks) {
                if (menulinks.hasOwnProperty(id)) {
                  var link = menulinks[id],
                    html = Mustache.to_html(Candy.View.Template.Chat.Context.menulinks, {
                      roomId: roomId, 'class': link['class'], id: id, label: link.label
                    });
                  $('ul', menu).append(html);
                  $('#context-menu-' + id).bind('click', link, clickHandler(roomJid, user))
                }
              }
              if (id) {
                var pos = elem.offset(),
                  posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(menu, pos.left),
                  posTop = Candy.Util.getPosTopAccordingToWindowBounds(menu, pos.top);
                menu.css({
                  left: posLeft.px, top: posTop.px
                }).removeClass('left-top left-bottom right-top right-bottom').addClass(posLeft.backgroundPositionAlignment + '-' + posTop.backgroundPositionAlignment).fadeIn('fast');
                $(Candy).triggerHandler('candy:view.roster.after-context-menu', {
                  roomJid: roomJid, user: user, element: menu
                });
                return true
              }
            }, getMenuLinks: function(roomJid, user, elem) {
              var menulinks,
                id;
              var evtData = {
                  roomJid: roomJid, user: user, elem: elem, menulinks: this.initialMenuLinks(elem)
                };
              $(Candy).triggerHandler('candy:view.roster.context-menu', evtData);
              menulinks = evtData.menulinks;
              for (id in menulinks) {
                if (menulinks.hasOwnProperty(id) && menulinks[id].requiredPermission !== undefined && !menulinks[id].requiredPermission(user, self.Room.getUser(roomJid), elem)) {
                  delete menulinks[id]
                }
              }
              return menulinks
            }, initialMenuLinks: function() {
              return {
                  'private': {
                    requiredPermission: function(user, me) {
                      return me.getNick() !== user.getNick() && Candy.Core.getRoom(Candy.View.getCurrent().roomJid) && !Candy.Core.getUser().isInPrivacyList('ignore', user.getJid())
                    }, 'class': 'private', label: $.i18n._('privateActionLabel'), callback: function(e, roomJid, user) {
                        $('#user-' + Candy.Util.jidToId(roomJid) + '-' + Candy.Util.jidToId(user.getJid())).click()
                      }
                  }, ignore: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && !Candy.Core.getUser().isInPrivacyList('ignore', user.getJid())
                      }, 'class': 'ignore', label: $.i18n._('ignoreActionLabel'), callback: function(e, roomJid, user) {
                          Candy.View.Pane.Room.ignoreUser(roomJid, user.getJid())
                        }
                    }, unignore: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && Candy.Core.getUser().isInPrivacyList('ignore', user.getJid())
                      }, 'class': 'unignore', label: $.i18n._('unignoreActionLabel'), callback: function(e, roomJid, user) {
                          Candy.View.Pane.Room.unignoreUser(roomJid, user.getJid())
                        }
                    }, kick: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && me.isModerator() && !user.isModerator()
                      }, 'class': 'kick', label: $.i18n._('kickActionLabel'), callback: function(e, roomJid, user) {
                          self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
                            _label: $.i18n._('reason'), _submit: $.i18n._('kickActionLabel')
                          }), true);
                          $('#context-modal-field').focus();
                          $('#context-modal-form').submit(function() {
                            Candy.Core.Action.Jabber.Room.Admin.UserAction(roomJid, user.getJid(), 'kick', $('#context-modal-field').val());
                            self.Chat.Modal.hide();
                            return false
                          })
                        }
                    }, ban: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && me.isModerator() && !user.isModerator()
                      }, 'class': 'ban', label: $.i18n._('banActionLabel'), callback: function(e, roomJid, user) {
                          self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
                            _label: $.i18n._('reason'), _submit: $.i18n._('banActionLabel')
                          }), true);
                          $('#context-modal-field').focus();
                          $('#context-modal-form').submit(function() {
                            Candy.Core.Action.Jabber.Room.Admin.UserAction(roomJid, user.getJid(), 'ban', $('#context-modal-field').val());
                            self.Chat.Modal.hide();
                            return false
                          })
                        }
                    }, subject: {
                      requiredPermission: function(user, me) {
                        return me.getNick() === user.getNick() && me.isModerator()
                      }, 'class': 'subject', label: $.i18n._('setSubjectActionLabel'), callback: function(e, roomJid) {
                          self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
                            _label: $.i18n._('subject'), _submit: $.i18n._('setSubjectActionLabel')
                          }), true);
                          $('#context-modal-field').focus();
                          $('#context-modal-form').submit(function(e) {
                            Candy.Core.Action.Jabber.Room.Admin.SetSubject(roomJid, $('#context-modal-field').val());
                            self.Chat.Modal.hide();
                            e.preventDefault()
                          })
                        }
                    }
                }
            }, showEmoticonsMenu: function(elem) {
              elem = $(elem);
              var pos = elem.offset(),
                menu = $('#context-menu'),
                content = $('ul', menu),
                emoticons = '',
                i;
              $('#tooltip').hide();
              for (i = Candy.Util.Parser.emoticons.length - 1; i >= 0; i--) {
                emoticons = '<img src="' + Candy.Util.Parser._emoticonPath + Candy.Util.Parser.emoticons[i].image + '" alt="' + Candy.Util.Parser.emoticons[i].plain + '" />' + emoticons
              }
              content.html('<li class="emoticons">' + emoticons + '</li>');
              content.find('img').click(function() {
                var input = Candy.View.Pane.Room.getPane(Candy.View.getCurrent().roomJid, '.message-form').children('.field'),
                  value = input.val(),
                  emoticon = $(this).attr('alt') + ' ';
                if (!input.attr('disabled')) {
                  input.val(value ? value + ' ' + emoticon : emoticon).focus()
                }
              });
              var posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(menu, pos.left),
                posTop = Candy.Util.getPosTopAccordingToWindowBounds(menu, pos.top);
              menu.css({
                left: posLeft.px, top: posTop.px
              }).removeClass('left-top left-bottom right-top right-bottom').addClass(posLeft.backgroundPositionAlignment + '-' + posTop.backgroundPositionAlignment).fadeIn('fast');
              return true
            }
        }
    };
    self.Room = {
      init: function(roomJid, roomName, roomType) {
        roomType = roomType || 'groupchat';
        roomJid = Candy.Util.unescapeJid(roomJid);
        var evtData = {
            roomJid: roomJid, type: roomType
          };
        if ($(Candy).triggerHandler('candy:view.room.before-add', evtData) === false) {
          return false
        }
        if (Candy.Util.isEmptyObject(self.Chat.rooms)) {
          self.Chat.Toolbar.show()
        }
        var roomId = Candy.Util.jidToId(roomJid);
        self.Chat.rooms[roomJid] = {
          id: roomId, usercount: 0, name: roomName, type: roomType, messageCount: 0, scrollPosition: -1
        };
        $('#chat-rooms').append(Mustache.to_html(Candy.View.Template.Room.pane, {
          roomId: roomId, roomJid: roomJid, roomType: roomType, form: {_messageSubmit: $.i18n._('messageSubmit')}, roster: {_userOnline: $.i18n._('userOnline')}
        }, {
          roster: Candy.View.Template.Roster.pane, messages: Mustache.to_html(Candy.View.Template.Message.pane, {}, {header: Candy.View.Template.Message.header}), form: Candy.View.Template.Room.form
        }));
        self.Chat.addTab(roomJid, roomName, roomType);
        self.Room.getPane(roomJid, '.message-form').submit(self.Message.submit);
        evtData.element = self.Room.getPane(roomJid);
        $(Candy).triggerHandler('candy:view.room.after-add', evtData);
        self.Chat.Toolbar.playSound("new_chat");
        return roomId
      }, show: function(roomJid) {
          var roomId = self.Chat.rooms[roomJid].id,
            evtData;
          $('.room-pane').each(function() {
            var elem = $(this);
            evtData = {
              roomJid: elem.attr('data-roomjid'), element: elem
            };
            if (elem.attr('id') === ('chat-room-' + roomId)) {
              elem.show();
              Candy.View.getCurrent().roomJid = roomJid;
              self.Chat.setActiveTab(roomJid);
              self.Chat.Toolbar.update(roomJid);
              self.Chat.clearUnreadMessages(roomJid);
              self.Room.setFocusToForm(roomJid);
              self.Room.scrollToBottom(roomJid);
              $(Candy).triggerHandler('candy:view.room.after-show', evtData)
            }
            else if (elem.is(':visible')) {
              elem.hide();
              $(Candy).triggerHandler('candy:view.room.after-hide', evtData)
            }
          })
        }, setSubject: function(roomJid, subject) {
          subject = Candy.Util.Parser.linkify(Candy.Util.Parser.escape(subject));
          var html = Mustache.to_html(Candy.View.Template.Room.subject, {
              subject: subject, roomName: self.Chat.rooms[roomJid].name, _roomSubject: $.i18n._('roomSubject'), time: Candy.Util.localizedTime((new Date).toGMTString())
            });
          self.Room.appendToMessagePane(roomJid, html);
          $(Candy).triggerHandler('candy:view.room.after-subject-change', {
            roomJid: roomJid, element: self.Room.getPane(roomJid), subject: subject
          })
        }, close: function(roomJid) {
          self.Chat.removeTab(roomJid);
          self.Window.clearUnreadMessages();
          self.Room.getPane(roomJid).remove();
          var openRooms = $('#chat-rooms').children();
          if (Candy.View.getCurrent().roomJid === roomJid) {
            Candy.View.getCurrent().roomJid = null;
            if (openRooms.length === 0) {
              self.Chat.allTabsClosed()
            }
            else {
              self.Room.show(openRooms.last().attr('data-roomjid'))
            }
          }
          delete self.Chat.rooms[roomJid];
          $(Candy).triggerHandler('candy:view.room.after-close', {roomJid: roomJid})
        }, insertInMessagePane: function(roomJid, html, id, seqId) {
          var inserted = false;
          var pane = self.Room.getPane(roomJid, ".message-pane");
          if (pane.children('li[data-id="' + id + '"]').length > 0) {
            return
          }
          pane.children().each(function() {
            var msg = $(this);
            if (Number(seqId) < Number(msg.attr("data-seqid"))) {
              msg.before(html);
              inserted = true;
              return false
            }
          });
          if (!inserted)
            self.Room.getPane(roomJid, ".message-pane").append(html)
        }, appendToMessagePane: function(roomJid, html) {
          self.Room.getPane(roomJid, '.message-pane').append(html);
          self.Chat.rooms[roomJid].messageCount++;
          self.Room.sliceMessagePane(roomJid);
          if (Candy.View.getCurrent().roomJid === roomJid) {
            self.Room.scrollToBottom(roomJid)
          }
        }, sliceMessagePane: function(roomJid) {
          if (self.Window.autoscroll) {
            var options = Candy.View.getOptions().messages;
            if (self.Chat.rooms[roomJid].messageCount > options.limit) {
              self.Room.getPane(roomJid, '.message-pane').children().slice(0, options.remove).remove();
              self.Chat.rooms[roomJid].messageCount -= options.remove
            }
          }
        }, scrollToBottom: function(roomJid) {
          self.Room.onScrollToBottom(roomJid)
        }, onScrollToBottom: function(roomJid) {
          var messagePane = self.Room.getPane(roomJid, '.message-pane-wrapper');
          messagePane.scrollTop(messagePane.prop('scrollHeight'))
        }, onScrollToStoredPosition: function(roomJid) {
          if (self.Chat.rooms[roomJid].scrollPosition > -1) {
            var messagePane = self.Room.getPane(roomJid, '.message-pane-wrapper');
            messagePane.scrollTop(self.Chat.rooms[roomJid].scrollPosition);
            self.Chat.rooms[roomJid].scrollPosition = -1
          }
        }, setFocusToForm: function(roomJid) {
          var pane = self.Room.getPane(roomJid, '.message-form');
          if (pane) {
            try {
              pane.children('.field')[0].focus()
            }
            catch(e) {}
          }
        }, setUser: function(roomJid, user) {
          self.Chat.rooms[roomJid].user = user;
          var roomPane = self.Room.getPane(roomJid),
            chatPane = $('#chat-pane');
          roomPane.attr('data-userjid', user.getJid());
          if (user.isModerator()) {
            if (user.getRole() === user.ROLE_MODERATOR) {
              chatPane.addClass('role-moderator')
            }
            if (user.getAffiliation() === user.AFFILIATION_OWNER) {
              chatPane.addClass('affiliation-owner')
            }
          }
          else {
            chatPane.removeClass('role-moderator affiliation-owner')
          }
          self.Chat.Context.init()
        }, getUser: function(roomJid) {
          return self.Chat.rooms[roomJid].user
        }, ignoreUser: function(roomJid, userJid) {
          Candy.Core.Action.Jabber.Room.IgnoreUnignore(userJid);
          Candy.View.Pane.Room.addIgnoreIcon(roomJid, userJid)
        }, unignoreUser: function(roomJid, userJid) {
          Candy.Core.Action.Jabber.Room.IgnoreUnignore(userJid);
          Candy.View.Pane.Room.removeIgnoreIcon(roomJid, userJid)
        }, addIgnoreIcon: function(roomJid, userJid) {
          if (Candy.View.Pane.Chat.rooms[userJid]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[userJid].id + '-' + Candy.Util.jidToId(userJid)).addClass('status-ignored')
          }
          if (Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)].id + '-' + Candy.Util.jidToId(userJid)).addClass('status-ignored')
          }
        }, removeIgnoreIcon: function(roomJid, userJid) {
          if (Candy.View.Pane.Chat.rooms[userJid]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[userJid].id + '-' + Candy.Util.jidToId(userJid)).removeClass('status-ignored')
          }
          if (Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)].id + '-' + Candy.Util.jidToId(userJid)).removeClass('status-ignored')
          }
        }, getPane: function(roomJid, subPane) {
          if (self.Chat.rooms[roomJid]) {
            if (subPane) {
              if (self.Chat.rooms[roomJid]['pane-' + subPane]) {
                return self.Chat.rooms[roomJid]['pane-' + subPane]
              }
              else {
                self.Chat.rooms[roomJid]['pane-' + subPane] = $('#chat-room-' + self.Chat.rooms[roomJid].id).find(subPane);
                return self.Chat.rooms[roomJid]['pane-' + subPane]
              }
            }
            else {
              return $('#chat-room-' + self.Chat.rooms[roomJid].id)
            }
          }
        }, changeDataUserJidIfUserIsMe: function(roomId, user) {
          if (user.getNick() === Candy.Core.getUser().getNick()) {
            var roomElement = $('#chat-room-' + roomId);
            roomElement.attr('data-userjid', Strophe.getBareJidFromJid(roomElement.attr('data-userjid')) + '/' + user.getNick())
          }
        }
    };
    self.PrivateRoom = {
      open: function(roomJid, roomName, switchToRoom, isNoConferenceRoomJid) {
        var user = isNoConferenceRoomJid ? Candy.Core.getUser() : self.Room.getUser(Strophe.getBareJidFromJid(roomJid)),
          evtData = {
            roomJid: roomJid, roomName: roomName, type: 'chat'
          };
        if ($(Candy).triggerHandler('candy:view.private-room.before-open', evtData) === false) {
          return false
        }
        if (Candy.Core.getUser().isInPrivacyList('ignore', roomJid)) {
          return false
        }
        if (!self.Chat.rooms[roomJid]) {
          if (self.Room.init(roomJid, roomName, 'chat') === false) {
            return false
          }
        }
        if (switchToRoom) {
          self.Room.show(roomJid)
        }
        self.Roster.update(roomJid, new Candy.Core.ChatUser(roomJid, roomName), 'join', user);
        self.Roster.update(roomJid, user, 'join', user);
        self.PrivateRoom.setStatus(roomJid, 'join');
        if (isNoConferenceRoomJid) {
          self.Chat.infoMessage(roomJid, $.i18n._('presenceUnknownWarningSubject'), $.i18n._('presenceUnknownWarning'))
        }
        evtData.element = self.Room.getPane(roomJid);
        $(Candy).triggerHandler('candy:view.private-room.after-open', evtData)
      }, setStatus: function(roomJid, status) {
          var messageForm = self.Room.getPane(roomJid, '.message-form');
          if (status === 'join') {
            self.Chat.getTab(roomJid).addClass('online').removeClass('offline');
            messageForm.children('.field').removeAttr('disabled');
            messageForm.children('.submit').removeAttr('disabled');
            messageForm.parent().removeAttr('disabled');
            $('#chat-toolbar').removeAttr('disabled');
            self.Chat.getTab(roomJid)
          }
          else if (status === 'leave') {
            self.Chat.getTab(roomJid).addClass('offline').removeClass('online');
            messageForm.parent().attr('disabled', true);
            $('#chat-toolbar').attr('disabled', true);
            messageForm.children('.field').attr('disabled', true);
            messageForm.children('.submit').attr('disabled', true)
          }
        }, changeNick: function changeNick(roomJid, user) {
          Candy.Core.log('[View:Pane:PrivateRoom] changeNick');
          var previousPrivateRoomJid = roomJid + '/' + user.getPreviousNick(),
            newPrivateRoomJid = roomJid + '/' + user.getNick(),
            previousPrivateRoomId = Candy.Util.jidToId(previousPrivateRoomJid),
            newPrivateRoomId = Candy.Util.jidToId(newPrivateRoomJid),
            room = self.Chat.rooms[previousPrivateRoomJid],
            roomElement,
            roomTabElement;
          if (self.Chat.rooms[newPrivateRoomJid]) {
            self.Room.close(newPrivateRoomJid)
          }
          if (room) {
            room.name = user.getNick(true);
            room.id = newPrivateRoomId;
            self.Chat.rooms[newPrivateRoomJid] = room;
            delete self.Chat.rooms[previousPrivateRoomJid];
            roomElement = $('#chat-room-' + previousPrivateRoomId);
            if (roomElement) {
              roomElement.attr('data-roomjid', newPrivateRoomJid);
              roomElement.attr('id', 'chat-room-' + newPrivateRoomId);
              roomTabElement = $('#chat-tabs li[data-roomjid="' + previousPrivateRoomJid + '"]');
              roomTabElement.attr('data-roomjid', newPrivateRoomJid);
              roomTabElement.children('a.label').text('@' + user.getNick(true));
              if (Candy.View.getCurrent().roomJid === previousPrivateRoomJid) {
                Candy.View.getCurrent().roomJid = newPrivateRoomJid
              }
            }
          }
          else {
            roomElement = $('.room-pane.roomtype-chat[data-userjid="' + previousPrivateRoomJid + '"]');
            if (roomElement.length) {
              previousPrivateRoomId = Candy.Util.jidToId(roomElement.attr('data-roomjid'));
              roomElement.attr('data-userjid', newPrivateRoomJid)
            }
          }
          if (roomElement && roomElement.length) {
            self.Roster.changeNick(previousPrivateRoomId, user)
          }
        }
    };
    self.Roster = {
      update: function(roomJid, user, action, currentUser) {
        Candy.Core.log('[View:Pane:Roster] ' + action);
        var roomId = self.Chat.rooms[roomJid].id,
          userId = Candy.Util.jidToId(user.getJid()),
          usercountDiff = -1,
          userElem = $('#user-' + roomId + '-' + userId),
          evtData = {
            roomJid: roomJid, user: user, action: action, element: userElem
          };
        $(Candy).triggerHandler('candy:view.roster.before-update', evtData);
        if (action === 'join') {
          usercountDiff = 1;
          var html = Mustache.to_html(Candy.View.Template.Roster.user, {
              roomId: roomId, userId: userId, userJid: user.getJid(), nick: user.getNick(), displayNick: Candy.Util.crop(user.getNick(true), Candy.View.getOptions().crop.roster.nickname), role: user.getRole(), affiliation: user.getAffiliation(), me: currentUser !== undefined && user.getNick() === currentUser.getNick(), tooltipRole: $.i18n._('tooltipRole'), tooltipIgnored: $.i18n._('tooltipIgnored')
            });
          if (userElem.length < 1) {
            var userInserted = false,
              rosterPane = self.Room.getPane(roomJid, '.roster-pane');
            if (rosterPane.children().length > 0) {
              var userSortCompare = user.getNick().toUpperCase();
              rosterPane.children().each(function() {
                var elem = $(this);
                if (elem.attr('data-nick').toUpperCase() > userSortCompare) {
                  elem.before(html);
                  userInserted = true;
                  return false
                }
                return true
              })
            }
            if (!userInserted) {
              rosterPane.append(html)
            }
            self.Roster.showJoinAnimation(user, userId, roomId, roomJid, currentUser);
            self.Roster.showJoinMessage(user, userId, roomId, roomJid, currentUser)
          }
          else {
            usercountDiff = 0;
            userElem.replaceWith(html);
            $('#user-' + roomId + '-' + userId).css({opacity: 1}).show();
            if (currentUser !== undefined && user.getNick() === currentUser.getNick() && self.Room.getUser(roomJid)) {
              self.Chat.Toolbar.update(roomJid)
            }
          }
          if (currentUser !== undefined && currentUser.getNick() === user.getNick()) {
            self.Room.setUser(roomJid, user)
          }
          else {
            $('#user-' + roomId + '-' + userId).click(self.Roster.userClick)
          }
          $('#user-' + roomId + '-' + userId + ' .context').click(function(e) {
            self.Chat.Context.show(e.currentTarget, roomJid, user);
            e.stopPropagation()
          });
          if (currentUser !== undefined && currentUser.isInPrivacyList('ignore', user.getJid())) {
            Candy.View.Pane.Room.addIgnoreIcon(roomJid, user.getJid())
          }
        }
        else if (action === "leave" || action === "kick" || action === "ban") {
          self.Roster.leaveAnimation('user-' + roomId + '-' + userId);
          if (self.Chat.rooms[roomJid].type === 'chat') {
            self.Chat.onInfoMessage(roomJid, $.i18n._('userLeftRoom', [user.getNick(true)]))
          }
          else {
            self.Chat.infoMessage(roomJid, $.i18n._('userLeftRoom', [user.getNick(true)]))
          }
        }
        else if (action === 'nickchange') {
          usercountDiff = 0;
          self.Roster.changeNick(roomId, user);
          self.Room.changeDataUserJidIfUserIsMe(roomId, user);
          self.PrivateRoom.changeNick(roomJid, user);
          var infoMessage = $.i18n._('userChangedNick', [user.getPreviousNick(), user.getNick(true)]);
          self.Chat.onInfoMessage(roomJid, infoMessage)
        }
        Candy.View.Pane.Chat.rooms[roomJid].usercount += usercountDiff;
        if (roomJid === Candy.View.getCurrent().roomJid) {
          Candy.View.Pane.Chat.Toolbar.updateUsercount(Candy.View.Pane.Chat.rooms[roomJid].usercount)
        }
        evtData.element = $('#user-' + roomId + '-' + userId);
        $(Candy).triggerHandler('candy:view.roster.after-update', evtData)
      }, userClick: function() {
          var elem = $(this);
          self.PrivateRoom.open(elem.attr('data-jid'), elem.attr('data-nick'), true)
        }, showJoinAnimation: function(user, userId, roomId, roomJid, currentUser) {
          var rosterUserId = 'user-' + roomId + '-' + userId,
            $rosterUserElem = $('#' + rosterUserId);
          if (!user.getPreviousNick() || !$rosterUserElem || $rosterUserElem.is(':visible') === false) {
            self.Roster.joinAnimation(rosterUserId)
          }
        }, showJoinMessage: function(user, userId, roomId, roomJid, currentUser) {
          if (!user.getPreviousNick()) {
            if (currentUser !== undefined && user.getNick() !== currentUser.getNick()) {
              if (!user.isModerator()) {
                self.Chat.onInfoMessage(roomJid, $.i18n._("userJoinedRoom", [user.getNick(true)]))
              }
            }
          }
        }, joinAnimation: function(elementId) {
          $('#' + elementId).stop(true).slideDown('normal', function() {
            $(this).animate({opacity: 1})
          })
        }, leaveAnimation: function(elementId) {
          $('#' + elementId).stop(true).attr('id', '#' + elementId + '-leaving').animate({opacity: 0}, {complete: function() {
              $(this).slideUp('normal', function() {
                $(this).remove()
              })
            }})
        }, changeNick: function(roomId, user) {
          Candy.Core.log('[View:Pane:Roster] changeNick');
          var previousUserJid = Strophe.getBareJidFromJid(user.getJid()) + '/' + user.getPreviousNick(),
            elementId = 'user-' + roomId + '-' + Candy.Util.jidToId(previousUserJid),
            el = $('#' + elementId);
          el.attr('data-nick', user.getNick());
          el.attr('data-jid', user.getJid());
          el.children('div.label').text(user.getNick());
          el.attr('id', 'user-' + roomId + '-' + Candy.Util.jidToId(user.getJid()))
        }
    };
    self.Message = {
      submit: function(event) {
        var roomJid = Candy.View.getCurrent().roomJid,
          roomType = Candy.View.Pane.Chat.rooms[roomJid].type,
          message = $(this).children('.field').val().substring(0, Candy.View.getOptions().crop.message.body),
          xhtmlMessage,
          evtData = {
            roomJid: roomJid, message: message, xhtmlMessage: xhtmlMessage
          };
        if ($(Candy).triggerHandler('candy:view.message.before-send', evtData) === false) {
          event.preventDefault();
          return
        }
        message = evtData.message;
        xhtmlMessage = evtData.xhtmlMessage;
        Candy.Core.Action.Jabber.Room.Message(roomJid, message, roomType, xhtmlMessage, Candies.getSource());
        if (roomType === 'chat' && message) {
          self.Message.show(roomJid, self.Room.getUser(roomJid).getNick(true), message)
        }
        $(this).children('.field').val('').trigger('change').focus();
        event.preventDefault()
      }, show: function(roomJid, name, message, xhtmlMessage, timestamp, attributes) {
          var raw = message;
          message = Candy.Util.Parser.all(message.substring(0, Candy.View.getOptions().crop.message.body));
          if (xhtmlMessage) {
            xhtmlMessage = Candy.Util.parseAndCropXhtml(xhtmlMessage, Candy.View.getOptions().crop.message.body)
          }
          var isHistoryMessage = !!timestamp;
          var evtData = {
              roomJid: roomJid, name: name, rawMessage: raw, attributes: attributes, message: message, xhtmlMessage: xhtmlMessage, history: isHistoryMessage
            };
          if ($(Candy).triggerHandler('candy:view.message.before-show', evtData) === false) {
            return
          }
          message = evtData.message;
          xhtmlMessage = evtData.xhtmlMessage;
          if (xhtmlMessage !== undefined && xhtmlMessage.length > 0) {
            message = xhtmlMessage
          }
          var now = new Date,
            user = self.Room.getUser(roomJid),
            nick = user && user.getNick();
          var renderEvtData = {
              rawMessage: raw, attributes: attributes, template: Candy.View.Template.Message.item, templateData: {
                  name: name, displayName: Candy.Util.getDisplayName(name), croppedDisplayName: Candy.Util.crop(Candy.Util.getDisplayName(name), Candy.View.getOptions().crop.message.nickname), message: message, time: Candy.Util.localizedTime(timestamp || now.toGMTString()), timestamp: timestamp || now.toISOString(), stamp: (timestamp && new Date(timestamp) || now).valueOf(), id: attributes.id || "", seqId: attributes.seqId || 0x8000000000000, roomJid: roomJid, sender: name === nick ? "sender-is-me" : "sender-is-other"
                }, history: isHistoryMessage
            };
          if ($(Candy).triggerHandler('candy:view.message.before-render', renderEvtData) === false) {
            return
          }
          var html = Mustache.to_html(renderEvtData.template, renderEvtData.templateData);
          if (isHistoryMessage) {
            self.Room.insertInMessagePane(roomJid, html, attributes.id, attributes.seqId)
          }
          else {
            self.Room.appendToMessagePane(roomJid, html);
            if (Candy.View.getCurrent().roomJid !== roomJid || !self.Window.hasFocus()) {
              self.Chat.increaseUnreadMessages(roomJid);
              self.Chat.Toolbar.playSound("new_message")
            }
          }
          var elem = self.Room.getPane(roomJid, '.message-pane').children().last();
          evtData.element = elem;
          $(Candy).triggerHandler('candy:view.message.after-show', evtData)
        }
    };
    return self
  }(Candy.View.Pane || {}, jQueryCandyInstance));
  Candy.View.Template = (function(self) {
    self.Window = {unreadmessages: '({{count}}) {{title}}'};
    self.Chat = {
      pane: '<div id="chat-pane">{{> tabs}}{{> toolbar}}{{> rooms}}</div>{{> modal}}', rooms: '<div id="chat-rooms" class="rooms"></div>', tabs: '<ul id="chat-tabs"></ul>', tab: '<li class="roomtype-{{roomType}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}">' + '<a href="#" class="label">{{#privateUserChat}}@{{/privateUserChat}}{{name}}</a>' + '<small class="transfer"></small><small class="unread"></small></li>', modal: '<div id="chat-modal"><a id="admin-message-cancel" class="close" href="#">\u00d7</a>' + '<span id="chat-modal-body"></span>' + '<span id="chat-modal-spinner-wrapper"><div id="chat-modal-spinner" /></span>' + '</div><div id="chat-modal-overlay"></div>', adminMessage: '<li><small data-stamp="{{stamp}}">{{time}}</small><div class="adminmessage">' + '<span class="label">{{sender}}</span>' + '<span class="spacer">\u25b8</span><span class="message">{{subject}} {{message}}</span></div></li>', infoMessage: '<li><small data-stamp="{{stamp}}">{{time}}</small><div class="infomessage">' + '<span class="spacer">\u2022</span><span class="message">{{subject}} {{message}}</span></div></li>', stateMessage: '<li name="chat-state-message"><div class="statemessage">{{subject}} {{message}}</div></li>', toolbar: '<ul id="chat-toolbar">' + '<li id="emoticons-icon" data-tooltip="{{tooltipEmoticons}}"></li>' + '<li id="chat-sound-control" class="checked" data-tooltip="{{tooltipSound}}"></li>' + '<li id="chat-autoscroll-control" class="checked" data-tooltip="{{tooltipAutoscroll}}"></li>' + '<li class="checked" id="chat-statusmessage-control" data-tooltip="{{tooltipStatusmessage}}">' + '</li><li class="context" data-tooltip="{{tooltipAdministration}}"></li>' + '<li class="usercount" data-tooltip="{{tooltipUsercount}}">' + '<span id="chat-usercount"></span></li></ul>', Context: {
          menu: '<div id="context-menu"><i class="arrow arrow-top"></i>' + '<ul></ul><i class="arrow arrow-bottom"></i></div>', menulinks: '<li class="{{class}}" id="context-menu-{{id}}">{{label}}</li>', contextModalForm: '<form action="#" id="context-modal-form">' + '<label for="context-modal-label">{{_label}}</label>' + '<input type="text" name="contextModalField" id="context-modal-field" />' + '<input type="submit" class="button" name="send" value="{{_submit}}" /></form>', adminMessageReason: '<a id="admin-message-cancel" class="close" href="#">\u00d7</a>' + '<p>{{_action}}</p>{{#reason}}<p>{{_reason}}</p>{{/reason}}'
        }, tooltip: '<div id="tooltip"><i class="arrow arrow-top"></i>' + '<div></div><i class="arrow arrow-bottom"></i></div>'
    };
    self.Room = {
      pane: '<div class="room-pane roomtype-{{roomType}}" id="chat-room-{{roomId}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}">' + '{{> roster}}{{> messages}}{{> form}}</div>', subject: '<li><small data-stamp="{{stamp}}">{{time}}</small><div class="subject">' + '<span class="label">{{roomName}}</span>' + '<span class="spacer">\u25b8</span>{{_roomSubject}} {{{subject}}}</div></li>', form: '<div class="message-form-wrapper">' + '<form method="post" class="message-form">' + '<input name="message" class="field" type="text" aria-label="Message Form Text Field" autocomplete="off" maxlength="1000" />' + '<input type="submit" class="submit" name="submit" value="{{_messageSubmit}}" /></form></div>'
    };
    self.Roster = {
      pane: '<div class="roster-pane"></div>', user: '<div class="user role-{{role}} affiliation-{{affiliation}}{{#me}} me{{/me}}"' + ' id="user-{{roomId}}-{{userId}}" data-jid="{{userJid}}"' + ' data-nick="{{nick}}" data-role="{{role}}" data-affiliation="{{affiliation}}">' + '<div class="label">{{displayNick}}</div><ul>' + '<li class="context" id="context-{{roomId}}-{{userId}}">&#x25BE;</li>' + '<li class="role role-{{role}} affiliation-{{affiliation}}" data-tooltip="{{tooltipRole}}"></li>' + '<li class="ignore" data-tooltip="{{tooltipIgnored}}"></li></ul></div>'
    };
    self.Message = {
      pane: '{{> header}}<div class="message-pane-wrapper"><ul class="message-pane"></ul></div>', item: '<li class="{{sender}}" data-id="{{id}}" data-seqid="{{seqId}}"><small data-stamp="{{stamp}}">{{time}}</small><div><a class="label name" href="#">{{croppedDisplayName}}</a>' + '<span class="spacer">\u25b8</span><span class="message">{{{message}}}</span></div></li>', header: '<div id="header"></div>'
    };
    self.Login = {form: '<form method="post" id="login-form" class="login-form">' + '{{#displayNickname}}<label for="username">{{_labelNickname}}</label><input type="text" id="username" name="username"/>{{/displayNickname}}' + '{{#displayUsername}}<label for="username">{{_labelUsername}}</label>' + '<input type="text" id="username" name="username"/>{{/displayUsername}}' + '{{#presetJid}}<input type="hidden" id="username" name="username" value="{{presetJid}}"/>{{/presetJid}}' + '{{#displayPassword}}<label for="password">{{_labelPassword}}</label>' + '<input type="password" id="password" name="password" />{{/displayPassword}}' + '<input type="submit" class="button" value="{{_loginSubmit}}" /></form>'};
    self.PresenceError = {
      enterPasswordForm: '<strong>{{_label}}</strong>' + '<form method="post" id="enter-password-form" class="enter-password-form">' + '<label for="password">{{_labelPassword}}</label><input type="password" id="password" name="password" />' + '<input type="submit" class="button" value="{{_joinSubmit}}" /></form>', nicknameConflictForm: '<strong>{{_label}}</strong>' + '<form method="post" id="nickname-conflict-form" class="nickname-conflict-form">' + '<label for="nickname">{{_labelNickname}}</label><input type="text" id="nickname" name="nickname" />' + '<input type="submit" class="button" value="{{_loginSubmit}}" /></form>', displayError: '<strong>{{_error}}</strong>'
    };
    return self
  }(Candy.View.Template || {}));
  Candy.View.Translation = {
    en: {
      status: 'Status: %s', statusConnecting: 'Connecting...', statusConnected: 'Connected', statusDisconnecting: 'Disconnecting...', statusDisconnected: 'Disconnected', statusAuthfail: 'Authentication failed', sessionRestored: 'Session restored', roomSubject: 'Subject:', messageSubmit: 'Send', labelUsername: 'Username:', labelNickname: 'Nickname:', labelPassword: 'Password:', loginSubmit: 'Login', loginInvalid: 'Invalid JID', reason: 'Reason:', subject: 'Subject:', reasonWas: 'Reason was: %s.', kickActionLabel: 'Kick', youHaveBeenKickedBy: 'You have been kicked from %2$s by %1$s', youHaveBeenKicked: 'You have been kicked from %s', banActionLabel: 'Ban', youHaveBeenBannedBy: 'You have been banned from %1$s by %2$s', youHaveBeenBanned: 'You have been banned from %s', privateActionLabel: 'Private chat', ignoreActionLabel: 'Ignore', unignoreActionLabel: 'Unignore', setSubjectActionLabel: 'Change Subject', administratorMessageSubject: 'Administrator', userJoinedRoom: '%s joined the room.', userLeftRoom: '%s left the room.', userHasBeenKickedFromRoom: '%s has been kicked from the room.', userHasBeenBannedFromRoom: '%s has been banned from the room.', userChangedNick: '%1$s has changed his nickname to %2$s.', presenceUnknownWarningSubject: 'Notice:', presenceUnknownWarning: 'This user might be offline. We can\'t track his presence.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'You ignore this user', tooltipEmoticons: 'Emoticons', tooltipSound: 'Play sound for new messages', tooltipAutoscroll: 'Autoscroll', tooltipStatusmessage: 'Display status messages', tooltipAdministration: 'Room Administration', tooltipUsercount: 'Room Occupants', enterRoomPassword: 'Room "%s" is password protected.', enterRoomPasswordSubmit: 'Join room', passwordEnteredInvalid: 'Invalid password for room "%s".', nicknameConflict: 'Username already in use. Please choose another one.', errorMembersOnly: 'You can\'t join room "%s": Insufficient rights.', errorMaxOccupantsReached: 'You can\'t join room "%s": Too many occupants.', errorAutojoinMissing: 'No autojoin parameter set in configuration. Please set one to continue.', antiSpamMessage: 'Please do not spam. You have been blocked for a short-time.'
    }, de: {
        status: 'Status: %s', statusConnecting: 'Verbinden...', statusConnected: 'Verbunden', statusDisconnecting: 'Verbindung trennen...', statusDisconnected: 'Verbindung getrennt', statusAuthfail: 'Authentifizierung fehlgeschlagen', sessionRestored: 'Session restored', roomSubject: 'Thema:', messageSubmit: 'Senden', labelUsername: 'Benutzername:', labelNickname: 'Spitzname:', labelPassword: 'Passwort:', loginSubmit: 'Anmelden', loginInvalid: 'Ung\u00fcltige JID', reason: 'Begr\u00fcndung:', subject: 'Titel:', reasonWas: 'Begr\u00fcndung: %s.', kickActionLabel: 'Kick', youHaveBeenKickedBy: 'Du wurdest soeben aus dem Raum %1$s gekickt (%2$s)', youHaveBeenKicked: 'Du wurdest soeben aus dem Raum %s gekickt', banActionLabel: 'Ban', youHaveBeenBannedBy: 'Du wurdest soeben aus dem Raum %1$s verbannt (%2$s)', youHaveBeenBanned: 'Du wurdest soeben aus dem Raum %s verbannt', privateActionLabel: 'Privater Chat', ignoreActionLabel: 'Ignorieren', unignoreActionLabel: 'Nicht mehr ignorieren', setSubjectActionLabel: 'Thema \u00e4ndern', administratorMessageSubject: 'Administrator', userJoinedRoom: '%s hat soeben den Raum betreten.', userLeftRoom: '%s hat soeben den Raum verlassen.', userHasBeenKickedFromRoom: '%s ist aus dem Raum gekickt worden.', userHasBeenBannedFromRoom: '%s ist aus dem Raum verbannt worden.', userChangedNick: '%1$s hat den Nicknamen zu %2$s ge\u00e4ndert.', presenceUnknownWarningSubject: 'Hinweis:', presenceUnknownWarning: 'Dieser Benutzer k\u00f6nnte bereits abgemeldet sein. Wir k\u00f6nnen seine Anwesenheit nicht verfolgen.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'Du ignorierst diesen Benutzer', tooltipEmoticons: 'Smileys', tooltipSound: 'Ton abspielen bei neuen Nachrichten', tooltipAutoscroll: 'Autoscroll', tooltipStatusmessage: 'Statusnachrichten anzeigen', tooltipAdministration: 'Raum Administration', tooltipUsercount: 'Anzahl Benutzer im Raum', enterRoomPassword: 'Raum "%s" ist durch ein Passwort gesch\u00fctzt.', enterRoomPasswordSubmit: 'Raum betreten', passwordEnteredInvalid: 'Inkorrektes Passwort f\u00fcr Raum "%s".', nicknameConflict: 'Der Benutzername wird bereits verwendet. Bitte w\u00e4hle einen anderen.', errorMembersOnly: 'Du kannst den Raum "%s" nicht betreten: Ungen\u00fcgende Rechte.', errorMaxOccupantsReached: 'Du kannst den Raum "%s" nicht betreten: Benutzerlimit erreicht.', errorAutojoinMissing: 'Keine "autojoin" Konfiguration gefunden. Bitte setze eine konfiguration um fortzufahren.', antiSpamMessage: 'Bitte nicht spammen. Du wurdest f\u00fcr eine kurze Zeit blockiert.'
      }, fr: {
        status: 'Status: %s', statusConnecting: 'Connexion\u2026', statusConnected: 'Connect\u00e9.', statusDisconnecting: 'D\u00e9connexion\u2026', statusDisconnected: 'D\u00e9connect\u00e9.', statusAuthfail: 'L\'authentification a \u00e9chou\u00e9', sessionRestored: 'Session restored', roomSubject: 'Sujet:', messageSubmit: 'Envoyer', labelUsername: 'Nom d\'utilisateur:', labelPassword: 'Mot de passe:', loginSubmit: 'Connexion', loginInvalid: 'JID invalide', reason: 'Motif:', subject: 'Titre:', reasonWas: 'Motif: %s.', kickActionLabel: 'Kick', youHaveBeenKickedBy: 'Vous avez \u00e9t\u00e9 expuls\u00e9 du salon %1$s (%2$s)', youHaveBeenKicked: 'Vous avez \u00e9t\u00e9 expuls\u00e9 du salon %s', banActionLabel: 'Ban', youHaveBeenBannedBy: 'Vous avez \u00e9t\u00e9 banni du salon %1$s (%2$s)', youHaveBeenBanned: 'Vous avez \u00e9t\u00e9 banni du salon %s', privateActionLabel: 'Chat priv\u00e9', ignoreActionLabel: 'Ignorer', unignoreActionLabel: 'Ne plus ignorer', setSubjectActionLabel: 'Changer le sujet', administratorMessageSubject: 'Administrateur', userJoinedRoom: '%s vient d\'entrer dans le salon.', userLeftRoom: '%s vient de quitter le salon.', userHasBeenKickedFromRoom: '%s a \u00e9t\u00e9 expuls\u00e9 du salon.', userHasBeenBannedFromRoom: '%s a \u00e9t\u00e9 banni du salon.', presenceUnknownWarningSubject: 'Note:', presenceUnknownWarning: 'Cet utilisateur n\'est malheureusement plus connect\u00e9, le message ne sera pas envoy\u00e9.', dateFormat: 'dd/mm/yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Mod\u00e9rateur', tooltipIgnored: 'Vous ignorez cette personne', tooltipEmoticons: 'Smileys', tooltipSound: 'Jouer un son lors de la r\u00e9ception de nouveaux messages', tooltipAutoscroll: 'D\u00e9filement automatique', tooltipStatusmessage: 'Messages d\'\u00e9tat', tooltipAdministration: 'Administration du salon', tooltipUsercount: 'Nombre d\'utilisateurs dans le salon', enterRoomPassword: 'Le salon "%s" est prot\u00e9g\u00e9 par un mot de passe.', enterRoomPasswordSubmit: 'Entrer dans le salon', passwordEnteredInvalid: 'Le mot de passe pour le salon "%s" est invalide.', nicknameConflict: 'Le nom d\'utilisateur est d\u00e9j\u00e0 utilis\u00e9. Veuillez en choisir un autre.', errorMembersOnly: 'Vous ne pouvez pas entrer dans le salon "%s": droits insuffisants.', errorMaxOccupantsReached: 'Vous ne pouvez pas entrer dans le salon "%s": Limite d\'utilisateur atteint.', antiSpamMessage: 'Merci de ne pas envoyer de spam. Vous avez \u00e9t\u00e9 bloqu\u00e9 pendant une courte p\u00e9riode..'
      }, nl: {
        status: 'Status: %s', statusConnecting: 'Verbinding maken...', statusConnected: 'Verbinding is gereed', statusDisconnecting: 'Verbinding verbreken...', statusDisconnected: 'Verbinding is verbroken', statusAuthfail: 'Authenticatie is mislukt', sessionRestored: 'Session restored', roomSubject: 'Onderwerp:', messageSubmit: 'Verstuur', labelUsername: 'Gebruikersnaam:', labelPassword: 'Wachtwoord:', loginSubmit: 'Inloggen', loginInvalid: 'JID is onjuist', reason: 'Reden:', subject: 'Onderwerp:', reasonWas: 'De reden was: %s.', kickActionLabel: 'Verwijderen', youHaveBeenKickedBy: 'Je bent verwijderd van %1$s door %2$s', youHaveBeenKicked: 'Je bent verwijderd van %s', banActionLabel: 'Blokkeren', youHaveBeenBannedBy: 'Je bent geblokkeerd van %1$s door %2$s', youHaveBeenBanned: 'Je bent geblokkeerd van %s', privateActionLabel: 'Prive gesprek', ignoreActionLabel: 'Negeren', unignoreActionLabel: 'Niet negeren', setSubjectActionLabel: 'Onderwerp wijzigen', administratorMessageSubject: 'Beheerder', userJoinedRoom: '%s komt de chat binnen.', userLeftRoom: '%s heeft de chat verlaten.', userHasBeenKickedFromRoom: '%s is verwijderd.', userHasBeenBannedFromRoom: '%s is geblokkeerd.', presenceUnknownWarningSubject: 'Mededeling:', presenceUnknownWarning: 'Deze gebruiker is waarschijnlijk offline, we kunnen zijn/haar aanwezigheid niet vaststellen.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'Je negeert deze gebruiker', tooltipEmoticons: 'Emotie-iconen', tooltipSound: 'Speel een geluid af bij nieuwe berichten.', tooltipAutoscroll: 'Automatisch scrollen', tooltipStatusmessage: 'Statusberichten weergeven', tooltipAdministration: 'Instellingen', tooltipUsercount: 'Gebruikers', enterRoomPassword: 'De Chatroom "%s" is met een wachtwoord beveiligd.', enterRoomPasswordSubmit: 'Ga naar Chatroom', passwordEnteredInvalid: 'Het wachtwoord voor de Chatroom "%s" is onjuist.', nicknameConflict: 'De gebruikersnaam is reeds in gebruik. Probeer a.u.b. een andere gebruikersnaam.', errorMembersOnly: 'Je kunt niet deelnemen aan de Chatroom "%s": Je hebt onvoldoende rechten.', errorMaxOccupantsReached: 'Je kunt niet deelnemen aan de Chatroom "%s": Het maximum aantal gebruikers is bereikt.', antiSpamMessage: 'Het is niet toegestaan om veel berichten naar de server te versturen. Je bent voor een korte periode geblokkeerd.'
      }, es: {
        status: 'Estado: %s', statusConnecting: 'Conectando...', statusConnected: 'Conectado', statusDisconnecting: 'Desconectando...', statusDisconnected: 'Desconectado', statusAuthfail: 'Fall\u00f3 la autenticaci\u00f3n', sessionRestored: 'Session restored', roomSubject: 'Asunto:', messageSubmit: 'Enviar', labelUsername: 'Usuario:', labelPassword: 'Clave:', loginSubmit: 'Entrar', loginInvalid: 'JID no v\u00e1lido', reason: 'Raz\u00f3n:', subject: 'Asunto:', reasonWas: 'La raz\u00f3n fue: %s.', kickActionLabel: 'Expulsar', youHaveBeenKickedBy: 'Has sido expulsado de %1$s por %2$s', youHaveBeenKicked: 'Has sido expulsado de %s', banActionLabel: 'Prohibir', youHaveBeenBannedBy: 'Has sido expulsado permanentemente de %1$s por %2$s', youHaveBeenBanned: 'Has sido expulsado permanentemente de %s', privateActionLabel: 'Chat privado', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'No ignorar', setSubjectActionLabel: 'Cambiar asunto', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s se ha unido a la sala.', userLeftRoom: '%s ha dejado la sala.', userHasBeenKickedFromRoom: '%s ha sido expulsado de la sala.', userHasBeenBannedFromRoom: '%s ha sido expulsado permanentemente de la sala.', presenceUnknownWarningSubject: 'Atenci\u00f3n:', presenceUnknownWarning: '\u00c9ste usuario podr\u00eda estar desconectado..', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Ignoras a \u00e9ste usuario', tooltipEmoticons: 'Emoticonos', tooltipSound: 'Reproducir un sonido para nuevos mensajes', tooltipAutoscroll: 'Desplazamiento autom\u00e1tico', tooltipStatusmessage: 'Mostrar mensajes de estado', tooltipAdministration: 'Administraci\u00f3n de la sala', tooltipUsercount: 'Usuarios en la sala', enterRoomPassword: 'La sala "%s" est\u00e1 protegida mediante contrase\u00f1a.', enterRoomPasswordSubmit: 'Unirse a la sala', passwordEnteredInvalid: 'Contrase\u00f1a incorrecta para la sala "%s".', nicknameConflict: 'El nombre de usuario ya est\u00e1 siendo utilizado. Por favor elija otro.', errorMembersOnly: 'No se puede unir a la sala "%s": no tiene privilegios suficientes.', errorMaxOccupantsReached: 'No se puede unir a la sala "%s": demasiados participantes.', antiSpamMessage: 'Por favor, no hagas spam. Has sido bloqueado temporalmente.'
      }, cn: {
        status: '\u72b6\u6001: %s', statusConnecting: '\u8fde\u63a5\u4e2d...', statusConnected: '\u5df2\u8fde\u63a5', statusDisconnecting: '\u65ad\u5f00\u8fde\u63a5\u4e2d...', statusDisconnected: '\u5df2\u65ad\u5f00\u8fde\u63a5', statusAuthfail: '\u8ba4\u8bc1\u5931\u8d25', sessionRestored: 'Session restored', roomSubject: '\u4e3b\u9898:', messageSubmit: '\u53d1\u9001', labelUsername: '\u7528\u6237\u540d:', labelPassword: '\u5bc6\u7801:', loginSubmit: '\u767b\u5f55', loginInvalid: '\u7528\u6237\u540d\u4e0d\u5408\u6cd5', reason: '\u539f\u56e0:', subject: '\u4e3b\u9898:', reasonWas: '\u539f\u56e0\u662f: %s.', kickActionLabel: '\u8e22\u9664', youHaveBeenKickedBy: '\u4f60\u5728 %1$s \u88ab\u7ba1\u7406\u8005 %2$s \u8bf7\u51fa\u623f\u95f4', banActionLabel: '\u7981\u8a00', youHaveBeenBannedBy: '\u4f60\u5728 %1$s \u88ab\u7ba1\u7406\u8005 %2$s \u7981\u8a00', privateActionLabel: '\u5355\u72ec\u5bf9\u8bdd', ignoreActionLabel: '\u5ffd\u7565', unignoreActionLabel: '\u4e0d\u5ffd\u7565', setSubjectActionLabel: '\u53d8\u66f4\u4e3b\u9898', administratorMessageSubject: '\u7ba1\u7406\u5458', userJoinedRoom: '%s \u52a0\u5165\u623f\u95f4', userLeftRoom: '%s \u79bb\u5f00\u623f\u95f4', userHasBeenKickedFromRoom: '%s \u88ab\u8bf7\u51fa\u8fd9\u4e2a\u623f\u95f4', userHasBeenBannedFromRoom: '%s \u88ab\u7ba1\u7406\u8005\u7981\u8a00', presenceUnknownWarningSubject: '\u6ce8\u610f:', presenceUnknownWarning: '\u8fd9\u4e2a\u4f1a\u5458\u53ef\u80fd\u5df2\u7ecf\u4e0b\u7ebf\uff0c\u4e0d\u80fd\u8ffd\u8e2a\u5230\u4ed6\u7684\u8fde\u63a5\u4fe1\u606f', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: '\u7ba1\u7406', tooltipIgnored: '\u4f60\u5ffd\u7565\u4e86\u8fd9\u4e2a\u4f1a\u5458', tooltipEmoticons: '\u8868\u60c5', tooltipSound: '\u65b0\u6d88\u606f\u53d1\u97f3', tooltipAutoscroll: '\u6eda\u52a8\u6761', tooltipStatusmessage: '\u7981\u7528\u72b6\u6001\u6d88\u606f', tooltipAdministration: '\u623f\u95f4\u7ba1\u7406', tooltipUsercount: '\u623f\u95f4\u5360\u6709\u8005', enterRoomPassword: '\u767b\u5f55\u623f\u95f4 "%s" \u9700\u8981\u5bc6\u7801.', enterRoomPasswordSubmit: '\u52a0\u5165\u623f\u95f4', passwordEnteredInvalid: '\u767b\u5f55\u623f\u95f4 "%s" \u7684\u5bc6\u7801\u4e0d\u6b63\u786e', nicknameConflict: '\u7528\u6237\u540d\u5df2\u7ecf\u5b58\u5728\uff0c\u8bf7\u53e6\u9009\u4e00\u4e2a', errorMembersOnly: '\u60a8\u7684\u6743\u9650\u4e0d\u591f\uff0c\u4e0d\u80fd\u767b\u5f55\u623f\u95f4 "%s" ', errorMaxOccupantsReached: '\u623f\u95f4 "%s" \u7684\u4eba\u6570\u5df2\u8fbe\u4e0a\u9650\uff0c\u60a8\u4e0d\u80fd\u767b\u5f55', antiSpamMessage: '\u56e0\u4e3a\u60a8\u5728\u77ed\u65f6\u95f4\u5185\u53d1\u9001\u8fc7\u591a\u7684\u6d88\u606f \u670d\u52a1\u5668\u8981\u963b\u6b62\u60a8\u4e00\u5c0f\u6bb5\u65f6\u95f4\u3002'
      }, ja: {
        status: '\u30b9\u30c6\u30fc\u30bf\u30b9: %s', statusConnecting: '\u63a5\u7d9a\u4e2d\u2026', statusConnected: '\u63a5\u7d9a\u3055\u308c\u307e\u3057\u305f', statusDisconnecting: '\u30c7\u30a3\u30b9\u30b3\u30cd\u30af\u30c8\u4e2d\u2026', statusDisconnected: '\u30c7\u30a3\u30b9\u30b3\u30cd\u30af\u30c8\u3055\u308c\u307e\u3057\u305f', statusAuthfail: '\u8a8d\u8a3c\u306b\u5931\u6557\u3057\u307e\u3057\u305f', sessionRestored: 'Session restored', roomSubject: '\u30c8\u30d4\u30c3\u30af\uff1a', messageSubmit: '\u9001\u4fe1', labelUsername: '\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\uff1a', labelPassword: '\u30d1\u30b9\u30ef\u30fc\u30c9\uff1a', loginSubmit: '\u30ed\u30b0\u30a4\u30f3', loginInvalid: '\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\u304c\u6b63\u3057\u304f\u3042\u308a\u307e\u305b\u3093', reason: '\u7406\u7531\uff1a', subject: '\u30c8\u30d4\u30c3\u30af\uff1a', reasonWas: '\u7406\u7531: %s\u3002', kickActionLabel: '\u30ad\u30c3\u30af', youHaveBeenKickedBy: '\u3042\u306a\u305f\u306f%2$s\u306b\u3088\u308a%1$s\u304b\u3089\u30ad\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002', youHaveBeenKicked: '\u3042\u306a\u305f\u306f%s\u304b\u3089\u30ad\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002', banActionLabel: '\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3', youHaveBeenBannedBy: '\u3042\u306a\u305f\u306f%2$s\u306b\u3088\u308a%1$s\u304b\u3089\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3\u3055\u308c\u307e\u3057\u305f\u3002', youHaveBeenBanned: '\u3042\u306a\u305f\u306f%s\u304b\u3089\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3\u3055\u308c\u307e\u3057\u305f\u3002', privateActionLabel: '\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8', ignoreActionLabel: '\u7121\u8996\u3059\u308b', unignoreActionLabel: '\u7121\u8996\u3092\u3084\u3081\u308b', setSubjectActionLabel: '\u30c8\u30d4\u30c3\u30af\u3092\u5909\u3048\u308b', administratorMessageSubject: '\u7ba1\u7406\u8005', userJoinedRoom: '%s\u306f\u5165\u5ba4\u3057\u307e\u3057\u305f\u3002', userLeftRoom: '%s\u306f\u9000\u5ba4\u3057\u307e\u3057\u305f\u3002', userHasBeenKickedFromRoom: '%s\u306f\u90e8\u5c4b\u304b\u3089\u30ad\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002', userHasBeenBannedFromRoom: '%s\u306f\u90e8\u5c4b\u304b\u3089\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3\u3055\u308c\u307e\u3057\u305f\u3002', presenceUnknownWarningSubject: '\u5fe0\u544a\uff1a', presenceUnknownWarning: '\u3053\u306e\u30e6\u30fc\u30b6\u30fc\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u306f\u4e0d\u660e\u3067\u3059\u3002', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: '\u30e2\u30c7\u30ec\u30fc\u30bf\u30fc', tooltipIgnored: '\u3053\u306e\u30e6\u30fc\u30b6\u30fc\u3092\u7121\u8996\u8a2d\u5b9a\u306b\u3057\u3066\u3044\u308b', tooltipEmoticons: '\u7d75\u6587\u5b57', tooltipSound: '\u65b0\u3057\u3044\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u5c4a\u304f\u305f\u3073\u306b\u97f3\u3092\u9cf4\u3089\u3059', tooltipAutoscroll: '\u30aa\u30fc\u30c8\u30b9\u30af\u30ed\u30fc\u30eb', tooltipStatusmessage: '\u30b9\u30c6\u30fc\u30bf\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u8868\u793a', tooltipAdministration: '\u90e8\u5c4b\u306e\u7ba1\u7406', tooltipUsercount: '\u3053\u306e\u90e8\u5c4b\u306e\u53c2\u52a0\u8005\u306e\u6570', enterRoomPassword: '"%s"\u306e\u90e8\u5c4b\u306b\u5165\u308b\u306b\u306f\u30d1\u30b9\u30ef\u30fc\u30c9\u304c\u5fc5\u8981\u3067\u3059\u3002', enterRoomPasswordSubmit: '\u90e8\u5c4b\u306b\u5165\u308b', passwordEnteredInvalid: '"%s"\u306e\u30d1\u30b9\u30ef\u30fc\u30c9\u3068\u7570\u306a\u308b\u30d1\u30b9\u30ef\u30fc\u30c9\u3092\u5165\u529b\u3057\u307e\u3057\u305f\u3002', nicknameConflict: '\u3053\u306e\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\u306f\u3059\u3067\u306b\u5229\u7528\u3055\u308c\u3066\u3044\u308b\u305f\u3081\u3001\u5225\u306e\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\u3092\u9078\u3093\u3067\u304f\u3060\u3055\u3044\u3002', errorMembersOnly: '"%s"\u306e\u90e8\u5c4b\u306b\u5165\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093: \u5229\u7528\u6a29\u9650\u3092\u6e80\u305f\u3057\u3066\u3044\u307e\u305b\u3093\u3002', errorMaxOccupantsReached: '"%s"\u306e\u90e8\u5c4b\u306b\u5165\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093: \u53c2\u52a0\u8005\u306e\u6570\u306f\u3059\u3067\u306b\u4e0a\u9650\u306b\u9054\u3057\u307e\u3057\u305f\u3002', antiSpamMessage: '\u30b9\u30d1\u30e0\u306a\u3069\u306e\u884c\u70ba\u306f\u3084\u3081\u3066\u304f\u3060\u3055\u3044\u3002\u3042\u306a\u305f\u306f\u4e00\u6642\u7684\u306b\u30d6\u30ed\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002'
      }, sv: {
        status: 'Status: %s', statusConnecting: 'Ansluter...', statusConnected: 'Ansluten', statusDisconnecting: 'Kopplar fr\u00e5n...', statusDisconnected: 'Fr\u00e5nkopplad', statusAuthfail: 'Autentisering misslyckades', sessionRestored: 'Session restored', roomSubject: '\u00c4mne:', messageSubmit: 'Skicka', labelUsername: 'Anv\u00e4ndarnamn:', labelPassword: 'L\u00f6senord:', loginSubmit: 'Logga in', loginInvalid: 'Ogiltigt JID', reason: 'Anledning:', subject: '\u00c4mne:', reasonWas: 'Anledningen var: %s.', kickActionLabel: 'Sparka ut', youHaveBeenKickedBy: 'Du har blivit utsparkad fr\u00e5n %2$s av %1$s', youHaveBeenKicked: 'Du har blivit utsparkad fr\u00e5n %s', banActionLabel: 'Bannlys', youHaveBeenBannedBy: 'Du har blivit bannlyst fr\u00e5n %1$s av %2$s', youHaveBeenBanned: 'Du har blivit bannlyst fr\u00e5n %s', privateActionLabel: 'Privat chatt', ignoreActionLabel: 'Blockera', unignoreActionLabel: 'Avblockera', setSubjectActionLabel: '\u00c4ndra \u00e4mne', administratorMessageSubject: 'Administrat\u00f6r', userJoinedRoom: '%s kom in i rummet.', userLeftRoom: '%s har l\u00e4mnat rummet.', userHasBeenKickedFromRoom: '%s har blivit utsparkad ur rummet.', userHasBeenBannedFromRoom: '%s har blivit bannlyst fr\u00e5n rummet.', presenceUnknownWarningSubject: 'Notera:', presenceUnknownWarning: 'Denna anv\u00e4ndare kan vara offline. Vi kan inte f\u00f6lja dennes n\u00e4rvaro.', dateFormat: 'yyyy-mm-dd', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'Du blockerar denna anv\u00e4ndare', tooltipEmoticons: 'Smilies', tooltipSound: 'Spela upp ett ljud vid nytt meddelande', tooltipAutoscroll: 'Autoskrolla', tooltipStatusmessage: 'Visa statusmeddelanden', tooltipAdministration: 'Rumadministrering', tooltipUsercount: 'Antal anv\u00e4ndare i rummet', enterRoomPassword: 'Rummet "%s" \u00e4r l\u00f6senordsskyddat.', enterRoomPasswordSubmit: 'Anslut till rum', passwordEnteredInvalid: 'Ogiltigt l\u00f6senord f\u00f6r rummet "%s".', nicknameConflict: 'Upptaget anv\u00e4ndarnamn. Var god v\u00e4lj ett annat.', errorMembersOnly: 'Du kan inte ansluta till rummet "%s": Otillr\u00e4ckliga r\u00e4ttigheter.', errorMaxOccupantsReached: 'Du kan inte ansluta till rummet "%s": Rummet \u00e4r fullt.', antiSpamMessage: 'Var god avst\u00e5 fr\u00e5n att spamma. Du har blivit blockerad f\u00f6r en kort stund.'
      }, it: {
        status: 'Stato: %s', statusConnecting: 'Connessione...', statusConnected: 'Connessione', statusDisconnecting: 'Disconnessione...', statusDisconnected: 'Disconnesso', statusAuthfail: 'Autenticazione fallita', sessionRestored: 'Sessione ristabilita', roomSubject: 'Oggetto:', messageSubmit: 'Invia', labelUsername: 'Nome utente:', labelPassword: 'Password:', loginSubmit: 'Login', loginInvalid: 'JID non valido', reason: 'Ragione:', subject: 'Oggetto:', reasonWas: 'Ragione precedente: %s.', kickActionLabel: 'Espelli', youHaveBeenKickedBy: 'Sei stato espulso da %2$s da %1$s', youHaveBeenKicked: 'Sei stato espulso da %s', banActionLabel: 'Escluso', youHaveBeenBannedBy: 'Sei stato escluso da %1$s da %2$s', youHaveBeenBanned: 'Sei stato escluso da %s', privateActionLabel: 'Stanza privata', ignoreActionLabel: 'Ignora', unignoreActionLabel: 'Non ignorare', setSubjectActionLabel: 'Cambia oggetto', administratorMessageSubject: 'Amministratore', userJoinedRoom: '%s si \u00e8 unito alla stanza.', userLeftRoom: '%s ha lasciato la stanza.', userHasBeenKickedFromRoom: '%s \u00e8 stato espulso dalla stanza.', userHasBeenBannedFromRoom: '%s \u00e8 stato escluso dalla stanza.', presenceUnknownWarningSubject: 'Nota:', presenceUnknownWarning: 'Questo utente potrebbe essere offline. Non possiamo tracciare la sua presenza.', dateFormat: 'dd/mm/yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderatore', tooltipIgnored: 'Stai ignorando questo utente', tooltipEmoticons: 'Emoticons', tooltipSound: 'Riproduci un suono quando arrivano messaggi', tooltipAutoscroll: 'Autoscroll', tooltipStatusmessage: 'Mostra messaggi di stato', tooltipAdministration: 'Amministrazione stanza', tooltipUsercount: 'Partecipanti alla stanza', enterRoomPassword: 'La stanza "%s" \u00e8 protetta da password.', enterRoomPasswordSubmit: 'Unisciti alla stanza', passwordEnteredInvalid: 'Password non valida per la stanza "%s".', nicknameConflict: 'Nome utente gi\u00e0 in uso. Scegline un altro.', errorMembersOnly: 'Non puoi unirti alla stanza "%s": Permessi insufficienti.', errorMaxOccupantsReached: 'Non puoi unirti alla stanza "%s": Troppi partecipanti.', antiSpamMessage: 'Per favore non scrivere messaggi pubblicitari. Sei stato bloccato per un po\' di tempo.'
      }, pt: {
        status: 'Status: %s', statusConnecting: 'Conectando...', statusConnected: 'Conectado', statusDisconnecting: 'Desligando...', statusDisconnected: 'Desligado', statusAuthfail: 'Falha na autentica\u00e7\u00e3o', sessionRestored: 'Session restored', roomSubject: 'Assunto:', messageSubmit: 'Enviar', labelUsername: 'Usu\u00e1rio:', labelPassword: 'Senha:', loginSubmit: 'Entrar', loginInvalid: 'JID inv\u00e1lido', reason: 'Motivo:', subject: 'Assunto:', reasonWas: 'O motivo foi: %s.', kickActionLabel: 'Excluir', youHaveBeenKickedBy: 'Voc\u00ea foi excluido de %1$s por %2$s', youHaveBeenKicked: 'Voc\u00ea foi excluido de %s', banActionLabel: 'Bloquear', youHaveBeenBannedBy: 'Voc\u00ea foi excluido permanentemente de %1$s por %2$s', youHaveBeenBanned: 'Voc\u00ea foi excluido permanentemente de %s', privateActionLabel: 'Bate-papo privado', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'N\u00e3o ignorar', setSubjectActionLabel: 'Trocar Assunto', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s entrou na sala.', userLeftRoom: '%s saiu da sala.', userHasBeenKickedFromRoom: '%s foi excluido da sala.', userHasBeenBannedFromRoom: '%s foi excluido permanentemente da sala.', presenceUnknownWarning: 'Este usu\u00e1rio pode estar desconectado. N\u00e3o \u00e9 poss\u00edvel determinar o status.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Voc\u00ea ignora este usu\u00e1rio', tooltipEmoticons: 'Emoticons', tooltipSound: 'Reproduzir o som para novas mensagens', tooltipAutoscroll: 'Deslocamento autom\u00e1tico', tooltipStatusmessage: 'Mostrar mensagens de status', tooltipAdministration: 'Administra\u00e7\u00e3o da sala', tooltipUsercount: 'Usu\u00e1rios na sala', enterRoomPassword: 'A sala "%s" \u00e9 protegida por senha.', enterRoomPasswordSubmit: 'Junte-se \u00e0 sala', passwordEnteredInvalid: 'Senha incorreta para a sala "%s".', nicknameConflict: 'O nome de usu\u00e1rio j\u00e1 est\u00e1 em uso. Por favor, escolha outro.', errorMembersOnly: 'Voc\u00ea n\u00e3o pode participar da sala "%s":  privil\u00e9gios insuficientes.', errorMaxOccupantsReached: 'Voc\u00ea n\u00e3o pode participar da sala "%s": muitos participantes.', antiSpamMessage: 'Por favor, n\u00e3o envie spam. Voc\u00ea foi bloqueado temporariamente.'
      }, pt_br: {
        status: 'Estado: %s', statusConnecting: 'Conectando...', statusConnected: 'Conectado', statusDisconnecting: 'Desconectando...', statusDisconnected: 'Desconectado', statusAuthfail: 'Autentica\u00e7\u00e3o falhou', sessionRestored: 'Session restored', roomSubject: 'Assunto:', messageSubmit: 'Enviar', labelUsername: 'Usu\u00e1rio:', labelPassword: 'Senha:', loginSubmit: 'Entrar', loginInvalid: 'JID inv\u00e1lido', reason: 'Motivo:', subject: 'Assunto:', reasonWas: 'Motivo foi: %s.', kickActionLabel: 'Derrubar', youHaveBeenKickedBy: 'Voc\u00ea foi derrubado de %2$s por %1$s', youHaveBeenKicked: 'Voc\u00ea foi derrubado de %s', banActionLabel: 'Banir', youHaveBeenBannedBy: 'Voc\u00ea foi banido de %1$s por %2$s', youHaveBeenBanned: 'Voc\u00ea foi banido de %s', privateActionLabel: 'Conversa privada', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'N\u00e3o ignorar', setSubjectActionLabel: 'Mudar Assunto', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s entrou na sala.', userLeftRoom: '%s saiu da sala.', userHasBeenKickedFromRoom: '%s foi derrubado da sala.', userHasBeenBannedFromRoom: '%s foi banido da sala.', presenceUnknownWarningSubject: 'Aviso:', presenceUnknownWarning: 'Este usu\u00e1rio pode estar desconectado.. N\u00e3o conseguimos rastrear sua presen\u00e7a..', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Voc\u00ea ignora este usu\u00e1rio', tooltipEmoticons: 'Emoticons', tooltipSound: 'Tocar som para novas mensagens', tooltipAutoscroll: 'Auto-rolagem', tooltipStatusmessage: 'Exibir mensagens de estados', tooltipAdministration: 'Administra\u00e7\u00e3o de Sala', tooltipUsercount: 'Participantes da Sala', enterRoomPassword: 'Sala "%s" \u00e9 protegida por senha.', enterRoomPasswordSubmit: 'Entrar na sala', passwordEnteredInvalid: 'Senha inv\u00e1ida para sala "%s".', nicknameConflict: 'Nome de usu\u00e1rio j\u00e1 em uso. Por favor escolha outro.', errorMembersOnly: 'Voc\u00ea n\u00e3o pode entrar na sala "%s": privil\u00e9gios insuficientes.', errorMaxOccupantsReached: 'Voc\u00ea n\u00e3o pode entrar na sala "%s": m\u00e1ximo de participantes atingido.', antiSpamMessage: 'Por favor, n\u00e3o fa\u00e7a spam. Voc\u00ea foi bloqueado temporariamente.'
      }, ru: {
        status: '\u0421\u0442\u0430\u0442\u0443\u0441: %s', statusConnecting: '\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435...', statusConnected: '\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u043e', statusDisconnecting: '\u041e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435...', statusDisconnected: '\u041e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u043e', statusAuthfail: '\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043b\u043e\u0433\u0438\u043d', sessionRestored: 'Session restored', roomSubject: '\u0422\u043e\u043f\u0438\u043a:', messageSubmit: '\u041f\u043e\u0441\u043b\u0430\u0442\u044c', labelUsername: '\u0418\u043c\u044f:', labelPassword: '\u041f\u0430\u0440\u043e\u043b\u044c:', loginSubmit: '\u041b\u043e\u0433\u0438\u043d', loginInvalid: '\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 JID', reason: '\u041f\u0440\u0438\u0447\u0438\u043d\u0430:', subject: '\u0422\u043e\u043f\u0438\u043a:', reasonWas: '\u041f\u0440\u0438\u0447\u0438\u043d\u0430 \u0431\u044b\u043b\u0430: %s.', kickActionLabel: '\u0412\u044b\u0431\u0440\u043e\u0441\u0438\u0442\u044c', youHaveBeenKickedBy: '\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c %1$s \u0432\u044b\u0431\u0440\u043e\u0441\u0438\u043b \u0432\u0430\u0441 \u0438\u0437 \u0447\u0430\u0442\u0430 %2$s', youHaveBeenKicked: '\u0412\u0430\u0441 \u0432\u044b\u0431\u0440\u043e\u0441\u0438\u043b\u0438 \u0438\u0437 \u0447\u0430\u0442\u0430 %s', banActionLabel: '\u0417\u0430\u043f\u0440\u0435\u0442\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f', youHaveBeenBannedBy: '\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c %1$s \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u043b \u0432\u0430\u043c \u0434\u043e\u0441\u0442\u0443\u043f \u0432 \u0447\u0430\u0442 %2$s', youHaveBeenBanned: '\u0412\u0430\u043c \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u0432 \u0447\u0430\u0442 %s', privateActionLabel: '\u041e\u0434\u0438\u043d-\u043d\u0430-\u043e\u0434\u0438\u043d \u0447\u0430\u0442', ignoreActionLabel: '\u0418\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c', unignoreActionLabel: '\u041e\u0442\u043c\u0435\u043d\u0438\u0442\u044c \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435', setSubjectActionLabel: '\u0418\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0442\u043e\u043f\u0438\u043a', administratorMessageSubject: '\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440', userJoinedRoom: '%s \u0432\u043e\u0448\u0451\u043b \u0432 \u0447\u0430\u0442.', userLeftRoom: '%s \u0432\u044b\u0448\u0435\u043b \u0438\u0437 \u0447\u0430\u0442\u0430.', userHasBeenKickedFromRoom: '%s \u0432\u044b\u0431\u0440\u043e\u0448\u0435\u043d \u0438\u0437 \u0447\u0430\u0442\u0430.', userHasBeenBannedFromRoom: '%s \u0437\u0430\u043f\u0440\u0435\u0449\u0451\u043d \u0434\u043e\u0441\u0442\u0443\u043f \u0432 \u0447\u0430\u0442.', presenceUnknownWarningSubject: '\u0423\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0435:', presenceUnknownWarning: '\u042d\u0442\u043e\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u0435\u0435 \u0432\u0441\u0435\u0433\u043e \u043e\u0444\u0444\u043b\u0430\u0439\u043d.', dateFormat: 'mm.dd.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: '\u041c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440', tooltipIgnored: '\u0412\u044b \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442\u0435 \u044d\u0442\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.', tooltipEmoticons: '\u0421\u043c\u0430\u0439\u043b\u0438\u043a\u0438', tooltipSound: '\u041e\u0437\u0432\u0443\u0447\u0438\u0432\u0430\u0442\u044c \u043d\u043e\u0432\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435', tooltipAutoscroll: '\u0410\u0432\u0442\u043e-\u043f\u0440\u043e\u043a\u0440\u0443\u0447\u0438\u0432\u0430\u043d\u0438\u0435', tooltipStatusmessage: '\u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0441\u0442\u0430\u0442\u0443\u0441 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f', tooltipAdministration: '\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0447\u0430\u0442 \u043a\u043e\u043c\u043d\u0430\u0442\u044b', tooltipUsercount: '\u0423\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0438 \u0447\u0430\u0442\u0430', enterRoomPassword: '\u0427\u0430\u0442 \u043a\u043e\u043c\u043d\u0430\u0442\u0430 "%s" \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u0430 \u043f\u0430\u0440\u043e\u043b\u0435\u043c.', enterRoomPasswordSubmit: '\u0412\u043e\u0439\u0442\u0438 \u0432 \u0447\u0430\u0442', passwordEnteredInvalid: '\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u043a\u043e\u043c\u043d\u0430\u0442\u044b "%s".', nicknameConflict: '\u042d\u0442\u043e \u0438\u043c\u044f \u0443\u0436\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u043e\u0435 \u0438\u043c\u044f.', errorMembersOnly: '\u0412\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u043e\u0439\u0442\u0438 \u0432 \u0447\u0430\u0442 "%s": \u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043f\u0440\u0430\u0432 \u0434\u043e\u0441\u0442\u0443\u043f\u0430.', errorMaxOccupantsReached: '\u0412\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u043e\u0439\u0442\u0438 \u0432 \u0447\u0430\u0442 "%s": \u0421\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u043e\u0432.', antiSpamMessage: '\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430 \u043d\u0435 \u0440\u0430\u0441\u0441\u044b\u043b\u0430\u0439\u0442\u0435 \u0441\u043f\u0430\u043c. \u0412\u0430\u0441 \u0437\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u043b\u0438 \u043d\u0430 \u043a\u043e\u0440\u043e\u0442\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f.'
      }, ca: {
        status: 'Estat: %s', statusConnecting: 'Connectant...', statusConnected: 'Connectat', statusDisconnecting: 'Desconnectant...', statusDisconnected: 'Desconnectat', statusAuthfail: 'Ha fallat la autenticaci\u00f3', sessionRestored: 'Session restored', roomSubject: 'Assumpte:', messageSubmit: 'Enviar', labelUsername: 'Usuari:', labelPassword: 'Clau:', loginSubmit: 'Entrar', loginInvalid: 'JID no v\u00e0lid', reason: 'Ra\u00f3:', subject: 'Assumpte:', reasonWas: 'La ra\u00f3 ha estat: %s.', kickActionLabel: 'Expulsar', youHaveBeenKickedBy: 'Has estat expulsat de %1$s per %2$s', youHaveBeenKicked: 'Has estat expulsat de %s', banActionLabel: 'Prohibir', youHaveBeenBannedBy: 'Has estat expulsat permanentment de %1$s per %2$s', youHaveBeenBanned: 'Has estat expulsat permanentment de %s', privateActionLabel: 'Xat privat', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'No ignorar', setSubjectActionLabel: 'Canviar assumpte', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s ha entrat a la sala.', userLeftRoom: '%s ha deixat la sala.', userHasBeenKickedFromRoom: '%s ha estat expulsat de la sala.', userHasBeenBannedFromRoom: '%s ha estat expulsat permanentment de la sala.', presenceUnknownWarningSubject: 'Atenci\u00f3:', presenceUnknownWarning: 'Aquest usuari podria estar desconnectat ...', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Est\u00e0s ignorant aquest usuari', tooltipEmoticons: 'Emoticones', tooltipSound: 'Reproduir un so per a nous missatges', tooltipAutoscroll: 'Despla\u00e7ament autom\u00e0tic', tooltipStatusmessage: 'Mostrar missatges d\'estat', tooltipAdministration: 'Administraci\u00f3 de la sala', tooltipUsercount: 'Usuaris dins la sala', enterRoomPassword: 'La sala "%s" est\u00e0 protegida amb contrasenya.', enterRoomPasswordSubmit: 'Entrar a la sala', passwordEnteredInvalid: 'Contrasenya incorrecta per a la sala "%s".', nicknameConflict: 'El nom d\'usuari ja s\'est\u00e0 utilitzant. Si us plau, escolleix-ne un altre.', errorMembersOnly: 'No pots unir-te a la sala "%s": no tens prous privilegis.', errorMaxOccupantsReached: 'No pots unir-te a la sala "%s": hi ha masses participants.', antiSpamMessage: 'Si us plau, no facis spam. Has estat bloquejat temporalment.'
      }
  };
  window.Candy = Candy
}
;
(function() {
  namespace("Ifm.PhoneBar");
  Ifm.PhoneBar.Mediatypes = {
    NearRealTime: 8, StoreAndForward: 16
  };
  namespace("Ifm");
  Ifm.phonebarIntegration = (function() {
    if (!window.jQuery)
      throw Ifm.Diagnostics.Errors.miss("jQuery");
    if (!window.Strophe)
      throw Ifm.Diagnostics.Errors.miss("Candy/Libs");
    var _phonebarConnection;
    var _activeCalls = {},
      _activeRooms = {},
      _isInitialized = false;
    var strings;
    var config = {
        mediatypes: 0, service: "", server: "", ftservice: "", ndservice: "", nickname: "", theme: "themes/classic/", language: "it", domain_nrt: "xmpp-nrt", domain_saf: "xmpp-saf", admin_nrt: "lxadmin-nrt", admin_saf: "lxadmin-saf", presence: "login", phonebar: "ws://localhost:22022", debug: false, showtransfer: false, newcallpopupenabled: 0, newcallpopuptimeout: 0, areValidMediatypes: function() {
            var mediatypes = Ifm.Type.isNumber(this.mediatypes) ? this.mediatypes : parseInt(this.mediatypes);
            if (isFinite(mediatypes) && mediatypes == Ifm.PhoneBar.Mediatypes.NearRealTime || mediatypes == Ifm.PhoneBar.Mediatypes.StoreAndForward || mediatypes == Ifm.PhoneBar.Mediatypes.NearRealTime + Ifm.PhoneBar.Mediatypes.StoreAndForward) {
              return true
            }
            return false
          }, getAdmin_nrt: function() {
            return this.admin_nrt + '@' + this.server
          }, getAdmin_saf: function() {
            return this.admin_saf + '@' + this.server
          }, getDomain_nrt: function() {
            return this.domain_nrt + '.' + this.server
          }, getDomain_saf: function() {
            return this.domain_saf + '.' + this.server
          }, getPresence_nrt: function() {
            return this.presence + '@' + this.domain_nrt + '.' + this.server
          }, getPresence_saf: function() {
            return this.presence + '@' + this.domain_saf + '.' + this.server
          }, getAgentPre: function() {
            return "Agent_" + this.extension
          }, getUsername: function() {
            return (this.displayname || "Agent") + '_' + this.extension
          }
      };
    function setupCandy() {
      Ifm.Diagnostics.Debug.enabled = config.debug;
      Ifm.Diagnostics.Debug.print(Ifm.phonebarIntegration.about.name + "/" + Ifm.phonebarIntegration.about.version + "; " + Ifm.version);
      Strophe.timeProvider = Ifm.Net.TimeProvider.getDefault();
      if (!document.getElementById("candy")) {
        var candybox = document.createElement("div");
        candybox.id = "candy";
        candybox.style.display = "none";
        document.body.appendChild(candybox)
      }
      if (config.theme) {
        if (!config.theme.endsWith('/'))
          config.theme += '/';
        $('head').append('<link rel="stylesheet" href="' + config.theme + 'default.css" />')
      }
      else {
        document.getElementById("candy").style.display = "none"
      }
      Candy.init(config.service, {
        core: {
          debug: config.debug, autojoin: [], disconnectWithoutTabs: false
        }, view: {
            assets: config.theme, language: config.language
          }
      });
      Candy.View.getOptions().crop.message.body = 1e6;
      strings = Ifm.Chat.Strings[config.language] || Ifm.Chat.Strings.it;
      var defaultUnloadHandler = window.onbeforeunload;
      if (window.addEventListener) {
        window.addEventListener("pagehide", defaultUnloadHandler);
        window.addEventListener("unload", defaultUnloadHandler)
      }
      else {
        window.attachEvent("onunload", defaultUnloadHandler)
      }
      window.onbeforeunload = null;
      Candy.View.Template.FileTransfer = {item: '<li><small>{{time}}</small><div class="filetransfer"><span class="spacer">\u2022</span><span class="message">{{{view}}}</span></div></li>'};
      Candy.View.Template.Message.header = '<div class="header-wrapper"><span class="chatstatus-text header-text"></span><span timerid="" class="chatduration-text header-text"></span><button class="header-button hangup-button"></button><button class="header-button chattransfer-button"></button><button class="header-button chatclosetab-button" style="display:none;"></button></div>';
      $(Candy).on('candy:core.chat.connection', function(evt, args) {
        var self = Ifm.phonebarIntegration;
        switch (args.status) {
          case Strophe.Status.CONNECTING:
            Ifm.Diagnostics.Debug.print("Connecting to XMPP server");
            break;
          case Strophe.Status.ATTACHED:
            Ifm.Diagnostics.Debug.print("Connection restored with XMPP server");
            restoreSessionData();
            self.events.connected.raise({});
            break;
          case Strophe.Status.CONNECTED:
            Ifm.Diagnostics.Debug.print("Connected to XMPP server");
            self.events.connected.raise({});
            setTimeout(function() {
              if (config.mediatypes & Ifm.PhoneBar.Mediatypes.NearRealTime) {
                Candy.Core.subscribe(config.getPresence_nrt(), config.getAgentPre(), config.presence);
                Candy.Core.subscribe(config.getDomain_nrt());
                Candy.Core.subscribe(config.getAdmin_nrt())
              }
              if (config.mediatypes & Ifm.PhoneBar.Mediatypes.StoreAndForward) {
                Candy.Core.subscribe(config.getPresence_saf(), config.getAgentPre(), config.presence);
                Candy.Core.subscribe(config.getDomain_saf());
                Candy.Core.subscribe(config.getAdmin_saf())
              }
            }, 100);
            break;
          case Strophe.Status.DISCONNECTING:
            Ifm.Diagnostics.Debug.print("Disconnecting from XMPP server");
            break;
          case Strophe.Status.DISCONNECTED:
            Ifm.Diagnostics.Debug.print("Disconnected from XMPP server");
            var e = {};
            if (Candy.Core.keepconnected) {
              e = {
                lost: true, reason: "Connection with XMPP server lost"
              };
              setTimeout(function() {
                Candy.Core.connect(config.server, null, config.getUsername())
              }, 200)
            }
            else {
              e = {
                clean: true, reason: ""
              }
            }
            self.events.disconnected.raise(e);
            break;
          case Strophe.Status.CONNFAIL:
          case Strophe.Status.AUTHFAIL:
            Ifm.Diagnostics.Debug.print("Connection with XMPP server failed", args.status);
            self.events.disconnected.raise({
              failed: true, reason: "Connection with XMPP server failed"
            });
            break;
          default:
            Ifm.Diagnostics.Debug.print("Connection with XMPP server in status", args.status)
        }
      });
      $(Candy).on('candy:view.connection.status-6', function(evt, args) {
        Candy.View.Pane.Chat.Modal.hide();
        for (var roomJid in _activeRooms) {
          cancelAllFileTransfers(roomJid);
          Candy.View.Pane.Room.close(roomJid)
        }
        _activeCalls = {};
        _activeRooms = {};
        updateSessionData();
        return false
      });
      $(Candy).on('candy:view.connection.status-7', function(evt, args) {
        Candy.View.Pane.Chat.Modal.hide();
        return false
      });
      $(Candy).on('candy:core.presence', function(evt, args) {
        var msg = args.stanza,
          from = msg.attr("from"),
          id = msg.attr("id"),
          type = msg.attr("type") || "available";
        Ifm.Diagnostics.Debug.print("Got", type, "message from", from, "(id", id || "none", ")");
        switch (type) {
          case"subscribe":
            Candy.Core.subscribed(from, id);
            break;
          case"subscribed":
            Candy.Core.available(from);
            break
        }
      });
      $(Candy).on('candy:core:chat:invite', function(evt, args) {
        if (args.inviteType === undefined || args.inviteType === "DirectInvite") {
          var type = args.inviteType || "Invite";
          Ifm.Diagnostics.Debug.print("Got", type, "message from", args.roomJid);
          var roomJid = Candy.Util.unescapeJid(args.roomJid);
          Candy.Core.Action.Jabber.Room.Join(roomJid, null)
        }
      });
      $(Candy).on('candy:core.message.chatstate', function(evt, args) {
        if (!args.chatstate || args.name === Candy.Core.getUsername())
          return;
        if (args.chatstate === "composing")
          Candy.View.updatenotification(args.roomJid, args.displayName, args.chatstate, strings.ChatStateComposing);
        else
          Candy.View.deletenotification(args.roomJid)
      });
      $(Candy).on('candy:view.room.before-add', function(evt, args) {
        var roomJid = args.roomJid,
          callId,
          callGuid = roomJid.substr(1, 36).toUpperCase();
        if (!_activeRooms[roomJid] || !_activeCalls[_activeRooms[roomJid]]) {
          for (callId in _activeCalls) {
            if (callGuid === _activeCalls[callId].callGuid) {
              _activeCalls[callId].roomJid = roomJid;
              _activeRooms[roomJid] = Number(callId);
              updateSessionData();
              break
            }
          }
        }
      });
      $(Candy).on('candy:view.room.after-add', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid];
        Candy.View.Pane.Chat.getTab(roomJid).find(".label").html(_activeCalls[callId].campaignName);
        var self = Ifm.phonebarIntegration;
        var pane = Candy.View.Pane.Room.getPane(roomJid);
        var button = pane.find(".hangup-button");
        button.click(function() {
          self.close(callId)
        });
        button = pane.find(".chatclosetab-button");
        button.click(function() {
          self.ready(callId)
        });
        button = pane.find(".chattransfer-button");
        if (config.showtransfer) {
          button.click(function() {
            self.showTransferDialog(callId)
          })
        }
        else {
          button.hide()
        }
        var status = pane.find(".chatstatus-text");
        status.text(strings.ChatStateTalking);
        var myTimerId = setInterval(function() {
            var endDate = new Date;
            var timeDiff = Math.abs(startDate - endDate);
            var hh = Math.floor(timeDiff / 1000 / 60 / 60);
            if (hh < 10) {
              hh = '0' + hh
            }
            timeDiff -= hh * 1000 * 60 * 60;
            var mm = Math.floor(timeDiff / 1000 / 60);
            if (mm < 10) {
              mm = '0' + mm
            }
            timeDiff -= mm * 1000 * 60;
            var ss = Math.floor(timeDiff / 1000);
            if (ss < 10) {
              ss = '0' + ss
            }
            timer.text(hh + ":" + mm + ":" + ss)
          }, 1000);
        var timer = pane.find(".chatduration-text");
        var data = timer.data();
        data.timerid = myTimerId;
        var startDate = new Date;
        timer.text("00:00:00");
        var messageList = pane.find(".message-pane-wrapper")[0],
          messageText = pane.find("[name=message]")[0];
        data = pane.data();
        data.filetransfers = {};
        Candy.View.Pane.Chat.fitTabs();
        messageText.onchange = messageText.oninput = function() {
          if (messageText.value === '') {
            Candy.Core.notifystate(roomJid, "paused");
            data.lastnotificationsent = 0
          }
          else if (!data.lastnotificationsent || dT() - data.lastnotificationsent > 5000) {
            Candy.Core.notifystate(roomJid, "composing");
            data.lastnotificationsent = dT()
          }
        };
        messageList.ondragover = messageText.ondragover = function(evt) {
          evt.preventDefault();
          evt.cancelBubble = true;
          evt.returnValue = false
        };
        messageList.ondrop = messageText.ondrop = function(evt) {
          evt.preventDefault();
          evt.cancelBubble = true;
          evt.returnValue = false;
          if (!Candy.Core.isConnected()) {
            return
          }
          if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
            return
          }
          if (evt.source === messageList || evt.source === messageText) {
            return
          }
          var text = evt.dataTransfer.getData("text");
          if (text) {
            messageText.value = text;
            messageText.select();
            return
          }
          var files = evt.dataTransfer.files;
          if (files && files.length > 0) {
            doFileTransfer(roomJid, files[0]);
            return
          }
        }
      });
      $(Candy).on('candy:view.pane.roster.after-update', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid];
        if (args.action === "join") {
          if (!_activeCalls[callId].externalPartyUserName) {
            var user = args.user,
              username = user.getNick();
            if (user.getRole() !== user.ROLE_MODERATOR && username !== Candy.Core.getUsername()) {
              _activeCalls[callId].externalPartyUserName = username;
              _activeCalls[callId].externalPartyDisplayName = user.getNick(true);
              updateSessionData();
              var self = Ifm.phonebarIntegration;
              self.events.newcall.raise({callId: callId})
            }
          }
        }
        else {
          Candy.View.deletenotification(roomJid)
        }
      });
      $(Candy).on('candy:view.message.before-show', function(evt, args) {
        if (args.message.startsWith("*begin*")) {
          if (!args.history && args.name !== Candy.Core.getUsername()) {
            var message = new Ifm.Messaging.FStringMessageReader(args.message);
            if (message.type === "FTTOKEN") {
              var file = {
                  token: message.data[0], name: message.data[1], size: Number(message.data[2]), type: message.data[3]
                };
              doFileTransfer(args.roomJid, file)
            }
            else if (message.type === "FTUNSUP") {
              cancelAllFileTransfers(args.roomJid);
              Candy.View.Pane.Chat.Modal.showError(strings.FileTransfer.NotAvailOther)
            }
            else {
              var roomJid = args.roomJid,
                callId = _activeRooms[roomJid];
              var self = Ifm.phonebarIntegration;
              self.events.sysmessage.raise({
                callId: callId, message: message
              })
            }
          }
          return false
        }
      });
      $(Candy).on('candy:view.message.before-render', function(evt, args) {
        var data = args.templateData,
          callId = _activeRooms[data.roomJid],
          mediatype = _activeCalls[callId].mediatype,
          sender = data.displayName,
          senderIsBot = sender.startsWith('Synthetic'),
          sentFromHere = data.name !== _activeCalls[callId].externalPartyUserName;
        if (senderIsBot && strings.BotNickname) {
          data.displayName = strings.BotNickname;
          data.croppedDisplayName = Candy.Util.crop(data.displayName, Candy.View.getOptions().crop.message.nickname)
        }
        var e = {
            callId: callId, displayName: data.displayName, sender: sender, senderIsBot: senderIsBot, sentFromHere: sentFromHere, rawMessage: args.rawMessage, message: data.message, time: data.time, timestamp: data.timestamp, history: args.history, attributes: args.attributes
          };
        data.sender = e.sentFromHere ? "sender-is-me" : "sender-is-other";
        if (senderIsBot)
          data.sender += " sender-is-bot";
        var self = Ifm.phonebarIntegration;
        self.events.newmessage.raise(e);
        if (e.displayName && e.displayName !== data.displayName) {
          data.displayName = e.displayName;
          data.croppedDisplayName = Candy.Util.crop(data.displayName, Candy.View.getOptions().crop.message.nickname)
        }
        data.message = Ifm.Chat.Extras.UrlPreview.findAndGenerate(args.templateData.roomJid, e.message);
        if (!data.message)
          return false
      });
      $(Candy).on('candy:view.message.after-show', function(evt, args) {
        if (args.name === Candy.Core.getUsername())
          return;
        var e = args.element;
        e.addClass("new-message-highlight");
        setTimeout(function() {
          e.removeClass("new-message-highlight")
        }, 4000);
        Candy.View.movenotification(args.roomJid)
      });
      $(Candy).on('candy:view.presence', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid],
          transferred = _activeCalls[callId] && _activeCalls[callId].transferred,
          pane = Candy.View.Pane.Room.getPane(roomJid);
        Candy.View.deletenotification(roomJid);
        cancelAllFileTransfers(roomJid);
        if (transferred) {
          Candy.View.Pane.Room.close(roomJid)
        }
        else if (pane) {
          Candy.View.Pane.Chat.getTab(roomJid).find(".label").css({opacity: ".80"});
          pane.find(".message-form-wrapper").hide();
          pane.find(".message-pane-wrapper").css({opacity: ".80"});
          pane.find(".hangup-button").hide();
          pane.find(".chattransfer-button").hide();
          pane.find(".chatclosetab-button").show();
          var timer = pane.find(".chatduration-text");
          var data = timer.data();
          clearInterval(data.timerid);
          var status = pane.find(".chatstatus-text");
          status.text(strings.ChatStateClosed)
        }
      });
      $(Candy).on('candy:view.room.after-close', function(evt, args) {
        delete _activeCalls[_activeRooms[args.roomJid]];
        delete _activeRooms[args.roomJid];
        updateSessionData()
      })
    }
    function restoreSessionData() {
      var data = window.sessionStorage.getItem('chat-session-calls');
      if (data) {
        _activeCalls = JSON.parse(data)
      }
      data = window.sessionStorage.getItem('chat-session-rooms');
      if (data) {
        _activeRooms = JSON.parse(data)
      }
    }
    function updateSessionData() {
      window.sessionStorage.setItem('chat-session-calls', JSON.stringify(_activeCalls));
      window.sessionStorage.setItem('chat-session-rooms', JSON.stringify(_activeRooms))
    }
    function doFileTransfer(roomJid, file) {
      if (roomJid === undefined || _activeRooms[roomJid] === undefined) {
        Ifm.Diagnostics.Debug.print("Invalid conversation");
        return
      }
      var callId = _activeRooms[roomJid];
      if (_activeCalls[callId].mediatype !== Ifm.PhoneBar.Mediatypes.NearRealTime) {
        Ifm.Diagnostics.Debug.print("Unsupported mediatype of call", callId);
        return
      }
      if (!Ifm.Net.Services.FileTransfer.isSupported() || !config.ftservice) {
        if (isSender) {
          Candy.View.Pane.Chat.Modal.showError(strings.FileTransfer.NotAvailable)
        }
        else {
          var um = new Ifm.Messaging.FStringMessageWriter("FTUNSUP").end();
          Candies.send(roomJid, um)
        }
        return
      }
      var ft = Ifm.Net.Services.FileTransfer.create(config.ftservice);
      Ifm.Chat.Extras.FileTransfer.transferFile(roomJid, ft, file, strings);
      var self = Ifm.phonebarIntegration;
      self.events.filetransfer.raise({
        callId: _activeRooms[roomJid], file: file, filetransfer: ft
      })
    }
    function cancelAllFileTransfers(roomJid) {
      var pane = Candy.View.Pane.Room.getPane(roomJid);
      var data = pane && pane.data();
      if (data && data.filetransfers) {
        for (var id in data.filetransfers) {
          data.filetransfers[id].filetransfer.cancel();
          delete data.filetransfers[id]
        }
      }
    }
    function hangup(callId, close) {
      if (!callId || !_activeCalls[callId]) {
        return
      }
      var roomJid = _activeCalls[callId].roomJid;
      if (!roomJid || !_activeRooms[roomJid]) {
        return
      }
      Candy.Core.Action.Jabber.Room.Leave(roomJid);
      if (close) {
        if (Candy.View.Pane.Room.getPane(roomJid)) {
          cancelAllFileTransfers(roomJid);
          Candy.View.Pane.Room.close(roomJid)
        }
      }
    }
    function showPhoneBarPopup(text) {
      var timeout = Ifm.Type.isNumber(config.newcallpopuptimeout) && (config.newcallpopuptimeout > 0) ? config.newcallpopuptimeout : 0;
      var msg = new Ifm.Messaging.FStringMessageWriter("ShowInformationPopup");
      msg.add(text).add(timeout).end();
      _phonebarConnection.send(msg)
    }
    function onPhonesMessage(messageReader) {
      var self = Ifm.phonebarIntegration,
        Messages = Ifm.PhoneBar.Messages,
        message = null;
      for (var messageName in Messages.PhonesToPhoneBarMessages) {
        if (messageReader.code === Messages.PhonesToPhoneBarMessages[messageName]) {
          message = new Messages[messageName](messageReader);
          break
        }
      }
      if (message === null) {
        Ifm.Diagnostics.Debug.fail("Unknown message received:", messageReader.code);
        return
      }
      var callId = message.callId;
      if (callId)
        Ifm.Diagnostics.Debug.print("Got", messageName, "message, callId", callId);
      else
        Ifm.Diagnostics.Debug.print("Got", messageName, "message");
      switch (messageReader.code) {
        case Messages.PhonesToPhoneBarMessages.BookedEvent:
          break;
        case Messages.PhonesToPhoneBarMessages.AssignmentRequest:
          var callData = new Ifm.Messaging.FPropertyList(message.callDataStr),
            mediatype = message.mediatype || callData.get("_MediaType_") || 0;
          callData.save = function() {
            Ifm.Diagnostics.Debug.print("Sending SetCallResultEvent message");
            _phonebarConnection.send(Messages.SetCallResultEvent(callId, callData.toString()))
          };
          (function addCall() {
            if (_activeCalls[callId] !== undefined) {
              Ifm.Diagnostics.Debug.print("Waiting for previous call to be closed...");
              setTimeout(addCall, 200);
              return
            }
            _activeCalls[callId] = {
              callId: callId, callGuid: callData.get("GUID").toUpperCase(), mediatype: mediatype, campaignName: message.campaignName, callDataStr: message.callDataStr, callData: callData
            };
            self.events.assignment.raise(self.getCall(callId));
            _phonebarConnection.send(Messages.AssignmentReply(callId, 1));
            if (config.newcallpopupenabled == 1 || (config.newcallpopupenabled == 2 && document.hidden !== false)) {
              showPhoneBarPopup(strings.EventAssignment + " (" + message.campaignName + ")")
            }
          })();
          break;
        case Messages.PhonesToPhoneBarMessages.AlertingEvent:
          break;
        case Messages.PhonesToPhoneBarMessages.AnsweredEvent:
          break;
        case Messages.PhonesToPhoneBarMessages.CallFailureEvent:
          self.events.callfailure.raise({
            callId: callId, cause: message.cause
          });
          hangup(callId, true);
          delete _activeRooms[roomJid];
          delete _activeCalls[callId];
          updateSessionData();
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyForDetachEvent:
          if (_activeCalls[callId]) {
            hangup(callId, _activeCalls[callId].transferred);
            if (!_activeCalls[callId].transferred) {
              _activeCalls[callId].terminated = true;
              updateSessionData()
            }
          }
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyForTransferEvent:
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyReply:
          if (callId) {
            if (message.accepted === 0) {
              Ifm.Diagnostics.Debug.fail("ReadyReply not accepted for call " + callId);
              return
            }
            if (_activeCalls[callId] !== undefined) {
              var roomJid = _activeCalls[callId].roomJid;
              if (Candy.View.Pane.Room.getPane(roomJid)) {
                Candy.View.Pane.Room.close(roomJid)
              }
              delete _activeRooms[roomJid];
              delete _activeCalls[callId];
              updateSessionData()
            }
          }
          break;
        case Messages.PhonesToPhoneBarMessages.TerminatedEvent:
          var postcall = message.postCallWork === 1 ? true : false;
          if (_activeCalls[callId]) {
            _activeCalls[callId].terminated = true;
            if (postcall)
              _activeCalls[callId].postcall = true;
            updateSessionData()
          }
          self.events.callclosed.raise({
            callId: callId, postCallWork: postcall
          });
          break;
        case Messages.PhonesToPhoneBarMessages.TransferCallReply:
          var accepted = message.accepted === 1 ? true : false;
          if (accepted && _activeCalls[callId]) {
            _activeCalls[callId].transferred = true;
            updateSessionData()
          }
          self.events.transferred.raise({
            callId: callId, accepted: accepted
          });
          break;
        default:
          break
      }
    }
    function onPhoneBarMessage(messageReader) {
      var self = Ifm.phonebarIntegration;
      switch (messageReader.type) {
        case"SetConfiguration":
          Ifm.Diagnostics.Debug.print("Got PhoneBar configuration");
          var newext = messageReader.data[0];
          var newfirstname = messageReader.data[1];
          self.agent.extension = newext;
          self.agent.firstName = newfirstname;
          if (messageReader.data.length > 2) {
            var newlastname = messageReader.data[2];
            self.agent.lastName = newlastname
          }
          var oldext = config.extension || null;
          config.extension = newext;
          var oldname = config.firstname || null;
          config.firstname = newfirstname;
          var olddisplayname = config.displayname || null;
          config.displayname = config.nickname || config.firstname;
          var wasConnected = Candy.Core.isConnected();
          if (newext !== oldext || config.displayname !== olddisplayname) {
            if (wasConnected) {
              Candy.Core.keepconnected = true;
              Candy.Core.disconnect()
            }
          }
          if (!wasConnected) {
            Ifm.Diagnostics.Debug.print("Loggin'in as", config.displayname);
            Candy.Core.keepconnected = true;
            self.events.connecting.raise({});
            Candy.Core.connect(config.server, null, config.getUsername())
          }
          else {
            self.events.connected.raise({})
          }
          break;
        default:
          Ifm.Diagnostics.Debug.print("Not implemented:", messageName);
          break
      }
    }
    return {
        about: {
          name: "Ifm.phonebarIntegration", product: "#phones", version: "1.2.18-4697"
        }, events: defineEvents("initialized", "connecting", "connected", "disconnecting", "disconnected", "assignment", "newcall", "newmessage", "sysmessage", "callfailure", "callclosed", "transfer", "filetransfer"), isInitialized: function() {
            return _isInitialized
          }, isSupported: function() {
            return Ifm.Messaging.FPort.isSupported()
          }, isConnected: function() {
            return _phonebarConnection && _phonebarConnection.isConnected() && Candy.Core.isConnected()
          }, activeCalls: function() {
            var copy = {};
            for (var callId in _activeCalls) {
              copy[callId] = this.getCall(callId)
            }
            return copy
          }, getCall: function(id) {
            var call = _activeCalls[id];
            if (call === undefined) {
              var callId = _activeRooms[id];
              if (callId === undefined) {
                Ifm.Diagnostics.Debug.fail("Invalid id " + id);
                return
              }
              call = _activeCalls[callId]
            }
            return {
                callId: call.callId, mediatype: call.mediatype, campaignName: call.campaignName, callData: call.callData, roomJid: call.roomJid
              }
          }, connect: function(conf) {
            if (_phonebarConnection && !_phonebarConnection.isClosed()) {
              Ifm.Diagnostics.Debug.print("A previous request is pending");
              return
            }
            if (!conf)
              throw Error("Invalid configuration.");
            function customOrDefault(propertyName) {
              return conf.hasOwnProperty(propertyName) ? conf[propertyName] : config[propertyName]
            }
            function customOrError(propertyName) {
              if (!conf[propertyName])
                throw Error("Invalid configuration, argument '" + propertyName + "' is missing.");
              return conf[propertyName]
            }
            config.service = customOrError("service");
            config.server = customOrError("server");
            config.mediatypes = customOrError("mediatypes");
            config.ftservice = customOrDefault("ftservice");
            config.ndservice = customOrDefault("ndservice");
            config.nickname = customOrDefault("nickname");
            config.theme = customOrDefault("theme");
            config.language = customOrDefault("language");
            config.domain_nrt = customOrDefault("domain_nrt");
            config.domain_saf = customOrDefault("domain_saf");
            config.admin_nrt = customOrDefault("admin_nrt");
            config.admin_saf = customOrDefault("admin_saf");
            config.presence = customOrDefault("presence");
            config.debug = customOrDefault("debug");
            config.showtransfer = customOrDefault("showtransfer");
            config.phonebar = customOrDefault("phonebar");
            config.newcallpopupenabled = customOrDefault("newcallpopupenabled");
            config.newcallpopuptimeout = customOrDefault("newcallpopuptimeout");
            if (!config.areValidMediatypes())
              throw Error("Invalid mediatypes.");
            config.mediatypes = +config.mediatypes;
            var self = this;
            if (!_isInitialized) {
              buildCandy();
              buildCandies('2');
              setupCandy();
              _isInitialized = true;
              self.events.initialized.raise({})
            }
            _phonebarConnection = new Ifm.Messaging.FConnection;
            _phonebarConnection.events.binarymessage = function(sender, e) {
              onPhonesMessage(e.reader)
            };
            _phonebarConnection.events.stringmessage = function(sender, e) {
              onPhoneBarMessage(e.reader)
            };
            _phonebarConnection.events.connecting = function(sender, e) {
              Ifm.Diagnostics.Debug.print("Connecting to PhoneBar via", e.address);
              self.events.connecting.raise({})
            };
            _phonebarConnection.events.connected = function(sender, e) {
              Ifm.Diagnostics.Debug.print("Connected to PhoneBar: waiting for provisioning");
              var m = new Ifm.Messaging.FStringMessageWriter("SetMediaType");
              m.add(config.mediatypes).end();
              _phonebarConnection.send(m)
            };
            _phonebarConnection.events.disconnecting = function(sender, e) {
              Ifm.Diagnostics.Debug.print("Disconnecting from PhoneBar")
            };
            _phonebarConnection.events.disconnected = function(sender, e) {
              Ifm.Diagnostics.Debug.print(e.reason);
              if (e.failed && _phonebarConnection.getAddress().startsWith("ws://localhost")) {
                var nd = Ifm.Net.Services.NetworkDiscovery;
                if (nd.isSupported() && config.ndservice) {
                  nd.queryLocalAddress(config.ndservice, function(addr) {
                    if (addr) {
                      config.phonebar = "ws://" + addr + ":22022"
                    }
                    else {
                      Ifm.Diagnostics.Debug.print("Local address query failed")
                    }
                    _phonebarConnection.connect(config.phonebar)
                  });
                  return
                }
              }
              if (Candy.Core.isConnected()) {
                Candy.Core.disconnect()
              }
              else {
                self.events.disconnected.raise(e)
              }
            };
            _phonebarConnection.connect(config.phonebar)
          }, disconnect: function() {
            if (!this.isConnected())
              return;
            var self = Ifm.phonebarIntegration;
            self.events.disconnecting.raise({});
            for (var roomJid in _activeRooms) {
              Candy.Core.Action.Jabber.Room.Leave(roomJid)
            }
            setTimeout(function() {
              var attempt = 0;
              var check = setInterval(function() {
                  var calls = Ifm.Enum.getLength(_activeRooms);
                  if (calls > 0 && ++attempt < 10) {
                    Ifm.Diagnostics.Debug.print("Waiting for calls to close:", calls, "remaining");
                    return
                  }
                  clearInterval(check);
                  for (var roomJid in _activeRooms) {
                    cancelAllFileTransfers(roomJid);
                    Candy.View.Pane.Room.close(roomJid)
                  }
                  Candy.Core.keepconnected = false;
                  _phonebarConnection.disconnect()
                }, 100)
            }, 100)
          }, handled: function(callId) {
            if (this.sendSysMessage(callId, "HANDLED")) {
              _activeCalls[callId].handled = true;
              updateSessionData();
              return true
            }
            return false
          }, send: function(callId, message) {
            if (!this.isConnected()) {
              Ifm.Diagnostics.Debug.fail("Cannot send messages while disconnected from XMPP server");
              return false
            }
            if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
              Ifm.Diagnostics.Debug.fail("Invalid callId " + callId);
              return false
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              Ifm.Diagnostics.Debug.fail("Session not yet created " + callId);
              return false
            }
            Candies.send(roomJid, message);
            return true
          }, sendCallInfo: function(callId, data) {
            var msg = new Ifm.Messaging.FStringMessageWriter("CALLINFO");
            for (var i in data) {
              msg.add(i + ':' + data[i])
            }
            return this.send(callId, msg.end().toString())
          }, sendSysMessage: function(callId, type, args) {
            var msg = new Ifm.Messaging.FStringMessageWriter(type);
            for (var i = 2; i < arguments.length; i++) {
              msg.add(arguments[i])
            }
            return this.send(callId, msg.end().toString())
          }, showTransferDialog: function(callId) {
            if (!this.isConnected())
              return;
            if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
              Ifm.Diagnostics.Debug.fail("Invalid callId " + callId);
              return
            }
            var m = new Ifm.Messaging.FStringMessageWriter("ShowTransferCallForm");
            m.add(callId).add(_activeCalls[callId].callData.toString()).end();
            _phonebarConnection.send(m)
          }, close: function(callId) {
            if (!this.isConnected())
              return;
            if (_activeCalls[callId] === undefined) {
              Ifm.Diagnostics.Debug.fail("Invalid callId " + callId);
              return
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              Ifm.Diagnostics.Debug.fail("Session not yet created " + callId);
              return
            }
            Candy.Core.Action.Jabber.Room.Leave(roomJid)
          }, ready: function(callId) {
            if (_activeCalls[callId] && _activeCalls[callId].postcall) {
              _phonebarConnection.send(new Ifm.PhoneBar.Messages.ReadyRequest(callId))
            }
            if (!this.isConnected())
              return;
            if (_activeCalls[callId] === undefined) {
              Ifm.Diagnostics.Debug.print("Invalid callId", callId);
              return
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              Ifm.Diagnostics.Debug.print("Session not yet created for call", callId);
              return
            }
            if (Candy.View.Pane.Room.getPane(roomJid)) {
              cancelAllFileTransfers(roomJid);
              Candy.View.Pane.Room.close(roomJid)
            }
          }, append: function(callId, html) {
            console.warn("Obsolete. Use Ifm.phonebarIntegration.conversation.append() instead");
            this.conversation.append(callId, html)
          }, conversation: {
            append: function(callId, html) {
              if (_activeCalls[callId] === undefined) {
                Ifm.Diagnostics.Debug.print("Invalid callId", callId);
                return
              }
              var roomJid = _activeCalls[callId].roomJid;
              if (roomJid === undefined) {
                Ifm.Diagnostics.Debug.print("Session not yet created for call", callId);
                return
              }
              Candy.View.Pane.Chat.onInfoMessage(roomJid, "{{message}}");
              var pane = Candy.View.Pane.Room.getPane(roomJid),
                lastmessage = pane.find(".message-pane").children().last(),
                templatedhtml = lastmessage.html();
              lastmessage.html(templatedhtml.replace("{{message}}", html))
            }, html: function(callId) {
                if (_activeCalls[callId] === undefined) {
                  Ifm.Diagnostics.Debug.print("Invalid callId", callId);
                  return
                }
                var roomJid = _activeCalls[callId].roomJid;
                if (roomJid === undefined) {
                  Ifm.Diagnostics.Debug.print("Session not yet created for call", callId);
                  return
                }
                var pane = Candy.View.Pane.Room.getPane(roomJid);
                return pane.find(".message-pane").html()
              }, prepend: function(callId, html) {
                if (_activeCalls[callId] === undefined) {
                  Ifm.Diagnostics.Debug.print("Invalid callId", callId);
                  return
                }
                var roomJid = _activeCalls[callId].roomJid;
                if (roomJid === undefined) {
                  Ifm.Diagnostics.Debug.print("Session not yet created for call", callId);
                  return
                }
                if (html) {
                  var pane = Candy.View.Pane.Room.getPane(roomJid);
                  pane.find(".message-pane").prepend(html)
                }
              }, select: function(callId) {
                if (_activeCalls[callId] === undefined) {
                  Ifm.Diagnostics.Debug.print("Invalid callId", callId);
                  return
                }
                var roomJid = _activeCalls[callId].roomJid;
                if (roomJid === undefined) {
                  Ifm.Diagnostics.Debug.print("Session not yet created for call", callId);
                  return
                }
                Candy.View.Pane.Room.show(roomJid)
              }
          }, queryFileTransfer: function(callback) {
            if (!Ifm.Type.isFunction(callback)) {
              throw Ifm.Diagnostics.Errors.func("callback");
            }
            if (!Ifm.Net.Services.FileTransfer.isSupported() || !config.ftservice) {
              callback(false);
              return
            }
            var ft = Ifm.Net.Services.FileTransfer.create(config.ftservice);
            ft.enabled(callback)
          }, requestFileTransfer: function(callId, file) {
            if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
              Ifm.Diagnostics.Debug.print("Invalid callId", callId);
              return
            }
            if (_activeCalls[callId].mediatype !== Ifm.PhoneBar.Mediatypes.NearRealTime) {
              Ifm.Diagnostics.Debug.print("Unsupported mediatype of call", callId);
              return
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              Ifm.Diagnostics.Debug.print("Session not yet created for call", callId);
              return
            }
            if (!file || !file.name || file.size === undefined || !file.type) {
              var i = document.createElement("input");
              i.type = "file";
              i.style.cssText = "display:none!important;";
              document.body.appendChild(i);
              i.click();
              document.body.removeChild(i);
              i.onchange = function(e) {
                if (i.files && i.files.length > 0) {
                  doFileTransfer(roomJid, i.files[0])
                }
              };
              return
            }
          }, agent: {
            firstName: "", lastName: "", extension: ""
          }
      }
  })()
})();
namespace("Ifm.Chat.Strings");
(function(ns) {
  ns.en = {
    ChatStateComposing: "is writing...", ChatStateTalking: "Chatting", ChatStateClosed: "Chat terminated", EventAssignment: "Incoming call", EventFailed: "Call failed", BotNickname: "Synthetic", FileTransfer: {
        NotAvailable: "File transfer not available", NotAvailOther: "File transfer not available with this user", TransferTitle: "File", Complete: "transferred", Accept: "Accept", Cancel: "Cancel", Open: "Open", Waiting: "waiting", Canceled: "canceled", Error: "error", Receiving: "receiving", Sending: "sending", Received: "received", Sent: "sent"
      }
  };
  ns.it = {
    ChatStateComposing: "sta scrivendo...", ChatStateTalking: "In conversazione", ChatStateClosed: "Conversazione chiusa", EventAssignment: "Chiamata in arrivo", EventFailed: "Chiamata fallita", BotNickname: "Synthetic", FileTransfer: {
        NotAvailable: "Trasferimento file non disponibile", NotAvailOther: "Trasferimento file non disponibile con questo utente", TransferTitle: "File", Complete: "trasferito", Accept: "Accetta", Cancel: "Annulla", Open: "Apri", Waiting: "in attesa", Canceled: "annullato", Error: "errore", Receiving: "ricezione", Sending: "invio", Received: "ricevuto", Sent: "inviato"
      }
  }
})(Ifm.Chat.Strings);
function buildCandies(source) {
  if (!window.Candy)
    throw Ifm.Diagnostics.Errors.miss("Candy");
  _source = source;
  Candy.View.Translation.en.labelNickname = "Your name:";
  Candy.View.Translation.en.loginSubmit = "Enter chat";
  Candy.View.Translation.en.userJoinedRoom = "%s has entered the conversation.";
  Candy.View.Translation.en.userLeftRoom = "%s has left the conversation.";
  Candy.View.Translation.it.labelNickname = "Il tuo nome:";
  Candy.View.Translation.it.loginSubmit = "Entra in chat";
  Candy.View.Translation.it.userJoinedRoom = "%s \u00e8 entrato nella conversazione.";
  Candy.View.Translation.it.userLeftRoom = "%s ha lasciato la conversazione.";
  var baseInfoMessage = Candy.View.Pane.Chat.onInfoMessage;
  Candy.View.Pane.Chat.onInfoMessage = function(roomJid, subject, message) {
    if (!Candy.View.Pane.Room.getPane(roomJid))
      return;
    var lastmessage = Candy.View.Pane.Room.getPane(roomJid, ".message-pane").children().last().text();
    if (lastmessage.indexOf(subject) < 0 && lastmessage.indexOf(message) < 0) {
      baseInfoMessage(roomJid, subject, message)
    }
  };
  Candy.Core.isConnected = function() {
    const conn = Candy.Core.getConnection();
    return (conn && conn.connected) || false
  };
  Candy.Core.getUsername = function() {
    return Candy.Core.getUser().getNick()
  };
  Candy.Core.getRoomUserByName = function(roomJid, name) {
    var room = Candy.Core.getRoom(roomJid);
    if (room) {
      var users = room.roster.getAll();
      for (var i in users) {
        if (Strophe.getResourceFromJid(users[i].getJid()) === name) {
          return users[i]
        }
      }
    }
    return null
  };
  Candy.Core.available = function(target) {
    var presence = $pres({
        from: Candy.Core.getConnection().jid, to: target
      });
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] sending availability to", target);
    Candy.Core.getConnection().send(presence)
  };
  Candy.Core.subscribe = function(target, presencenick, presencestatus) {
    var id = "pres:" + Candy.Core.getConnection().getUniqueId();
    var presence = $pres({
        from: Candy.Core.getConnection().jid, to: target, id: id, type: "subscribe"
      });
    if (presencenick) {
      presence.c("nick", {xmlns: "http://jabber.org/protocol/nick"}, presencenick)
    }
    if (presencestatus) {
      presence.c("status", {}, presencestatus)
    }
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] requesting subscription to", target, "(id", id, ")", presencenick ? "as " + presencenick : "");
    Candy.Core.getConnection().send(presence)
  };
  Candy.Core.subscribed = function(target, replyid) {
    var id = replyid || "pres:" + Candy.Core.getConnection().getUniqueId();
    var presence = $pres({
        from: Candy.Core.getConnection().jid, to: target, id: id, type: "subscribed"
      });
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] replying subscription to", target, "(id", id, ")");
    Candy.Core.getConnection().send(presence)
  };
  Candy.Core.notifystate = function(roomJid, state) {
    var msg = $msg({
        from: Candy.Core.getConnection().jid, to: roomJid, type: "groupchat"
      }).c(state, {xmlns: "http://jabber.org/protocol/chatstates"});
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] sending", state, "notification");
    Candy.Core.getConnection().send(msg)
  };
  Candy.View.deletenotification = function(roomJid) {
    var pane = Candy.View.Pane.Room.getPane(roomJid);
    if (pane) {
      var messages = Candy.View.Pane.Room.getPane(roomJid, ".message-pane"),
        data = pane.data();
      if (data.resetnotificationtmr) {
        clearTimeout(data.resetnotificationtmr);
        data.resetnotificationtmr = 0
      }
      messages.find("[name=chat-state-message]").remove()
    }
  };
  Candy.View.movenotification = function(roomJid) {
    if (Candy.View.Pane.Room.getPane(roomJid)) {
      var messages = Candy.View.Pane.Room.getPane(roomJid, ".message-pane"),
        notification = messages.find("[name=chat-state-message]");
      if (notification.length) {
        messages.append(notification)
      }
    }
  };
  Candy.View.updatenotification = function(roomJid, displayName, state, message) {
    Candy.View.deletenotification(roomJid);
    var pane = Candy.View.Pane.Room.getPane(roomJid);
    if (pane) {
      var html = Mustache.to_html(Candy.View.Template.Chat.stateMessage, {
          subject: displayName, message: message
        });
      Candy.View.Pane.Room.appendToMessagePane(roomJid, html);
      pane.data({resetnotificationtmr: setTimeout(function() {
          Candy.View.deletenotification(roomJid)
        }, 10000)})
    }
  };
  window.Candies = window.Candies || {};
  Candies.appendToMessagePane = function(roomJid, message, sentFromHere, name) {
    name = name || "";
    var now = new Date,
      template = Candy.View.Template.Message.item,
      templateData = {
        name: name, displayName: Candy.Util.getDisplayName(name), croppedDisplayName: Candy.Util.crop(Candy.Util.getDisplayName(name), Candy.View.getOptions().crop.message.nickname), message: message, time: Candy.Util.localizedTime(now.toGMTString()), timestamp: now.toISOString(), stamp: now.valueOf(), id: "", seqId: 0x8000000000000, roomJid: roomJid, sender: sentFromHere ? "sender-is-me" : "sender-is-other"
      },
      html = Mustache.to_html(template, templateData);
    Candy.View.Pane.Room.appendToMessagePane(roomJid, html)
  };
  Candies.getSource = function() {
    return _source
  };
  Candies.send = function(roomJid, message) {
    Candy.Core.Action.Jabber.Room.Message(roomJid, message.toString(), undefined, undefined, _source)
  };
  Candies.sysMessage = function(roomJid, type, args) {
    var msg = new Ifm.Messaging.FStringMessageWriter(type);
    for (var i = 2; i < arguments.length; i++) {
      msg.add(arguments[i])
    }
    Candies.send(roomJid, msg.end())
  };
  Candies.getRoomHistory = function(roomJid) {
    Candy.Core.debug("Getting messages of room " + roomJid);
    var seqId = 0;
    Candy.Core.getConnection().mam.query(roomJid, {
      onMessage: function(message) {
        seqId += 1;
        var msg = $(message);
        var originalMsg = msg.find("forwarded message");
        var from = Candy.Util.unescapeJid(originalMsg.attr("from"));
        var name = Strophe.getResourceFromJid(from);
        var nom = {
            roomJid: roomJid, message: {
                name: name, body: originalMsg.children("body").text(), type: originalMsg.attr("type"), attributes: {
                    xmlns: originalMsg.attr("xmlns"), to: msg.attr("to"), type: originalMsg.attr("type"), id: originalMsg.attr("id"), from: from, seqId: seqId
                  }
              }, timestamp: msg.find("forwarded delay").attr("stamp")
          };
        Candy.View.Observer.Message(null, nom);
        return true
      }, onComplete: function(response) {
          Candy.Core.debug("[MAM] Response " + response);
          Candy.Core.debug("Got all messages of room " + roomJid);
          if (seqId === 0) {
            Candies.sysMessage(roomJid, "CONTINUITY")
          }
          Candy.View.Pane.Chat.onInfoMessage(roomJid, $.i18n._("sessionRestored"));
          Candy.View.Pane.Room.scrollToBottom(roomJid)
        }
    })
  };
  var _source
}
;
namespace("Ifm.Chat.Extras.FileTransfer", function() {
  this.transferFile = function(roomJid, ft, file, strings) {
    if (!file || !file.name || file.size === undefined || !file.type === undefined) {
      Ifm.Diagnostics.Debug.print("Invalid argument file");
      return
    }
    var isSender = !file.token ? true : false;
    var usize;
    if (file.size >= 1073741824)
      usize = Math.round(file.size / 1073741824) + " GB";
    else if (file.size >= 1048576)
      usize = Math.round(file.size / 1048576) + " MB";
    else if (file.size >= 1024)
      usize = Math.round(file.size / 1024) + " KB";
    else if (file.size > 1)
      usize = file.size + " bytes";
    else if (file.size === 1)
      usize = "1 byte";
    else
      usize = "0 bytes";
    ft.events.waiting = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data) {
        ft.cancel();
        return
      }
      if (isSender) {
        var tm = new Ifm.Messaging.FStringMessageWriter("FTTOKEN");
        tm.add(e.token).add(file.name).add(file.size).add(file.type).end();
        Candies.send(roomJid, tm)
      }
      var viewElementId = "ft-item-" + ft.id,
        viewElementHtml = "<span id='" + viewElementId + "'> " + "<span class='filetransfer-title'> " + strings.FileTransfer.TransferTitle + " </span> " + "<span class='filetransfer-file'> <b>" + file.name + "</b> </span> " + "<span class='filetransfer-status'> " + strings.FileTransfer.Waiting + " </span> " + "<a class='filetransfer-accept' href='#'> " + strings.FileTransfer.Accept + " </a> " + "<a class='filetransfer-cancel' href='#'> " + strings.FileTransfer.Cancel + " </a> " + "</span>";
      var template = Candy.View.Template.FileTransfer.item,
        templateData = {
          view: viewElementHtml, time: Candy.Util.localizedTime((new Date).toGMTString())
        },
        html = Mustache.to_html(template, templateData);
      Candy.View.Pane.Room.appendToMessagePane(roomJid, html);
      var tab = Candy.View.Pane.Chat.getTab(roomJid);
      tab.find(".transfer").show();
      var ve = $("#" + viewElementId);
      data.filetransfers[ft.id] = {
        filetransfer: ft, viewelement: ve
      };
      ve.find(".filetransfer-cancel").click(function() {
        ft.cancel();
        return false
      });
      if (isSender) {
        ve.find(".filetransfer-accept").remove()
      }
      else {
        ve.find(".filetransfer-status").text(usize);
        ve.find(".filetransfer-accept").click(function() {
          ft.accept();
          ve.find(".filetransfer-accept").remove();
          return false
        })
      }
    };
    ft.events.started = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      if (isSender) {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Sending)
      }
      else {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Receiving)
      }
      var tab = Candy.View.Pane.Chat.getTab(roomJid);
      tab.find(".transfer").hide()
    };
    ft.events.progress = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      ve.find(".filetransfer-status").text(e.percentage + "%")
    };
    ft.events.finished = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      ve.find(".filetransfer-cancel").remove();
      if (isSender) {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Sent);
        Candies.send(roomJid, strings.FileTransfer.TransferTitle + " " + file.name + " " + usize + " " + strings.FileTransfer.Complete)
      }
      else {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Received);
        ve.append($("<a>", {
          "class": "filetransfer-open", click: e.openOrSaveFunc, href: "#", text: strings.FileTransfer.Open
        }))
      }
      Ifm.Chat.Extras.MediaPreview.generateThumbnail(roomJid, file.name, e.fileBlob, isSender)
    };
    ft.events.canceled = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      ve.find(".filetransfer-status").text(strings.FileTransfer.Canceled);
      ve.find(".filetransfer-cancel").remove();
      if (!isSender)
        ve.find(".filetransfer-accept").remove();
      var tab = Candy.View.Pane.Chat.getTab(roomJid);
      tab.find(".transfer").hide()
    };
    ft.events.error = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      Candy.View.Pane.Chat.Modal.showError("File Transfer: " + e.reason);
      if (data.filetransfers[ft.id]) {
        var ve = data.filetransfers[ft.id].viewelement;
        ve.find(".filetransfer-status").text(strings.FileTransfer.Error);
        ve.find(".filetransfer-cancel").remove();
        if (!isSender)
          ve.find(".filetransfer-accept").remove();
        var tab = Candy.View.Pane.Chat.getTab(roomJid);
        tab.find(".transfer").hide()
      }
    };
    if (isSender) {
      ft.transfer(file)
    }
    else {
      ft.receive(file.token)
    }
  }
});
namespace("Ifm.Chat.Extras.MediaPreview", function() {
  this.generateThumbnail = function(roomJid, filename, fileBlob, isSender) {
    if (this.isTypeSupported(fileBlob)) {
      var url = URL.createObjectURL(fileBlob),
        type = fileBlob.type;
      if (type.startsWith("image/")) {
        var id = 'media-preview-thumbnail-' + (+new Date).toString(36);
        display(roomJid, '<img id="' + id + '" class="media-preview-thumbnail" src="' + url + '" alt="' + filename + '">', isSender);
        document.getElementById(id).onclick = function() {
          displayImageModalOnClick(id)
        }
      }
      else if (type.startsWith("audio/")) {
        display(roomJid, '<audio class="media-preview-player" controls><source src="' + url + '" type="' + fileBlob.type + '"></audio>', isSender)
      }
      else if (type.startsWith("video/")) {
        display(roomJid, '<video class="media-preview-player" controls><source src="' + url + '" type="' + fileBlob.type + '"></video>', isSender)
      }
    }
  };
  this.isTypeSupported = function(fileBlob) {
    var type = fileBlob.type;
    return type.startsWith("image/") || type.startsWith("audio/") || type.startsWith("video/")
  };
  function display(roomJid, html, isSender) {
    Candies.appendToMessagePane(roomJid, html, isSender)
  }
  function displayImageModalOnClick(id) {
    var img = document.getElementById(id);
    if (img) {
      var modalImg = getModalImage();
      modalImg.src = img.src;
      modalImg.alt = img.alt
    }
  }
  function getModalImage() {
    var modal = document.getElementById(ModalId),
      modalImg;
    if (!modal) {
      modal = document.createElement("div");
      modal.id = ModalId;
      modalImg = document.createElement("img");
      modalImg.id = ModalImgId;
      modal.appendChild(modalImg);
      document.body.appendChild(modal);
      var close = function() {
          modal.style.display = "none";
          modalImg.src = "";
          modalImg.alt = ""
        };
      modal.onclick = function() {
        close()
      };
      $("body").on("keydown", function(e) {
        if (e.which === 27 && !modal.style.display) {
          close()
        }
      })
    }
    else {
      modalImg = document.getElementById(ModalImgId)
    }
    modal.style.display = "";
    return modalImg
  }
  var ModalId = "media-preview-modal-div";
  var ModalImgId = "media-preview-modal-img"
});
namespace("Ifm.Chat.Extras.UrlPreview", function() {
  this.findAndGenerate = function(roomJid, message) {
    var authKey = this.settings && this.settings.authKey;
    if (authKey) {
      var linkRE = /<a[^>]*href\s*=\s*['"`]((?!javascript)[^\s#'"`]+?)['"`].*?>.*?<\/a\s*>/gi;
      if (linkRE.test(message)) {
        linkRE.lastIndex = 0;
        var originalMessage = message;
        var containerId = 'message-url-preview-' + (+new Date).toString(36);
        message = '<span id="' + containerId + '">' + originalMessage + '</span>';
        var match;
        while ((match = linkRE.exec(originalMessage)) !== null) {
          generate(authKey, match[1]).then(function(result) {
            replace(containerId, result.url, result.html)
          })
        }
        Candy.View.Pane.Room.scrollToBottom(roomJid)
      }
    }
    return message
  };
  function generate(authKey, url) {
    return new Promise(function(resolve) {
        $.ajax({
          url: 'https://api.linkpreview.net?key=' + authKey + '&q=' + url, success: function(result) {
              if (!result.title && !result.description || !result.image) {
                Ifm.Diagnostics.Debug.print("[Candy] [UrlPreview] preview not available for", url);
                return
              }
              var html = '<div class="message-url-preview-container">' + '<h1 class="message-url-preview-title">' + result.title + '</h1>' + '<h2 class="message-url-preview-subtitle">' + result.description + '</h2>' + '<img class="message-url-preview-img" src="' + result.image + '" alt="' + result.title + '">' + '</div>';
              resolve({
                url: url, html: html
              })
            }, error: function(error) {
              Ifm.Diagnostics.Debug.print("[Candy] [UrlPreview] review service returned an error:", error.statusText)
            }
        })
      })
  }
  function replace(containerId, url, html) {
    var containerElement = document.getElementById(containerId);
    if (containerElement) {
      var newLinkElement = '<a class="message-url" href="' + url + '" target="_blank">' + html + '</a>';
      var validREUrl = url.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1').replace(/&(?!amp;)/g, '&amp;');
      var oldLinkRE = new RegExp('<a[^>]*href\\s*=\\s*[\'"`]' + validREUrl + '[\'"`].*?>.*?<\\/a\\s*>', 'gi');
      if (containerElement.innerHTML.match(oldLinkRE)) {
        containerElement.innerHTML = containerElement.innerHTML.replace(oldLinkRE, newLinkElement)
      }
    }
  }
});
(function(root, factory) {
  if (typeof exports == 'object')
    module{}
  .exports = factory();
  if (typeof define == 'function' && define.amd)
    define(factory);
  else
    root.Spinner = factory()
}(this, function() {
  var prefixes = ['webkit', 'Moz', 'ms', 'O'],
    animations = {},
    useCssAnimations;
  function createEl(tag, prop) {
    var el = document.createElement(tag || 'div'),
      n;
    for (n in prop)
      el[n] = prop[n];
    return el
  }
  function ins(parent) {
    for (var i = 1, n = arguments.length; i < n; i++)
      parent.appendChild(arguments[i]);
    return parent
  }
  var sheet = (function() {
      var el = createEl('style', {type: 'text/css'});
      ins(document.getElementsByTagName('head')[0], el);
      return el.sheet || el.styleSheet
    }());
  function addAnimation(alpha, trail, i, lines) {
    var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-'),
      start = 0.01 + i / lines * 100,
      z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha),
      prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase(),
      pre = prefix && '-' + prefix + '-' || '';
    if (!animations[name]) {
      sheet.insertRule('@' + pre + 'keyframes ' + name + '{' + '0%{opacity:' + z + '}' + start + '%{opacity:' + alpha + '}' + (start + 0.01) + '%{opacity:1}' + (start + trail) % 100 + '%{opacity:' + alpha + '}' + '100%{opacity:' + z + '}' + '}', sheet.cssRules.length);
      animations[name] = 1
    }
    return name
  }
  function vendor(el, prop) {
    var s = el.style,
      pp,
      i;
    prop = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (i = 0; i < prefixes.length; i++) {
      pp = prefixes[i] + prop;
      if (s[pp] !== undefined)
        return pp
    }
    if (s[prop] !== undefined)
      return prop
  }
  function css(el, prop) {
    for (var n in prop)
      el.style[vendor(el, n) || n] = prop[n];
    return el
  }
  function merge(obj) {
    for (var i = 1; i < arguments.length; i++) {
      var def = arguments[i];
      for (var n in def)
        if (obj[n] === undefined)
          obj[n] = def[n]
    }
    return obj
  }
  function pos(el) {
    var o = {
        x: el.offsetLeft, y: el.offsetTop
      };
    while ((el = el.offsetParent))
      o.x += el.offsetLeft,
      o.y += el.offsetTop;
    return o
  }
  function getColor(color, idx) {
    return typeof color == 'string' ? color : color[idx % color.length]
  }
  var defaults = {
      lines: 12, length: 7, width: 5, radius: 10, rotate: 0, corners: 1, color: '#000', direction: 1, speed: 1, trail: 100, opacity: 1 / 4, fps: 20, zIndex: 2e9, className: 'spinner', top: '50%', left: '50%', position: 'absolute'
    };
  function Spinner(o) {
    this.opts = merge(o || {}, Spinner.defaults, defaults)
  }
  Spinner.defaults = {};
  merge(Spinner.prototype, {
    spin: function(target) {
      this.stop();
      var self = this,
        o = self.opts,
        el = self.el = css(createEl(0, {className: o.className}), {
          position: o.position, width: 0, zIndex: o.zIndex
        }),
        mid = o.radius + o.length + o.width;
      css(el, {
        left: o.left, top: o.top
      });
      if (target) {
        target.insertBefore(el, target.firstChild || null)
      }
      el.setAttribute('role', 'progressbar');
      self.lines(el, self.opts);
      if (!useCssAnimations) {
        var i = 0,
          start = (o.lines - 1) * (1 - o.direction) / 2,
          alpha,
          fps = o.fps,
          f = fps / o.speed,
          ostep = (1 - o.opacity) / (f * o.trail / 100),
          astep = f / o.lines;
        (function anim() {
          i++;
          for (var j = 0; j < o.lines; j++) {
            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity);
            self.opacity(el, j * o.direction + start, alpha, o)
          }
          self.timeout = self.el && setTimeout(anim, ~~(1000 / fps))
        })()
      }
      return self
    }, stop: function() {
        var el = this.el;
        if (el) {
          clearTimeout(this.timeout);
          if (el.parentNode)
            el.parentNode.removeChild(el);
          this.el = undefined
        }
        return this
      }, lines: function(el, o) {
        var i = 0,
          start = (o.lines - 1) * (1 - o.direction) / 2,
          seg;
        function fill(color, shadow) {
          return css(createEl(), {
              position: 'absolute', width: (o.length + o.width) + 'px', height: o.width + 'px', background: color, boxShadow: shadow, transformOrigin: 'left', transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.radius + 'px' + ',0)', borderRadius: (o.corners * o.width >> 1) + 'px'
            })
        }
        for (; i < o.lines; i++) {
          seg = css(createEl(), {
            position: 'absolute', top: 1 + ~(o.width / 2) + 'px', transform: o.hwaccel ? 'translate3d(0,0,0)' : '', opacity: o.opacity, animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
          });
          if (o.shadow)
            ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2 + 'px'}));
          ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))
        }
        return el
      }, opacity: function(el, i, val) {
        if (i < el.childNodes.length)
          el.childNodes[i].style.opacity = val
      }
  });
  function initVML() {
    function vml(tag, attr) {
      return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr)
    }
    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)');
    Spinner.prototype.lines = function(el, o) {
      var r = o.length + o.width,
        s = 2 * r;
      function grp() {
        return css(vml('group', {
            coordsize: s + ' ' + s, coordorigin: -r + ' ' + -r
          }), {
            width: s, height: s
          })
      }
      var margin = -(o.width + o.length) * 2 + 'px',
        g = css(grp(), {
          position: 'absolute', top: margin, left: margin
        }),
        i;
      function seg(i, dx, filter) {
        ins(g, ins(css(grp(), {
          rotation: 360 / o.lines * i + 'deg', left: ~~dx
        }), ins(css(vml('roundrect', {arcsize: o.corners}), {
          width: r, height: o.width, left: o.radius, top: -o.width >> 1, filter: filter
        }), vml('fill', {
          color: getColor(o.color, i), opacity: o.opacity
        }), vml('stroke', {opacity: 0}))))
      }
      if (o.shadow)
        for (i = 1; i <= o.lines; i++)
          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)');
      for (i = 1; i <= o.lines; i++)
        seg(i);
      return ins(el, g)
    };
    Spinner.prototype.opacity = function(el, i, val, o) {
      var c = el.firstChild;
      o = o.shadow && o.lines || 0;
      if (c && i + o < c.childNodes.length) {
        c = c.childNodes[i + o];
        c = c && c.firstChild;
        c = c && c.firstChild;
        if (c)
          c.opacity = val
      }
    }
  }
  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'});
  if (!vendor(probe, 'transform') && probe.adj)
    initVML();
  else
    useCssAnimations = vendor(probe, 'animation');
  return Spinner
}));
(function() {
  if (!window.Spinner)
    throw new Error("Dependency module missing or not yet loaded: spin");
  Spinner.show = function() {
    var box = document.getElementById("spinnerBox");
    if (box)
      return;
    Ifm.Dom.Fader.show();
    box = document.createElement("div");
    box.id = "spinnerBox";
    box.style.position = "absolute";
    box.style.margin = "auto";
    box.style.left = "25%";
    box.style.top = "25%";
    box.style.right = "25%";
    box.style.bottom = "25%";
    document.body.appendChild(box);
    new Spinner({
      lines: 11, length: 20, width: 10, radius: 30, corners: 1, rotate: 0, direction: 1, color: 'white', speed: 1, trail: 60, shadow: false, hwaccel: false, className: 'spinner', zIndex: 2e9, top: '50%', left: '50%'
    }).spin(box)
  };
  Spinner.hide = function() {
    var box = document.getElementById("spinnerBox");
    if (!box)
      return;
    box.parentNode.removeChild(box);
    Ifm.Dom.Fader.hide()
  }
})()
