
//============================================================================

// Copyright (c) Base Digitale Platform. All rights reserved.

//============================================================================

"use strict";
var global = global || window;
if (Object.defineProperty) {
  Object.defineProperty(global, "T0", {value: +new Date})
}
else {
  var T0 = +new Date
}
var dT = function() {
    return new Date - T0
  };
function defineEvents(names) {
  var eventbox = {};
  for (var i = 0; i < arguments.length; i++) {
    var name = arguments[i];
    if (!Ifm.Type.isString(name)) {
      throw Ifm.Diagnostics.Errors.arg("name");
    }
    createEventAccessors(eventbox, name)
  }
  return eventbox
}
function createEventAccessors(owner, name) {
  var evt = new Ifm.Event;
  Object.defineProperty(owner, name, {
    get: function() {
      return evt
    }, set: function(handler) {
        evt.addHandler(handler)
      }
  })
}
function inherits(ctorClass, ctorBase) {
  if (!Ifm.Type.isFunction(ctorClass))
    throw Ifm.Diagnostics.Errors.func("ctorClass");
  if (!Ifm.Type.isFunction(ctorBase))
    throw Ifm.Diagnostics.Errors.func("ctorBase");
  ctorClass.prototype = Object.create(ctorBase.prototype);
  ctorClass.prototype.constructor = ctorClass;
  return ctorBase.prototype
}
;
function namespace(globalNamespace, factory) {
  var ns = window,
    parts = globalNamespace.split('.');
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    ns[part] = ns[part] || {};
    ns = ns[part]
  }
  if (typeof factory === typeof namespace) {
    factory.call(ns)
  }
  else {
    for (var e in factory) {
      ns[e] = factory[e]
    }
  }
  return ns
}
function query(url) {
  var query = url || window.location.search,
    pairs = {};
  query.replace(/[?&#]([^=]+)=([^&]*)?/g, function(match, key, val) {
    if (key)
      pairs[key] = val || "";
    return ""
  });
  return pairs
}
Function.getName = function(func) {
  if (!Ifm.Type.isFunction(func))
    throw Ifm.Diagnostics.Errors.func("func");
  var res = /function\s+(\w+)/.exec(func);
  if (res && res.length === 2)
    return res[1];
  res = /(\w+)\s*=\s*function/.exec(func);
  if (res && res.length === 2)
    return res[1];
  return 'anonymous function'
};
Function.prototype.toShortString = function() {
  var body = this.toString().replace(/[\r|\n]/g, '').replace(/[\s]+/g, ' ');
  return body.substr(0, body.indexOf('{')).trim()
};
Array.pushArray = function(array1, array2) {
  if (!Ifm.Type.isArray(array1))
    throw Ifm.Diagnostics.Errors.arg("array1");
  if (!Ifm.Type.isArray(array2))
    throw Ifm.Diagnostics.Errors.arg("array2");
  return Array.prototype.push.apply(array1, array2)
};
if (!Array.prototype.find) {
  try {
    Object.defineProperty(Array.prototype, "find", {
      enumerable: false, value: function(func, thisArg) {
          if (!Ifm.Type.isFunction(func))
            throw Ifm.Diagnostics.Errors.func("func");
          for (var i = 0, len = this.length; i < len; i++) {
            if (i in this && func.call(thisArg, this[i], i, this)) {
              return this[i]
            }
          }
          return undefined
        }
    })
  }
  catch(e) {}
}
if (window.ArrayBuffer) {
  ArrayBuffer.fromBytes = function(bytes) {
    var len = bytes.length;
    var buffer = new ArrayBuffer(len);
    var bufView = new Uint8Array(buffer);
    for (var i = 0; i < len; i++) {
      bufView[i] = bytes[i]
    }
    return buffer
  };
  ArrayBuffer.prototype.getBytes = function() {
    var bufView = new Uint8Array(this);
    var bytes = [];
    for (var i = 0, l = bufView.length; i < l; i++) {
      bytes.push(bufView[i])
    }
    return bytes
  }
}
if (!Object.entries) {
  Object.entries = function(obj) {
    var e = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        e.push([i, obj[i]]);
    return e
  }
}
if (!Object.keys) {
  Object.keys = function(obj) {
    var k = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        k.push(i);
    return k
  }
}
if (!Object.values) {
  Object.values = function(obj) {
    var v = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        v.push(obj[i]);
    return v
  }
}
String.format = function(str, formatargs) {
  if (!str || !Ifm.Type.isString(str))
    return str;
  var args = Array.prototype.slice.call(arguments, 1);
  return str.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] !== 'undefined' ? args[number] : ''
    })
};
String.prototype.format = function(formatargs) {
  var args = [this];
  Array.prototype.push.apply(args, arguments);
  return String.format.apply(null, args)
};
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(str, position) {
    position = position || 0;
    return this.substr(position, str.length) === str
  }
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(str, position) {
    position = position || this.length;
    var start = Math.max(position - str.length, 0);
    return this.slice(start, position) === str
  }
}
if (!String.prototype.trim) {
  String.prototype.trim = function() {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
  }
}
String.prototype.indexAfter = function(str) {
  var p = this.indexOf(str);
  return p + (p < 0 ? 0 : str.length)
};
String.prototype.lastIndexAfter = function(str) {
  var p = this.lastIndexOf(str);
  return p + (p < 0 ? 0 : str.length)
};
if (!Date.now) {
  Date.now = function() {
    return +new Date
  }
}
if (!Date.prototype.toISOString) {
  (function() {
    function pad(number) {
      var r = String(number);
      if (r.length === 1) {
        r = '0' + r
      }
      return r
    }
    Date.prototype.toISOString = function() {
      return this.getUTCFullYear() + '-' + pad(this.getUTCMonth() + 1) + '-' + pad(this.getUTCDate()) + 'T' + pad(this.getUTCHours()) + ':' + pad(this.getUTCMinutes()) + ':' + pad(this.getUTCSeconds()) + '.' + String((this.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5) + 'Z'
    }
  })()
}
if (!Date.prototype.toISOLocaleDateString) {
  Date.prototype.toISOLocaleDateString = function() {
    var yyyy = '' + this.getFullYear(),
      mm = '' + (this.getMonth() + 1),
      dd = '' + this.getDate();
    if (mm.length < 2)
      mm = '0' + mm;
    if (dd.length < 2)
      dd = '0' + dd;
    return yyyy + '-' + mm + '-' + dd
  }
}
namespace("Ifm", function() {
  Ifm.version = "Ifm.js/1.0.92-4649";
  this.Objects = {deepMerge: function recursive(o1, o2, skipNullOrUndefined) {
      for (var i in o2) {
        if (typeof o2[i] === typeof{}) {
          if (o2[i] === null) {
            if (skipNullOrUndefined !== true) {
              o1[i] = null
            }
          }
          else if (typeof o1[i] !== typeof{} || o1[i] === null) {
            o1[i] = {}
          }
          recursive(o1[i], o2[i], skipNullOrUndefined)
        }
        else {
          if (o2[i] !== undefined || skipNullOrUndefined !== true) {
            o1[i] = o2[i]
          }
        }
      }
      return o1
    }};
  this.Enum = {};
  this.Enum.getName = function(enumObject, value) {
    var names = Object.getOwnPropertyNames(enumObject);
    for (var i = 0, l = names.length; i < l; i++) {
      var name = names[i];
      if (enumObject[name] === value) {
        return name
      }
    }
    return ''
  };
  this.Enum.getLength = function(enumObject) {
    return Object.getOwnPropertyNames(enumObject).length
  };
  this.Type = {};
  this.Type.getTypeName = function(o) {
    var ecmaname = Object.prototype.toString.call(o).slice(8, -1);
    if (ecmaname === 'Object') {
      var ctorname = o && o.constructor && o.constructor.toString().match(/function\s+([^\s]{1,})\s*\(/);
      if (ctorname)
        return ctorname[1]
    }
    return ecmaname
  };
  this.Type.isArray = function(o) {
    return Object.prototype.toString.call(o) === "[object Array]"
  };
  this.Type.isLikeArray = function(o) {
    return typeof o === 'object' && !Ifm.Type.isString(o) && typeof o.length === 'number' && !o.propertyIsEnumerable('length')
  };
  this.Type.isFunction = function(o) {
    return typeof o === 'function'
  };
  this.Type.isNumber = function(o) {
    return typeof o === 'number'
  };
  this.Type.isString = function(o) {
    return typeof o === 'string' || o instanceof String
  };
  this.Event = function() {
    if (!(this instanceof Ifm.Event))
      throw Ifm.Diagnostics.Errors.ctor();
    var handlers = [];
    return {
        constructor: Ifm.Event, addHandler: function(func, owner = null, once = false) {
            if (!Ifm.Type.isFunction(func))
              return;
            handlers.push({
              func, owner, once
            })
          }, hasHandlers: function() {
            return handlers.length > 0
          }, removeAllHandlers: function() {
            handlers.length = 0
          }, removeHandler: function(func) {
            var len = handlers.length;
            while (len--) {
              if (handlers[len].func === func) {
                handlers.splice(len, 1)
              }
            }
          }, raise: function(args) {
            var len = handlers.length;
            while (len--) {
              var h = handlers[len];
              h.func.apply(h.owner, arguments);
              if (h.once) {
                handlers.splice(len, 1)
              }
            }
          }
      }
  }
});
namespace("Ifm.Diagnostics", function() {
  this.Debug = {};
  this.Debug.onprint = new Ifm.Event;
  this.Debug.enabled = false;
  this.Debug.popupAssertions = false;
  this.Debug.assert = function __assert(condition, message) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    if (Ifm.Type.isString(condition)) {
      try {
        var tester = new Function("return " + condition);
        Ifm.Diagnostics.Debug.assert(tester(), condition + ' ' + message)
      }
      catch(e) {
        Ifm.Diagnostics.Debug.fail("Invalid assert condition '" + condition + "' : " + e.message)
      }
      return
    }
    if (!condition)
      Ifm.Diagnostics.Debug.fail(message)
  };
  this.Debug.fail = function __fail(message) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    var st = arguments[1];
    var fn = arguments[2] || __fail;
    if (!st) {
      try {
        throw new Error("Assertion failed");
      }
      catch(e) {
        st = e.stack || "[Callstack not available]"
      }
    }
    window.console && console.error && console.error(message, st);
    Ifm.Diagnostics.Debug.popupAssertions && alert(message + "\n\n----Stack----\n\n" + st)
  };
  this.Debug.clear = function() {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    window.console && console.clear && console.clear();
    var conview = document.getElementById("consoleview");
    if (conview) {
      conview.innerHTML = ''
    }
  };
  this.Debug.print = function(str) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    var line = arguments.length > 1 ? Array.prototype.slice.call(arguments).join(' ') : str && str.toString() || null;
    if (line === null) {
      return
    }
    window.console && console.log && console.log(line);
    Ifm.Diagnostics.Debug.onprint.raise(line);
    var conview = document.getElementById("consoleview");
    if (conview) {
      conview.innerHTML += line + "<br>";
      conview.scrollTop = conview.scrollHeight
    }
  };
  this.Debug.printf = function(format, args) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    Ifm.Diagnostics.Debug.print(String.format.apply(null, arguments))
  };
  this.Errors = (function() {
    var instance = {};
    instance.arg = function(name) {
      return _error("Invalid function argument", name)
    };
    instance.argsno = function(num) {
      return _error("Invalid number of function arguments", num)
    };
    instance.browser = function() {
      return _error("Browser not supported")
    };
    instance.ctor = function(name) {
      return _error("Invalid constructor call", name)
    };
    instance.func = function(name) {
      return _error("Function argument expected", name)
    };
    instance.miss = function(name) {
      return _error("Missing type or module", name)
    };
    instance.notimpl = function(name) {
      return _error("Feature not implemented", name)
    };
    instance.notsup = function(name) {
      return _error("Feature not supported", name)
    };
    instance.op = function(state) {
      return _error("Invalid operation", state)
    };
    function _error(error, name) {
      return new Error(error + (name ? ": '" + name + "'" : ""))
    }
    return instance
  })()
});
;
function __errhandler(a, b, c, d, e) {
  if (!arguments || !arguments.length) {
    return
  }
  var message = e && e.message ? e.message : (a || "Script error");
  var source = b || (e ? e.filename : '') || '';
  var line = c || (e ? e.lineno : '') || '';
  var column = d || (e ? e.colno : '') || '';
  var stack = e && e.stack ? e.stack : (source ? [source, line, column].join(' ') : "window.onerror");
  Ifm.Application.onerror(message, stack)
}
namespace("Ifm");
(function() {
  Ifm.version += "; Ifm.Dom.js/1.1.0-4649";
  this.Application = {frameworkPath: ''};
  var scripts = document.getElementsByTagName("script");
  for (var i = 0; i < scripts.length; i++) {
    var matches = scripts[i].src.match(/(.*)Ifm\.Dom\.js/);
    if (matches && matches.length === 2) {
      Ifm.Application.frameworkPath = matches[1];
      break
    }
  }
  var readyNotified = false;
  var readyDelegates = [];
  var readyCompleted = function() {
      if (readyNotified)
        return;
      if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
        Ifm.Dom.Strings.replaceAll('%');
        readyNotified = true;
        var len = readyDelegates.length;
        while (len--) {
          readyDelegates[len]()
        }
        readyDelegates = []
      }
    };
  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", readyCompleted, false);
    window.addEventListener("load", readyCompleted, false)
  }
  else {
    document.attachEvent("onreadystatechange", readyCompleted);
    window.attachEvent("onload", readyCompleted)
  }
  this.Application.abort = function(error, stack) {
    var ehome = encodeURIComponent(window.location.href);
    var eerror = encodeURIComponent(error || '');
    var estack = encodeURIComponent(stack || '');
    var s = sessionStorage;
    var p = '';
    if (s) {
      s.setItem("home", ehome);
      s.setItem("error", eerror);
      s.setItem("stack", estack);
      s.setItem("info", Ifm.version)
    }
    else {
      p = "?home=" + ehome + "&error=" + eerror + "&stack=" + estack + "&info=" + Ifm.version
    }
    window.onerror = null;
    window.onbeforeunload = null;
    window.location.assign(this.frameworkPath + "blue.htm" + p)
  };
  this.Application.parameters = function() {
    var p = {};
    p.count = 0;
    (window.location.search + window.location.hash).replace(/([^?&=]+)=([^&]*)?/g, function(match, key, val) {
      if (key) {
        p[key] = val || '';
        p.count++
      }
    });
    return p
  };
  this.Application.showBand = function(message, additional) {
    var html = "<div style='margin:16px;'>" + "<pre style='font-size:xx-large;'>" + (message || '') + "</pre>" + "<pre style='font-size:medium;'>" + (additional || '') + "</pre>" + "</div>";
    Ifm.Dom.Band.show(html)
  };
  this.Application.ready = function(onready) {
    if (!Ifm.Type.isFunction(onready)) {
      throw new Error("Application.ready() -> Invalid ready handler function");
    }
    if (readyNotified) {
      setTimeout(onready);
      return
    }
    readyDelegates.push(onready)
  };
  this.Application.quit = function(onquit, oncancel) {
    if (onquit && !Ifm.Type.isFunction(onquit)) {
      throw new Error("Application.quit() -> Invalid quit handler function");
    }
    if (oncancel && !Ifm.Type.isFunction(oncancel)) {
      throw new Error("Application.quit() -> Invalid cancel handler function");
    }
    window.onbeforeunload = function() {
      var userchoice = false;
      setTimeout(function() {
        setTimeout(function() {
          if (userchoice && oncancel)
            oncancel()
        }, 100)
      });
      return userchoice = onquit()
    }
  };
  this.Application.onerror = function __onerror(error, stack) {
    if (Ifm.Diagnostics.Debug.enabled) {
      Ifm.Diagnostics.Debug.fail(error, stack)
    }
    else {
      debugger;
      Ifm.Application.abort(error, stack)
    }
  }
}).call(Ifm);
namespace("Ifm.Dom");
(function() {
  this.isReady = function(document) {
    if (Ifm.Dom.isWindow(document)) {
      document = document.document
    }
    return isDocumentReady(document)
  };
  this.isWindow = function(obj) {
    return obj.constructor.name === 'Window'
  };
  this.whenReady = function(document, callback) {
    if (Ifm.Dom.isWindow(document)) {
      document = document.document
    }
    if (isDocumentReady(document)) {
      callback(document)
    }
    else {
      var onReadyStateChange = function() {
          if (isDocumentReady(document)) {
            document.removeEventListener('readystatechange', onReadyStateChange);
            callback(document)
          }
        };
      document.addEventListener('readystatechange', onReadyStateChange)
    }
  };
  this.whenWindowNavigates = function(window, url, callback) {
    var attempt = 0;
    var navigationtimer = setInterval(function() {
        if (window.location.href.toLowerCase().indexOf(url.toLowerCase()) < 0 || !isDocumentReady(window.document)) {
          return
        }
        if (++attempt < 5)
          return;
        clearInterval(navigationtimer);
        Ifm.Dom.whenReady(window, callback)
      }, 100)
  };
  function isDocumentReady(document) {
    if (!document || !document.URL || document.URL === 'about:blank' || document.URL === 'edge://newtab/' || document.URL === 'chrome://newtab/') {
      return false
    }
    var state = document.readyState;
    return state === 'interactive' || state === 'complete'
  }
  this.Events = {
    addHandler: (window.addEventListener ? function(element, type, handler) {
      element.addEventListener(type, handler, false)
    } : function(element, type, handler) {
      element.attachEvent("on" + type, handler)
    }), getEvent: function(e) {
        return e || window.event
      }, getTarget: function(e) {
        var event = e || window.event;
        return event.target || event.srcElement
      }, preventDefault: function(e) {
        var event = e || window.event;
        if (event.preventDefault) {
          event.preventDefault()
        }
        else {
          event.returnValue = false
        }
      }, removeHandler: (window.removeEventListener ? function(element, type, handler) {
        element.removeEventListener(type, handler, false)
      } : function(element, type, handler) {
        element.detachEvent("on" + type, handler)
      }), stopPropagation: function(e) {
        var event = e || window.event;
        if (event.stopPropagation) {
          event.stopPropagation()
        }
        else {
          event.cancelBubble = true
        }
      }, stop: function(e) {
        var event = e || window.event;
        if (event.preventDefault) {
          event.preventDefault()
        }
        if (event.stopImmediatePropagation) {
          event.stopImmediatePropagation()
        }
        if (event.stopPropagation) {
          event.stopPropagation()
        }
        if (event.stop) {
          event.stop()
        }
        event.cancelBubble = true;
        event.returnValue = false
      }
  };
  this.Dialogs = {_dialogs: []};
  this.Dialogs.create = function(id, buttons, opts) {
    if (!id || !Ifm.Type.isString(id)) {
      throw new Error("Dialogs.create() -> Invalid dialog object id: " + id);
    }
    if (Ifm.Dom.Dialogs._dialogs[id]) {
      throw new Error("Dialogs.create() -> Dialog already created:" + id);
    }
    var dialog = document.getElementById(id);
    if (!dialog) {
      throw new Error("Dialogs.create() -> Dialog definition object not found in DOM: " + id);
    }
    dialog.parentNode.removeChild(dialog);
    if (buttons && !Ifm.Type.isArray(buttons)) {
      throw new Error("Dialogs.create() -> Invalid buttons array:" + buttons);
    }
    Ifm.Dom.Dialogs._dialogs[id] = {
      instance: dialog, buttons: buttons || null, options: {
          modal: (opts || {}).hasOwnProperty("modal") ? opts.modal : true, title: (opts || {}).hasOwnProperty("title") ? opts.title : ""
        }, arguments: null, result: undefined
    }
  };
  this.Dialogs.show = function(id, title, beforeShow, onHide) {
    if (!id || !Ifm.Type.isString(id)) {
      throw new Error("Dialogs.show() -> Invalid dialog object id: " + id);
    }
    var ref = Ifm.Dom.Dialogs._dialogs[id];
    if (!ref) {
      throw new Error("Dialogs.show() -> Dialog not created: " + id);
    }
    if (beforeShow && (!Ifm.Type.isFunction(beforeShow))) {
      throw new Error("Dialogs.show() -> Invalid handler: beforeShow");
    }
    if (onHide && (!Ifm.Type.isFunction(onHide))) {
      throw new Error("Dialogs.show() -> Invalid handler: onHide");
    }
    if (!ref.shown) {
      ref.shown = true;
      ref.onhide = onHide || null;
      var dialog = ref.instance.cloneNode(true);
      var buttons = ref.buttons;
      if (ref.options.modal) {
        Ifm.Dom.Fader.show()
      }
      var dialogContainer = document.createElement("div");
      dialogContainer.className = "dialog";
      dialogContainer.style.zIndex = "1100";
      dialogContainer.innerHTML = '' + '<div class="dialog-title">' + (title || ref.options.title || '') + '</div>' + '<div class="dialog-body"></div>' + '<div class="dialog-buttons"></div>';
      if (!buttons || buttons.length === 0) {
        dialogContainer.innerHTML += '<div class="dialog-close"><button class="dialog-close-button" onclick="Ifm.Dom.Dialogs.hide(&apos;' + id + '&apos;, 0);">r</button></div>'
      }
      document.body.appendChild(dialogContainer);
      ref.container = dialogContainer;
      dialogContainer.children[1].appendChild(dialog);
      if (buttons) {
        for (var i = 0; i < buttons.length; i++) {
          var button = document.createElement("button");
          var code = "Ifm.Dom.Dialogs._dialogs['" + id + "'].result = (function() { " + buttons[i].click + " })(); Ifm.Dom.Dialogs.hide('" + id + "', " + (i + 1) + ");";
          button.onclick = new Function(code);
          button.innerHTML = buttons[i].text;
          button.style.cssText = buttons[i].cssText;
          dialogContainer.children[2].appendChild(button)
        }
      }
      if (beforeShow) {
        beforeShow()
      }
      Ifm.Dom.Strings.replaceAll('%%')
    }
  };
  this.Dialogs.hide = function(id, buttonindex) {
    if (!id || !Ifm.Type.isString(id)) {
      throw new Error("Dialogs.hide() -> Invalid dialog object id: " + id);
    }
    var ref = Ifm.Dom.Dialogs._dialogs[id];
    if (!ref) {
      throw new Error("Dialogs.hide() -> Dialog not created: " + id);
    }
    if (ref.shown) {
      if (ref.onhide) {
        ref.onhide(buttonindex)
      }
      ref.shown = false;
      var dialogContainer = ref.container;
      dialogContainer.style.opacity = "0";
      setTimeout(function() {
        document.body.removeChild(dialogContainer)
      }, 200);
      if (ref.options.modal) {
        Ifm.Dom.Fader.hide()
      }
    }
  };
  this.Cards = (function() {
    var cards = {};
    return {
        show: function(html, id, dialog, fade, level, title, options = {}) {
          if (!id)
            id = "card" + (+new Date).toString(16);
          var card;
          if (cards[id]) {
            card = cards[id].element
          }
          else {
            card = document.createElement("div");
            cards[id] = {
              element: card, fade: !!fade
            };
            card.close = Ifm.Dom.Cards.close.bind(null, id);
            card.shake = Ifm.Dom.Cards.shake.bind(null, id);
            card.onclosed = null;
            if (fade)
              Ifm.Dom.Fader.show();
            card.style.zIndex = "1100";
            document.body.appendChild(card);
            card.className = "dialog level-" + (level && /^[12345]$/.test(level) ? level : "1");
            if (!dialog)
              setTimeout(() =>  {
                  var fader = document.getElementById("ifmjs_sys_fader") || document;
                  var oldfunc = fader.onclick;
                  fader.onclick = function(e) {
                    fader.onclick = oldfunc;
                    Ifm.Dom.Events.stop(e);
                    Ifm.Dom.Cards.close(id)
                  };
                  card.onclick = fader.onclick
                }, 20)
          }
          if (html)
            card.innerHTML = html;
          return card
        }, showDialog: function(html, id, title, buttons, options = {}, onload) {
            var htmlDialog = Ifm.Dom.Cards._createDialogBody(html, title);
            var dialog = Ifm.Dom.Cards.show(htmlDialog, id, true, true);
            Ifm.Dom.Cards._createDialogButtons(dialog, dialog, buttons);
            if (Ifm.Type.isFunction(onload)) {
              onload(dialog, dialog)
            }
          }, shake: function(id) {
            if (!cards[id])
              return;
            var card = cards[id].element,
              styleLeft = card.style.left,
              styleRight = card.style.right,
              curLeft = card.offsetLeft;
            var f = function(i) {
                var shakeX = 10 * ((i % 3) - 1);
                card.style.left = curLeft + shakeX + "px";
                card.style.right = curLeft - shakeX + "px";
                if (--i > 0) {
                  setTimeout(f, 20, i)
                }
                else {
                  card.style.left = styleLeft;
                  card.style.right = styleRight
                }
              };
            f(16)
          }, close: function(id) {
            if (!cards[id])
              return;
            var card = cards[id].element;
            document.body.removeChild(card);
            if (cards[id].fade)
              Ifm.Dom.Fader.hide();
            if (Ifm.Type.isFunction(card.onclosed))
              card.onclosed(card);
            delete cards[id];
            return card
          }, get: function(id) {
            return cards[id] || null
          }, getBody: function(id) {
            return cards[id] || null
          }, isShown: function(id) {
            return cards[id] ? true : false
          }, _createDialogBody: function(html, title) {
            var htmlDialog = `
                    <div class="dialog-title">${title}</div>
                    <div class="dialog-body">${html}</div>
                    <div class="dialog-buttons"></div>
                `;
            return htmlDialog
          }, _createDialogButtons: function(dialog, dialogBody, buttons) {
            if (dialogBody && buttons && buttons.length) {
              const buttonContainer = dialogBody.lastElementChild;
              for (var i = 0; i < buttons.length; i++) {
                var btn = document.createElement("button");
                btn.innerHTML = buttons[i].text || "[Button" + (i + 1) + "]";
                btn.style.cssText = buttons[i].cssText;
                btn.onclick = (function(fn) {
                  if (Ifm.Type.isFunction(fn)) {
                    return function() {
                        buttonContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);
                        var result = false;
                        try {
                          result = fn(dialog, dialogBody);
                          if (result instanceof Promise) {
                            result.then(function(resolved) {
                              if (resolved !== false) {
                                dialog.close()
                              }
                            });
                            result.catch(function(err) {
                              console.warn('[Ifm.Dom.Cards] Error executing button action', err);
                              dialog.shake()
                            });
                            result.finally(function() {
                              buttonContainer.querySelectorAll('button').forEach(btn => btn.disabled = false)
                            });
                            return false
                          }
                        }
                        catch(err) {
                          console.warn('[Ifm.Dom.Cards] Error executing button action', err);
                          dialog.shake()
                        }
                        buttonContainer.querySelectorAll('button').forEach(btn => btn.disabled = false);
                        if (result !== false) {
                          dialog.close()
                        }
                      }
                  }
                  else {
                    return function() {
                        dialog.close()
                      }
                  }
                })(buttons[i].click);
                buttonContainer.appendChild(btn)
              }
            }
          }
      }
  })();
  this.Band = {_bands: []};
  this.Band.show = function(html) {
    Ifm.Dom.Fader.show();
    var band = document.createElement("div");
    band.className = "band";
    band.style.position = "absolute";
    band.style.top = "50%";
    band.style.marginTop = "-80px";
    band.style.minHeight = "160px";
    band.style.left = "0px";
    band.style.width = "100%";
    band.style.backgroundColor = "#0066CC";
    band.style.color = "white";
    band.style.overflow = "hidden";
    band.style.zIndex = "1200";
    var fader = document.getElementById("ifmjs_sys_fader") || document;
    var oldfunc = fader.onclick;
    fader.onclick = function(e) {
      fader.onclick = oldfunc;
      Ifm.Dom.Events.stop(e);
      Ifm.Dom.Band.hide()
    };
    band.onclick = fader.onclick;
    band.innerHTML = html;
    document.body.appendChild(band);
    Ifm.Dom.Band._bands.push(band);
    if (Ifm.Dom.Band._bands.length > 1) {
      Ifm.Dom.Band._bands[Ifm.Dom.Band._bands.length - 2].style.display = "none"
    }
    return band
  };
  this.Band.hide = function() {
    if (Ifm.Dom.Band._bands.length > 0) {
      var band = Ifm.Dom.Band._bands.pop(band);
      document.body.removeChild(band);
      Ifm.Dom.Fader.hide()
    }
    if (Ifm.Dom.Band._bands.length > 0) {
      Ifm.Dom.Band._bands[Ifm.Dom.Band._bands.length - 1].style.display = ''
    }
    return band
  };
  this.Fader = {_faders: 0};
  this.Fader.show = function() {
    Ifm.Dom.Fader._faders++;
    if (Ifm.Dom.Fader._faders === 1) {
      var fader = document.getElementById("ifmjs_sys_fader");
      if (!fader) {
        fader = document.createElement("div");
        fader.id = "ifmjs_sys_fader";
        fader.style.backgroundColor = "#003366";
        fader.style.opacity = "0.50";
        fader.style.position = "absolute";
        fader.style.left = "0";
        fader.style.top = "0";
        fader.style.width = "100%";
        fader.style.height = "100%";
        fader.style.zIndex = "1000";
        var pageLayout = document.getElementById("page-layout");
        if (pageLayout) {
          pageLayout.className += " fade-effect"
        }
      }
      document.body.appendChild(fader)
    }
    return Ifm.Dom.Fader._faders > 0
  };
  this.Fader.hide = function() {
    Ifm.Dom.Fader._faders--;
    if (Ifm.Dom.Fader._faders === 0) {
      var fader = document.getElementById("ifmjs_sys_fader");
      if (fader) {
        document.body.removeChild(fader);
        var pageLayout = document.getElementById("page-layout");
        if (pageLayout) {
          pageLayout.className = pageLayout.className.replace(" fade-effect", "")
        }
      }
    }
    return Ifm.Dom.Fader._faders <= 0
  };
  this.Menu = function() {
    if (!(this instanceof Ifm.Dom.Menu))
      throw Ifm.Diagnostics.Errors.ctor();
    var menuClassId = "ifmjs_menu";
    return {
        constructor: Ifm.Dom.Menu, choose: function(items, callback) {
            if (!Ifm.Type.isArray(items))
              throw Ifm.Diagnostics.Errors.arg("items");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.arg("callback");
            var options = '';
            for (var i = 0, item; i < items.length, item = items[i]; i++) {
              if (item.visible !== false) {
                if (item.label !== '-') {
                  options += '<option value="{0}" {2}>{1}</option>'.format(item.value, item.label, item.disabled ? "disabled" : "")
                }
                else {
                  options += '<option value="" disabled></option>'
                }
              }
            }
            var select = '<div class="menu"><select style="width:100%;" size="{0}">{1}</select></div>'.format(items.length === 1 ? 2 : items.length, options);
            var card = Ifm.Dom.Cards.show(select, menuClassId),
              sele = card.children[0].children[0];
            sele.onclick = function() {
              callback(this.value)
            };
            sele.onkeydown = function(e) {
              e = Ifm.Dom.Events.getEvent(e);
              if (e.which === 13) {
                Ifm.Dom.Cards.close(menuClassId);
                callback(this.value)
              }
              if (e.which === 27) {
                Ifm.Dom.Cards.close(menuClassId)
              }
            };
            sele.focus()
          }
      }
  };
  this.Strings = (function() {
    function parse(subchar, ref) {
      if (Ifm.Type.isString(ref.nodeValue) && ref.nodeValue.startsWith(subchar + '(') && ref.nodeValue.endsWith(')')) {
        try {
          ref.nodeValue = (Function('return ' + ref.nodeValue.slice(subchar.length + 1, -1)))()
        }
        catch(err) {}
      }
    }
    return {replaceAll: function(subchar) {
          if (!subchar)
            subchar = '%';
          Ifm.Dom.Walker.walk(document.body, function(node) {
            if ((node.nodeType === 1)) {
              for (var i = 0; i < node.attributes.length; i++) {
                parse(subchar, node.attributes[i])
              }
            }
            else if (node.nodeType === 3) {
              parse(subchar, node)
            }
          })
        }}
  })();
  this.Walker = {};
  this.Walker.walk = function walk(node, func) {
    func(node);
    node = node.firstChild;
    while (node) {
      walk(node, func);
      node = node.nextSibling
    }
  }
}).call(Ifm.Dom);
;
namespace("Ifm.Messaging").FPropertyList = function(pliststr) {
  if (!(this instanceof Ifm.Messaging.FPropertyList)) {
    throw Ifm.Diagnostics.Errors.ctor();
  }
  if (!pliststr || !Ifm.Type.isString(pliststr)) {
    throw Ifm.Diagnostics.Errors.arg("pliststr");
  }
  pliststr = pliststr.trim();
  var list = {},
    sort = [],
    match;
  var re = /{\s*([^\s{]*)\s*=\s*([^}]*)}/g;
  while (match = re.exec(pliststr)) {
    list[match[1]] = match[2];
    sort.push(match[1])
  }
  this.events = defineEvents("changed");
  this.originalString = pliststr;
  this.get = function(key) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    return list[key]
  };
  this.keys = function() {
    var properties = [];
    for (var p in list) {
      properties.push(p)
    }
    return properties
  };
  this.remove = function(key) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    if (list.hasOwnProperty(key)) {
      delete list[key];
      var len = sort.length;
      while (len--) {
        if (sort[len] === key) {
          sort.splice(len, 1);
          this.events.changed.raise(this, {
            key: key, value: undefined
          })
        }
      }
    }
  };
  this.set = function(key, value) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    if (value !== undefined) {
      if (!list.hasOwnProperty(key)) {
        sort.push(key)
      }
      if (list[key] !== value) {
        list[key] = value;
        this.events.changed.raise(this, {
          key: key, value: value
        })
      }
    }
  };
  this.toString = function() {
    var pliststr = "{";
    for (var i = 0; i < sort.length; i++) {
      pliststr += "{" + sort[i] + " = " + list[sort[i]] + "}"
    }
    return pliststr + "}"
  }
};
;
namespace("Ifm.Net").WebSocket = (function() {
  var factory = {};
  factory.ErrorReasons = {
    Failed: "Connection failed", Lost: "Connection lost", Refused: "Connection refused"
  };
  factory.MessageType = {
    BINARY: "Binary", OBJECT: "Object", TEXT: "Text"
  };
  factory.isSupported = function() {
    return (global && global.Ifm && global.WebSocket) ? true : false
  };
  factory.create = function(url, protocol) {
    if (!factory.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("WebSocket");
    }
    if (!Ifm.Type.isString(url)) {
      throw Ifm.Diagnostics.Errors.arg("url");
    }
    var instance = {};
    instance.events = defineEvents("connecting", "open", "closing", "closed", "error", "receive");
    instance.id = (function() {
      return id += 1
    })();
    instance.connect = function() {
      if (ws && ws.readyState < WebSocket.CLOSING) {
        return
      }
      instance.events.connecting.raise(instance, {});
      try {
        if (protocol) {
          ws = new WebSocket(url, protocol)
        }
        else {
          ws = new WebSocket(url)
        }
      }
      catch(err) {
        instance.events.error.raise(instance, {error: err});
        instance.events.closed.raise(instance, {
          clean: false, reason: Ifm.Net.WebSocket.ErrorReasons.Failed
        });
        return
      }
      function open() {
        if (!wasOpen) {
          console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s", id, url, protocol, "onopen");
          wasOpen = true;
          instance.events.open.raise(instance, {})
        }
      }
      ;
      ws.onmessage = function(e) {
        if (Ifm.Type.isString(e.data)) {
          var s = e.data;
          if (s.startsWith("#close")) {
            var parts = s.split("|"),
              code = parts.length > 1 ? parts[1] : "0",
              reason = code + getCloseReason(code);
            console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s (%s)", id, url, protocol, "close notification", reason);
            return
          }
          open();
          if (s.startsWith("{") && s.endsWith("}")) {
            var o = null;
            try {
              o = JSON.parse(s)
            }
            catch(err) {}
            ;
            if (o !== null) {
              instance.events.receive.raise(instance, {
                type: factory.MessageType.OBJECT, message: o
              });
              return
            }
          }
          instance.events.receive.raise(instance, {
            type: factory.MessageType.TEXT, message: s
          })
        }
        else {
          open();
          instance.events.receive.raise(instance, {
            type: factory.MessageType.BINARY, message: e.data
          })
        }
      };
      ws.onclose = function(e) {
        console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s (code: %d)", id, url, protocol, "onclose", e.code);
        instance.events.closed.raise(instance, {
          clean: e.wasClean, reason: (e.wasClean ? "" : (wasOpen ? Ifm.Net.WebSocket.ErrorReasons.Lost : Ifm.Net.WebSocket.ErrorReasons.Refused))
        });
        wasOpen = false;
        ws = null
      };
      ws.onerror = function(e) {
        instance.events.error.raise(instance, e)
      }
    };
    instance.close = function() {
      console.debug("[Ifm.Net.WebSocket] %d [%s|%s] %s", id, url, protocol, "close");
      if (!ws || ws.readyState === WebSocket.CLOSED) {
        return
      }
      instance.events.closing.raise(instance, {});
      ws.close()
    };
    instance.send = function(message) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        throw Ifm.Diagnostics.Errors.op("WebSocket not open");
      }
      ws.send(message)
    };
    Object.defineProperties(instance, {
      isOpen: {get: function() {
          return instance.state === WebSocket.OPEN
        }}, state: {get: function() {
            return ws ? ws.readyState : WebSocket.CLOSED
          }}
    });
    var ws = null;
    var wasOpen = false;
    return instance
  };
  function getCloseReason(code) {
    switch (code) {
      case"403":
        return ": no destination for protocol";
      case"500":
        return ": client-gateway protocol error";
      case"502":
        return ": gateway-server protocol error";
      case"503":
        return ": no destination reachable";
      default:
        return ""
    }
  }
  var id = 0;
  return factory
})();
;
namespace("Ifm.Net").Peer = (function() {
  var factory = {};
  factory.isSupported = function() {
    return (Ifm && Ifm.Net && Ifm.Net.WebSocket && Ifm.Net.WebSocket.isSupported()) ? true : false
  };
  factory.query = function(url, protocol, query, callback) {
    factory.create(url, protocol, function(peer) {
      if (peer) {
        peer.query(query, function(response) {
          callback(response);
          peer.close()
        })
      }
      else {
        callback(null)
      }
    })
  };
  factory.create = function(url, protocol, callback) {
    if (!factory.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("Peer");
    }
    if (!Ifm.Type.isFunction(callback)) {
      throw Ifm.Diagnostics.Errors.func("callback");
    }
    var instance = {};
    instance.query = function(query, callback) {
      if (!Ifm.Type.isString(query)) {
        throw Ifm.Diagnostics.Errors.arg("query");
      }
      if (!Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      resetEvents();
      ws.events.closed = function(ws, e) {
        resetEvents();
        callback(null)
      };
      ws.events.receive = function(ws, e) {
        resetEvents();
        callback(e)
      };
      if (ws.isOpen) {
        ws.send(query)
      }
      else {
        callback(null)
      }
    };
    instance.receive = function(callback) {
      if (!Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      resetEvents();
      ws.events.closed = function(ws, e) {
        callback(null)
      };
      ws.events.receive = function(ws, e) {
        callback(e)
      }
    };
    instance.send = function(message) {
      if (ws.isOpen) {
        ws.send(message)
      }
    };
    instance.close = function() {
      resetEvents();
      ws.close()
    };
    function resetEvents() {
      ws.events.closed.removeAllHandlers();
      ws.events.receive.removeAllHandlers()
    }
    var ws = Ifm.Net.WebSocket.create(url, protocol);
    ws.events.closed = function(ws, e) {
      resetEvents();
      callback(null)
    };
    ws.events.receive = function(ws, e) {
      resetEvents();
      if (e.type === Ifm.Net.WebSocket.MessageType.TEXT) {
        var parts = e.message.split("|");
        switch (parts[0]) {
          case"#ready":
            callback(instance);
            return;
          case"#close":
            console.warn(parts[1] || "Forcibly closed by server");
            ws.close();
            callback(null);
            return
        }
      }
      console.warn("[Ifm.Net.Services.Peer] Unexpected message from server", e.message);
      ws.close();
      callback(null)
    };
    ws.connect();
    return instance
  };
  return factory
})();
;
namespace("Ifm.Net.Services").FileTransfer = (function() {
  var factory = {};
  factory.ErrorReasons = {
    Unavailable: "Service unavailable", RequestRefused: "Request refused", InvalidToken: "Invalid token", FileCorrupted: "File corrupted", FileReadError: "File read error", SecurityError: "Security error: {err}"
  };
  factory.isSupported = function() {
    return global && global.Ifm && Ifm.Net.Peer && Ifm.Net.Peer.isSupported() && global.File && global.FileList && global.FileReader && global.Blob ? true : false
  };
  factory.create = function(url) {
    if (!factory.isSupported()) {
      throw Ifm.Diagnostics.Errors.notsup("FileTransfer");
    }
    var instance = {};
    instance.events = defineEvents("waiting", "started", "progress", "finished", "canceled", "error");
    instance.id = (function() {
      return id += 1
    })();
    instance.isSender = undefined;
    instance.enabled = function(callback) {
      if (!Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      Ifm.Net.Peer.query(url, protocol, "#enabled", function(e) {
        callback(e && e.message || false)
      })
    };
    instance.receive = function(token) {
      if (!Ifm.Type.isString(token)) {
        throw Ifm.Diagnostics.Errors.arg("token");
      }
      if (instance.isSender !== undefined) {
        throw Ifm.Diagnostics.Errors.op("FileTransfer instance already in use");
      }
      instance.isSender = false;
      var BIN = Ifm.Net.WebSocket.MessageType.BINARY;
      var OBJ = Ifm.Net.WebSocket.MessageType.OBJECT;
      var TXT = Ifm.Net.WebSocket.MessageType.TEXT;
      var errors = Ifm.Net.Services.FileTransfer.ErrorReasons;
      var blobs = [],
        name,
        size,
        type;
      var offset = 0;
      Ifm.Net.Peer.create(url, protocol, function(peer) {
        if (!peer) {
          instance.events.error.raise(instance, {reason: errors.Unavailable});
          return
        }
        instance.accept = function() {
          instance.accept = function(){};
          peer.send("#start")
        };
        instance.cancel = function() {
          instance.cancel = function(){};
          peer.send("#cancel");
          peer.close();
          instance.events.canceled.raise(instance, {})
        };
        peer.receive(function(e) {
          if (!e) {
            instance.events.error.raise(instance, {reason: errors.RequestRefused});
            return
          }
          if (e.type === TXT) {
            var parts = e.message.split("|");
            switch (parts[0]) {
              case"#invalidtoken":
                peer.close();
                instance.events.error.raise(instance, {reason: errors.InvalidToken});
                break;
              case"#cancel":
                instance.cancel();
                break;
              case"#paired":
                instance.events.waiting.raise(instance, {token: token});
                break;
              case"#info":
                name = parts[1];
                size = Number(parts[2]);
                type = parts[3];
                instance.events.started.raise(instance, {});
                break;
              case"#finished":
                instance.cancel = function(){};
                peer.close();
                var blob = new Blob(blobs, {type: type});
                if (blob.size !== size) {
                  instance.events.error.raise(instance, {reason: errors.FileCorrupted});
                  return
                }
                instance.events.finished.raise(instance, {
                  fileBlob: blob, openOrSaveFunc: function() {
                      if (Ifm.Type.isFunction(window.navigator.msSaveOrOpenBlob)) {
                        window.navigator.msSaveOrOpenBlob(blob, name)
                      }
                      else {
                        var a = document.createElement("a");
                        a.href = URL.createObjectURL(blob);
                        a.download = name;
                        a.target = "_blank";
                        a.style.cssText = "display:none!important;";
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a)
                      }
                      return false
                    }
                });
                break;
              default:
                console.warn("[Ifm.Net.Services.FileTransfer] %s Unexpected message: %s", "receive()", e.message);
                break
            }
          }
          else if (e.type === BIN) {
            blobs.push(e.message);
            instance.events.progress.raise(instance, {percentage: Math.ceil(blobs.length * chunkSize * 100 / size)})
          }
        });
        peer.send("#receive" + "|" + token)
      })
    };
    instance.transfer = function(file) {
      if (!(file instanceof File)) {
        throw Ifm.Diagnostics.Errors.arg("file");
      }
      if (instance.isSender !== undefined) {
        throw Ifm.Diagnostics.Errors.op("FileTransfer instance already in use");
      }
      instance.isSender = true;
      var BIN = Ifm.Net.WebSocket.MessageType.BINARY;
      var OBJ = Ifm.Net.WebSocket.MessageType.OBJECT;
      var TXT = Ifm.Net.WebSocket.MessageType.TEXT;
      var errors = Ifm.Net.Services.FileTransfer.ErrorReasons;
      var offset = 0,
        iscanceled = false;
      Ifm.Net.Peer.create(url, protocol, function(peer) {
        if (!peer) {
          instance.events.error.raise(instance, {reason: errors.Unavailable});
          return
        }
        instance.cancel = function() {
          instance.cancel = function(){};
          iscanceled = true;
          if (reader) {
            reader.onloadend = function(){};
            reader.onerror = function(){};
            reader.abort();
            reader = null
          }
          peer.send("#cancel");
          peer.close();
          instance.events.canceled.raise(instance, {})
        };
        var reader = new FileReader;
        reader.onloadend = function(e) {
          if (iscanceled)
            return;
          if (reader.readyState === FileReader.DONE) {
            peer.send(reader.result);
            offset += chunkSize;
            var end = offset + Math.min(chunkSize, file.size - offset);
            if (offset < file.size) {
              instance.events.progress.raise(instance, {percentage: Math.ceil(offset * 100 / file.size)});
              var blob = file.slice(offset, end);
              reader.readAsArrayBuffer(blob)
            }
            else {
              instance.cancel = function(){};
              peer.send("#finished");
              peer.close();
              instance.events.finished.raise(instance, {
                fileBlob: file, openOrSaveFunc: null
              })
            }
          }
        };
        reader.onerror = function(e) {
          peer.close();
          instance.events.error.raise(instance, {reason: errors.FileReadError})
        };
        peer.receive(function(e) {
          if (!e) {
            instance.events.error.raise(instance, {reason: errors.RequestRefused});
            return
          }
          if (e.type === TXT) {
            var parts = e.message.split("|");
            switch (parts[0]) {
              case"#denied":
                peer.close();
                instance.events.error.raise(instance, {reason: errors.SecurityError.replace("{err}", parts[1])});
                break;
              case"#cancel":
                instance.cancel();
                break;
              case"#token":
                instance.events.waiting.raise(instance, {token: parts[1]});
                break;
              case"#paired":
                break;
              case"#start":
                peer.send("#info" + "|" + file.name + "|" + file.size + "|" + file.type);
                instance.events.started.raise(instance, {});
                var blob = file.slice(offset, Math.min(chunkSize, file.size));
                reader.readAsArrayBuffer(blob);
                break;
              default:
                console.warn("[Ifm.Net.Services.FileTransfer] %s Unexpected message: %s", "transfer()", e.message);
                break
            }
          }
        });
        peer.send("#transfer" + "|" + file.name + "|" + file.size + "|" + file.type)
      })
    };
    instance.accept = function(){};
    instance.cancel = function(){};
    return instance
  };
  var protocol = "ift";
  var chunkSize = 32 * 1024;
  var id = 0;
  return factory
})();
;
/*!
 * BDP Strophe bundle 1.3.1-4672
 * Copyright (c) Base Digitale Platform. All rights reserved.
 */
;
(function(callback) {
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-base64', function() {
        return factory()
      })
    }
    else {
      root.Base64 = factory()
    }
  }(globalThis, function() {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var obj = {
        encode: function(input) {
          var output = "";
          var chr1,
            chr2,
            chr3;
          var enc1,
            enc2,
            enc3,
            enc4;
          var i = 0;
          do {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc2 = ((chr1 & 3) << 4);
              enc3 = enc4 = 64
            }
            else if (isNaN(chr3)) {
              enc4 = 64
            }
            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4)
          } while (i < input.length);
          return output
        }, decode: function(input) {
            var output = "";
            var chr1,
              chr2,
              chr3;
            var enc1,
              enc2,
              enc3,
              enc4;
            var i = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do {
              enc1 = keyStr.indexOf(input.charAt(i++));
              enc2 = keyStr.indexOf(input.charAt(i++));
              enc3 = keyStr.indexOf(input.charAt(i++));
              enc4 = keyStr.indexOf(input.charAt(i++));
              chr1 = (enc1 << 2) | (enc2 >> 4);
              chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
              chr3 = ((enc3 & 3) << 6) | enc4;
              output = output + String.fromCharCode(chr1);
              if (enc3 != 64) {
                output = output + String.fromCharCode(chr2)
              }
              if (enc4 != 64) {
                output = output + String.fromCharCode(chr3)
              }
            } while (i < input.length);
            return output
          }
      };
    return obj
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-sha1', function() {
        return factory()
      })
    }
    else {
      root.SHA1 = factory()
    }
  }(globalThis, function() {
    function core_sha1(x, len) {
      x[len >> 5] |= 0x80 << (24 - len % 32);
      x[((len + 64 >> 9) << 4) + 15] = len;
      var w = new Array(80);
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      var e = -1009589776;
      var i,
        j,
        t,
        olda,
        oldb,
        oldc,
        oldd,
        olde;
      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        olde = e;
        for (j = 0; j < 80; j++) {
          if (j < 16) {
            w[j] = x[i + j]
          }
          else {
            w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1)
          }
          t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
          e = d;
          d = c;
          c = rol(b, 30);
          b = a;
          a = t
        }
        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde)
      }
      return [a, b, c, d, e]
    }
    function sha1_ft(t, b, c, d) {
      if (t < 20) {
        return (b & c) | ((~b) & d)
      }
      if (t < 40) {
        return b ^ c ^ d
      }
      if (t < 60) {
        return (b & c) | (b & d) | (c & d)
      }
      return b ^ c ^ d
    }
    function sha1_kt(t) {
      return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 : (t < 60) ? -1894007588 : -899497514
    }
    function core_hmac_sha1(key, data) {
      var bkey = str2binb(key);
      if (bkey.length > 16) {
        bkey = core_sha1(bkey, key.length * 8)
      }
      var ipad = new Array(16),
        opad = new Array(16);
      for (var i = 0; i < 16; i++) {
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C
      }
      var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);
      return core_sha1(opad.concat(hash), 512 + 160)
    }
    function safe_add(x, y) {
      var lsw = (x & 0xFFFF) + (y & 0xFFFF);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return (msw << 16) | (lsw & 0xFFFF)
    }
    function rol(num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt))
    }
    function str2binb(str) {
      var bin = [];
      var mask = 255;
      for (var i = 0; i < str.length * 8; i += 8) {
        bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << (24 - i % 32)
      }
      return bin
    }
    function binb2str(bin) {
      var str = "";
      var mask = 255;
      for (var i = 0; i < bin.length * 32; i += 8) {
        str += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & mask)
      }
      return str
    }
    function binb2b64(binarray) {
      var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var str = "";
      var triplet,
        j;
      for (var i = 0; i < binarray.length * 4; i += 3) {
        triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) | (((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) | ((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
        for (j = 0; j < 4; j++) {
          if (i * 8 + j * 6 > binarray.length * 32) {
            str += "="
          }
          else {
            str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F)
          }
        }
      }
      return str
    }
    return {
        b64_hmac_sha1: function(key, data) {
          return binb2b64(core_hmac_sha1(key, data))
        }, b64_sha1: function(s) {
            return binb2b64(core_sha1(str2binb(s), s.length * 8))
          }, binb2str: binb2str, core_hmac_sha1: core_hmac_sha1, str_hmac_sha1: function(key, data) {
            return binb2str(core_hmac_sha1(key, data))
          }, str_sha1: function(s) {
            return binb2str(core_sha1(str2binb(s), s.length * 8))
          }
      }
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-md5', function() {
        return factory()
      })
    }
    else {
      root.MD5 = factory()
    }
  }(globalThis, function(b) {
    var safe_add = function(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF)
      };
    var bit_rol = function(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt))
      };
    var str2binl = function(str) {
        var bin = [];
        for (var i = 0; i < str.length * 8; i += 8) {
          bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << (i % 32)
        }
        return bin
      };
    var binl2str = function(bin) {
        var str = "";
        for (var i = 0; i < bin.length * 32; i += 8) {
          str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & 255)
        }
        return str
      };
    var binl2hex = function(binarray) {
        var hex_tab = "0123456789abcdef";
        var str = "";
        for (var i = 0; i < binarray.length * 4; i++) {
          str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 0xF) + hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 0xF)
        }
        return str
      };
    var md5_cmn = function(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
      };
    var md5_ff = function(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
      };
    var md5_gg = function(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
      };
    var md5_hh = function(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t)
      };
    var md5_ii = function(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
      };
    var core_md5 = function(x, len) {
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        var olda,
          oldb,
          oldc,
          oldd;
        for (var i = 0; i < x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;
          a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
          d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
          a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
          c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
          d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safe_add(a, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd)
        }
        return [a, b, c, d]
      };
    var obj = {
        hexdigest: function(s) {
          return binl2hex(core_md5(str2binl(s), s.length * 8))
        }, hash: function(s) {
            return binl2str(core_md5(str2binl(s), s.length * 8))
          }
      };
    return obj
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-utils', function() {
        return factory()
      })
    }
    else {
      root.stropheUtils = factory()
    }
  }(globalThis, function() {
    var utils = {
        utf16to8: function(str) {
          var i,
            c;
          var out = "";
          var len = str.length;
          for (i = 0; i < len; i++) {
            c = str.charCodeAt(i);
            if ((c >= 0x0000) && (c <= 0x007F)) {
              out += str.charAt(i)
            }
            else if (c > 0x07FF) {
              out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
              out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));
              out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F))
            }
            else {
              out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));
              out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F))
            }
          }
          return out
        }, addCookies: function(cookies) {
            var cookieName,
              cookieObj,
              isObj,
              cookieValue,
              expires,
              domain,
              path;
            for (cookieName in(cookies || {})) {
              expires = '';
              domain = '';
              path = '';
              cookieObj = cookies[cookieName];
              isObj = typeof cookieObj == "object";
              cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));
              if (isObj) {
                expires = cookieObj.expires ? ";expires=" + cookieObj.expires : '';
                domain = cookieObj.domain ? ";domain=" + cookieObj.domain : '';
                path = cookieObj.path ? ";path=" + cookieObj.path : ''
              }
              document.cookie = cookieName + '=' + cookieValue + expires + domain + path
            }
          }
      };
    return utils
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-polyfill', [], function() {
        return factory()
      })
    }
    else {
      return factory()
    }
  }(globalThis, function() {
    if (!Function.prototype.bind) {
      Function.prototype.bind = function(obj) {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        return function() {
            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)))
          }
      }
    }
    if (!Array.isArray) {
      Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]'
      }
    }
    if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function(elt) {
        var len = this.length;
        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) {
          from += len
        }
        for (; from < len; from++) {
          if (from in this && this[from] === elt) {
            return from
          }
        }
        return -1
      }
    }
  }));
  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
      var T,
        k;
      if (this === null) {
        throw new TypeError(' this is null or not defined');
      }
      var O = Object(this);
      var len = O.length >>> 0;
      if (typeof callback !== "function") {
        throw new TypeError(callback + ' is not a function');
      }
      if (arguments.length > 1) {
        T = thisArg
      }
      k = 0;
      while (k < len) {
        var kValue;
        if (k in O) {
          kValue = O[k];
          callback.call(T, kValue, k, O)
        }
        k++
      }
    }
  }
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-core', ['strophe-sha1', 'strophe-base64', 'strophe-md5', 'strophe-utils', "strophe-polyfill"], function() {
        return factory.apply(this, arguments)
      })
    }
    else {
      var o = factory(root.SHA1, root.Base64, root.MD5, root.stropheUtils);
      window.Strophe = o.Strophe;
      window.$build = o.$build;
      window.$iq = o.$iq;
      window.$msg = o.$msg;
      window.$pres = o.$pres;
      window.SHA1 = o.SHA1;
      window.Base64 = o.Base64;
      window.MD5 = o.MD5;
      window.b64_hmac_sha1 = o.SHA1.b64_hmac_sha1;
      window.b64_sha1 = o.SHA1.b64_sha1;
      window.str_hmac_sha1 = o.SHA1.str_hmac_sha1;
      window.str_sha1 = o.SHA1.str_sha1
    }
  }(globalThis, function(SHA1, Base64, MD5, utils) {
    var Strophe;
    function $build(name, attrs) {
      return new Strophe.Builder(name, attrs)
    }
    function $msg(attrs) {
      return new Strophe.Builder("message", attrs)
    }
    function $iq(attrs) {
      return new Strophe.Builder("iq", attrs)
    }
    function $pres(attrs) {
      return new Strophe.Builder("presence", attrs)
    }
    Strophe = {
      VERSION: "1.2.9", NS: {
          HTTPBIND: "http://jabber.org/protocol/httpbind", BOSH: "urn:xmpp:xbosh", CLIENT: "jabber:client", AUTH: "jabber:iq:auth", ROSTER: "jabber:iq:roster", PROFILE: "jabber:iq:profile", DISCO_INFO: "http://jabber.org/protocol/disco#info", DISCO_ITEMS: "http://jabber.org/protocol/disco#items", MUC: "http://jabber.org/protocol/muc", SASL: "urn:ietf:params:xml:ns:xmpp-sasl", STREAM: "http://etherx.jabber.org/streams", FRAMING: "urn:ietf:params:xml:ns:xmpp-framing", BIND: "urn:ietf:params:xml:ns:xmpp-bind", SESSION: "urn:ietf:params:xml:ns:xmpp-session", VERSION: "jabber:iq:version", STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas", XHTML_IM: "http://jabber.org/protocol/xhtml-im", XHTML: "http://www.w3.org/1999/xhtml"
        }, XHTML: {
          tags: ['a', 'blockquote', 'br', 'cite', 'em', 'img', 'li', 'ol', 'p', 'span', 'strong', 'ul', 'body'], attributes: {
              a: ['href'], blockquote: ['style'], br: [], cite: ['style'], em: [], img: ['src', 'alt', 'style', 'height', 'width'], li: ['style'], ol: ['style'], p: ['style'], span: ['style'], strong: [], ul: ['style'], body: []
            }, css: ['background-color', 'color', 'font-family', 'font-size', 'font-style', 'font-weight', 'margin-left', 'margin-right', 'text-align', 'text-decoration'], validTag: function(tag) {
              for (var i = 0; i < Strophe.XHTML.tags.length; i++) {
                if (tag == Strophe.XHTML.tags[i]) {
                  return true
                }
              }
              return false
            }, validAttribute: function(tag, attribute) {
              if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {
                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                  if (attribute == Strophe.XHTML.attributes[tag][i]) {
                    return true
                  }
                }
              }
              return false
            }, validCSS: function(style) {
              for (var i = 0; i < Strophe.XHTML.css.length; i++) {
                if (style == Strophe.XHTML.css[i]) {
                  return true
                }
              }
              return false
            }
        }, Status: {
          ERROR: 0, CONNECTING: 1, CONNFAIL: 2, AUTHENTICATING: 3, AUTHFAIL: 4, CONNECTED: 5, DISCONNECTED: 6, DISCONNECTING: 7, ATTACHED: 8, REDIRECT: 9, CONNTIMEOUT: 10
        }, LogLevel: {
          DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, FATAL: 4
        }, ElementType: {
          NORMAL: 1, TEXT: 3, CDATA: 4, FRAGMENT: 11
        }, TIMEOUT: 1.1, SECONDARY_TIMEOUT: 0.1, addNamespace: function(name, value) {
          Strophe.NS[name] = value
        }, forEachChild: function(elem, elemName, func) {
          var i,
            childNode;
          for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {
              func(childNode)
            }
          }
        }, isTagEqual: function(el, name) {
          return el.tagName == name
        }, _xmlGenerator: null, _makeGenerator: function() {
          var doc;
          if (document.implementation.createDocument === undefined || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'))
          }
          else {
            doc = document.implementation.createDocument('jabber:client', 'strophe', null)
          }
          return doc
        }, xmlGenerator: function() {
          if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator()
          }
          return Strophe._xmlGenerator
        }, _getIEXmlDom: function() {
          var doc = null;
          var docStrings = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];
          for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
              try {
                doc = new ActiveXObject(docStrings[d])
              }
              catch(e) {
                doc = null
              }
            }
            else {
              break
            }
          }
          return doc
        }, xmlElement: function(name) {
          if (!name) {
            return null
          }
          var node = Strophe.xmlGenerator().createElement(name);
          var a,
            i,
            k;
          for (a = 1; a < arguments.length; a++) {
            var arg = arguments[a];
            if (!arg) {
              continue
            }
            if (typeof(arg) == "string" || typeof(arg) == "number") {
              node.appendChild(Strophe.xmlTextNode(arg))
            }
            else if (typeof(arg) == "object" && typeof(arg.sort) == "function") {
              for (i = 0; i < arg.length; i++) {
                var attr = arg[i];
                if (typeof(attr) == "object" && typeof(attr.sort) == "function" && attr[1] !== undefined && attr[1] !== null) {
                  node.setAttribute(attr[0], attr[1])
                }
              }
            }
            else if (typeof(arg) == "object") {
              for (k in arg) {
                if (arg.hasOwnProperty(k)) {
                  if (arg[k] !== undefined && arg[k] !== null) {
                    node.setAttribute(k, arg[k])
                  }
                }
              }
            }
          }
          return node
        }, xmlescape: function(text) {
          text = text.replace(/\&/g, "&amp;");
          text = text.replace(/</g, "&lt;");
          text = text.replace(/>/g, "&gt;");
          text = text.replace(/'/g, "&apos;");
          text = text.replace(/"/g, "&quot;");
          return text
        }, xmlunescape: function(text) {
          text = text.replace(/\&amp;/g, "&");
          text = text.replace(/&lt;/g, "<");
          text = text.replace(/&gt;/g, ">");
          text = text.replace(/&apos;/g, "'");
          text = text.replace(/&quot;/g, "\"");
          return text
        }, xmlTextNode: function(text) {
          return Strophe.xmlGenerator().createTextNode(text)
        }, xmlHtmlNode: function(html) {
          var node;
          if (window.DOMParser) {
            var parser = new DOMParser;
            node = parser.parseFromString(html, "text/xml")
          }
          else {
            node = new ActiveXObject("Microsoft.XMLDOM");
            node.async = "false";
            node.loadXML(html)
          }
          return node
        }, getText: function(elem) {
          if (!elem) {
            return null
          }
          var str = "";
          if (elem.childNodes.length === 0 && elem.nodeType == Strophe.ElementType.TEXT) {
            str += elem.nodeValue
          }
          for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
              str += elem.childNodes[i].nodeValue
            }
          }
          return Strophe.xmlescape(str)
        }, copyElement: function(elem) {
          var i,
            el;
          if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);
            for (i = 0; i < elem.attributes.length; i++) {
              el.setAttribute(elem.attributes[i].nodeName, elem.attributes[i].value)
            }
            for (i = 0; i < elem.childNodes.length; i++) {
              el.appendChild(Strophe.copyElement(elem.childNodes[i]))
            }
          }
          else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue)
          }
          return el
        }, createHtml: function(elem) {
          var i,
            el,
            j,
            tag,
            attribute,
            value,
            css,
            cssAttrs,
            attr,
            cssName,
            cssValue;
          if (elem.nodeType == Strophe.ElementType.NORMAL) {
            tag = elem.nodeName.toLowerCase();
            if (Strophe.XHTML.validTag(tag)) {
              try {
                el = Strophe.xmlElement(tag);
                for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
                  attribute = Strophe.XHTML.attributes[tag][i];
                  value = elem.getAttribute(attribute);
                  if (typeof value == 'undefined' || value === null || value === '' || value === false || value === 0) {
                    continue
                  }
                  if (attribute == 'style' && typeof value == 'object') {
                    if (typeof value.cssText != 'undefined') {
                      value = value.cssText
                    }
                  }
                  if (attribute == 'style') {
                    css = [];
                    cssAttrs = value.split(';');
                    for (j = 0; j < cssAttrs.length; j++) {
                      attr = cssAttrs[j].split(':');
                      cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                      if (Strophe.XHTML.validCSS(cssName)) {
                        cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                        css.push(cssName + ': ' + cssValue)
                      }
                    }
                    if (css.length > 0) {
                      value = css.join('; ');
                      el.setAttribute(attribute, value)
                    }
                  }
                  else {
                    el.setAttribute(attribute, value)
                  }
                }
                for (i = 0; i < elem.childNodes.length; i++) {
                  el.appendChild(Strophe.createHtml(elem.childNodes[i]))
                }
              }
              catch(e) {
                el = Strophe.xmlTextNode('')
              }
            }
            else {
              el = Strophe.xmlGenerator().createDocumentFragment();
              for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.createHtml(elem.childNodes[i]))
              }
            }
          }
          else if (elem.nodeType == Strophe.ElementType.FRAGMENT) {
            el = Strophe.xmlGenerator().createDocumentFragment();
            for (i = 0; i < elem.childNodes.length; i++) {
              el.appendChild(Strophe.createHtml(elem.childNodes[i]))
            }
          }
          else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlTextNode(elem.nodeValue)
          }
          return el
        }, escapeNode: function(node) {
          if (typeof node !== "string") {
            return node
          }
          return node.replace(/^\s+|\s+$/g, '').replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
        }, unescapeNode: function(node) {
          if (typeof node !== "string") {
            return node
          }
          return node.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
        }, getNodeFromJid: function(jid) {
          if (jid.indexOf("@") < 0) {
            return null
          }
          return jid.split("@")[0]
        }, getDomainFromJid: function(jid) {
          var bare = Strophe.getBareJidFromJid(jid);
          if (bare.indexOf("@") < 0) {
            return bare
          }
          else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@')
          }
        }, getResourceFromJid: function(jid) {
          var s = jid.split("/");
          if (s.length < 2) {
            return null
          }
          s.splice(0, 1);
          return s.join('/')
        }, getBareJidFromJid: function(jid) {
          return jid ? jid.split("/")[0] : null
        }, _handleError: function(e) {
          if (typeof e.stack !== "undefined") {
            Strophe.fatal(e.stack)
          }
          if (e.sourceURL) {
            Strophe.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message)
          }
          else if (e.fileName) {
            Strophe.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message)
          }
          else {
            Strophe.fatal("error: " + e.message)
          }
        }, log: function(level, msg) {
          return
        }, debug: function(msg) {
          this.log(this.LogLevel.DEBUG, msg)
        }, info: function(msg) {
          this.log(this.LogLevel.INFO, msg)
        }, warn: function(msg) {
          this.log(this.LogLevel.WARN, msg)
        }, error: function(msg) {
          this.log(this.LogLevel.ERROR, msg)
        }, fatal: function(msg) {
          this.log(this.LogLevel.FATAL, msg)
        }, serialize: function(elem) {
          var result;
          if (!elem) {
            return null
          }
          if (typeof(elem.tree) === "function") {
            elem = elem.tree()
          }
          var nodeName = elem.nodeName;
          var i,
            child;
          if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname")
          }
          result = "<" + nodeName;
          for (i = 0; i < elem.attributes.length; i++) {
            if (elem.attributes[i].nodeName != "_realname") {
              result += " " + elem.attributes[i].nodeName + "='" + Strophe.xmlescape(elem.attributes[i].value) + "'"
            }
          }
          if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
              child = elem.childNodes[i];
              switch (child.nodeType) {
                case Strophe.ElementType.NORMAL:
                  result += Strophe.serialize(child);
                  break;
                case Strophe.ElementType.TEXT:
                  result += Strophe.xmlescape(child.nodeValue);
                  break;
                case Strophe.ElementType.CDATA:
                  result += "<![CDATA[" + child.nodeValue + "]]>"
              }
            }
            result += "</" + nodeName + ">"
          }
          else {
            result += "/>"
          }
          return result
        }, _requestId: 0, _connectionPlugins: {}, addConnectionPlugin: function(name, ptype) {
          Strophe._connectionPlugins[name] = ptype
        }
    };
    Strophe.Builder = function(name, attrs) {
      if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
          attrs.xmlns = Strophe.NS.CLIENT
        }
        else if (!attrs) {
          attrs = {xmlns: Strophe.NS.CLIENT}
        }
      }
      this.nodeTree = Strophe.xmlElement(name, attrs);
      this.node = this.nodeTree
    };
    Strophe.Builder.prototype = {
      tree: function() {
        return this.nodeTree
      }, toString: function() {
          return Strophe.serialize(this.nodeTree)
        }, up: function() {
          this.node = this.node.parentNode;
          return this
        }, root: function() {
          this.node = this.nodeTree;
          return this
        }, attrs: function(moreattrs) {
          for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
              if (moreattrs[k] === undefined) {
                this.node.removeAttribute(k)
              }
              else {
                this.node.setAttribute(k, moreattrs[k])
              }
            }
          }
          return this
        }, c: function(name, attrs, text) {
          var child = Strophe.xmlElement(name, attrs, text);
          this.node.appendChild(child);
          if (typeof text !== "string" && typeof text !== "number") {
            this.node = child
          }
          return this
        }, cnode: function(elem) {
          var impNode;
          var xmlGen = Strophe.xmlGenerator();
          try {
            impNode = (xmlGen.importNode !== undefined)
          }
          catch(e) {
            impNode = false
          }
          var newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);
          this.node.appendChild(newElem);
          this.node = newElem;
          return this
        }, t: function(text) {
          var child = Strophe.xmlTextNode(text);
          this.node.appendChild(child);
          return this
        }, h: function(html) {
          var fragment = document.createElement('body');
          fragment.innerHTML = html;
          var xhtml = Strophe.createHtml(fragment);
          while (xhtml.childNodes.length > 0) {
            this.node.appendChild(xhtml.childNodes[0])
          }
          return this
        }
    };
    Strophe.Handler = function(handler, ns, name, type, id, from, options) {
      this.handler = handler;
      this.ns = ns;
      this.name = name;
      this.type = type;
      this.id = id;
      this.options = options || {
        matchBareFromJid: false, ignoreNamespaceFragment: false
      };
      if (this.options.matchBare) {
        Strophe.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.');
        this.options.matchBareFromJid = this.options.matchBare;
        delete this.options.matchBare
      }
      if (this.options.matchBareFromJid) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null
      }
      else {
        this.from = from
      }
      this.user = true
    };
    Strophe.Handler.prototype = {
      getNamespace: function(elem) {
        var elNamespace = elem.getAttribute("xmlns");
        if (elNamespace && this.options.ignoreNamespaceFragment) {
          elNamespace = elNamespace.split('#')[0]
        }
        return elNamespace
      }, namespaceMatch: function(elem) {
          var nsMatch = false;
          if (!this.ns) {
            return true
          }
          else {
            var that = this;
            Strophe.forEachChild(elem, null, function(elem) {
              if (that.getNamespace(elem) === that.ns) {
                nsMatch = true
              }
            });
            nsMatch = nsMatch || this.getNamespace(elem) === this.ns
          }
          return nsMatch
        }, isMatch: function(elem) {
          var from = elem.getAttribute('from');
          if (this.options.matchBareFromJid) {
            from = Strophe.getBareJidFromJid(from)
          }
          var elem_type = elem.getAttribute("type");
          if (this.namespaceMatch(elem) && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) != -1 : elem_type == this.type)) && (!this.id || elem.getAttribute("id") == this.id) && (!this.from || from == this.from)) {
            return true
          }
          return false
        }, run: function(elem) {
          var result = null;
          try {
            result = this.handler(elem)
          }
          catch(e) {
            Strophe._handleError(e);
            throw e;
          }
          return result
        }, toString: function() {
          return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
        }
    };
    Strophe.TimedHandler = function(period, handler) {
      this.period = period;
      this.handler = handler;
      this.lastCalled = (new Date).getTime();
      this.user = true
    };
    Strophe.TimedHandler.prototype = {
      run: function() {
        this.lastCalled = (new Date).getTime();
        return this.handler()
      }, reset: function() {
          this.lastCalled = (new Date).getTime()
        }, toString: function() {
          return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
        }
    };
    Strophe.Connection = function(service, options) {
      this.service = service;
      this.options = options || {};
      var proto = this.options.protocol || "";
      if (service.indexOf("ws:") === 0 || service.indexOf("wss:") === 0 || proto.indexOf("ws") === 0) {
        this._proto = new Strophe.Websocket(this)
      }
      else {
        this._proto = new Strophe.Bosh(this)
      }
      this._timeProvider = Strophe.timeProvider || window;
      this.jid = "";
      this.domain = null;
      this.features = null;
      this._sasl_data = {};
      this.do_session = false;
      this.do_bind = false;
      this.timedHandlers = [];
      this.handlers = [];
      this.removeTimeds = [];
      this.removeHandlers = [];
      this.addTimeds = [];
      this.addHandlers = [];
      this.protocolErrorHandlers = {
        HTTP: {}, websocket: {}
      };
      this._idleTimeout = null;
      this._disconnectTimeout = null;
      this.authenticated = false;
      this.connected = false;
      this.disconnecting = false;
      this.do_authentication = true;
      this.paused = false;
      this.restored = false;
      this._data = [];
      this._uniqueId = 0;
      this._sasl_success_handler = null;
      this._sasl_failure_handler = null;
      this._sasl_challenge_handler = null;
      this.maxRetries = 5;
      this._idleTimeout = this._timeProvider.setTimeout(function() {
        this._onIdle()
      }.bind(this), 100);
      utils.addCookies(this.options.cookies);
      this.registerSASLMechanisms(this.options.mechanisms);
      for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
          var ptype = Strophe._connectionPlugins[k];
          var F = function(){};
          F.prototype = ptype;
          this[k] = new F;
          this[k].init(this)
        }
      }
    };
    Strophe.Connection.prototype = {
      reset: function() {
        if (!this.jid)
          return;
        this._proto._reset();
        this.do_session = false;
        this.do_bind = false;
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];
        this.authenticated = false;
        this.connected = false;
        this.disconnecting = false;
        this.restored = false;
        this._data = [];
        this._requests = [];
        this._uniqueId = 0
      }, pause: function() {
          this.paused = true
        }, resume: function() {
          this.paused = false
        }, getUniqueId: function(suffix) {
          var partid = Strophe.getNodeFromJid(this.jid),
            partri = (Math.floor(Math.random() * 0xF0000000) + 0x10000000).toString(16);
          if (typeof suffix == "string" || typeof suffix == "number") {
            return ++this._uniqueId + ":" + partid + "-" + partri + ":" + suffix
          }
          else {
            return ++this._uniqueId + ":" + partid + "-" + partri
          }
        }, addProtocolErrorHandler: function(protocol, status_code, callback) {
          this.protocolErrorHandlers[protocol][status_code] = callback
        }, connect: function(jid, pass, callback, wait, hold, route, authcid) {
          this.jid = jid;
          this.authzid = Strophe.getBareJidFromJid(this.jid);
          this.authcid = authcid || Strophe.getNodeFromJid(this.jid);
          this.pass = pass;
          this.servtype = "xmpp";
          this.connect_callback = callback;
          this.disconnecting = false;
          this.connected = false;
          this.authenticated = false;
          this.restored = false;
          this.domain = Strophe.getDomainFromJid(this.jid);
          this._changeConnectStatus(Strophe.Status.CONNECTING, null);
          this._proto._connect(wait, hold, route)
        }, attach: function(jid, sid, rid, callback, wait, hold, wind) {
          if (this._proto instanceof Strophe.Bosh) {
            this._proto._attach(jid, sid, rid, callback, wait, hold, wind)
          }
          else {
            throw{
              name: 'StropheSessionError', message: 'The "attach" method can only be used with a BOSH connection.'
            };
          }
        }, isRestoreSupported: function() {
          return this._sessionCachingSupported()
        }, isRestorable: function(jid, maxAge) {
          if (this._sessionCachingSupported()) {
            var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
            if (this._proto._isRestorable(session, jid)) {
              if (typeof maxAge === typeof undefined) {
                return true
              }
              else {
                return (typeof session.cts !== typeof undefined && (Date.now() - Number(session.cts)) < (maxAge * 1000))
              }
            }
          }
          return false
        }, restore: function(jid, callback, wait, hold, wind) {
          if (this._sessionCachingSupported()) {
            return this._proto._restore(jid, callback, wait, hold, wind)
          }
          else {
            throw{
              name: 'StropheSessionError', message: 'The "restore" method can only be used with a BOSH connection.'
            };
          }
        }, _sessionCachingSupported: function() {
          if (this._proto instanceof Strophe.Bosh) {
            if (!JSON) {
              return false
            }
            try {
              window.sessionStorage.setItem('_strophe_', '_strophe_');
              window.sessionStorage.removeItem('_strophe_')
            }
            catch(e) {
              return false
            }
            return true
          }
          return false
        }, xmlInput: function(elem) {
          return
        }, xmlOutput: function(elem) {
          return
        }, rawInput: function(data) {
          return
        }, rawOutput: function(data) {
          return
        }, nextValidRid: function(rid) {
          return
        }, send: function(elem) {
          if (elem === null) {
            return
          }
          if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
              this._queueData(elem[i])
            }
          }
          else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree())
          }
          else {
            this._queueData(elem)
          }
          this._proto._send()
        }, flush: function() {
          this._timeProvider.clearTimeout(this._idleTimeout);
          this._onIdle()
        }, sendIQ: function(elem, callback, errback, timeout) {
          var timeoutHandler = null;
          var that = this;
          if (typeof(elem.tree) === "function") {
            elem = elem.tree()
          }
          var id = elem.getAttribute('id');
          if (!id) {
            id = this.getUniqueId("sendIQ");
            elem.setAttribute("id", id)
          }
          var expectedFrom = elem.getAttribute("to");
          var fulljid = this.jid;
          var handler = this.addHandler(function(stanza) {
              if (timeoutHandler) {
                that.deleteTimedHandler(timeoutHandler)
              }
              var acceptable = false;
              var from = stanza.getAttribute("from");
              if (from === expectedFrom || (!expectedFrom && (from === Strophe.getBareJidFromJid(fulljid) || from === Strophe.getDomainFromJid(fulljid) || from === fulljid))) {
                acceptable = true
              }
              if (!acceptable) {
                throw{
                  name: "StropheError", message: "Got answer to IQ from wrong jid:" + from + "\nExpected jid: " + expectedFrom
                };
              }
              var iqtype = stanza.getAttribute('type');
              if (iqtype == 'result') {
                if (callback) {
                  callback(stanza)
                }
              }
              else if (iqtype == 'error') {
                if (errback) {
                  errback(stanza)
                }
              }
              else {
                throw{
                  name: "StropheError", message: "Got bad IQ type of " + iqtype
                };
              }
            }, null, 'iq', ['error', 'result'], id);
          if (timeout) {
            timeoutHandler = this.addTimedHandler(timeout, function() {
              that.deleteHandler(handler);
              if (errback) {
                errback(null)
              }
              return false
            })
          }
          this.send(elem);
          return id
        }, _queueData: function(element) {
          if (element === null || !element.tagName || !element.childNodes) {
            throw{
              name: "StropheError", message: "Cannot queue non-DOMElement."
            };
          }
          this._data.push(element)
        }, _sendRestart: function() {
          this._data.push("restart");
          this._proto._sendRestart();
          this._idleTimeout = this._timeProvider.setTimeout(function() {
            this._onIdle()
          }.bind(this), 100)
        }, addTimedHandler: function(period, handler) {
          var thand = new Strophe.TimedHandler(period, handler);
          this.addTimeds.push(thand);
          return thand
        }, deleteTimedHandler: function(handRef) {
          this.removeTimeds.push(handRef)
        }, addHandler: function(handler, ns, name, type, id, from, options) {
          var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
          this.addHandlers.push(hand);
          return hand
        }, deleteHandler: function(handRef) {
          this.removeHandlers.push(handRef);
          var i = this.addHandlers.indexOf(handRef);
          if (i >= 0) {
            this.addHandlers.splice(i, 1)
          }
        }, registerSASLMechanisms: function(mechanisms) {
          this.mechanisms = {};
          mechanisms = mechanisms || [Strophe.SASLAnonymous, Strophe.SASLExternal, Strophe.SASLMD5, Strophe.SASLOAuthBearer, Strophe.SASLPlain, Strophe.SASLSHA1];
          mechanisms.forEach(this.registerSASLMechanism.bind(this))
        }, registerSASLMechanism: function(mechanism) {
          this.mechanisms[mechanism.prototype.name] = mechanism
        }, disconnect: function(reason) {
          this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);
          Strophe.info("Disconnect was called because: " + reason);
          if (this.connected) {
            var pres = false;
            this.disconnecting = true;
            if (this.authenticated) {
              pres = $pres({
                xmlns: Strophe.NS.CLIENT, type: 'unavailable'
              })
            }
            this._disconnectTimeout = this._addSysTimedHandler(3000, this._onDisconnectTimeout.bind(this));
            this._proto._disconnect(pres)
          }
          else {
            Strophe.info("Disconnect was called before Strophe connected to the server");
            this._proto._abortAllRequests()
          }
        }, _changeConnectStatus: function(status, condition) {
          for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
              var plugin = this[k];
              if (plugin.statusChanged) {
                try {
                  plugin.statusChanged(status, condition)
                }
                catch(err) {
                  Strophe.error("" + k + " plugin caused an exception " + "changing status: " + err)
                }
              }
            }
          }
          if (this.connect_callback) {
            try {
              this.connect_callback(status, condition)
            }
            catch(e) {
              Strophe._handleError(e);
              Strophe.error("User connection callback caused an " + "exception: " + e)
            }
          }
        }, _doDisconnect: function(condition) {
          if (typeof this._idleTimeout == "number") {
            this._timeProvider.clearTimeout(this._idleTimeout)
          }
          if (this._disconnectTimeout !== null) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null
          }
          Strophe.debug("_doDisconnect was called");
          this._proto._doDisconnect();
          this.authenticated = false;
          this.disconnecting = false;
          this.restored = false;
          this.handlers = [];
          this.timedHandlers = [];
          this.removeTimeds = [];
          this.removeHandlers = [];
          this.addTimeds = [];
          this.addHandlers = [];
          this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);
          this.connected = false
        }, _dataRecv: function(req, raw) {
          var elem = this._proto._reqToData(req);
          if (elem === null) {
            return
          }
          if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {
              this.xmlInput(elem.childNodes[0])
            }
            else {
              this.xmlInput(elem)
            }
          }
          if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
              this.rawInput(raw)
            }
            else {
              this.rawInput(Strophe.serialize(elem))
            }
          }
          var i,
            hand;
          while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
              this.handlers.splice(i, 1)
            }
          }
          while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop())
          }
          if (this.disconnecting && this._proto._emptyQueue()) {
            this._doDisconnect();
            return
          }
          var type = elem.getAttribute("type");
          var cond,
            conflict;
          if (type !== null && type == "terminate") {
            if (this.disconnecting) {
              return
            }
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
              if (cond == "remote-stream-error" && conflict.length > 0) {
                cond = "conflict"
              }
              this._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
            }
            else {
              this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
            }
            this._doDisconnect(cond);
            return
          }
          var that = this;
          Strophe.forEachChild(elem, null, function(child) {
            var i,
              newList;
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
              var hand = newList[i];
              try {
                if (hand.isMatch(child) && (that.authenticated || !hand.user)) {
                  if (hand.run(child)) {
                    that.handlers.push(hand)
                  }
                }
                else {
                  that.handlers.push(hand)
                }
              }
              catch(e) {
                Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message)
              }
            }
          })
        }, mechanisms: {}, _connect_cb: function(req, _callback, raw) {
          Strophe.debug("_connect_cb was called");
          this.connected = true;
          var bodyWrap;
          try {
            bodyWrap = this._proto._reqToData(req)
          }
          catch(e) {
            if (e != "badformat") {
              throw e;
            }
            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');
            this._doDisconnect('bad-format')
          }
          if (!bodyWrap) {
            return
          }
          if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {
              this.xmlInput(bodyWrap.childNodes[0])
            }
            else {
              this.xmlInput(bodyWrap)
            }
          }
          if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            if (raw) {
              this.rawInput(raw)
            }
            else {
              this.rawInput(Strophe.serialize(bodyWrap))
            }
          }
          var conncheck = this._proto._connect_cb(bodyWrap);
          if (conncheck === Strophe.Status.CONNFAIL) {
            return
          }
          var hasFeatures;
          if (bodyWrap.getElementsByTagNameNS) {
            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "features").length > 0
          }
          else {
            hasFeatures = bodyWrap.getElementsByTagName("stream:features").length > 0 || bodyWrap.getElementsByTagName("features").length > 0
          }
          if (!hasFeatures) {
            this._proto._no_auth_received(_callback);
            return
          }
          var matched = [],
            i,
            mech;
          var mechanisms = bodyWrap.getElementsByTagName("mechanism");
          if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
              mech = Strophe.getText(mechanisms[i]);
              if (this.mechanisms[mech])
                matched.push(this.mechanisms[mech])
            }
          }
          if (matched.length === 0) {
            if (bodyWrap.getElementsByTagName("auth").length === 0) {
              this._proto._no_auth_received(_callback);
              return
            }
          }
          if (this.do_authentication !== false) {
            this.authenticate(matched)
          }
        }, sortMechanismsByPriority: function(mechanisms) {
          var i,
            j,
            higher,
            swap;
          for (i = 0; i < mechanisms.length - 1; ++i) {
            higher = i;
            for (j = i + 1; j < mechanisms.length; ++j) {
              if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {
                higher = j
              }
            }
            if (higher != i) {
              swap = mechanisms[i];
              mechanisms[i] = mechanisms[higher];
              mechanisms[higher] = swap
            }
          }
          return mechanisms
        }, _attemptSASLAuth: function(mechanisms) {
          mechanisms = this.sortMechanismsByPriority(mechanisms || []);
          var i = 0,
            mechanism_found = false;
          for (i = 0; i < mechanisms.length; ++i) {
            if (!mechanisms[i].prototype.test(this)) {
              continue
            }
            this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null);
            this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null);
            this._sasl_mechanism = new mechanisms[i];
            this._sasl_mechanism.onStart(this);
            var request_auth_exchange = $build("auth", {
                xmlns: Strophe.NS.SASL, mechanism: this._sasl_mechanism.name
              });
            if (this._sasl_mechanism.isClientFirst) {
              var response = this._sasl_mechanism.onChallenge(this, null);
              request_auth_exchange.t(Base64.encode(response))
            }
            this.send(request_auth_exchange.tree());
            mechanism_found = true;
            break
          }
          return mechanism_found
        }, _attemptLegacyAuth: function() {
          if (Strophe.getNodeFromJid(this.jid) === null) {
            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'x-strophe-bad-non-anon-jid');
            this.disconnect('x-strophe-bad-non-anon-jid')
          }
          else {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(this._auth1_cb.bind(this), null, null, null, "_auth_1");
            this.send($iq({
              type: "get", to: this.domain, id: "_auth_1"
            }).c("query", {xmlns: Strophe.NS.AUTH}).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree())
          }
        }, authenticate: function(matched) {
          if (!this._attemptSASLAuth(matched)) {
            this._attemptLegacyAuth()
          }
        }, _sasl_challenge_cb: function(elem) {
          var challenge = Base64.decode(Strophe.getText(elem));
          var response = this._sasl_mechanism.onChallenge(this, challenge);
          var stanza = $build('response', {xmlns: Strophe.NS.SASL});
          if (response !== "") {
            stanza.t(Base64.encode(response))
          }
          this.send(stanza.tree());
          return true
        }, _auth1_cb: function(elem) {
          var iq = $iq({
              type: "set", id: "_auth_2"
            }).c('query', {xmlns: Strophe.NS.AUTH}).c('username', {}).t(Strophe.getNodeFromJid(this.jid)).up().c('password').t(this.pass);
          if (!Strophe.getResourceFromJid(this.jid)) {
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe'
          }
          iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));
          this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2");
          this.send(iq.tree());
          return false
        }, _sasl_success_cb: function(elem) {
          if (this._sasl_data["server-signature"]) {
            var serverSignature;
            var success = Base64.decode(Strophe.getText(elem));
            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
            var matches = success.match(attribMatch);
            if (matches[1] == "v") {
              serverSignature = matches[2]
            }
            if (serverSignature != this._sasl_data["server-signature"]) {
              this.deleteHandler(this._sasl_failure_handler);
              this._sasl_failure_handler = null;
              if (this._sasl_challenge_handler) {
                this.deleteHandler(this._sasl_challenge_handler);
                this._sasl_challenge_handler = null
              }
              this._sasl_data = {};
              return this._sasl_failure_cb(null)
            }
          }
          Strophe.info("SASL authentication succeeded.");
          if (this._sasl_mechanism) {
            this._sasl_mechanism.onSuccess()
          }
          this.deleteHandler(this._sasl_failure_handler);
          this._sasl_failure_handler = null;
          if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null
          }
          var streamfeature_handlers = [];
          var wrapper = function(handlers, elem) {
              while (handlers.length) {
                this.deleteHandler(handlers.pop())
              }
              this._sasl_auth1_cb.bind(this)(elem);
              return false
            };
          streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem)
          }.bind(this), null, "stream:features", null, null));
          streamfeature_handlers.push(this._addSysHandler(function(elem) {
            wrapper.bind(this)(streamfeature_handlers, elem)
          }.bind(this), Strophe.NS.STREAM, "features", null, null));
          this._sendRestart();
          return false
        }, _sasl_auth1_cb: function(elem) {
          this.features = elem;
          var i,
            child;
          for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
              this.do_bind = true
            }
            if (child.nodeName == 'session') {
              this.do_session = true
            }
          }
          if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
          }
          else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, "_bind_auth_2");
            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
              this.send($iq({
                type: "set", id: "_bind_auth_2"
              }).c('bind', {xmlns: Strophe.NS.BIND}).c('resource', {}).t(resource).tree())
            }
            else {
              this.send($iq({
                type: "set", id: "_bind_auth_2"
              }).c('bind', {xmlns: Strophe.NS.BIND}).tree())
            }
          }
          return false
        }, _sasl_bind_cb: function(elem) {
          if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            var conflict = elem.getElementsByTagName("conflict"),
              condition;
            if (conflict.length > 0) {
              condition = 'conflict'
            }
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);
            return false
          }
          var bind = elem.getElementsByTagName("bind");
          var jidNode;
          if (bind.length > 0) {
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
              this.jid = Strophe.getText(jidNode[0]);
              if (this.do_session) {
                this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, "_session_auth_2");
                this.send($iq({
                  type: "set", id: "_session_auth_2"
                }).c('session', {xmlns: Strophe.NS.SESSION}).tree())
              }
              else {
                this.authenticated = true;
                this._changeConnectStatus(Strophe.Status.CONNECTED, null)
              }
            }
          }
          else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
          }
        }, _sasl_session_cb: function(elem) {
          if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null)
          }
          else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false
          }
          return false
        }, _sasl_failure_cb: function(elem) {
          if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null
          }
          if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null
          }
          if (this._sasl_mechanism)
            this._sasl_mechanism.onFailure();
          this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
          return false
        }, _auth2_cb: function(elem) {
          if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null)
          }
          else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect('authentication failed')
          }
          return false
        }, _addSysTimedHandler: function(period, handler) {
          var thand = new Strophe.TimedHandler(period, handler);
          thand.user = false;
          this.addTimeds.push(thand);
          return thand
        }, _addSysHandler: function(handler, ns, name, type, id) {
          var hand = new Strophe.Handler(handler, ns, name, type, id);
          hand.user = false;
          this.addHandlers.push(hand);
          return hand
        }, _onDisconnectTimeout: function() {
          Strophe.info("_onDisconnectTimeout was called");
          this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);
          this._proto._onDisconnectTimeout();
          this._doDisconnect();
          return false
        }, _onIdle: function() {
          var i,
            thand,
            since,
            newList;
          while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop())
          }
          while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
              this.timedHandlers.splice(i, 1)
            }
          }
          var now = (new Date).getTime();
          newList = [];
          for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
              since = thand.lastCalled + thand.period;
              if (since - now <= 0) {
                if (thand.run()) {
                  newList.push(thand)
                }
              }
              else {
                newList.push(thand)
              }
            }
          }
          this.timedHandlers = newList;
          this._timeProvider.clearTimeout(this._idleTimeout);
          this._proto._onIdle();
          if (this.connected) {
            this._idleTimeout = this._timeProvider.setTimeout(function() {
              this._onIdle()
            }.bind(this), 100)
          }
        }
    };
    Strophe.SASLMechanism = function(name, isClientFirst, priority) {
      this.name = name;
      this.isClientFirst = isClientFirst;
      this.priority = priority
    };
    Strophe.SASLMechanism.prototype = {
      test: function(connection) {
        return true
      }, onStart: function(connection) {
          this._connection = connection
        }, onChallenge: function(connection, challenge) {
          throw new Error("You should implement challenge handling!");
        }, onFailure: function() {
          this._connection = null
        }, onSuccess: function() {
          this._connection = null
        }
    };
    Strophe.SASLAnonymous = function(){};
    Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism("ANONYMOUS", false, 10);
    Strophe.SASLAnonymous.prototype.test = function(connection) {
      return connection.authcid === null
    };
    Strophe.SASLPlain = function(){};
    Strophe.SASLPlain.prototype = new Strophe.SASLMechanism("PLAIN", true, 20);
    Strophe.SASLPlain.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLPlain.prototype.onChallenge = function(connection) {
      var auth_str = connection.authzid;
      auth_str = auth_str + "\u0000";
      auth_str = auth_str + connection.authcid;
      auth_str = auth_str + "\u0000";
      auth_str = auth_str + connection.pass;
      return utils.utf16to8(auth_str)
    };
    Strophe.SASLSHA1 = function(){};
    Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism("SCRAM-SHA-1", true, 40);
    Strophe.SASLSHA1.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {
      var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);
      var auth_str = "n=" + utils.utf16to8(connection.authcid);
      auth_str += ",r=";
      auth_str += cnonce;
      connection._sasl_data.cnonce = cnonce;
      connection._sasl_data["client-first-message-bare"] = auth_str;
      auth_str = "n,," + auth_str;
      this.onChallenge = function(connection, challenge) {
        var nonce,
          salt,
          iter,
          Hi,
          U,
          U_old,
          i,
          k,
          pass;
        var clientKey,
          serverKey,
          clientSignature;
        var responseText = "c=biws,";
        var authMessage = connection._sasl_data["client-first-message-bare"] + "," + challenge + ",";
        var cnonce = connection._sasl_data.cnonce;
        var attribMatch = /([a-z]+)=([^,]+)(,|$)/;
        while (challenge.match(attribMatch)) {
          var matches = challenge.match(attribMatch);
          challenge = challenge.replace(matches[0], "");
          switch (matches[1]) {
            case"r":
              nonce = matches[2];
              break;
            case"s":
              salt = matches[2];
              break;
            case"i":
              iter = matches[2];
              break
          }
        }
        if (nonce.substr(0, cnonce.length) !== cnonce) {
          connection._sasl_data = {};
          return connection._sasl_failure_cb()
        }
        responseText += "r=" + nonce;
        authMessage += responseText;
        salt = Base64.decode(salt);
        salt += "\x00\x00\x00\x01";
        pass = utils.utf16to8(connection.pass);
        Hi = U_old = SHA1.core_hmac_sha1(pass, salt);
        for (i = 1; i < iter; i++) {
          U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));
          for (k = 0; k < 5; k++) {
            Hi[k] ^= U[k]
          }
          U_old = U
        }
        Hi = SHA1.binb2str(Hi);
        clientKey = SHA1.core_hmac_sha1(Hi, "Client Key");
        serverKey = SHA1.str_hmac_sha1(Hi, "Server Key");
        clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);
        connection._sasl_data["server-signature"] = SHA1.b64_hmac_sha1(serverKey, authMessage);
        for (k = 0; k < 5; k++) {
          clientKey[k] ^= clientSignature[k]
        }
        responseText += ",p=" + Base64.encode(SHA1.binb2str(clientKey));
        return responseText
      }.bind(this);
      return auth_str
    };
    Strophe.SASLMD5 = function(){};
    Strophe.SASLMD5.prototype = new Strophe.SASLMechanism("DIGEST-MD5", false, 30);
    Strophe.SASLMD5.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLMD5.prototype._quote = function(str) {
      return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
    };
    Strophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {
      var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;
      var cnonce = test_cnonce || MD5.hexdigest("" + (Math.random() * 1234567890));
      var realm = "";
      var host = null;
      var nonce = "";
      var qop = "";
      var matches;
      while (challenge.match(attribMatch)) {
        matches = challenge.match(attribMatch);
        challenge = challenge.replace(matches[0], "");
        matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
        switch (matches[1]) {
          case"realm":
            realm = matches[2];
            break;
          case"nonce":
            nonce = matches[2];
            break;
          case"qop":
            qop = matches[2];
            break;
          case"host":
            host = matches[2];
            break
        }
      }
      var digest_uri = connection.servtype + "/" + connection.domain;
      if (host !== null) {
        digest_uri = digest_uri + "/" + host
      }
      var cred = utils.utf16to8(connection.authcid + ":" + realm + ":" + this._connection.pass);
      var A1 = MD5.hash(cred) + ":" + nonce + ":" + cnonce;
      var A2 = 'AUTHENTICATE:' + digest_uri;
      var responseText = "";
      responseText += 'charset=utf-8,';
      responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';
      responseText += 'realm=' + this._quote(realm) + ',';
      responseText += 'nonce=' + this._quote(nonce) + ',';
      responseText += 'nc=00000001,';
      responseText += 'cnonce=' + this._quote(cnonce) + ',';
      responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
      responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + ":" + nonce + ":00000001:" + cnonce + ":auth:" + MD5.hexdigest(A2)) + ",";
      responseText += 'qop=auth';
      this.onChallenge = function() {
        return ""
      };
      return responseText
    };
    Strophe.SASLOAuthBearer = function(){};
    Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism("OAUTHBEARER", true, 50);
    Strophe.SASLOAuthBearer.prototype.test = function(connection) {
      return connection.authcid !== null
    };
    Strophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {
      var auth_str = 'n,a=';
      auth_str = auth_str + connection.authzid;
      auth_str = auth_str + ',';
      auth_str = auth_str + "\u0001";
      auth_str = auth_str + 'auth=Bearer ';
      auth_str = auth_str + connection.pass;
      auth_str = auth_str + "\u0001";
      auth_str = auth_str + "\u0001";
      return utils.utf16to8(auth_str)
    };
    Strophe.SASLExternal = function(){};
    Strophe.SASLExternal.prototype = new Strophe.SASLMechanism("EXTERNAL", true, 60);
    Strophe.SASLExternal.prototype.onChallenge = function(connection) {
      return connection.authcid === connection.authzid ? '' : connection.authzid
    };
    return {
        Strophe: Strophe, $build: $build, $msg: $msg, $iq: $iq, $pres: $pres, SHA1: SHA1, Base64: Base64, MD5: MD5
      }
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-bosh', ['strophe-core'], function(core) {
        return factory(core.Strophe, core.$build)
      })
    }
    else {
      return factory(Strophe, $build)
    }
  }(globalThis, function(Strophe, $build) {
    Strophe.Request = function(elem, func, rid, sends) {
      this.id = ++Strophe._requestId;
      this.xmlData = elem;
      this.data = Strophe.serialize(elem);
      this.origFunc = func;
      this.func = func;
      this.rid = rid;
      this.date = NaN;
      this.sends = sends || 0;
      this.abort = false;
      this.dead = null;
      this.age = function() {
        if (!this.date) {
          return 0
        }
        var now = new Date;
        return (now - this.date) / 1000
      };
      this.timeDead = function() {
        if (!this.dead) {
          return 0
        }
        var now = new Date;
        return (now - this.dead) / 1000
      };
      this.xhr = this._newXHR()
    };
    Strophe.Request.prototype = {
      getResponse: function() {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
          node = this.xhr.responseXML.documentElement;
          if (node.tagName == "parsererror") {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            Strophe.error("responseXML: " + Strophe.serialize(this.xhr.responseXML));
            throw"parsererror";
          }
        }
        else if (this.xhr.responseText) {
          Strophe.error("invalid response received");
          Strophe.error("responseText: " + this.xhr.responseText);
          throw"badformat";
        }
        return node
      }, _newXHR: function() {
          var xhr = null;
          if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest;
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType("text/xml; charset=utf-8")
            }
          }
          else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP")
          }
          xhr.onreadystatechange = this.func.bind(null, this);
          return xhr
        }
    };
    Strophe.Bosh = function(connection) {
      this._conn = connection;
      this.rid = Math.floor(Math.random() * 4294967295);
      this.sid = null;
      this.hold = 1;
      this.wait = 60;
      this.window = 5;
      this.errors = 0;
      this._requests = []
    };
    Strophe.Bosh.prototype = {
      strip: null, _buildBody: function() {
          var bodyWrap = $build('body', {
              rid: this.rid++, xmlns: Strophe.NS.HTTPBIND
            });
          if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid})
          }
          if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {
            this._cacheSession()
          }
          return bodyWrap
        }, _reset: function() {
          this.rid = Math.floor(Math.random() * 4294967295);
          this.sid = null;
          this.errors = 0;
          if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session')
          }
          this._conn.nextValidRid(this.rid)
        }, _connect: function(wait, hold, route) {
          this.wait = wait || this.wait;
          this.hold = hold || this.hold;
          this.errors = 0;
          var body = this._buildBody().attrs({
              to: this._conn.domain, "xml:lang": "en", wait: this.wait, hold: this.hold, content: "text/xml; charset=utf-8", ver: "1.6", "xmpp:version": "1.0", "xmlns:xmpp": Strophe.NS.BOSH
            });
          if (route) {
            body.attrs({route: route})
          }
          var _connect_cb = this._conn._connect_cb;
          this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)), body.tree().getAttribute("rid")));
          this._throttledRequestHandler()
        }, _attach: function(jid, sid, rid, callback, wait, hold, wind) {
          this._conn.jid = jid;
          this.sid = sid;
          this.rid = rid;
          this._conn.connect_callback = callback;
          this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);
          this._conn.authenticated = true;
          this._conn.connected = true;
          this.wait = wait || this.wait;
          this.hold = hold || this.hold;
          this.window = wind || this.window;
          this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null)
        }, _isRestorable: function(session, jid) {
          return (typeof session !== "undefined" && session !== null && session.rid && session.sid && session.jid && (typeof jid === "undefined" || jid === null || Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid)))
        }, _restore: function(jid, callback, wait, hold, wind) {
          var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));
          if (this._isRestorable(session, jid)) {
            this._conn.restored = true;
            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);
            return session
          }
          else {
            throw{
              name: "StropheSessionError", message: "_restore: no restorable session."
            };
          }
        }, _cacheSession: function() {
          if (this._conn.authenticated) {
            if (this._conn.jid && this.rid && this.sid) {
              window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({
                jid: this._conn.jid, rid: this.rid, sid: this.sid, cts: Date.now()
              }))
            }
          }
          else {
            window.sessionStorage.removeItem('strophe-bosh-session')
          }
        }, _connect_cb: function(bodyWrap) {
          var typ = bodyWrap.getAttribute("type");
          var cond,
            conflict;
          if (typ !== null && typ == "terminate") {
            cond = bodyWrap.getAttribute("condition");
            Strophe.error("BOSH-Connection failed: " + cond);
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
              if (cond == "remote-stream-error" && conflict.length > 0) {
                cond = "conflict"
              }
              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond)
            }
            else {
              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown")
            }
            this._conn._doDisconnect(cond);
            return Strophe.Status.CONNFAIL
          }
          if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid")
          }
          var wind = bodyWrap.getAttribute('requests');
          if (wind) {
            this.window = parseInt(wind, 10)
          }
          var hold = bodyWrap.getAttribute('hold');
          if (hold) {
            this.hold = parseInt(hold, 10)
          }
          var wait = bodyWrap.getAttribute('wait');
          if (wait) {
            this.wait = parseInt(wait, 10)
          }
        }, _disconnect: function(pres) {
          this._sendTerminate(pres)
        }, _doDisconnect: function() {
          this.sid = null;
          this.rid = Math.floor(Math.random() * 4294967295);
          if (this._conn._sessionCachingSupported()) {
            window.sessionStorage.removeItem('strophe-bosh-session')
          }
          this._conn.nextValidRid(this.rid)
        }, _emptyQueue: function() {
          return this._requests.length === 0
        }, _callProtocolErrorHandlers: function(req) {
          var reqStatus = this._getRequestStatus(req),
            err_callback;
          err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];
          if (err_callback) {
            err_callback.call(this, reqStatus)
          }
        }, _hitError: function(reqStatus) {
          this.errors++;
          Strophe.warn("request errored, status: " + reqStatus + ", number of errors: " + this.errors);
          if (this.errors > 4) {
            this._conn._onDisconnectTimeout()
          }
        }, _no_auth_received: function(_callback) {
          if (_callback) {
            _callback = _callback.bind(this._conn)
          }
          else {
            _callback = this._conn._connect_cb.bind(this._conn)
          }
          var body = this._buildBody();
          this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _callback.bind(this._conn)), body.tree().getAttribute("rid")));
          this._throttledRequestHandler()
        }, _onDisconnectTimeout: function() {
          this._abortAllRequests()
        }, _abortAllRequests: function _abortAllRequests() {
          var req;
          while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            req.xhr.onreadystatechange = function(){}
          }
        }, _onIdle: function() {
          var data = this._conn._data;
          if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {
            Strophe.debug("no requests during idle cycle, sending " + "blank request");
            data.push(null)
          }
          if (this._conn.paused) {
            return
          }
          if (this._requests.length < 2 && data.length > 0) {
            var body = this._buildBody();
            for (var i = 0; i < data.length; i++) {
              if (data[i] !== null) {
                if (data[i] === "restart") {
                  body.attrs({
                    to: this._conn.domain, "xml:lang": "en", "xmpp:restart": "true", "xmlns:xmpp": Strophe.NS.BOSH
                  })
                }
                else {
                  body.cnode(data[i]).up()
                }
              }
            }
            delete this._conn._data;
            this._conn._data = [];
            this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid")));
            this._throttledRequestHandler()
          }
          if (this._requests.length > 0) {
            var time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
              if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                this._throttledRequestHandler()
              }
            }
            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
              Strophe.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) + " seconds since last activity");
              this._throttledRequestHandler()
            }
          }
        }, _getRequestStatus: function(req, def) {
          var reqStatus;
          if (req.xhr.readyState == 4) {
            try {
              reqStatus = req.xhr.status
            }
            catch(e) {
              Strophe.error("Caught an error while retrieving a request's status, " + "reqStatus: " + reqStatus)
            }
          }
          if (typeof(reqStatus) == "undefined") {
            reqStatus = typeof def === 'number' ? def : 0
          }
          return reqStatus
        }, _onRequestStateChange: function(func, req) {
          Strophe.debug("request id " + req.id + "." + req.sends + " state changed to " + req.xhr.readyState);
          if (req.abort) {
            req.abort = false;
            return
          }
          if (req.xhr.readyState !== 4) {
            return
          }
          var reqStatus = this._getRequestStatus(req);
          if (this.disconnecting && reqStatus >= 400) {
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            return
          }
          if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            this._removeRequest(req);
            Strophe.debug("request id " + req.id + " should now be removed")
          }
          if (reqStatus == 200) {
            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);
            if (reqIs1 || (reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
              this._restartRequest(0)
            }
            this._conn.nextValidRid(Number(req.rid) + 1);
            Strophe.debug("request id " + req.id + "." + req.sends + " got 200");
            func(req);
            this.errors = 0
          }
          else if (reqStatus === 0 || (reqStatus >= 400 && reqStatus < 600) || reqStatus >= 12000) {
            Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened");
            this._hitError(reqStatus);
            this._callProtocolErrorHandlers(req);
            if (reqStatus >= 400 && reqStatus < 500) {
              this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);
              this._conn._doDisconnect()
            }
          }
          else {
            Strophe.error("request id " + req.id + "." + req.sends + " error " + reqStatus + " happened")
          }
          if (!(reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
            this._throttledRequestHandler()
          }
        }, _processRequest: function(i) {
          var self = this;
          var req = this._requests[i];
          var reqStatus = this._getRequestStatus(req, -1);
          if (req.sends > this._conn.maxRetries) {
            this._conn._onDisconnectTimeout();
            return
          }
          var time_elapsed = req.age();
          var primaryTimeout = (!isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
          var secondaryTimeout = (req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
          var requestCompletedWithServerError = (req.xhr.readyState == 4 && (reqStatus < 1 || reqStatus >= 500));
          if (primaryTimeout || secondaryTimeout || requestCompletedWithServerError) {
            if (secondaryTimeout) {
              Strophe.error("Request " + this._requests[i].id + " timed out (secondary), restarting")
            }
            req.abort = true;
            req.xhr.abort();
            req.xhr.onreadystatechange = function(){};
            this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);
            req = this._requests[i]
          }
          if (req.xhr.readyState === 0) {
            Strophe.debug("request id " + req.id + "." + req.sends + " posting");
            try {
              var contentType = this._conn.options.contentType || "text/xml; charset=utf-8";
              req.xhr.open("POST", this._conn.service, this._conn.options.sync ? false : true);
              if (typeof req.xhr.setRequestHeader !== 'undefined') {
                req.xhr.setRequestHeader("Content-Type", contentType)
              }
              if (this._conn.options.withCredentials) {
                req.xhr.withCredentials = true
              }
            }
            catch(e2) {
              Strophe.error("XHR open failed.");
              if (!this._conn.connected) {
                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "bad-service")
              }
              this._conn.disconnect();
              return
            }
            var sendFunc = function() {
                req.date = new Date;
                if (self._conn.options.customHeaders) {
                  var headers = self._conn.options.customHeaders;
                  for (var header in headers) {
                    if (headers.hasOwnProperty(header)) {
                      req.xhr.setRequestHeader(header, headers[header])
                    }
                  }
                }
                req.xhr.send(req.data)
              };
            if (req.sends > 1) {
              var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait), Math.pow(req.sends, 3)) * 1000;
              this._conn._timeProvider.setTimeout(function() {
                sendFunc()
              }, backoff)
            }
            else {
              sendFunc()
            }
            req.sends++;
            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
              if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {
                this._conn.xmlOutput(req.xmlData.childNodes[0])
              }
              else {
                this._conn.xmlOutput(req.xmlData)
              }
            }
            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {
              this._conn.rawOutput(req.data)
            }
          }
          else {
            Strophe.debug("_processRequest: " + (i === 0 ? "first" : "second") + " request has readyState of " + req.xhr.readyState)
          }
        }, _removeRequest: function(req) {
          Strophe.debug("removing request");
          var i;
          for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
              this._requests.splice(i, 1)
            }
          }
          req.xhr.onreadystatechange = function(){};
          this._throttledRequestHandler()
        }, _restartRequest: function(i) {
          var req = this._requests[i];
          if (req.dead === null) {
            req.dead = new Date
          }
          this._processRequest(i)
        }, _reqToData: function(req) {
          try {
            return req.getResponse()
          }
          catch(e) {
            if (e != "parsererror") {
              throw e;
            }
            this._conn.disconnect("strophe-parsererror")
          }
        }, _sendTerminate: function(pres) {
          Strophe.debug("_sendTerminate was called");
          var body = this._buildBody().attrs({type: "terminate"});
          if (pres) {
            body.cnode(pres.tree())
          }
          var req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute("rid"));
          this._requests.push(req);
          this._throttledRequestHandler()
        }, _send: function() {
          this._conn._timeProvider.clearTimeout(this._conn._idleTimeout);
          this._throttledRequestHandler();
          this._conn._idleTimeout = this._conn._timeProvider.setTimeout(function() {
            this._onIdle()
          }.bind(this._conn), 100)
        }, _sendRestart: function() {
          this._throttledRequestHandler();
          this._conn._timeProvider.clearTimeout(this._conn._idleTimeout)
        }, _throttledRequestHandler: function() {
          if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " + "undefined requests")
          }
          else {
            Strophe.debug("_throttledRequestHandler called with " + this._requests.length + " requests")
          }
          if (!this._requests || this._requests.length === 0) {
            return
          }
          if (this._requests.length > 0) {
            this._processRequest(0)
          }
          if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {
            this._processRequest(1)
          }
        }
    };
    return Strophe
  }));
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define('strophe-websocket', ['strophe-core'], function(core) {
        return factory(core.Strophe, core.$build)
      })
    }
    else {
      return factory(Strophe, $build)
    }
  }(globalThis, function(Strophe, $build) {
    Strophe.Websocket = function(connection) {
      this._conn = connection;
      this.strip = "wrapper";
      var service = connection.service;
      if (service.indexOf("ws:") !== 0 && service.indexOf("wss:") !== 0) {
        var new_service = "";
        if (connection.options.protocol === "ws" && window.location.protocol !== "https:") {
          new_service += "ws"
        }
        else {
          new_service += "wss"
        }
        new_service += "://" + window.location.host;
        if (service.indexOf("/") !== 0) {
          new_service += window.location.pathname + service
        }
        else {
          new_service += service
        }
        connection.service = new_service
      }
    };
    Strophe.Websocket.prototype = {
      _buildStream: function() {
        return $build("open", {
            xmlns: Strophe.NS.FRAMING, to: this._conn.domain, version: '1.0'
          })
      }, _check_streamerror: function(bodyWrap, connectstatus) {
          var errors;
          if (bodyWrap.getElementsByTagNameNS) {
            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, "error")
          }
          else {
            errors = bodyWrap.getElementsByTagName("stream:error")
          }
          if (errors.length === 0) {
            return false
          }
          var error = errors[0];
          var condition = "";
          var text = "";
          var ns = "urn:ietf:params:xml:ns:xmpp-streams";
          for (var i = 0; i < error.childNodes.length; i++) {
            var e = error.childNodes[i];
            if (e.getAttribute("xmlns") !== ns) {
              break
            }
            if (e.nodeName === "text") {
              text = e.textContent
            }
            else {
              condition = e.nodeName
            }
          }
          var errorString = "WebSocket stream error: ";
          if (condition) {
            errorString += condition
          }
          else {
            errorString += "unknown"
          }
          if (text) {
            errorString += " - " + condition
          }
          Strophe.error(errorString);
          this._conn._changeConnectStatus(connectstatus, condition);
          this._conn._doDisconnect();
          return true
        }, _reset: function() {
          return
        }, _connect: function() {
          this._closeSocket();
          this.socket = new WebSocket(this._conn.service, "xmpp");
          this.socket.onopen = this._onOpen.bind(this);
          this.socket.onerror = this._onError.bind(this);
          this.socket.onclose = this._onClose.bind(this);
          this.socket.onmessage = this._connect_cb_wrapper.bind(this)
        }, _connect_cb: function(bodyWrap) {
          var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);
          if (error) {
            return Strophe.Status.CONNFAIL
          }
        }, _handleStreamStart: function(message) {
          var error = false;
          var ns = message.getAttribute("xmlns");
          if (typeof ns !== "string") {
            error = "Missing xmlns in <open />"
          }
          else if (ns !== Strophe.NS.FRAMING) {
            error = "Wrong xmlns in <open />: " + ns
          }
          var ver = message.getAttribute("version");
          if (typeof ver !== "string") {
            error = "Missing version in <open />"
          }
          else if (ver !== "1.0") {
            error = "Wrong version in <open />: " + ver
          }
          if (error) {
            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);
            this._conn._doDisconnect();
            return false
          }
          return true
        }, _connect_cb_wrapper: function(message) {
          if (message.data.indexOf("<open ") === 0 || message.data.indexOf("<?xml") === 0) {
            var data = message.data.replace(/^(<\?.*?\?>\s*)*/, "");
            if (data === '')
              return;
            var streamStart = (new DOMParser).parseFromString(data, "text/xml").documentElement;
            this._conn.xmlInput(streamStart);
            this._conn.rawInput(message.data);
            if (this._handleStreamStart(streamStart)) {
              this._connect_cb(streamStart)
            }
          }
          else if (message.data.indexOf("<close ") === 0) {
            this._conn.rawInput(message.data);
            this._conn.xmlInput(message);
            var see_uri = message.getAttribute("see-other-uri");
            if (see_uri) {
              this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection");
              this._conn.reset();
              this._conn.service = see_uri;
              this._connect()
            }
            else {
              this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Received closing stream");
              this._conn._doDisconnect()
            }
          }
          else {
            var string = this._streamWrap(message.data);
            var elem = (new DOMParser).parseFromString(string, "text/xml").documentElement;
            this.socket.onmessage = this._onMessage.bind(this);
            this._conn._connect_cb(elem, null, message.data)
          }
        }, _disconnect: function(pres) {
          if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
            if (pres) {
              this._conn.send(pres)
            }
            var close = $build("close", {xmlns: Strophe.NS.FRAMING});
            this._conn.xmlOutput(close);
            var closeString = Strophe.serialize(close);
            this._conn.rawOutput(closeString);
            try {
              this.socket.send(closeString)
            }
            catch(e) {
              Strophe.info("Couldn't send <close /> tag.")
            }
          }
          this._conn._doDisconnect()
        }, _doDisconnect: function() {
          Strophe.debug("WebSockets _doDisconnect was called");
          this._closeSocket()
        }, _streamWrap: function(stanza) {
          return "<wrapper>" + stanza + '</wrapper>'
        }, _closeSocket: function() {
          if (this.socket) {
            try {
              this.socket.close()
            }
            catch(e) {}
          }
          this.socket = null
        }, _emptyQueue: function() {
          return true
        }, _onClose: function() {
          if (this._conn.connected && !this._conn.disconnecting) {
            Strophe.error("Websocket closed unexpectedly");
            this._conn._doDisconnect()
          }
          else {
            Strophe.info("Websocket closed")
          }
        }, _no_auth_received: function(_callback) {
          Strophe.error("Server did not send any auth methods");
          this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "Server did not send any auth methods");
          if (_callback) {
            _callback = _callback.bind(this._conn);
            _callback()
          }
          this._conn._doDisconnect()
        }, _onDisconnectTimeout: function(){}, _abortAllRequests: function(){}, _onError: function(error) {
          Strophe.error("Websocket error " + error);
          this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected.");
          this._disconnect()
        }, _onIdle: function() {
          var data = this._conn._data;
          if (data.length > 0 && !this._conn.paused) {
            for (var i = 0; i < data.length; i++) {
              if (data[i] !== null) {
                var stanza,
                  rawStanza;
                if (data[i] === "restart") {
                  stanza = this._buildStream().tree()
                }
                else {
                  stanza = data[i]
                }
                rawStanza = Strophe.serialize(stanza);
                this._conn.xmlOutput(stanza);
                this._conn.rawOutput(rawStanza);
                this.socket.send(rawStanza)
              }
            }
            this._conn._data = []
          }
        }, _onMessage: function(message) {
          var elem,
            data;
          var close = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
          if (message.data === close) {
            this._conn.rawInput(close);
            this._conn.xmlInput(message);
            if (!this._conn.disconnecting) {
              this._conn._doDisconnect()
            }
            return
          }
          else if (message.data.search("<open ") === 0) {
            elem = (new DOMParser).parseFromString(message.data, "text/xml").documentElement;
            if (!this._handleStreamStart(elem)) {
              return
            }
          }
          else {
            data = this._streamWrap(message.data);
            elem = (new DOMParser).parseFromString(data, "text/xml").documentElement
          }
          if (this._check_streamerror(elem, Strophe.Status.ERROR)) {
            return
          }
          if (this._conn.disconnecting && elem.firstChild.nodeName === "presence" && elem.firstChild.getAttribute("type") === "unavailable") {
            this._conn.xmlInput(elem);
            this._conn.rawInput(Strophe.serialize(elem));
            return
          }
          this._conn._dataRecv(elem, message.data)
        }, _onOpen: function() {
          Strophe.info("Websocket open");
          var start = this._buildStream();
          this._conn.xmlOutput(start.tree());
          var startString = Strophe.serialize(start);
          this._conn.rawOutput(startString);
          this.socket.send(startString)
        }, _reqToData: function(stanza) {
          return stanza
        }, _send: function() {
          this._conn.flush()
        }, _sendRestart: function() {
          this._conn._timeProvider.clearTimeout(this._conn._idleTimeout);
          this._conn._onIdle.bind(this._conn)()
        }
    };
    return Strophe
  }));
  (function(root) {
    if (typeof define === 'function' && define.amd) {
      define("strophe", ["strophe-core", "strophe-bosh", "strophe-websocket"], function(wrapper) {
        return wrapper
      })
    }
  })(this);
  if (callback) {
    if (typeof define === 'function' && define.amd) {
      var n_callback = callback;
      if (typeof requirejs === 'function') {
        requirejs(["strophe"], function(o) {
          n_callback(o.Strophe, o.$build, o.$msg, o.$iq, o.$pres)
        })
      }
      else {
        require(["strophe"], function(o) {
          n_callback(o.Strophe, o.$build, o.$msg, o.$iq, o.$pres)
        })
      }
    }
    else {
      return callback(Strophe, $build, $msg, $iq, $pres)
    }
  }
})(function(Strophe, build, msg, iq, pres) {
  window.Strophe = Strophe;
  window.$build = build;
  window.$msg = msg;
  window.$iq = iq;
  window.$pres = pres
});
;
var Occupant,
  RoomConfig,
  XmppRoom,
  __bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments)
      }
  };
Strophe.addConnectionPlugin('muc', {
  _connection: null, rooms: {}, roomNames: [], init: function(conn) {
      this._connection = conn;
      this._muc_handler = null;
      Strophe.addNamespace('MUC_OWNER', Strophe.NS.MUC + "#owner");
      Strophe.addNamespace('MUC_ADMIN', Strophe.NS.MUC + "#admin");
      Strophe.addNamespace('MUC_USER', Strophe.NS.MUC + "#user");
      return Strophe.addNamespace('MUC_ROOMCONF', Strophe.NS.MUC + "#roomconfig")
    }, join: function(room, nick, msg_handler_cb, pres_handler_cb, roster_cb, password, history_attrs) {
      var msg,
        room_nick,
        _ref,
        _this = this;
      room_nick = this.test_append_nick(room, nick);
      msg = $pres({
        from: this._connection.jid, to: room_nick
      }).c("x", {xmlns: Strophe.NS.MUC});
      if (history_attrs != null) {
        msg = msg.c("history", history_attrs)
      }
      if (password != null) {
        msg.cnode(Strophe.xmlElement("password", [], password))
      }
      if ((_ref = this._muc_handler) == null) {
        this._muc_handler = this._connection.addHandler(function(stanza) {
          var from,
            handler,
            handlers,
            id,
            roomname,
            x,
            xmlns,
            xquery,
            _i,
            _len;
          from = stanza.getAttribute('from');
          if (!from) {
            return true
          }
          roomname = from.split("/")[0];
          if (!_this.rooms[roomname]) {
            return true
          }
          room = _this.rooms[roomname];
          handlers = {};
          if (stanza.nodeName === "message") {
            handlers = room._message_handlers
          }
          else if (stanza.nodeName === "presence") {
            xquery = stanza.getElementsByTagName("x");
            if (xquery.length > 0) {
              for (_i = 0, _len = xquery.length; _i < _len; _i++) {
                x = xquery[_i];
                xmlns = x.getAttribute("xmlns");
                if (xmlns && xmlns.match(Strophe.NS.MUC)) {
                  handlers = room._presence_handlers;
                  break
                }
              }
            }
          }
          for (id in handlers) {
            handler = handlers[id];
            if (!handler(stanza, room)) {
              delete handlers[id]
            }
          }
          return true
        })
      }
      if (!this.rooms.hasOwnProperty(room)) {
        this.rooms[room] = new XmppRoom(this, room, nick, password);
        this.roomNames.push(room)
      }
      if (pres_handler_cb) {
        this.rooms[room].addHandler('presence', pres_handler_cb)
      }
      if (msg_handler_cb) {
        this.rooms[room].addHandler('message', msg_handler_cb)
      }
      if (roster_cb) {
        this.rooms[room].addHandler('roster', roster_cb)
      }
      return this._connection.send(msg)
    }, leave: function(room, nick, handler_cb, exit_msg) {
      var id,
        presence,
        presenceid,
        room_nick;
      id = this.roomNames.indexOf(room);
      delete this.rooms[room];
      if (id >= 0) {
        this.roomNames.splice(id, 1);
        if (this.roomNames.length === 0) {
          this._connection.deleteHandler(this._muc_handler);
          this._muc_handler = null
        }
      }
      room_nick = this.test_append_nick(room, nick);
      presenceid = this._connection.getUniqueId();
      presence = $pres({
        type: "unavailable", id: presenceid, from: this._connection.jid, to: room_nick
      });
      if (exit_msg != null) {
        presence.c("status", exit_msg)
      }
      if (handler_cb != null) {
        this._connection.addHandler(handler_cb, null, "presence", null, presenceid)
      }
      this._connection.send(presence);
      return presenceid
    }, message: function(room, nick, message, html_message, type, source) {
      var msg,
        msgid,
        parent,
        room_nick;
      room_nick = this.test_append_nick(room, nick);
      type = type || (nick != null ? "chat" : "groupchat");
      msgid = this._connection.getUniqueId();
      msg = $msg({
        to: room_nick, from: this._connection.jid, type: type, id: msgid, __Source__: source
      }).c("body", {xmlns: Strophe.NS.CLIENT}).t(message);
      msg.up();
      if (html_message != null) {
        msg.c("html", {xmlns: Strophe.NS.XHTML_IM}).c("body", {xmlns: Strophe.NS.XHTML}).t(html_message);
        if (msg.node.childNodes.length === 0) {
          parent = msg.node.parentNode;
          msg.up().up();
          msg.node.removeChild(parent)
        }
        else {
          msg.up().up()
        }
      }
      msg.c("x", {xmlns: "jabber:x:event"}).c("composing");
      this._connection.send(msg);
      return msgid
    }, groupchat: function(room, message, html_message) {
      return this.message(room, null, message, html_message)
    }, invite: function(room, receiver, reason) {
      var invitation,
        msgid;
      msgid = this._connection.getUniqueId();
      invitation = $msg({
        from: this._connection.jid, to: room, id: msgid
      }).c('x', {xmlns: Strophe.NS.MUC_USER}).c('invite', {to: receiver});
      if (reason != null) {
        invitation.c('reason', reason)
      }
      this._connection.send(invitation);
      return msgid
    }, directInvite: function(room, receiver, reason, password) {
      var attrs,
        invitation,
        msgid;
      msgid = this._connection.getUniqueId();
      attrs = {
        xmlns: 'jabber:x:conference', jid: room
      };
      if (reason != null) {
        attrs.reason = reason
      }
      if (password != null) {
        attrs.password = password
      }
      invitation = $msg({
        from: this._connection.jid, to: receiver, id: msgid
      }).c('x', attrs);
      this._connection.send(invitation);
      return msgid
    }, queryOccupants: function(room, success_cb, error_cb) {
      var attrs,
        info;
      attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
      info = $iq({
        from: this._connection.jid, to: room, type: 'get'
      }).c('query', attrs);
      return this._connection.sendIQ(info, success_cb, error_cb)
    }, configure: function(room, handler_cb, error_cb) {
      var config,
        stanza;
      config = $iq({
        to: room, type: "get"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER});
      stanza = config.tree();
      return this._connection.sendIQ(stanza, handler_cb, error_cb)
    }, cancelConfigure: function(room) {
      var config,
        stanza;
      config = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER}).c("x", {
        xmlns: "jabber:x:data", type: "cancel"
      });
      stanza = config.tree();
      return this._connection.sendIQ(stanza)
    }, saveConfiguration: function(room, config, success_cb, error_cb) {
      var conf,
        iq,
        stanza,
        _i,
        _len;
      iq = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER});
      if (config instanceof Form) {
        config.type = "submit";
        iq.cnode(config.toXML())
      }
      else {
        iq.c("x", {
          xmlns: "jabber:x:data", type: "submit"
        });
        for (_i = 0, _len = config.length; _i < _len; _i++) {
          conf = config[_i];
          iq.cnode(conf).up()
        }
      }
      stanza = iq.tree();
      return this._connection.sendIQ(stanza, success_cb, error_cb)
    }, createInstantRoom: function(room, success_cb, error_cb) {
      var roomiq;
      roomiq = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_OWNER}).c("x", {
        xmlns: "jabber:x:data", type: "submit"
      });
      return this._connection.sendIQ(roomiq.tree(), success_cb, error_cb)
    }, setTopic: function(room, topic) {
      var msg;
      msg = $msg({
        to: room, from: this._connection.jid, type: "groupchat"
      }).c("subject", {xmlns: "jabber:client"}).t(topic);
      return this._connection.send(msg.tree())
    }, _modifyPrivilege: function(room, item, reason, handler_cb, error_cb) {
      var iq;
      iq = $iq({
        to: room, type: "set"
      }).c("query", {xmlns: Strophe.NS.MUC_ADMIN}).cnode(item.node);
      if (reason != null) {
        iq.c("reason", reason)
      }
      return this._connection.sendIQ(iq.tree(), handler_cb, error_cb)
    }, modifyRole: function(room, nick, role, reason, handler_cb, error_cb) {
      var item;
      item = $build("item", {
        nick: nick, role: role
      });
      return this._modifyPrivilege(room, item, reason, handler_cb, error_cb)
    }, kick: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'none', reason, handler_cb, error_cb)
    }, voice: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'participant', reason, handler_cb, error_cb)
    }, mute: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'visitor', reason, handler_cb, error_cb)
    }, op: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'moderator', reason, handler_cb, error_cb)
    }, deop: function(room, nick, reason, handler_cb, error_cb) {
      return this.modifyRole(room, nick, 'participant', reason, handler_cb, error_cb)
    }, modifyAffiliation: function(room, jid, affiliation, reason, handler_cb, error_cb) {
      var item;
      item = $build("item", {
        jid: jid, affiliation: affiliation
      });
      return this._modifyPrivilege(room, item, reason, handler_cb, error_cb)
    }, ban: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'outcast', reason, handler_cb, error_cb)
    }, member: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'member', reason, handler_cb, error_cb)
    }, revoke: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'none', reason, handler_cb, error_cb)
    }, owner: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'owner', reason, handler_cb, error_cb)
    }, admin: function(room, jid, reason, handler_cb, error_cb) {
      return this.modifyAffiliation(room, jid, 'admin', reason, handler_cb, error_cb)
    }, changeNick: function(room, user) {
      var presence,
        room_nick;
      room_nick = this.test_append_nick(room, user);
      presence = $pres({
        from: this._connection.jid, to: room_nick, id: this._connection.getUniqueId()
      });
      return this._connection.send(presence.tree())
    }, setStatus: function(room, user, show, status) {
      var presence,
        room_nick;
      room_nick = this.test_append_nick(room, user);
      presence = $pres({
        from: this._connection.jid, to: room_nick
      });
      if (show != null) {
        presence.c('show', show).up()
      }
      if (status != null) {
        presence.c('status', status)
      }
      return this._connection.send(presence.tree())
    }, listRooms: function(server, handle_cb, error_cb) {
      var iq;
      iq = $iq({
        to: server, from: this._connection.jid, type: "get"
      }).c("query", {xmlns: Strophe.NS.DISCO_ITEMS});
      return this._connection.sendIQ(iq, handle_cb, error_cb)
    }, test_append_nick: function(room, nick) {
      return room + (nick != null ? "/" + (Strophe.escapeNode(nick)) : "")
    }
});
XmppRoom = (function() {
  function XmppRoom(client, name, nick, password) {
    this.client = client;
    this.name = name;
    this.nick = nick;
    this.password = password;
    this._roomRosterHandler = __bind(this._roomRosterHandler, this);
    this._addOccupant = __bind(this._addOccupant, this);
    this.roster = {};
    this._message_handlers = {};
    this._presence_handlers = {};
    this._roster_handlers = {};
    this._handler_ids = 0;
    if (client.muc) {
      this.client = client.muc
    }
    this.name = Strophe.getBareJidFromJid(name);
    this.addHandler('presence', this._roomRosterHandler)
  }
  XmppRoom.prototype.join = function(msg_handler_cb, pres_handler_cb, roster_cb) {
    return this.client.join(this.name, this.nick, msg_handler_cb, pres_handler_cb, roster_cb, this.password)
  };
  XmppRoom.prototype.leave = function(handler_cb, message) {
    this.client.leave(this.name, this.nick, handler_cb, message);
    return delete this.client.rooms[this.name]
  };
  XmppRoom.prototype.message = function(nick, message, html_message, type) {
    return this.client.message(this.name, nick, message, html_message, type)
  };
  XmppRoom.prototype.groupchat = function(message, html_message) {
    return this.client.groupchat(this.name, message, html_message)
  };
  XmppRoom.prototype.invite = function(receiver, reason) {
    return this.client.invite(this.name, receiver, reason)
  };
  XmppRoom.prototype.directInvite = function(receiver, reason) {
    return this.client.directInvite(this.name, receiver, reason, this.password)
  };
  XmppRoom.prototype.configure = function(handler_cb) {
    return this.client.configure(this.name, handler_cb)
  };
  XmppRoom.prototype.cancelConfigure = function() {
    return this.client.cancelConfigure(this.name)
  };
  XmppRoom.prototype.saveConfiguration = function(config) {
    return this.client.saveConfiguration(this.name, config)
  };
  XmppRoom.prototype.queryOccupants = function(success_cb, error_cb) {
    return this.client.queryOccupants(this.name, success_cb, error_cb)
  };
  XmppRoom.prototype.setTopic = function(topic) {
    return this.client.setTopic(this.name, topic)
  };
  XmppRoom.prototype.modifyRole = function(nick, role, reason, success_cb, error_cb) {
    return this.client.modifyRole(this.name, nick, role, reason, success_cb, error_cb)
  };
  XmppRoom.prototype.kick = function(nick, reason, handler_cb, error_cb) {
    return this.client.kick(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.voice = function(nick, reason, handler_cb, error_cb) {
    return this.client.voice(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.mute = function(nick, reason, handler_cb, error_cb) {
    return this.client.mute(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.op = function(nick, reason, handler_cb, error_cb) {
    return this.client.op(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.deop = function(nick, reason, handler_cb, error_cb) {
    return this.client.deop(this.name, nick, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.modifyAffiliation = function(jid, affiliation, reason, success_cb, error_cb) {
    return this.client.modifyAffiliation(this.name, jid, affiliation, reason, success_cb, error_cb)
  };
  XmppRoom.prototype.ban = function(jid, reason, handler_cb, error_cb) {
    return this.client.ban(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.member = function(jid, reason, handler_cb, error_cb) {
    return this.client.member(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.revoke = function(jid, reason, handler_cb, error_cb) {
    return this.client.revoke(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.owner = function(jid, reason, handler_cb, error_cb) {
    return this.client.owner(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.admin = function(jid, reason, handler_cb, error_cb) {
    return this.client.admin(this.name, jid, reason, handler_cb, error_cb)
  };
  XmppRoom.prototype.changeNick = function(nick) {
    this.nick = nick;
    return this.client.changeNick(this.name, nick)
  };
  XmppRoom.prototype.setStatus = function(show, status) {
    return this.client.setStatus(this.name, this.nick, show, status)
  };
  XmppRoom.prototype.addHandler = function(handler_type, handler) {
    var id;
    id = this._handler_ids++;
    switch (handler_type) {
      case'presence':
        this._presence_handlers[id] = handler;
        break;
      case'message':
        this._message_handlers[id] = handler;
        break;
      case'roster':
        this._roster_handlers[id] = handler;
        break;
      default:
        this._handler_ids--;
        return null
    }
    return id
  };
  XmppRoom.prototype.removeHandler = function(id) {
    delete this._presence_handlers[id];
    delete this._message_handlers[id];
    return delete this._roster_handlers[id]
  };
  XmppRoom.prototype._addOccupant = function(data) {
    var occ;
    occ = new Occupant(data, this);
    this.roster[occ.nick] = occ;
    return occ
  };
  XmppRoom.prototype._roomRosterHandler = function(pres) {
    var data,
      handler,
      id,
      newnick,
      nick,
      _ref;
    data = XmppRoom._parsePresence(pres);
    nick = data.nick;
    newnick = data.newnick || null;
    switch (data.type) {
      case'error':
        return;
      case'unavailable':
        if (newnick) {
          data.nick = newnick;
          if (this.roster[nick] && this.roster[newnick]) {
            this.roster[nick].update(this.roster[newnick]);
            this.roster[newnick] = this.roster[nick]
          }
          if (this.roster[nick] && !this.roster[newnick]) {
            this.roster[newnick] = this.roster[nick].update(data)
          }
        }
        delete this.roster[nick];
        break;
      default:
        if (this.roster[nick]) {
          this.roster[nick].update(data)
        }
        else {
          this._addOccupant(data)
        }
    }
    _ref = this._roster_handlers;
    for (id in _ref) {
      handler = _ref[id];
      if (!handler(this.roster, this)) {
        delete this._roster_handlers[id]
      }
    }
    return true
  };
  XmppRoom._parsePresence = function(pres) {
    var a,
      c,
      c2,
      data,
      _i,
      _j,
      _len,
      _len1,
      _ref,
      _ref1,
      _ref2,
      _ref3,
      _ref4,
      _ref5,
      _ref6,
      _ref7;
    data = {};
    a = pres.attributes;
    data.nick = Strophe.getResourceFromJid(a.from.textContent);
    data.type = ((_ref = a.type) != null ? _ref.textContent : void 0) || null;
    data.states = [];
    _ref1 = pres.childNodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      switch (c.nodeName) {
        case"status":
          data.status = c.textContent || null;
          break;
        case"show":
          data.show = c.textContent || null;
          break;
        case"x":
          a = c.attributes;
          if (((_ref2 = a.xmlns) != null ? _ref2.textContent : void 0) === Strophe.NS.MUC_USER) {
            _ref3 = c.childNodes;
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              c2 = _ref3[_j];
              switch (c2.nodeName) {
                case"item":
                  a = c2.attributes;
                  data.affiliation = ((_ref4 = a.affiliation) != null ? _ref4.textContent : void 0) || null;
                  data.role = ((_ref5 = a.role) != null ? _ref5.textContent : void 0) || null;
                  data.jid = ((_ref6 = a.jid) != null ? _ref6.textContent : void 0) || null;
                  data.newnick = ((_ref7 = a.nick) != null ? _ref7.textContent : void 0) || null;
                  break;
                case"status":
                  if (c2.attributes.code) {
                    data.states.push(c2.attributes.code.textContent)
                  }
              }
            }
          }
      }
    }
    return data
  };
  return XmppRoom
})();
RoomConfig = (function() {
  function RoomConfig(info) {
    this.parse = __bind(this.parse, this);
    if (info != null) {
      this.parse(info)
    }
  }
  RoomConfig.prototype.parse = function(result) {
    var attr,
      attrs,
      child,
      field,
      identity,
      query,
      _i,
      _j,
      _k,
      _len,
      _len1,
      _len2,
      _ref;
    query = result.getElementsByTagName("query")[0].childNodes;
    this.identities = [];
    this.features = [];
    this.x = [];
    for (_i = 0, _len = query.length; _i < _len; _i++) {
      child = query[_i];
      attrs = child.attributes;
      switch (child.nodeName) {
        case"identity":
          identity = {};
          for (_j = 0, _len1 = attrs.length; _j < _len1; _j++) {
            attr = attrs[_j];
            identity[attr.name] = attr.textContent
          }
          this.identities.push(identity);
          break;
        case"feature":
          this.features.push(attrs["var"].textContent);
          break;
        case"x":
          attrs = child.childNodes[0].attributes;
          if ((!attrs["var"].textContent === 'FORM_TYPE') || (!attrs.type.textContent === 'hidden')) {
            break
          }
          _ref = child.childNodes;
          for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
            field = _ref[_k];
            if (!(!field.attributes.type)) {
              continue
            }
            attrs = field.attributes;
            this.x.push({
              "var": attrs["var"].textContent, label: attrs.label.textContent || "", value: field.firstChild.textContent || ""
            })
          }
      }
    }
    return {
        identities: this.identities, features: this.features, x: this.x
      }
  };
  return RoomConfig
})();
Occupant = (function() {
  function Occupant(data, room) {
    this.room = room;
    this.update = __bind(this.update, this);
    this.admin = __bind(this.admin, this);
    this.owner = __bind(this.owner, this);
    this.revoke = __bind(this.revoke, this);
    this.member = __bind(this.member, this);
    this.ban = __bind(this.ban, this);
    this.modifyAffiliation = __bind(this.modifyAffiliation, this);
    this.deop = __bind(this.deop, this);
    this.op = __bind(this.op, this);
    this.mute = __bind(this.mute, this);
    this.voice = __bind(this.voice, this);
    this.kick = __bind(this.kick, this);
    this.modifyRole = __bind(this.modifyRole, this);
    this.update(data)
  }
  Occupant.prototype.modifyRole = function(role, reason, success_cb, error_cb) {
    return this.room.modifyRole(this.nick, role, reason, success_cb, error_cb)
  };
  Occupant.prototype.kick = function(reason, handler_cb, error_cb) {
    return this.room.kick(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.voice = function(reason, handler_cb, error_cb) {
    return this.room.voice(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.mute = function(reason, handler_cb, error_cb) {
    return this.room.mute(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.op = function(reason, handler_cb, error_cb) {
    return this.room.op(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.deop = function(reason, handler_cb, error_cb) {
    return this.room.deop(this.nick, reason, handler_cb, error_cb)
  };
  Occupant.prototype.modifyAffiliation = function(affiliation, reason, success_cb, error_cb) {
    return this.room.modifyAffiliation(this.jid, affiliation, reason, success_cb, error_cb)
  };
  Occupant.prototype.ban = function(reason, handler_cb, error_cb) {
    return this.room.ban(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.member = function(reason, handler_cb, error_cb) {
    return this.room.member(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.revoke = function(reason, handler_cb, error_cb) {
    return this.room.revoke(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.owner = function(reason, handler_cb, error_cb) {
    return this.room.owner(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.admin = function(reason, handler_cb, error_cb) {
    return this.room.admin(this.jid, reason, handler_cb, error_cb)
  };
  Occupant.prototype.update = function(data) {
    this.nick = data.nick || null;
    this.affiliation = data.affiliation || null;
    this.role = data.role || null;
    this.jid = data.jid || null;
    this.status = data.status || null;
    this.show = data.show || null;
    return this
  };
  return Occupant
})();
Strophe.addConnectionPlugin('disco', {
  _connection: null, _identities: [], _features: [], _items: [], init: function(conn) {
      this._connection = conn;
      this._identities = [];
      this._features = [];
      this._items = [];
      conn.addHandler(this._onDiscoInfo.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'get', null, null);
      conn.addHandler(this._onDiscoItems.bind(this), Strophe.NS.DISCO_ITEMS, 'iq', 'get', null, null)
    }, addIdentity: function(category, type, name, lang) {
      if (typeof name === 'undefined') {
        name = ''
      }
      if (typeof lang === 'undefined') {
        lang = ''
      }
      for (var i = 0; i < this._identities.length; i++) {
        if (this._identities[i].category == category && this._identities[i].type == type && this._identities[i].name == name && this._identities[i].lang == lang) {
          return false
        }
      }
      this._identities.push({
        category: category, type: type, name: name, lang: lang
      });
      return true
    }, addFeature: function(var_name) {
      for (var i = 0; i < this._features.length; i++) {
        if (this._features[i] == var_name)
          return false
      }
      this._features.push(var_name);
      return true
    }, removeFeature: function(var_name) {
      for (var i = 0; i < this._features.length; i++) {
        if (this._features[i] === var_name) {
          this._features.splice(i, 1);
          return true
        }
      }
      return false
    }, addItem: function(jid, name, node, call_back) {
      if (node && !call_back)
        return false;
      this._items.push({
        jid: jid, name: name, node: node, call_back: call_back
      });
      return true
    }, info: function(jid, node, success, error, timeout) {
      var attrs = {xmlns: Strophe.NS.DISCO_INFO};
      if (node)
        attrs.node = node;
      var info = $iq({
          from: this._connection.jid, to: jid, type: 'get'
        }).c('query', attrs);
      this._connection.sendIQ(info, success, error, timeout)
    }, items: function(jid, node, success, error, timeout) {
      var attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
      if (node)
        attrs.node = node;
      var items = $iq({
          from: this._connection.jid, to: jid, type: 'get'
        }).c('query', attrs);
      this._connection.sendIQ(items, success, error, timeout)
    }, _buildIQResult: function(stanza, query_attrs) {
      var id = stanza.getAttribute('id');
      var from = stanza.getAttribute('from');
      var iqresult = $iq({
          type: 'result', id: id
        });
      if (from !== null) {
        iqresult.attrs({to: from})
      }
      return iqresult.c('query', query_attrs)
    }, _onDiscoInfo: function(stanza) {
      var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
      var attrs = {xmlns: Strophe.NS.DISCO_INFO};
      var i;
      if (node) {
        attrs.node = node
      }
      var iqresult = this._buildIQResult(stanza, attrs);
      for (i = 0; i < this._identities.length; i++) {
        attrs = {
          category: this._identities[i].category, type: this._identities[i].type
        };
        if (this._identities[i].name)
          attrs.name = this._identities[i].name;
        if (this._identities[i].lang)
          attrs['xml:lang'] = this._identities[i].lang;
        iqresult.c('identity', attrs).up()
      }
      for (i = 0; i < this._features.length; i++) {
        iqresult.c('feature', {'var': this._features[i]}).up()
      }
      this._connection.send(iqresult.tree());
      return true
    }, _onDiscoItems: function(stanza) {
      var query_attrs = {xmlns: Strophe.NS.DISCO_ITEMS};
      var node = stanza.getElementsByTagName('query')[0].getAttribute('node');
      var items,
        i;
      if (node) {
        query_attrs.node = node;
        items = [];
        for (i = 0; i < this._items.length; i++) {
          if (this._items[i].node == node) {
            items = this._items[i].call_back(stanza);
            break
          }
        }
      }
      else {
        items = this._items
      }
      var iqresult = this._buildIQResult(stanza, query_attrs);
      for (i = 0; i < items.length; i++) {
        var attrs = {jid: items[i].jid};
        if (items[i].name)
          attrs.name = items[i].name;
        if (items[i].node)
          attrs.node = items[i].node;
        iqresult.c('item', attrs).up()
      }
      this._connection.send(iqresult.tree());
      return true
    }
});
Strophe.addConnectionPlugin('caps', {
  HASH: 'sha-1', node: 'http://strophe.im/strophejs/', _ver: '', _connection: null, _knownCapabilities: {}, _jidVerIndex: {}, init: function(conn) {
      this._connection = conn;
      Strophe.addNamespace('CAPS', 'http://jabber.org/protocol/caps');
      if (!this._connection.disco) {
        throw"Caps plugin requires the disco plugin to be installed.";
      }
      this._connection.disco.addFeature(Strophe.NS.CAPS);
      this._connection.addHandler(this._delegateCapabilities.bind(this), Strophe.NS.CAPS)
    }, generateCapsAttrs: function() {
      return {
          xmlns: Strophe.NS.CAPS, hash: this.HASH, node: this.node, ver: this.generateVer()
        }
    }, generateVer: function() {
      if (this._ver !== "") {
        return this._ver
      }
      var ver = "",
        identities = this._connection.disco._identities.sort(this._sortIdentities),
        identitiesLen = identities.length,
        features = this._connection.disco._features.sort(),
        featuresLen = features.length;
      for (var i = 0; i < identitiesLen; i++) {
        var curIdent = identities[i];
        ver += curIdent.category + "/" + curIdent.type + "/" + curIdent.lang + "/" + curIdent.name + "<"
      }
      for (var i = 0; i < featuresLen; i++) {
        ver += features[i] + '<'
      }
      this._ver = b64_sha1(ver);
      return this._ver
    }, getCapabilitiesByJid: function(jid) {
      if (this._jidVerIndex[jid]) {
        return this._knownCapabilities[this._jidVerIndex[jid]]
      }
      return null
    }, _delegateCapabilities: function(stanza) {
      var from = stanza.getAttribute('from'),
        c = stanza.getElementsByTagName('c')[0],
        ver = c.getAttribute('ver'),
        node = c.getAttribute('node');
      if (!this._knownCapabilities[ver]) {
        return this._requestCapabilities(from, node, ver)
      }
      else {
        this._jidVerIndex[from] = ver
      }
      if (!this._jidVerIndex[from] || !this._jidVerIndex[from] !== ver) {
        this._jidVerIndex[from] = ver
      }
      return true
    }, _requestCapabilities: function(to, node, ver) {
      if (to !== this._connection.jid) {
        var id = this._connection.disco.info(to, node + '#' + ver);
        this._connection.addHandler(this._handleDiscoInfoReply.bind(this), Strophe.NS.DISCO_INFO, 'iq', 'result', id, to)
      }
      return true
    }, _handleDiscoInfoReply: function(stanza) {
      var query = stanza.getElementsByTagName('query')[0],
        node = query.getAttribute('node').split('#'),
        ver = node[1],
        from = stanza.getAttribute('from');
      if (!this._knownCapabilities[ver]) {
        var childNodes = query.childNodes,
          childNodesLen = childNodes.length;
        this._knownCapabilities[ver] = [];
        for (var i = 0; i < childNodesLen; i++) {
          var node = childNodes[i];
          this._knownCapabilities[ver].push({
            name: node.nodeName, attributes: node.attributes
          })
        }
        this._jidVerIndex[from] = ver
      }
      else if (!this._jidVerIndex[from] || !this._jidVerIndex[from] !== ver) {
        this._jidVerIndex[from] = ver
      }
      return false
    }, _sortIdentities: function(a, b) {
      if (a.category > b.category) {
        return 1
      }
      if (a.category < b.category) {
        return -1
      }
      if (a.type > b.type) {
        return 1
      }
      if (a.type < b.type) {
        return -1
      }
      if (a.lang > b.lang) {
        return 1
      }
      if (a.lang < b.lang) {
        return -1
      }
      return 0
    }
});
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define("strophe.rsm", ["strophe"], function(Strophe) {
      factory(Strophe.Strophe, Strophe.$build, Strophe.$iq, Strophe.$msg, Strophe.$pres);
      return Strophe
    })
  }
  else {
    factory(root.Strophe, root.$build, root.$iq, root.$msg, root.$pres)
  }
}(this, function(Strophe, $build, $iq, $msg, $pres) {
  Strophe.addNamespace('RSM', 'http://jabber.org/protocol/rsm');
  Strophe.RSM = function(options) {
    this.attribs = ['max', 'first', 'last', 'after', 'before', 'index', 'count'];
    if (typeof options.xml != 'undefined') {
      this.fromXMLElement(options.xml)
    }
    else {
      for (var ii = 0; ii < this.attribs.length; ii++) {
        var attrib = this.attribs[ii];
        this[attrib] = options[attrib]
      }
    }
  };
  Strophe.RSM.prototype = {
    toXML: function() {
      var xml = $build('set', {xmlns: Strophe.NS.RSM});
      for (var ii = 0; ii < this.attribs.length; ii++) {
        var attrib = this.attribs[ii];
        if (typeof this[attrib] != 'undefined') {
          xml = xml.c(attrib).t(this[attrib].toString()).up()
        }
      }
      return xml.tree()
    }, next: function(max) {
        var newSet = new Strophe.RSM({
            max: max, after: this.last
          });
        return newSet
      }, previous: function(max) {
        var newSet = new Strophe.RSM({
            max: max, before: this.first
          });
        return newSet
      }, fromXMLElement: function(xmlElement) {
        for (var ii = 0; ii < this.attribs.length; ii++) {
          var attrib = this.attribs[ii];
          var elem = xmlElement.getElementsByTagName(attrib)[0];
          if (typeof elem != 'undefined' && elem !== null) {
            this[attrib] = Strophe.getText(elem);
            if (attrib == 'first') {
              this.index = elem.getAttribute('index')
            }
          }
        }
      }
  }
}));
(function() {
  Strophe.addConnectionPlugin('mam', {
    _c: null, _p: ['with', 'start', 'end'], init: function(conn) {
        this._c = conn;
        Strophe.addNamespace('MAM', 'urn:xmpp:mam:2')
      }, query: function(jid, options) {
        var _p = this._p;
        var attr = {
            type: 'set', to: jid
          };
        options = options || {};
        var mamAttr = {xmlns: Strophe.NS.MAM};
        if (!!options.queryid) {
          mamAttr.queryid = options.queryid;
          delete options.queryid
        }
        var iq = $iq(attr).c('query', mamAttr).c('x', {
            xmlns: 'jabber:x:data', type: 'submit'
          });
        iq.c('field', {
          var: 'FORM_TYPE', type: 'hidden'
        }).c('value').t(Strophe.NS.MAM).up().up();
        var i;
        for (i = 0; i < this._p.length; i++) {
          var pn = _p[i];
          var p = options[pn];
          delete options[pn];
          if (!!p) {
            iq.c('field', {var: pn}).c('value').t(p).up().up()
          }
        }
        iq.up();
        var onMessage = options.onMessage;
        delete options.onMessage;
        var onComplete = options.onComplete;
        delete options.onComplete;
        iq.cnode(new Strophe.RSM(options).toXML());
        var _c = this._c;
        var handler = _c.addHandler(onMessage, Strophe.NS.MAM, 'message', null);
        return this._c.sendIQ(iq, function() {
            _c.deleteHandler(handler);
            onComplete.apply(this, arguments)
          })
      }
  })
})();
var Mustache = function() {
    var Renderer = function(){};
    Renderer.prototype = {
      otag: "{{", ctag: "}}", pragmas: {}, buffer: [], pragmas_implemented: {"IMPLICIT-ITERATOR": true}, context: {}, render: function(template, context, partials, in_recursion) {
          if (!in_recursion) {
            this.context = context;
            this.buffer = []
          }
          if (!this.includes("", template)) {
            if (in_recursion) {
              return template
            }
            else {
              this.send(template);
              return
            }
          }
          template = this.render_pragmas(template);
          var html = this.render_section(template, context, partials);
          if (in_recursion) {
            return this.render_tags(html, context, partials, in_recursion)
          }
          this.render_tags(html, context, partials, in_recursion)
        }, send: function(line) {
          if (line != "") {
            this.buffer.push(line)
          }
        }, render_pragmas: function(template) {
          if (!this.includes("%", template)) {
            return template
          }
          var that = this;
          var regex = new RegExp(this.otag + "%([\\w-]+) ?([\\w]+=[\\w]+)?" + this.ctag);
          return template.replace(regex, function(match, pragma, options) {
              if (!that.pragmas_implemented[pragma]) {
                throw({message: "This implementation of mustache doesn't understand the '" + pragma + "' pragma"});
              }
              that.pragmas[pragma] = {};
              if (options) {
                var opts = options.split("=");
                that.pragmas[pragma][opts[0]] = opts[1]
              }
              return ""
            })
        }, render_partial: function(name, context, partials) {
          name = this.trim(name);
          if (!partials || partials[name] === undefined) {
            throw({message: "unknown_partial '" + name + "'"});
          }
          if (typeof(context[name]) != "object") {
            return this.render(partials[name], context, partials, true)
          }
          return this.render(partials[name], context[name], partials, true)
        }, render_section: function(template, context, partials) {
          if (!this.includes("#", template) && !this.includes("^", template)) {
            return template
          }
          var that = this;
          var regex = new RegExp(this.otag + "(\\^|\\#)\\s*(.+)\\s*" + this.ctag + "\n*([\\s\\S]+?)" + this.otag + "\\/\\s*\\2\\s*" + this.ctag + "\\s*", "mg");
          return template.replace(regex, function(match, type, name, content) {
              var value = that.find(name, context);
              if (type == "^") {
                if (!value || that.is_array(value) && value.length === 0) {
                  return that.render(content, context, partials, true)
                }
                else {
                  return ""
                }
              }
              else if (type == "#") {
                if (that.is_array(value)) {
                  return that.map(value, function(row) {
                      return that.render(content, that.create_context(row), partials, true)
                    }).join("")
                }
                else if (that.is_object(value)) {
                  return that.render(content, that.create_context(value), partials, true)
                }
                else if (typeof value === "function") {
                  return value.call(context, content, function(text) {
                      return that.render(text, context, partials, true)
                    })
                }
                else if (value) {
                  return that.render(content, context, partials, true)
                }
                else {
                  return ""
                }
              }
            })
        }, render_tags: function(template, context, partials, in_recursion) {
          var that = this;
          var new_regex = function() {
              return new RegExp(that.otag + "(=|!|>|\\{|%)?([^\\/#\\^]+?)\\1?" + that.ctag + "+", "g")
            };
          var regex = new_regex();
          var tag_replace_callback = function(match, operator, name) {
              switch (operator) {
                case"!":
                  return "";
                case"=":
                  that.set_delimiters(name);
                  regex = new_regex();
                  return "";
                case">":
                  return that.render_partial(name, context, partials);
                case"{":
                  return that.find(name, context);
                default:
                  return that.escape(that.find(name, context))
              }
            };
          var lines = template.split("\n");
          for (var i = 0; i < lines.length; i++) {
            lines[i] = lines[i].replace(regex, tag_replace_callback, this);
            if (!in_recursion) {
              this.send(lines[i])
            }
          }
          if (in_recursion) {
            return lines.join("\n")
          }
        }, set_delimiters: function(delimiters) {
          var dels = delimiters.split(" ");
          this.otag = this.escape_regex(dels[0]);
          this.ctag = this.escape_regex(dels[1])
        }, escape_regex: function(text) {
          if (!arguments.callee.sRE) {
            var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
            arguments.callee.sRE = new RegExp('(\\' + specials.join('|\\') + ')', 'g')
          }
          return text.replace(arguments.callee.sRE, '\\$1')
        }, find: function(name, context) {
          name = this.trim(name);
          function is_kinda_truthy(bool) {
            return bool === false || bool === 0 || bool
          }
          var value;
          if (is_kinda_truthy(context[name])) {
            value = context[name]
          }
          else if (is_kinda_truthy(this.context[name])) {
            value = this.context[name]
          }
          if (typeof value === "function") {
            return value.apply(context)
          }
          if (value !== undefined) {
            return value
          }
          return ""
        }, includes: function(needle, haystack) {
          return haystack.indexOf(this.otag + needle) != -1
        }, escape: function(s) {
          s = String(s === null ? "" : s);
          return s.replace(/&(?!\w+;)|["<>\\]/g, function(s) {
              switch (s) {
                case"&":
                  return "&amp;";
                case"\\":
                  return "\\\\";
                case'"':
                  return '\"';
                case"<":
                  return "&lt;";
                case">":
                  return "&gt;";
                default:
                  return s
              }
            })
        }, create_context: function(_context) {
          if (this.is_object(_context)) {
            return _context
          }
          else {
            var iterator = ".";
            if (this.pragmas["IMPLICIT-ITERATOR"]) {
              iterator = this.pragmas["IMPLICIT-ITERATOR"].iterator
            }
            var ctx = {};
            ctx[iterator] = _context;
            return ctx
          }
        }, is_object: function(a) {
          return a && typeof a == "object"
        }, is_array: function(a) {
          return Object.prototype.toString.call(a) === '[object Array]'
        }, trim: function(s) {
          return s.replace(/^\s*|\s*$/g, "")
        }, map: function(array, fn) {
          if (typeof array.map == "function") {
            return array.map(fn)
          }
          else {
            var r = [];
            var l = array.length;
            for (var i = 0; i < l; i++) {
              r.push(fn(array[i]))
            }
            return r
          }
        }
    };
    return ({
        name: "mustache.js", version: "0.3.0", to_html: function(template, view, partials, send_fun) {
            var renderer = new Renderer;
            if (send_fun) {
              renderer.send = send_fun
            }
            renderer.render(template, view, partials);
            if (!send_fun) {
              return renderer.buffer.join("\n")
            }
          }
      })
  }();
(function($) {
  var __slice = Array.prototype.slice;
  var i18n = {
      dict: null, missingPattern: null, load: function(i18nDict, missingPattern) {
          if (this.dict !== null) {
            $.extend(this.dict, i18nDict)
          }
          else {
            this.dict = i18nDict
          }
          if (missingPattern) {
            this.missingPattern = missingPattern
          }
        }, unload: function() {
          this.dict = null;
          this.missingPattern = null
        }, _: function(str) {
          var dict = this.dict;
          if (dict && dict.hasOwnProperty(str)) {
            str = dict[str]
          }
          else if (this.missingPattern !== null) {
            return this.printf(this.missingPattern, str)
          }
          var args = __slice.call(arguments);
          args[0] = str;
          return this.printf.apply(this, args)
        }, printf: function(str, args) {
          if (arguments.length < 2)
            return str;
          args = $.isArray(args) ? args : __slice.call(arguments, 1);
          return str.replace(/([^%]|^)%(?:(\d+)\$)?s/g, function(p0, p, position) {
              if (position) {
                return p + args[parseInt(position) - 1]
              }
              return p + args.shift()
            }).replace(/%%s/g, '%s')
        }
    };
  $.fn._t = function(str, params) {
    return $(this).html(i18n._.apply(i18n, arguments))
  };
  $.i18n = i18n
})(jQuery);
var dateFormat = function() {
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
      timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
      timezoneClip = /[^-+\dA-Z]/g,
      pad = function(val, len) {
        val = String(val);
        len = len || 2;
        while (val.length < len)
          val = "0" + val;
        return val
      };
    return function(date, mask, utc) {
        var dF = dateFormat;
        if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
          mask = date;
          date = undefined
        }
        date = date ? new Date(date) : new Date;
        if (isNaN(date))
          throw SyntaxError("invalid date");
        mask = String(dF.masks[mask] || mask || dF.masks["default"]);
        if (mask.slice(0, 4) == "UTC:") {
          mask = mask.slice(4);
          utc = true
        }
        var _ = utc ? "getUTC" : "get",
          d = date[_ + "Date"](),
          D = date[_ + "Day"](),
          m = date[_ + "Month"](),
          y = date[_ + "FullYear"](),
          H = date[_ + "Hours"](),
          M = date[_ + "Minutes"](),
          s = date[_ + "Seconds"](),
          L = date[_ + "Milliseconds"](),
          o = utc ? 0 : date.getTimezoneOffset(),
          flags = {
            d: d, dd: pad(d), ddd: dF.i18n.dayNames[D], dddd: dF.i18n.dayNames[D + 7], m: m + 1, mm: pad(m + 1), mmm: dF.i18n.monthNames[m], mmmm: dF.i18n.monthNames[m + 12], yy: String(y).slice(2), yyyy: y, h: H % 12 || 12, hh: pad(H % 12 || 12), H: H, HH: pad(H), M: M, MM: pad(M), s: s, ss: pad(s), l: pad(L, 3), L: pad(L > 99 ? Math.round(L / 10) : L), t: H < 12 ? "a" : "p", tt: H < 12 ? "am" : "pm", T: H < 12 ? "A" : "P", TT: H < 12 ? "AM" : "PM", Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""), o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4), S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
          };
        return mask.replace(token, function($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)
          })
      }
  }();
dateFormat.masks = {
  "default": "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:ss", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};
dateFormat.i18n = {
  dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
Date.prototype.format = function(mask, utc) {
  return dateFormat(this, mask, utc)
};
/*!
 * BDP Candy bundle 1.3.1-4673
 * Copyright (c) Base Digitale Platform. All rights reserved.
 */
;
function buildCandy(jQueryCandyInstance = jQuery) {
  ;
  window.jQueryCandyInstance = window.jQueryCandyInstance || jQuery;
  var Candy = (function(self, $) {
      self.about = {
        name: 'Candy', version: '1.10.0'
      };
      self.init = function(service, options, chatContainer = '#candy') {
        if (!options.viewClass) {
          options.viewClass = self.View
        }
        options.viewClass.init($(chatContainer), options.view);
        self.Core.init(service, options.core)
      };
      return self
    }(Candy || {}, jQueryCandyInstance));
  Candy.Core = (function(self, Strophe, $) {
    var _connection = null,
      _service = null,
      _user = null,
      _rooms = {},
      _anonymousConnection = false,
      _status,
      _options = {
        autojoin: undefined, disconnectWithoutTabs: true, debug: false, disableWindowUnload: false, presencePriority: 1, resource: Candy.about.name
      },
      _addNamespace = function(name, value) {
        Strophe.addNamespace(name, value)
      },
      _addNamespaces = function() {
        _addNamespace('PRIVATE', 'jabber:iq:private');
        _addNamespace('BOOKMARKS', 'storage:bookmarks');
        _addNamespace('PRIVACY', 'jabber:iq:privacy');
        _addNamespace('DELAY', 'jabber:x:delay');
        _addNamespace('PUBSUB', 'http://jabber.org/protocol/pubsub')
      },
      _getEscapedJidFromJid = function(jid) {
        var node = Strophe.getNodeFromJid(jid),
          domain = Strophe.getDomainFromJid(jid);
        return node ? Strophe.escapeNode(node) + '@' + domain : domain
      },
      _clearCache = function() {
        var jid = Candy.Core.getConnection().jid;
        if (jid) {
          window.sessionStorage.removeItem('candy-cache-' + jid)
        }
      },
      _updateCache = function() {
        var jid = Candy.Core.getConnection().jid;
        if (jid && _user) {
          window.sessionStorage.setItem('candy-cache-' + jid, JSON.stringify({
            nick: _user.getNick(), rooms: _rooms
          }))
        }
      };
    self.init = function(service, options) {
      _service = service;
      $.extend(true, _options, options);
      if (_options.debug) {
        if (_options.debug.toString().indexOf("verbose") > -1) {
          self.debug = function(message) {
            var args = [];
            args.push('[Debug]');
            args.push('[Candy]');
            Array.prototype.push.apply(args, arguments);
            console.debug.apply(console, args)
          }
        }
        else {
          self.debug = function(message){}
        }
        if (_options.debug.toString().indexOf("xml") > -1) {
          self.xml = function(info, data) {
            data = $.parseXML(data);
            if (info) {
              console.debug(info, data)
            }
            else {
              console.debug(data)
            }
          }
        }
        else {
          self.xml = function(info, data){}
        }
        self.log = function(message) {
          var args = [];
          args.push('[Info]');
          args.push('[Candy]');
          Array.prototype.push.apply(args, arguments);
          console.log.apply(console, args)
        };
        Strophe.log = function(level, message) {
          var level_name,
            console_level;
          switch (level) {
            case Strophe.LogLevel.DEBUG:
              if (_options.debug.toString().indexOf("http") >= 0) {
                level_name = "Debug";
                console_level = "debug"
              }
              else
                return;
              break;
            case Strophe.LogLevel.INFO:
              level_name = "Info";
              console_level = "log";
              break;
            case Strophe.LogLevel.WARN:
              level_name = "WARN";
              console_level = "warn";
              break;
            case Strophe.LogLevel.ERROR:
              level_name = "ERROR";
              console_level = "error";
              break;
            case Strophe.LogLevel.FATAL:
              level_name = "FATAL";
              console_level = "error";
              break
          }
          var args = Array.prototype.slice.call(arguments, 1);
          args.unshift('[Strophe]', '[' + level_name + ']');
          try {
            console[console_level].apply(console, args)
          }
          catch(error) {}
        };
        self.debug('[Init] Debugging enabled')
      }
      _addNamespaces();
      _connection = new Strophe.Connection(_service, {
        keepalive: true, mechanisms: [Strophe.SASLAnonymous]
      });
      _connection.rawInput = self.rawInput.bind(self);
      _connection.rawOutput = self.rawOutput.bind(self);
      _connection.caps.node = 'https://candy-chat.github.io/candy/';
      if (!_options.disableWindowUnload) {
        window.onbeforeunload = self.onWindowUnload
      }
    };
    self.registerEventHandlers = function() {
      self.addHandler(self.Event.Jabber.Version, Strophe.NS.VERSION, 'iq');
      self.addHandler(self.Event.Jabber.Presence, null, 'presence');
      self.addHandler(self.Event.Jabber.Message, null, 'message');
      self.addHandler(self.Event.Jabber.Bookmarks, Strophe.NS.PRIVATE, 'iq');
      self.addHandler(self.Event.Jabber.Room.Disco, Strophe.NS.DISCO_INFO, 'iq', 'result')
    };
    self.connect = function(jidOrHost, password, nick) {
      _connection.reset();
      self.registerEventHandlers();
      $(Candy).triggerHandler('candy:core.before-connect', {connection: _connection});
      if (_connection.isRestoreSupported()) {
        if (_connection.isRestorable(null, 90)) {
          this.debug("Restoring session");
          var session = _connection.restore(null, Candy.Core.Event.Strophe.Connect);
          this.debug("Restoring cache");
          try {
            var cache = JSON.parse(window.sessionStorage.getItem('candy-cache-' + session.jid));
            if (typeof cache !== typeof undefined && cache !== null) {
              _user = new self.ChatUser(session.jid, cache.nick || nick || Strophe.getNodeFromJid(session.jid));
              for (var roomJid in cache.rooms) {
                var room = new Candy.Core.ChatRoom(roomJid);
                room.setUser(Candy.Core.getUser());
                _rooms[roomJid] = room;
                Candy.Core.Action.Jabber.Room.Disco(roomJid);
                Candies.getRoomHistory(roomJid)
              }
            }
            else {
              this.log("No restorable cache")
            }
          }
          catch(e) {
            this.log("Invalid cache content");
            this.log(e);
            _clearCache()
          }
          return
        }
        else {
          this.log("No restorable session");
          _clearCache()
        }
      }
      else {
        this.debug("Sessions not restorable in this configuration")
      }
      _anonymousConnection = !_anonymousConnection ? jidOrHost && jidOrHost.indexOf("@") < 0 : true;
      if (jidOrHost && password) {
        _connection.connect(_getEscapedJidFromJid(jidOrHost) + '/' + _options.resource, password, Candy.Core.Event.Strophe.Connect);
        if (nick) {
          _user = new self.ChatUser(jidOrHost, nick)
        }
        else {
          _user = new self.ChatUser(jidOrHost, Strophe.getNodeFromJid(jidOrHost))
        }
      }
      else if (jidOrHost && nick) {
        _connection.connect(_getEscapedJidFromJid(jidOrHost) + '/' + _options.resource, null, Candy.Core.Event.Strophe.Connect);
        _user = new self.ChatUser(null, nick)
      }
      else if (jidOrHost) {
        Candy.Core.Event.Login(jidOrHost)
      }
      else {
        Candy.Core.Event.Login()
      }
    };
    self.attach = function(jid, sid, rid) {
      _user = new self.ChatUser(jid, Strophe.getNodeFromJid(jid));
      self.registerEventHandlers();
      _connection.attach(jid, sid, rid, Candy.Core.Event.Strophe.Connect)
    };
    self.disconnect = function() {
      if (_connection.connected) {
        _clearCache();
        $.each(self.getRooms(), function() {
          Candy.Core.Action.Jabber.Room.Leave(this.getJid())
        });
        _connection.disconnect()
      }
    };
    self.addHandler = function(handler, ns, name, type, id, from, options) {
      return _connection.addHandler(handler, ns, name, type, id, from, options)
    };
    self.getUser = function() {
      return _user
    };
    self.setUser = function(user) {
      _user = user;
      _updateCache()
    };
    self.getConnection = function() {
      return _connection
    };
    self.removeRoom = function(roomJid) {
      delete _rooms[roomJid]
    };
    self.getRooms = function() {
      return _rooms
    };
    self.getStropheStatus = function() {
      return _status
    };
    self.setStropheStatus = function(status) {
      _status = status
    };
    self.isAnonymousConnection = function() {
      return _anonymousConnection
    };
    self.getOptions = function() {
      return _options
    };
    self.getRoom = function(roomJid) {
      if (_rooms[roomJid]) {
        return _rooms[roomJid]
      }
      return null
    };
    self.onWindowUnload = function() {
      return;
      var retry = false;
      _connection.options.sync = false;
      try {
        self.disconnect();
        _connection.flush()
      }
      catch(e) {
        retry = true
      }
      if (retry) {
        _connection.options.sync = true;
        try {
          self.disconnect();
          _connection.flush()
        }
        catch(e) {}
      }
    };
    self.rawInput = function(data) {
      this.xml('RECV:', data)
    };
    self.rawOutput = function(data) {
      this.xml('SENT:', data)
    };
    self.clearCache = function() {
      _clearCache()
    };
    self.updateCache = function() {
      _updateCache()
    };
    self.debug = function(message){};
    self.log = function(message){};
    self.xml = function(info, data){};
    return self
  }(Candy.Core || {}, Strophe, jQueryCandyInstance));
  Candy.View = (function(self, $) {
    var _current = {
        container: null, roomJid: null
      },
      _options = {
        language: 'en', assets: 'res/', messages: {
            limit: 2000, remove: 500
          }, crop: {
            message: {
              nickname: 15, body: 1000
            }, roster: {nickname: 15}
          }, enableXHTML: false
      },
      _setupTranslation = function(language) {
        $.i18n.load(self.Translation[language])
      },
      _registerObservers = function() {
        $(Candy).on('candy:core.chat.connection', self.Observer.Chat.Connection);
        $(Candy).on('candy:core.chat.message', self.Observer.Chat.Message);
        $(Candy).on('candy:core.login', self.Observer.Login);
        $(Candy).on('candy:core.autojoin-missing', self.Observer.AutojoinMissing);
        $(Candy).on('candy:core.presence', self.Observer.Presence.update);
        $(Candy).on('candy:core.presence.leave', self.Observer.Presence.update);
        $(Candy).on('candy:core.presence.room', self.Observer.Presence.update);
        $(Candy).on('candy:core.presence.error', self.Observer.PresenceError);
        $(Candy).on('candy:core.message', self.Observer.Message)
      },
      _registerWindowHandlers = function() {
        if (Candy.Util.getIeVersion() < 9) {
          $(document).focusin(Candy.View.Pane.Window.onFocus).focusout(Candy.View.Pane.Window.onBlur)
        }
        else {
          $(window).focus(Candy.View.Pane.Window.onFocus).blur(Candy.View.Pane.Window.onBlur)
        }
        $(window).resize(Candy.View.Pane.Chat.fitTabs)
      },
      _initToolbar = function() {
        self.Pane.Chat.Toolbar.init()
      },
      _delegateTooltips = function() {
        $('body').delegate('li[data-tooltip]', 'mouseenter', Candy.View.Pane.Chat.Tooltip.show)
      };
    self.init = function(container, options) {
      if (options.resources) {
        options.assets = options.resources;
        delete options.resources
      }
      $.extend(true, _options, options);
      _setupTranslation(_options.language);
      Candy.Util.Parser.setEmoticonPath('img/emoticons/');
      _current.container = container;
      _current.container.html(Mustache.to_html(Candy.View.Template.Chat.pane, {
        tooltipEmoticons: $.i18n._('tooltipEmoticons'), tooltipSound: $.i18n._('tooltipSound'), tooltipAutoscroll: $.i18n._('tooltipAutoscroll'), tooltipStatusmessage: $.i18n._('tooltipStatusmessage'), tooltipAdministration: $.i18n._('tooltipAdministration'), tooltipUsercount: $.i18n._('tooltipUsercount')
      }, {
        tabs: Candy.View.Template.Chat.tabs, rooms: Candy.View.Template.Chat.rooms, modal: Candy.View.Template.Chat.modal, toolbar: Candy.View.Template.Chat.toolbar
      }));
      _registerWindowHandlers();
      _initToolbar();
      _registerObservers();
      _delegateTooltips()
    };
    self.getCurrent = function() {
      return _current
    };
    self.getOptions = function() {
      return _options
    };
    return self
  }(Candy.View || {}, jQueryCandyInstance));
  Candy.Util = (function(self, $) {
    self.jidToId = function(jid) {
      return MD5.hexdigest(jid)
    };
    self.escapeJid = function(jid) {
      var node = Strophe.escapeNode(Strophe.getNodeFromJid(jid)),
        domain = Strophe.getDomainFromJid(jid),
        resource = Strophe.getResourceFromJid(jid);
      jid = node + '@' + domain;
      if (resource) {
        jid += '/' + resource
      }
      return jid
    };
    self.unescapeJid = function(jid) {
      var node = Strophe.unescapeNode(Strophe.getNodeFromJid(jid)),
        domain = Strophe.getDomainFromJid(jid),
        resource = Strophe.getResourceFromJid(jid);
      jid = node + '@' + domain;
      if (resource) {
        jid += '/' + resource
      }
      return jid
    };
    self.crop = function(str, len) {
      if (str.length > len) {
        str = str.substr(0, len - 3) + '...'
      }
      return str
    };
    self.getDisplayName = function(nick) {
      var name = Strophe.unescapeNode(nick);
      if (name.lastIndexOf('_') > 0) {
        return name.substring(0, name.lastIndexOf('_'))
      }
      return name
    };
    self.parseAndCropXhtml = function(str, len) {
      return $('<div/>').append(self.createHtml($(str).get(0), len)).html()
    };
    self.setCookie = function(name, value, lifetime_days) {
      var exp = new Date;
      exp.setDate(exp.getDate() + lifetime_days);
      document.cookie = name + '=' + value + ';expires=' + exp.toUTCString() + ';path=/'
    };
    self.cookieExists = function(name) {
      return document.cookie.indexOf(name) > -1
    };
    self.getCookie = function(name) {
      if (document.cookie) {
        var regex = new RegExp(escape(name) + '=([^;]*)', 'gm'),
          matches = regex.exec(document.cookie);
        if (matches) {
          return matches[1]
        }
      }
    };
    self.deleteCookie = function(name) {
      document.cookie = name + '=;expires=Thu, 01-Jan-70 00:00:01 GMT;path=/'
    };
    self.getPosLeftAccordingToWindowBounds = function(elem, pos) {
      var windowWidth = $(document).width(),
        elemWidth = elem.outerWidth(),
        marginDiff = elemWidth - elem.outerWidth(true),
        backgroundPositionAlignment = 'left',
        parentOffset = $(document).find("#candy").length > 0 ? $("#candy").offset().left : 0;
      if (pos + elemWidth >= windowWidth) {
        pos -= elemWidth - marginDiff;
        backgroundPositionAlignment = 'right'
      }
      return {
          px: pos - parentOffset, backgroundPositionAlignment: backgroundPositionAlignment
        }
    };
    self.getPosTopAccordingToWindowBounds = function(elem, pos) {
      var windowHeight = $(document).height(),
        elemHeight = elem.outerHeight(),
        marginDiff = elemHeight - elem.outerHeight(true),
        backgroundPositionAlignment = 'top',
        parentOffset = $(document).find("#candy").length > 0 ? $("#candy").offset().top : 0;
      if (pos + elemHeight >= windowHeight) {
        pos -= elemHeight - marginDiff;
        backgroundPositionAlignment = 'bottom'
      }
      return {
          px: pos - parentOffset, backgroundPositionAlignment: backgroundPositionAlignment
        }
    };
    self.localizedTime = function(dateTime) {
      if (dateTime === undefined) {
        return undefined
      }
      var date = self.iso8601toDate(dateTime);
      if (date.toDateString() === (new Date).toDateString()) {
        return date.format($.i18n._('timeFormat'))
      }
      else {
        return date.format($.i18n._('dateFormat'))
      }
    };
    self.iso8601toDate = function(date) {
      var timestamp = Date.parse(date);
      if (isNaN(timestamp)) {
        var struct = /^(\d{4}|[+\-]\d{6})-(\d{2})-(\d{2})(?:[T ](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?))?/.exec(date);
        if (struct) {
          var minutesOffset = 0;
          if (struct[8] !== 'Z') {
            minutesOffset = +struct[10] * 60 + (+struct[11]);
            if (struct[9] === '+') {
              minutesOffset = -minutesOffset
            }
          }
          minutesOffset -= (new Date).getTimezoneOffset();
          return new Date(+struct[1], +struct[2] - 1, +struct[3], +struct[4], +struct[5] + minutesOffset, +struct[6], struct[7] ? +struct[7].substr(0, 3) : 0)
        }
        else {
          timestamp = Date.parse(date.replace(/^(\d{4})(\d{2})(\d{2})/, '$1-$2-$3') + 'Z')
        }
      }
      return new Date(timestamp)
    };
    self.isEmptyObject = function(obj) {
      var prop;
      for (prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false
        }
      }
      return true
    };
    self.forceRedraw = function(elem) {
      elem.css({display: 'none'});
      setTimeout(function() {
        this.css({display: 'block'})
      }.bind(elem), 1)
    };
    var ie = (function() {
        var undef,
          v = 3,
          div = document.createElement('div'),
          all = div.getElementsByTagName('i');
        while (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->', all[0]) {}
        return v > 4 ? v : undef
      }());
    self.getIeVersion = function() {
      return ie
    };
    self.Parser = {
      _emoticonPath: '', setEmoticonPath: function(path) {
          if (!Candy.View.getOptions().assets)
            return;
          this._emoticonPath = Candy.View.getOptions().assets + path
        }, emoticons: [{
            plain: ':)', regex: /((\s):-?\)|:-?\)(\s|$))/gm, image: 'Smiling.png'
          }, {
            plain: ';)', regex: /((\s);-?\)|;-?\)(\s|$))/gm, image: 'Winking.png'
          }, {
            plain: ':D', regex: /((\s):-?D|:-?D(\s|$))/gm, image: 'Grinning.png'
          }, {
            plain: 'XD', regex: /((\s)XD|XD(\s|$))/gm, image: 'Laughing.png'
          }, {
            plain: ':(', regex: /((\s):-?\(|:-?\((\s|$))/gm, image: 'Unhappy.png'
          }, {
            plain: '^^', regex: /((\s)\^\^|\^\^(\s|$))/gm, image: 'Happy.png'
          }, {
            plain: ':P', regex: /((\s):-?P|:-?P(\s|$))/igm, image: 'Tease.png'
          }, {
            plain: ';P', regex: /((\s);-?P|;-?P(\s|$))/igm, image: 'Tongue_Out_Winking.png'
          }, {
            plain: ':S', regex: /((\s):-?S|:-?S(\s|$))/igm, image: 'Confused.png'
          }, {
            plain: ':/', regex: /((\s):-?\/|:-?\/(\s|$))/gm, image: 'Uncertain.png'
          }, {
            plain: '8)', regex: /((\s)8-?\)|8-?\)(\s|$))/gm, image: 'Cool.png'
          }, {
            plain: ':OK:', regex: /((\s):OK:|:OK:(\s|$))/gm, image: 'Thumb_Up.png'
          }, {
            plain: 'oO', regex: /((\s)oO|oO(\s|$))/gm, image: 'Huh.png'
          }, {
            plain: ':x', regex: /((\s):x|:x(\s|$))/gm, image: 'Lips_Sealed.png'
          }, {
            plain: ':666:', regex: /((\s):666:|:666:(\s|$))/gm, image: 'Devil.png'
          }, {
            plain: '<3', regex: /((\s)&lt;3|&lt;3(\s|$))/gm, image: 'Heart.png'
          }], emotify: function(text) {
          if (!Candy.View.getOptions().assets)
            return text;
          var i;
          for (i = this.emoticons.length - 1; i >= 0; i--) {
            text = text.replace(this.emoticons[i].regex, '$2<img class="emoticon" alt="$1" src="' + this._emoticonPath + this.emoticons[i].image + '" />$3')
          }
          return text
        }, linkify: function(text) {
          text = text.replace(/(^|[^\/])(www\.[^\.]+\.[\S]+(\b|$))/gi, '$1http://$2');
          return text.replace(/(\b(https?|ftp|file):\/\/[\-A-Z0-9+&@#\/%?=~_|!:,.;]*[\-A-Z0-9+&@#\/%=~_|])/ig, '<a href="$1" target="_blank">$1</a>')
        }, escape: function(text) {
          return $('<div/>').text(text).html()
        }, nl2br: function(text) {
          return text.replace(/\r\n|\r|\n/g, '<br />')
        }, all: function(text) {
          if (text) {
            text = this.escape(text);
            text = this.linkify(text);
            text = this.emotify(text);
            text = this.nl2br(text)
          }
          return text
        }
    };
    self.createHtml = function(elem, maxLength, currentLength) {
      currentLength = currentLength || 0;
      var i,
        el,
        j,
        tag,
        attribute,
        value,
        css,
        cssAttrs,
        attr,
        cssName,
        cssValue;
      if (elem.nodeType === Strophe.ElementType.NORMAL) {
        tag = elem.nodeName.toLowerCase();
        if (Strophe.XHTML.validTag(tag)) {
          try {
            el = $('<' + tag + '/>');
            for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {
              attribute = Strophe.XHTML.attributes[tag][i];
              value = elem.getAttribute(attribute);
              if (typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {
                continue
              }
              if (attribute === 'style' && typeof value === 'object') {
                if (typeof value.cssText !== 'undefined') {
                  value = value.cssText
                }
              }
              if (attribute === 'style') {
                css = [];
                cssAttrs = value.split(';');
                for (j = 0; j < cssAttrs.length; j++) {
                  attr = cssAttrs[j].split(':');
                  cssName = attr[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                  if (Strophe.XHTML.validCSS(cssName)) {
                    cssValue = attr[1].replace(/^\s*/, "").replace(/\s*$/, "");
                    css.push(cssName + ': ' + cssValue)
                  }
                }
                if (css.length > 0) {
                  value = css.join('; ');
                  el.attr(attribute, value)
                }
              }
              else {
                el.attr(attribute, value)
              }
            }
            for (i = 0; i < elem.childNodes.length; i++) {
              el.append(self.createHtml(elem.childNodes[i], maxLength, currentLength))
            }
          }
          catch(e) {
            Candy.Core.log("[Util:createHtml] Error while parsing XHTML:");
            Candy.Core.log(e);
            el = Strophe.xmlTextNode('')
          }
        }
        else {
          el = Strophe.xmlGenerator().createDocumentFragment();
          for (i = 0; i < elem.childNodes.length; i++) {
            el.appendChild(self.createHtml(elem.childNodes[i], maxLength, currentLength))
          }
        }
      }
      else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {
        el = Strophe.xmlGenerator().createDocumentFragment();
        for (i = 0; i < elem.childNodes.length; i++) {
          el.appendChild(self.createHtml(elem.childNodes[i], maxLength, currentLength))
        }
      }
      else if (elem.nodeType === Strophe.ElementType.TEXT) {
        var text = elem.nodeValue;
        currentLength += text.length;
        if (maxLength && currentLength > maxLength) {
          text = text.substring(0, maxLength)
        }
        text = Candy.Util.Parser.all(text);
        el = $.parseHTML(text)
      }
      return el
    };
    return self
  }(Candy.Util || {}, jQueryCandyInstance));
  Candy.Core.Action = (function(self, Strophe, $) {
    self.Jabber = {
      Version: function(msg) {
        Candy.Core.getConnection().sendIQ($iq({
          type: 'result', to: Candy.Util.escapeJid(msg.attr('from')), from: Candy.Util.escapeJid(msg.attr('to')), id: msg.attr('id')
        }).c('query', {
          name: Candy.about.name, version: Candy.about.version, os: navigator.userAgent
        }))
      }, SetNickname: function(nickname, rooms) {
          rooms = rooms instanceof Array ? rooms : Candy.Core.getRooms();
          var roomNick,
            presence,
            conn = Candy.Core.getConnection();
          $.each(rooms, function(roomJid) {
            roomNick = Candy.Util.escapeJid(roomJid + '/' + nickname);
            presence = $pres({
              to: roomNick, from: conn.jid, id: 'pres:' + conn.getUniqueId()
            });
            Candy.Core.getConnection().send(presence)
          })
        }, Roster: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'get', xmlns: Strophe.NS.CLIENT
          }).c('query', {xmlns: Strophe.NS.ROSTER}).tree())
        }, Presence: function(attr, el) {
          var conn = Candy.Core.getConnection();
          attr = attr || {};
          if (!attr.id) {
            attr.id = 'pres:' + conn.getUniqueId()
          }
          var pres = $pres(attr).c('priority').t(Candy.Core.getOptions().presencePriority.toString()).up().c('c', conn.caps.generateCapsAttrs()).up();
          if (el) {
            pres.node.appendChild(el.node)
          }
          conn.send(pres.tree())
        }, Services: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'get', xmlns: Strophe.NS.CLIENT
          }).c('query', {xmlns: Strophe.NS.DISCO_ITEMS}).tree())
        }, Autojoin: function() {
          if (Candy.Core.getOptions().autojoin === true) {
            Candy.Core.getConnection().sendIQ($iq({
              type: 'get', xmlns: Strophe.NS.CLIENT
            }).c('query', {xmlns: Strophe.NS.PRIVATE}).c('storage', {xmlns: Strophe.NS.BOOKMARKS}).tree());
            var pubsubBookmarkRequest = Candy.Core.getConnection().getUniqueId('pubsub');
            Candy.Core.addHandler(Candy.Core.Event.Jabber.Bookmarks, Strophe.NS.PUBSUB, 'iq', 'result', pubsubBookmarkRequest);
            Candy.Core.getConnection().sendIQ($iq({
              type: 'get', id: pubsubBookmarkRequest
            }).c('pubsub', {xmlns: Strophe.NS.PUBSUB}).c('items', {node: Strophe.NS.BOOKMARKS}).tree())
          }
          else if ($.isArray(Candy.Core.getOptions().autojoin)) {
            $.each(Candy.Core.getOptions().autojoin, function() {
              self.Jabber.Room.Join.apply(null, this.valueOf().split(':', 2))
            })
          }
          else {
            $(Candy).triggerHandler('candy:core.autojoin-missing')
          }
        }, ResetIgnoreList: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'set', from: Candy.Core.getUser().getEscapedJid()
          }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('list', {name: 'ignore'}).c('item', {
            action: 'allow', order: '0'
          }).tree())
        }, RemoveIgnoreList: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'set', from: Candy.Core.getUser().getEscapedJid()
          }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('list', {name: 'ignore'}).tree())
        }, GetIgnoreList: function() {
          var iq = $iq({
              type: 'get', from: Candy.Core.getUser().getEscapedJid()
            }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('list', {name: 'ignore'}).tree();
          var iqId = Candy.Core.getConnection().sendIQ(iq);
          Candy.Core.addHandler(Candy.Core.Event.Jabber.PrivacyList, null, 'iq', null, iqId)
        }, SetIgnoreListActive: function() {
          Candy.Core.getConnection().sendIQ($iq({
            type: 'set', from: Candy.Core.getUser().getEscapedJid()
          }).c('query', {xmlns: Strophe.NS.PRIVACY}).c('active', {name: 'ignore'}).tree())
        }, GetJidIfAnonymous: function() {
          if (!Candy.Core.getUser().getJid()) {
            Candy.Core.debug("[Jabber] Anonymous login");
            Candy.Core.getUser().data.jid = Candy.Core.getConnection().jid
          }
        }, Room: {
          Join: function(roomJid, password) {
            self.Jabber.Room.Disco(roomJid);
            roomJid = Candy.Util.escapeJid(roomJid);
            var conn = Candy.Core.getConnection(),
              roomNick = roomJid + '/' + Candy.Core.getUser().getNick(),
              pres = $pres({
                to: roomNick, id: 'pres:' + conn.getUniqueId()
              }).c('x', {xmlns: Strophe.NS.MUC});
            if (password) {
              pres.c('password').t(password)
            }
            pres.up().c('c', conn.caps.generateCapsAttrs());
            conn.send(pres.tree())
          }, Leave: function(roomJid) {
              var room = Candy.Core.getRoom(roomJid);
              if (room) {
                var user = room.getUser();
                if (user) {
                  roomJid = Candy.Util.escapeJid(roomJid);
                  Candy.Core.getConnection().muc.leave(roomJid, user.getNick(), function(){})
                }
              }
            }, Disco: function(roomJid) {
              Candy.Core.getConnection().sendIQ($iq({
                type: 'get', from: Candy.Core.getUser().getEscapedJid(), to: Candy.Util.escapeJid(roomJid)
              }).c('query', {xmlns: Strophe.NS.DISCO_INFO}).tree())
            }, Message: function(roomJid, msg, type, xhtmlMsg, source) {
              msg = $.trim(msg);
              if (msg === '') {
                return false
              }
              var nick = null;
              if (type === 'chat') {
                nick = Strophe.getResourceFromJid(roomJid);
                roomJid = Strophe.getBareJidFromJid(roomJid)
              }
              Candy.Core.getConnection().muc.message(roomJid, nick, msg, xhtmlMsg, type, source);
              return true
            }, Invite: function(roomJid, invitees, reason, password) {
              reason = $.trim(reason);
              var message = $msg({to: roomJid});
              var x = message.c('x', {xmlns: Strophe.NS.MUC_USER});
              $.each(invitees, function(i, invitee) {
                invitee = Strophe.getBareJidFromJid(invitee);
                x.c('invite', {to: invitee});
                if (typeof reason !== 'undefined' && reason !== '') {
                  x.c('reason', reason)
                }
              });
              if (typeof password !== 'undefined' && password !== '') {
                x.c('password', password)
              }
              Candy.Core.getConnection().send(message)
            }, IgnoreUnignore: function(userJid) {
              Candy.Core.getUser().addToOrRemoveFromPrivacyList('ignore', userJid);
              Candy.Core.Action.Jabber.Room.UpdatePrivacyList()
            }, UpdatePrivacyList: function() {
              var currentUser = Candy.Core.getUser(),
                iq = $iq({
                  type: 'set', from: currentUser.getEscapedJid()
                }).c('query', {xmlns: 'jabber:iq:privacy'}).c('list', {name: 'ignore'}),
                privacyList = currentUser.getPrivacyList('ignore');
              if (privacyList.length > 0) {
                $.each(privacyList, function(index, jid) {
                  iq.c('item', {
                    type: 'jid', value: Candy.Util.escapeJid(jid), action: 'deny', order: index
                  }).c('message').up().up()
                })
              }
              else {
                iq.c('item', {
                  action: 'allow', order: '0'
                })
              }
              Candy.Core.getConnection().sendIQ(iq.tree())
            }, Admin: {
              UserAction: function(roomJid, userJid, type, reason) {
                roomJid = Candy.Util.escapeJid(roomJid);
                userJid = Candy.Util.escapeJid(userJid);
                var itemObj = {nick: Strophe.getResourceFromJid(userJid)};
                switch (type) {
                  case'kick':
                    itemObj.role = 'none';
                    break;
                  case'ban':
                    itemObj.affiliation = 'outcast';
                    break;
                  default:
                    return false
                }
                Candy.Core.getConnection().sendIQ($iq({
                  type: 'set', from: Candy.Core.getUser().getEscapedJid(), to: roomJid
                }).c('query', {xmlns: Strophe.NS.MUC_ADMIN}).c('item', itemObj).c('reason').t(reason).tree());
                return true
              }, SetSubject: function(roomJid, subject) {
                  Candy.Core.getConnection().muc.setTopic(Candy.Util.escapeJid(roomJid), subject)
                }
            }
        }
    };
    return self
  }(Candy.Core.Action || {}, Strophe, jQueryCandyInstance));
  Candy.Core.ChatRoom = function(roomJid) {
    this.room = {
      jid: roomJid, name: Strophe.getNodeFromJid(roomJid)
    };
    this.user = null;
    this.roster = new Candy.Core.ChatRoster;
    this.setUser = function(user) {
      this.user = user;
      Candy.Core.updateCache()
    };
    this.getUser = function() {
      return this.user
    };
    this.getJid = function() {
      return this.room.jid
    };
    this.setName = function(name) {
      this.room.name = name;
      Candy.Core.updateCache()
    };
    this.getName = function() {
      return this.room.name
    };
    this.setRoster = function(roster) {
      this.roster = roster;
      Candy.Core.updateCache()
    };
    this.getRoster = function() {
      return this.roster
    }
  };
  Candy.Core.ChatRoster = function() {
    this.items = {};
    this.add = function(user) {
      this.items[user.getJid()] = user
    };
    this.remove = function(jid) {
      delete this.items[jid]
    };
    this.get = function(jid) {
      return this.items[jid]
    };
    this.getAll = function() {
      return this.items
    }
  };
  Candy.Core.ChatUser = function(jid, nick, affiliation, role) {
    this.ROLE_MODERATOR = 'moderator';
    this.AFFILIATION_OWNER = 'owner';
    this.data = {
      jid: jid, nick: Strophe.unescapeNode(nick), affiliation: affiliation, role: role, privacyLists: {}, customData: {}, previousNick: undefined
    };
    this.getJid = function() {
      if (this.data.jid) {
        return Candy.Util.unescapeJid(this.data.jid)
      }
      return
    };
    this.getEscapedJid = function() {
      return Candy.Util.escapeJid(this.data.jid)
    };
    this.setJid = function(jid) {
      this.data.jid = jid
    };
    this.getNick = function(display) {
      var name = Strophe.unescapeNode(this.data.nick);
      if (display && name.lastIndexOf('_') > 0) {
        return name.substring(0, name.lastIndexOf('_'))
      }
      return name
    };
    this.setNick = function(nick) {
      this.data.nick = nick
    };
    this.getRole = function() {
      return this.data.role
    };
    this.setRole = function(role) {
      this.data.role = role
    };
    this.setAffiliation = function(affiliation) {
      this.data.affiliation = affiliation
    };
    this.getAffiliation = function() {
      return this.data.affiliation
    };
    this.isModerator = function() {
      return this.getRole() === this.ROLE_MODERATOR || this.getAffiliation() === this.AFFILIATION_OWNER
    };
    this.addToOrRemoveFromPrivacyList = function(list, jid) {
      if (!this.data.privacyLists[list]) {
        this.data.privacyLists[list] = []
      }
      var index = -1;
      if ((index = this.data.privacyLists[list].indexOf(jid)) !== -1) {
        this.data.privacyLists[list].splice(index, 1)
      }
      else {
        this.data.privacyLists[list].push(jid)
      }
      return this.data.privacyLists[list]
    };
    this.getPrivacyList = function(list) {
      if (!this.data.privacyLists[list]) {
        this.data.privacyLists[list] = []
      }
      return this.data.privacyLists[list]
    };
    this.setPrivacyLists = function(lists) {
      this.data.privacyLists = lists
    };
    this.isInPrivacyList = function(list, jid) {
      if (!this.data.privacyLists[list]) {
        return false
      }
      return this.data.privacyLists[list].indexOf(jid) !== -1
    };
    this.setCustomData = function(data) {
      this.data.customData = data
    };
    this.getCustomData = function() {
      return this.data.customData
    };
    this.setPreviousNick = function(previousNick) {
      this.data.previousNick = previousNick
    };
    this.getPreviousNick = function() {
      return this.data.previousNick
    }
  };
  Candy.Core.Event = (function(self, Strophe, $) {
    self.Login = function(presetJid) {
      $(Candy).triggerHandler('candy:core.login', {presetJid: presetJid})
    };
    self.Strophe = {Connect: function(status) {
        Candy.Core.setStropheStatus(status);
        switch (status) {
          case Strophe.Status.CONNECTED:
            Candy.Core.log('[Connection] Connected');
            Candy.Core.Action.Jabber.GetJidIfAnonymous();
            Candy.Core.updateCache();
          case Strophe.Status.ATTACHED:
            Candy.Core.log('[Connection] Attached');
            Candy.Core.Action.Jabber.Presence();
            break;
          case Strophe.Status.DISCONNECTED:
            Candy.Core.log('[Connection] Disconnected');
            break;
          case Strophe.Status.AUTHFAIL:
            Candy.Core.log('[Connection] Authentication failed');
            Candy.Core.clearCache();
            break;
          case Strophe.Status.CONNECTING:
            Candy.Core.log('[Connection] Connecting');
            break;
          case Strophe.Status.DISCONNECTING:
            Candy.Core.log('[Connection] Disconnecting');
            Candy.Core.clearCache();
            break;
          case Strophe.Status.AUTHENTICATING:
            Candy.Core.log('[Connection] Authenticating');
            break;
          case Strophe.Status.ERROR:
          case Strophe.Status.CONNFAIL:
            Candy.Core.log('[Connection] Failed (' + status + ')');
            Candy.Core.clearCache();
            break;
          default:
            Candy.Core.log('[Connection] What?!');
            Candy.Core.clearCache();
            break
        }
        $(Candy).triggerHandler('candy:core.chat.connection', {status: status})
      }};
    self.Jabber = {
      Version: function(msg) {
        Candy.Core.debug('[Jabber] Version');
        Candy.Core.Action.Jabber.Version($(msg));
        return true
      }, Presence: function(msg) {
          Candy.Core.debug('[Jabber] Presence');
          msg = $(msg);
          if (msg.children('x[xmlns^="' + Strophe.NS.MUC + '"]').length > 0) {
            if (msg.attr('type') === 'error') {
              self.Jabber.Room.PresenceError(msg)
            }
            else {
              self.Jabber.Room.Presence(msg)
            }
          }
          else {
            $(Candy).triggerHandler('candy:core.presence', {
              from: msg.attr('from'), stanza: msg
            })
          }
          return true
        }, Bookmarks: function(msg) {
          Candy.Core.debug('[Jabber] Bookmarks');
          $('conference', msg).each(function() {
            var item = $(this);
            if (item.attr('autojoin')) {
              Candy.Core.Action.Jabber.Room.Join(item.attr('jid'))
            }
          });
          return true
        }, PrivacyList: function(msg) {
          Candy.Core.debug('[Jabber] PrivacyList');
          var currentUser = Candy.Core.getUser();
          msg = $(msg);
          if (msg.attr('type') === 'result') {
            $('list[name="ignore"] item', msg).each(function() {
              var item = $(this);
              if (item.attr('action') === 'deny') {
                currentUser.addToOrRemoveFromPrivacyList('ignore', item.attr('value'))
              }
            });
            Candy.Core.Action.Jabber.SetIgnoreListActive();
            return false
          }
          return self.Jabber.PrivacyListError(msg)
        }, PrivacyListError: function(msg) {
          if ($('error[code="503"][type="cancel"] service-unavailable', msg)) {
            return false
          }
          Candy.Core.log('[Jabber] PrivacyListError');
          if ($('error[code="404"][type="cancel"] item-not-found', msg)) {
            Candy.Core.Action.Jabber.ResetIgnoreList();
            Candy.Core.Action.Jabber.SetIgnoreListActive()
          }
          return false
        }, Message: function(msg) {
          Candy.Core.debug('[Jabber] Message');
          msg = $(msg);
          var fromJid = msg.attr('from'),
            type = msg.attr('type') || 'undefined',
            toJid = msg.attr('to');
          if (type === 'normal' || type === 'undefined') {
            var mediatedInvite = msg.find('invite'),
              directInvite = msg.find('x[xmlns="jabber:x:conference"]');
            if (mediatedInvite.length > 0) {
              var passwordNode = msg.find('password'),
                password = null,
                continueNode = mediatedInvite.find('continue'),
                continuedThread = null;
              if (passwordNode) {
                password = passwordNode.text()
              }
              if (continueNode) {
                continuedThread = continueNode.attr('thread')
              }
              $(Candy).triggerHandler('candy:core:chat:invite', {
                roomJid: fromJid, from: mediatedInvite.attr('from') || 'undefined', reason: mediatedInvite.find('reason') || '', password: password, continuedThread: continuedThread, inviteType: "MediatedInvite"
              })
            }
            if (directInvite.length > 0) {
              $(Candy).triggerHandler('candy:core:chat:invite', {
                roomJid: directInvite.attr('jid'), from: fromJid, reason: directInvite.attr('reason') || '', password: directInvite.attr('password'), continuedThread: directInvite.attr('thread'), inviteType: "DirectInvite"
              })
            }
            $(Candy).triggerHandler('candy:core:chat:message:normal', {
              type: (type || 'normal'), message: msg
            });
            return true
          }
          else if (type !== 'groupchat' && type !== 'chat' && type !== 'error' && type !== 'headline') {
            $(Candy).triggerHandler('candy:core:chat:message:other', {
              type: type, message: msg
            });
            return true
          }
          if (fromJid !== Strophe.getDomainFromJid(fromJid) && (type === 'groupchat' || type === 'chat' || type === 'error')) {
            self.Jabber.Room.Message(msg)
          }
          else if (!toJid && fromJid === Strophe.getDomainFromJid(fromJid)) {
            $(Candy).triggerHandler('candy:core.chat.message.admin', {
              type: (type || 'message'), message: msg.children('body').text()
            })
          }
          else if (toJid && fromJid === Strophe.getDomainFromJid(fromJid)) {
            $(Candy).triggerHandler('candy:core.chat.message.server', {
              type: (type || 'message'), subject: msg.children('subject').text(), message: msg.children('body').text()
            })
          }
          return true
        }, Room: {
          Leave: function(msg) {
            Candy.Core.debug('[Jabber:Room] Leave');
            msg = $(msg);
            var from = Candy.Util.unescapeJid(msg.attr('from')),
              roomJid = Strophe.getBareJidFromJid(from);
            if (!Candy.Core.getRoom(roomJid)) {
              return true
            }
            var roomName = Candy.Core.getRoom(roomJid).getName(),
              item = msg.find('item'),
              type = 'leave',
              reason,
              actor;
            delete Candy.Core.getRooms()[roomJid];
            Candy.Core.updateCache();
            if (item.attr('role') === 'none') {
              var code = msg.find('status').attr('code');
              if (code === '307') {
                type = 'kick'
              }
              else if (code === '301') {
                type = 'ban'
              }
              reason = item.find('reason').text();
              actor = item.find('actor').attr('jid')
            }
            var user = new Candy.Core.ChatUser(from, Strophe.getResourceFromJid(from), item.attr('affiliation'), item.attr('role'));
            $(Candy).triggerHandler('candy:core.presence.leave', {
              roomJid: roomJid, roomName: roomName, type: type, reason: reason, actor: actor, user: user
            });
            return true
          }, Disco: function(msg) {
              Candy.Core.debug('[Jabber:Room] Disco');
              msg = $(msg);
              if (!msg.find('identity[category="conference"]').length) {
                return true
              }
              var roomJid = Strophe.getBareJidFromJid(Candy.Util.unescapeJid(msg.attr('from')));
              if (!Candy.Core.getRooms()[roomJid]) {
                Candy.Core.getRooms()[roomJid] = new Candy.Core.ChatRoom(roomJid)
              }
              var identity = msg.find('identity');
              if (identity.length) {
                var roomName = identity.attr('name'),
                  room = Candy.Core.getRoom(roomJid);
                if (room.getName() === null) {
                  room.setName(Strophe.unescapeNode(roomName))
                }
              }
              Candy.Core.updateCache();
              return true
            }, Presence: function(msg) {
              Candy.Core.debug('[Jabber:Room] Presence');
              var from = Candy.Util.unescapeJid(msg.attr('from')),
                roomJid = Strophe.getBareJidFromJid(from),
                presenceType = msg.attr('type'),
                status = msg.find('status'),
                nickAssign = false,
                nickChange = false;
              if (status.length) {
                for (var i = 0, l = status.length; i < l; i++) {
                  var $status = $(status[i]),
                    code = $status.attr('code');
                  if (code === '303') {
                    nickChange = true
                  }
                  else if (code === '210') {
                    nickAssign = true
                  }
                }
              }
              var room = Candy.Core.getRoom(roomJid);
              if (!room) {
                Candy.Core.getRooms()[roomJid] = new Candy.Core.ChatRoom(roomJid);
                room = Candy.Core.getRoom(roomJid)
              }
              var currentUser = room.getUser() ? room.getUser() : Candy.Core.getUser();
              if (Strophe.getResourceFromJid(from) === currentUser.getNick() && presenceType === 'unavailable' && nickChange === false) {
                self.Jabber.Room.Leave(msg);
                return true
              }
              var roster = room.getRoster(),
                action,
                user,
                nick,
                item = msg.find('item');
              if (presenceType !== 'unavailable') {
                if (roster.get(from)) {
                  user = roster.get(from);
                  var role = item.attr('role'),
                    affiliation = item.attr('affiliation');
                  user.setRole(role);
                  user.setAffiliation(affiliation);
                  action = 'join'
                }
                else {
                  nick = Strophe.getResourceFromJid(from);
                  user = new Candy.Core.ChatUser(from, nick, item.attr('affiliation'), item.attr('role'));
                  if (room.getUser() === null && (Candy.Core.getUser().getNick() === nick || nickAssign)) {
                    room.setUser(user);
                    currentUser = user
                  }
                  roster.add(user);
                  action = 'join'
                }
              }
              else {
                user = roster.get(from);
                roster.remove(from);
                if (nickChange) {
                  nick = item.attr('nick');
                  action = 'nickchange';
                  user.setPreviousNick(user.getNick());
                  user.setNick(nick);
                  user.setJid(Strophe.getBareJidFromJid(from) + '/' + nick);
                  roster.add(user)
                }
                else {
                  action = 'leave';
                  if (item.attr('role') === 'none') {
                    if (msg.find('status').attr('code') === '307') {
                      action = 'kick'
                    }
                    else if (msg.find('status').attr('code') === '301') {
                      action = 'ban'
                    }
                  }
                }
              }
              $(Candy).triggerHandler('candy:core.presence.room', {
                roomJid: roomJid, roomName: room.getName(), user: user, action: action, currentUser: currentUser
              });
              Candy.Core.updateCache();
              return true
            }, PresenceError: function(msg) {
              Candy.Core.log('[Jabber:Room] Presence Error');
              var from = Candy.Util.unescapeJid(msg.attr('from')),
                roomJid = Strophe.getBareJidFromJid(from),
                room = Candy.Core.getRooms()[roomJid],
                roomName = room && room.getName() || null;
              Candy.Core.removeRoom(roomJid);
              room = undefined;
              $(Candy).triggerHandler('candy:core.presence.error', {
                msg: msg, type: msg.children('error').children()[0].tagName.toLowerCase(), roomJid: roomJid, roomName: roomName
              });
              return true
            }, Message: function(msg) {
              Candy.Core.debug('[Jabber:Room] Message');
              var roomJid,
                message,
                name;
              if (msg.children('subject').length > 0 && msg.children('subject').text().length > 0 && msg.attr('type') === 'groupchat') {
                roomJid = Candy.Util.unescapeJid(Strophe.getBareJidFromJid(msg.attr('from')));
                message = {
                  name: Strophe.getNodeFromJid(roomJid), body: msg.children('subject').text(), type: 'subject'
                }
              }
              else if (msg.attr('type') === 'error') {
                var error = msg.children('error');
                if (error.children('text').length > 0) {
                  roomJid = msg.attr('from');
                  message = {
                    type: 'info', body: error.children('text').text()
                  }
                }
              }
              else if (msg.children('composing').length > 0 || msg.children('inactive').length > 0 || msg.children('paused').length > 0 || msg.children('gone').length > 0) {
                var from = Candy.Util.unescapeJid(msg.attr("from"));
                roomJid = Strophe.getBareJidFromJid(from);
                name = Strophe.getResourceFromJid(from);
                var chatstate;
                if (msg.children('active').length > 0) {
                  chatstate = 'active'
                }
                else if (msg.children('composing').length > 0) {
                  chatstate = 'composing'
                }
                else if (msg.children('paused').length > 0) {
                  chatstate = 'paused'
                }
                else if (msg.children('inactive').length > 0) {
                  chatstate = 'inactive'
                }
                else if (msg.children('gone').length > 0) {
                  chatstate = 'gone'
                }
                $(Candy).triggerHandler('candy:core.message.chatstate', {
                  name: name, displayName: Candy.Util.getDisplayName(name), roomJid: roomJid, chatstate: chatstate
                });
                return true
              }
              else if (msg.children('body').length >= 0) {
                if (msg.attr('type') === 'chat' || msg.attr('type') === 'normal') {
                  roomJid = Candy.Util.unescapeJid(msg.attr('from'));
                  var bareRoomJid = Strophe.getBareJidFromJid(roomJid),
                    isNoConferenceRoomJid = !Candy.Core.getRoom(bareRoomJid);
                  name = isNoConferenceRoomJid ? Strophe.getNodeFromJid(roomJid) : Strophe.getResourceFromJid(roomJid);
                  message = {
                    name: name, body: msg.children('body').text(), type: msg.attr('type'), isNoConferenceRoomJid: isNoConferenceRoomJid
                  }
                }
                else {
                  roomJid = Candy.Util.unescapeJid(Strophe.getBareJidFromJid(msg.attr('from')));
                  var resource = Strophe.getResourceFromJid(msg.attr('from'));
                  if (resource) {
                    resource = Strophe.unescapeNode(resource);
                    message = {
                      name: resource, body: msg.children('body').text(), type: msg.attr('type')
                    }
                  }
                  else {
                    if (!Candy.View.Pane.Chat.rooms[msg.attr('from')]) {
                      return true
                    }
                    message = {
                      name: '', body: msg.children('body').text(), type: 'info'
                    }
                  }
                }
                var a = [];
                for (var i = 0; i < msg[0].attributes.length; i++) {
                  a.push(msg[0].attributes[i])
                }
                message.attributes = {};
                for (var i = 0; i < a.length; i++) {
                  message.attributes[a[i].name] = a[i].value
                }
                var xhtmlChild = msg.children('html[xmlns="' + Strophe.NS.XHTML_IM + '"]');
                if (Candy.View.getOptions().enableXHTML === true && xhtmlChild.length > 0) {
                  var xhtmlMessage = xhtmlChild.children('body[xmlns="' + Strophe.NS.XHTML + '"]').first().html();
                  message.xhtmlMessage = xhtmlMessage
                }
              }
              else {
                return true
              }
              var delay = msg.children('delay') ? msg.children('delay') : msg.children('x[xmlns="' + Strophe.NS.DELAY + '"]'),
                timestamp = delay !== undefined ? delay.attr('stamp') : null;
              $(Candy).triggerHandler('candy:core.message', {
                roomJid: roomJid, message: message, timestamp: timestamp
              });
              return true
            }
        }
    };
    return self
  }(Candy.Core.Event || {}, Strophe, jQueryCandyInstance));
  Candy.View.Observer = (function(self, $) {
    var _showConnectedMessageModal = true;
    self.Chat = {
      Connection: function(event, args) {
        var eventName = 'candy:view.connection.status-' + args.status;
        if ($(Candy).triggerHandler(eventName) === false) {
          return false
        }
        switch (args.status) {
          case Strophe.Status.CONNECTING:
          case Strophe.Status.AUTHENTICATING:
            Candy.View.Pane.Chat.Modal.show($.i18n._('statusConnecting'), false, true);
            break;
          case Strophe.Status.ATTACHED:
          case Strophe.Status.CONNECTED:
            if (_showConnectedMessageModal === true) {
              Candy.View.Pane.Chat.Modal.show($.i18n._('statusConnected'));
              Candy.View.Pane.Chat.Modal.hide()
            }
            break;
          case Strophe.Status.DISCONNECTING:
            Candy.View.Pane.Chat.Modal.show($.i18n._('statusDisconnecting'), false, true);
            break;
          case Strophe.Status.DISCONNECTED:
            var presetJid = Candy.Core.isAnonymousConnection() ? Strophe.getDomainFromJid(Candy.Core.getUser().getJid()) : null;
            Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('statusDisconnected'), presetJid);
            break;
          case Strophe.Status.AUTHFAIL:
            Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('statusAuthfail'));
            break;
          default:
            Candy.View.Pane.Chat.Modal.show($.i18n._('status', args.status));
            break
        }
      }, Message: function(event, args) {
          if (args.type === 'message') {
            Candy.View.Pane.Chat.adminMessage((args.subject || ''), args.message)
          }
          else if (args.type === 'chat' || args.type === 'groupchat') {
            Candy.View.Pane.Chat.onInfoMessage(Candy.View.getCurrent().roomJid, (args.subject || ''), args.message)
          }
        }
    };
    self.Presence = {
      update: function(event, args) {
        if (args.type === 'leave' || args.type === 'kick' || args.type === 'ban') {
          var evtData = {
              type: args.type, reason: args.reason, roomJid: args.roomJid, user: args.user
            };
          $(Candy).triggerHandler('candy:view.presence', [evtData])
        }
        else if (args.roomJid) {
          if (!args.user)
            return false;
          args.roomJid = Candy.Util.unescapeJid(args.roomJid);
          if (!Candy.View.Pane.Chat.rooms[args.roomJid]) {
            if (Candy.View.Pane.Room.init(args.roomJid, args.roomName) === false) {
              return false
            }
            if ($('#chat-rooms').children().length === 1) {
              Candy.View.Pane.Room.show(args.roomJid)
            }
          }
          Candy.View.Pane.Roster.update(args.roomJid, args.user, args.action, args.currentUser);
          if (Candy.View.Pane.Chat.rooms[args.user.getJid()] && args.action !== 'nickchange') {
            Candy.View.Pane.Roster.update(args.user.getJid(), args.user, args.action, args.currentUser);
            Candy.View.Pane.PrivateRoom.setStatus(args.user.getJid(), args.action)
          }
        }
      }, notifyPrivateChats: function(user, type) {
          Candy.Core.log('[View:Observer] notify Private Chats');
          var roomJid;
          for (roomJid in Candy.View.Pane.Chat.rooms) {
            if (Candy.View.Pane.Chat.rooms.hasOwnProperty(roomJid) && Candy.View.Pane.Room.getUser(roomJid) && user.getJid() === Candy.View.Pane.Room.getUser(roomJid).getJid()) {
              Candy.View.Pane.Roster.update(roomJid, user, type, user);
              Candy.View.Pane.PrivateRoom.setStatus(roomJid, type)
            }
          }
        }
    };
    self.PresenceError = function(obj, args) {
      switch (args.type) {
        case'not-authorized':
          var message;
          if (args.msg.children('x').children('password').length > 0) {
            message = $.i18n._('passwordEnteredInvalid', [args.roomName])
          }
          Candy.View.Pane.Chat.Modal.showEnterPasswordForm(args.roomJid, args.roomName, message);
          break;
        case'conflict':
          Candy.View.Pane.Chat.Modal.showNicknameConflictForm(args.roomJid);
          break;
        case'registration-required':
          Candy.View.Pane.Chat.Modal.showError('errorMembersOnly', [args.roomName]);
          break;
        case'service-unavailable':
          Candy.View.Pane.Chat.Modal.showError('errorMaxOccupantsReached', [args.roomName]);
          break
      }
    };
    self.Message = function(event, args) {
      if (!Candy.View.Pane.Chat.rooms[args.roomJid]) {
        Candy.View.Pane.Room.init(args.roomJid, args.message.name);
        Candy.View.Pane.Room.setUser(args.roomJid, Candy.Core.getUser());
        Candy.View.Pane.Room.show(args.roomJid)
      }
      if (args.message.type === 'subject') {
        Candy.View.Pane.Room.setSubject(args.roomJid, args.message.body)
      }
      else if (args.message.type === 'info') {
        Candy.View.Pane.Chat.infoMessage(args.roomJid, args.message.body)
      }
      else {
        if (args.message.type === 'chat' && !Candy.View.Pane.Chat.rooms[args.roomJid]) {
          Candy.View.Pane.PrivateRoom.open(args.roomJid, args.message.name, false, args.message.isNoConferenceRoomJid)
        }
        Candy.View.Pane.Message.show(args.roomJid, args.message.name, args.message.body, args.message.xhtmlMessage, args.timestamp, args.message.attributes)
      }
    };
    self.Login = function(event, args) {
      Candy.View.Pane.Chat.Modal.showLoginForm(null, args.presetJid)
    };
    self.AutojoinMissing = function() {
      _showConnectedMessageModal = false;
      Candy.View.Pane.Chat.Modal.showError('errorAutojoinMissing')
    };
    return self
  }(Candy.View.Observer || {}, jQueryCandyInstance));
  Candy.View.Pane = (function(self, $) {
    self.Window = {
      _hasFocus: true, _plainTitle: document.title, _unreadMessagesCount: 0, autoscroll: true, hasFocus: function() {
          return self.Window._hasFocus
        }, increaseUnreadMessages: function() {
          self.Window.renderUnreadMessages(++self.Window._unreadMessagesCount)
        }, reduceUnreadMessages: function(num) {
          self.Window._unreadMessagesCount -= num;
          if (self.Window._unreadMessagesCount <= 0) {
            self.Window.clearUnreadMessages()
          }
          else {
            self.Window.renderUnreadMessages(self.Window._unreadMessagesCount)
          }
        }, clearUnreadMessages: function() {
          self.Window._unreadMessagesCount = 0;
          document.title = self.Window._plainTitle
        }, renderUnreadMessages: function(count) {
          document.title = Candy.View.Template.Window.unreadmessages.replace('{{count}}', count).replace('{{title}}', self.Window._plainTitle)
        }, onFocus: function() {
          self.Window._hasFocus = true;
          if (Candy.View.getCurrent().roomJid) {
            self.Room.setFocusToForm(Candy.View.getCurrent().roomJid);
            self.Chat.clearUnreadMessages(Candy.View.getCurrent().roomJid)
          }
        }, onBlur: function() {
          self.Window._hasFocus = false
        }
    };
    self.Chat = {
      rooms: [], addTab: function(roomJid, roomName, roomType) {
          var roomId = Candy.Util.jidToId(roomJid),
            html = Mustache.to_html(Candy.View.Template.Chat.tab, {
              roomJid: roomJid, roomId: roomId, name: roomName || Strophe.getNodeFromJid(roomJid), privateUserChat: function() {
                  return roomType === 'chat'
                }, roomType: roomType
            }),
            tab = $(html).appendTo('#chat-tabs');
          tab.click(self.Chat.tabClick);
          $('a.close', tab).click(self.Chat.tabClose);
          self.Chat.clearUnreadMessages(roomJid);
          self.Chat.fitTabs()
        }, getTab: function(roomJid) {
          return $('#chat-tabs').children('li[data-roomjid="' + roomJid + '"]')
        }, removeTab: function(roomJid) {
          self.Chat.getTab(roomJid).remove();
          self.Chat.fitTabs()
        }, setActiveTab: function(roomJid) {
          $('#chat-tabs').children().each(function() {
            var tab = $(this);
            if (tab.attr('data-roomjid') === roomJid) {
              tab.addClass('active')
            }
            else {
              tab.removeClass('active')
            }
          })
        }, increaseUnreadMessages: function(roomJid) {
          var unreadElem = this.getTab(roomJid).find('.unread');
          unreadElem.show().text(unreadElem.text() !== '' ? parseInt(unreadElem.text(), 10) + 1 : 1);
          if (self.Chat.rooms[roomJid].type === 'chat') {
            self.Window.increaseUnreadMessages()
          }
        }, clearUnreadMessages: function(roomJid) {
          var unreadElem = self.Chat.getTab(roomJid).find('.unread');
          self.Window.reduceUnreadMessages(unreadElem.text());
          unreadElem.hide().text('')
        }, tabClick: function(e) {
          var currentRoomJid = Candy.View.getCurrent().roomJid;
          self.Chat.rooms[currentRoomJid].scrollPosition = self.Room.getPane(currentRoomJid, '.message-pane-wrapper').scrollTop();
          self.Room.show($(this).attr('data-roomjid'));
          e.preventDefault()
        }, tabClose: function() {
          var roomJid = $(this).parent().attr('data-roomjid');
          if (self.Chat.rooms[roomJid].type === 'chat') {
            self.Room.close(roomJid)
          }
          else {
            Candy.Core.Action.Jabber.Room.Leave(roomJid)
          }
          return false
        }, allTabsClosed: function() {
          self.Chat.Toolbar.hide();
          if (Candy.Core.getOptions().disconnectWithoutTabs) {
            Candy.Core.disconnect()
          }
        }, fitTabs: function() {
          var availableWidth = $('#chat-tabs').innerWidth(),
            tabsWidth = 0,
            tabs = $('#chat-tabs').children();
          tabs.each(function() {
            tabsWidth += $(this).css({
              width: 'auto', overflow: 'visible'
            }).outerWidth(true)
          });
          if (tabsWidth > availableWidth) {
            var tabDiffToRealWidth = tabs.outerWidth(true) - tabs.width(),
              tabWidth = Math.floor((availableWidth) / tabs.length) - tabDiffToRealWidth;
            tabs.css({
              width: tabWidth, overflow: 'hidden'
            })
          }
        }, adminMessage: function(subject, message) {
          if (Candy.View.getCurrent().roomJid) {
            var html = Mustache.to_html(Candy.View.Template.Chat.adminMessage, {
                subject: subject, message: message, sender: $.i18n._('administratorMessageSubject'), time: Candy.Util.localizedTime((new Date).toGMTString())
              });
            $('#chat-rooms').children().each(function() {
              self.Room.appendToMessagePane($(this).attr('data-roomjid'), html)
            });
            $(Candy).triggerHandler('candy:view.chat.admin-message', {
              subject: subject, message: message
            })
          }
        }, infoMessage: function(roomJid, subject, message) {
          self.Chat.onInfoMessage(roomJid, subject, message)
        }, onInfoMessage: function(roomJid, subject, message) {
          if (Candy.View.Pane.Room.getPane(roomJid)) {
            var html = Mustache.to_html(Candy.View.Template.Chat.infoMessage, {
                subject: subject, message: $.i18n._(message), time: Candy.Util.localizedTime((new Date).toGMTString())
              });
            self.Room.appendToMessagePane(roomJid, html)
          }
        }, Toolbar: {
          _supportsNativeAudio: null, init: function() {
              $('#emoticons-icon').click(function(e) {
                self.Chat.Context.showEmoticonsMenu(e.currentTarget);
                e.stopPropagation()
              });
              $('#chat-autoscroll-control').click(self.Chat.Toolbar.onAutoscrollControlClick);
              try {
                if (!!document.createElement("audio").canPlayType) {
                  var a = document.createElement("audio");
                  if (!!a.canPlayType("audio/mpeg;").replace(/no/, "")) {
                    self.Chat.Toolbar._supportsNativeAudio = "mp3"
                  }
                  else if (!!a.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, "")) {
                    self.Chat.Toolbar._supportsNativeAudio = "ogg"
                  }
                  else if (!!a.canPlayType('audio/mp4; codecs="mp4a.40.2"').replace(/no/, "")) {
                    self.Chat.Toolbar._supportsNativeAudio = "m4a"
                  }
                }
              }
              catch(e) {
                Candy.Core.log("[View:Pane:Toolbar] init error:");
                Candy.Core.log(e)
              }
              $("#chat-sound-control").click(self.Chat.Toolbar.onSoundControlClick);
              if (Candy.Util.cookieExists("candy-nosound")) {
                $("#chat-sound-control").click()
              }
              $('#chat-statusmessage-control').click(self.Chat.Toolbar.onStatusMessageControlClick);
              if (Candy.Util.cookieExists('candy-nostatusmessages')) {
                $('#chat-statusmessage-control').click()
              }
            }, show: function() {
              $('#chat-toolbar').show()
            }, hide: function() {
              $('#chat-toolbar').hide()
            }, update: function(roomJid) {
              var context = $('#chat-toolbar').find('.context'),
                me = self.Room.getUser(roomJid);
              if (!me || !me.isModerator()) {
                context.hide()
              }
              else {
                context.show().click(function(e) {
                  self.Chat.Context.show(e.currentTarget, roomJid);
                  e.stopPropagation()
                })
              }
              self.Chat.Toolbar.updateUsercount(self.Chat.rooms[roomJid].usercount)
            }, playSound: function(resource) {
              self.Chat.Toolbar.onPlaySound(resource)
            }, onPlaySound: function(resource) {
              if (!Candy.View.getOptions().assets)
                return;
              var filename = resource || "new_message";
              try {
                if (self.Chat.Toolbar._supportsNativeAudio !== null) {
                  new Audio(Candy.View.getOptions().assets + "sfx/" + filename + '.' + self.Chat.Toolbar._supportsNativeAudio).play()
                }
                else {
                  $("#chat-sound-control bgsound").remove();
                  $("<bgsound/>").attr({
                    src: Candy.View.getOptions().assets + "sfx/" + filename + ".mp3", loop: 1, autostart: true
                  }).appendTo("#chat-sound-control")
                }
              }
              catch(e) {
                Candy.Core.log("[View:Pane:Toolbar] onPlaySound error:");
                Candy.Core.log(e)
              }
            }, onSoundControlClick: function() {
              var control = $('#chat-sound-control');
              if (control.hasClass('checked')) {
                self.Chat.Toolbar.playSound = function(resource){};
                Candy.Util.setCookie('candy-nosound', '1', 365)
              }
              else {
                self.Chat.Toolbar.playSound = function(resource) {
                  self.Chat.Toolbar.onPlaySound(resource)
                };
                Candy.Util.deleteCookie('candy-nosound');
                self.Chat.Toolbar.playSound("toggle_on")
              }
              control.toggleClass('checked')
            }, onAutoscrollControlClick: function() {
              var control = $('#chat-autoscroll-control');
              if (control.hasClass('checked')) {
                self.Room.scrollToBottom = function(roomJid) {
                  self.Room.onScrollToStoredPosition(roomJid)
                };
                self.Window.autoscroll = false
              }
              else {
                self.Room.scrollToBottom = function(roomJid) {
                  self.Room.onScrollToBottom(roomJid)
                };
                self.Room.scrollToBottom(Candy.View.getCurrent().roomJid);
                self.Window.autoscroll = true
              }
              control.toggleClass('checked')
            }, onStatusMessageControlClick: function() {
              var control = $('#chat-statusmessage-control');
              if (control.hasClass('checked')) {
                self.Chat.infoMessage = function(){};
                Candy.Util.setCookie('candy-nostatusmessages', '1', 365)
              }
              else {
                self.Chat.infoMessage = function(roomJid, subject, message) {
                  self.Chat.onInfoMessage(roomJid, subject, message)
                };
                Candy.Util.deleteCookie('candy-nostatusmessages')
              }
              control.toggleClass('checked')
            }, updateUsercount: function(count) {
              $('#chat-usercount').text(count)
            }
        }, Modal: {
          show: function(html, showCloseControl, showSpinner) {
            if (showCloseControl) {
              self.Chat.Modal.showCloseControl()
            }
            else {
              self.Chat.Modal.hideCloseControl()
            }
            if (showSpinner) {
              self.Chat.Modal.showSpinner()
            }
            else {
              self.Chat.Modal.hideSpinner()
            }
            $('#chat-modal').stop(false, true);
            $('#chat-modal-body').html(html);
            $('#chat-modal').fadeIn('fast');
            $('#chat-modal-overlay').show()
          }, hide: function(callback) {
              $('#chat-modal').fadeOut('fast', function() {
                $('#chat-modal-body').text('');
                $('#chat-modal-overlay').hide()
              });
              $(document).keydown(function(e) {
                if (e.which === 27) {
                  e.preventDefault()
                }
              });
              if (callback) {
                callback()
              }
            }, showSpinner: function() {
              $('#chat-modal-spinner').show()
            }, hideSpinner: function() {
              $('#chat-modal-spinner').hide()
            }, showCloseControl: function() {
              $('#admin-message-cancel').show().click(function(e) {
                self.Chat.Modal.hide();
                e.preventDefault()
              });
              $(document).keydown(function(e) {
                if (e.which === 27) {
                  self.Chat.Modal.hide();
                  e.preventDefault()
                }
              })
            }, hideCloseControl: function() {
              $('#admin-message-cancel').hide().click(function(){})
            }, showLoginForm: function(message, presetJid) {
              self.Chat.Modal.show((message ? message : '') + Mustache.to_html(Candy.View.Template.Login.form, {
                _labelNickname: $.i18n._('labelNickname'), _labelUsername: $.i18n._('labelUsername'), _labelPassword: $.i18n._('labelPassword'), _loginSubmit: $.i18n._('loginSubmit'), displayPassword: !Candy.Core.isAnonymousConnection(), displayUsername: !presetJid, displayNickname: Candy.Core.isAnonymousConnection(), presetJid: presetJid ? presetJid : false
              }));
              $('#login-form').children(':input:first').focus();
              $('#login-form').submit(function() {
                var username = $('#username').val(),
                  password = $('#password').val();
                if (!Candy.Core.isAnonymousConnection()) {
                  var jid = Candy.Core.getUser() && username.indexOf("@") < 0 ? username + '@' + Strophe.getDomainFromJid(Candy.Core.getUser().getJid()) : username;
                  if (jid.indexOf("@") < 0 && !Candy.Core.getUser()) {
                    Candy.View.Pane.Chat.Modal.showLoginForm($.i18n._('loginInvalid'))
                  }
                  else {
                    Candy.Core.connect(jid, password)
                  }
                }
                else {
                  Candy.Core.connect(presetJid, null, username)
                }
                return false
              })
            }, showEnterPasswordForm: function(roomJid, roomName, message) {
              self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.enterPasswordForm, {
                roomName: roomName, _labelPassword: $.i18n._('labelPassword'), _label: (message ? message : $.i18n._('enterRoomPassword', [roomName])), _joinSubmit: $.i18n._('enterRoomPasswordSubmit')
              }), true);
              $('#password').focus();
              $('#enter-password-form').submit(function() {
                var password = $('#password').val();
                self.Chat.Modal.hide(function() {
                  Candy.Core.Action.Jabber.Room.Join(roomJid, password)
                });
                return false
              })
            }, showNicknameConflictForm: function(roomJid) {
              self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.nicknameConflictForm, {
                _labelNickname: $.i18n._('labelNickname'), _label: $.i18n._('nicknameConflict'), _loginSubmit: $.i18n._('loginSubmit')
              }));
              $('#nickname').focus();
              $('#nickname-conflict-form').submit(function() {
                var nickname = $('#nickname').val();
                self.Chat.Modal.hide(function() {
                  Candy.Core.getUser().data.nick = nickname;
                  Candy.Core.Action.Jabber.Room.Join(roomJid)
                });
                return false
              })
            }, showError: function(message, replacements) {
              self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.PresenceError.displayError, {_error: $.i18n._(message, replacements)}), true)
            }
        }, Tooltip: {show: function(event, content) {
            var tooltip = $('#tooltip'),
              target = $(event.currentTarget);
            if (!content) {
              content = target.attr('data-tooltip')
            }
            if (tooltip.length === 0) {
              var html = Mustache.to_html(Candy.View.Template.Chat.tooltip);
              $('#chat-pane').append(html);
              tooltip = $('#tooltip')
            }
            $('#context-menu').hide();
            tooltip.stop(false, true);
            tooltip.children('div').html(content);
            var pos = target.offset(),
              posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(tooltip, pos.left),
              posTop = Candy.Util.getPosTopAccordingToWindowBounds(tooltip, pos.top);
            tooltip.css({
              left: posLeft.px, top: posTop.px
            }).removeClass('left-top left-bottom right-top right-bottom').addClass(posLeft.backgroundPositionAlignment + '-' + posTop.backgroundPositionAlignment).fadeIn('fast');
            target.mouseleave(function(event) {
              event.stopPropagation();
              $('#tooltip').stop(false, true).fadeOut('fast', function() {
                $(this).css({
                  top: 0, left: 0
                })
              })
            })
          }}, Context: {
          init: function() {
            if ($('#context-menu').length === 0) {
              var html = Mustache.to_html(Candy.View.Template.Chat.Context.menu);
              $('#chat-pane').append(html);
              $('#context-menu').mouseleave(function() {
                $(this).fadeOut('fast')
              })
            }
          }, show: function(elem, roomJid, user) {
              elem = $(elem);
              var roomId = self.Chat.rooms[roomJid].id,
                menu = $('#context-menu'),
                links = $('ul li', menu);
              $('#tooltip').hide();
              if (!user) {
                user = Candy.Core.getUser()
              }
              links.remove();
              var menulinks = this.getMenuLinks(roomJid, user, elem),
                id,
                clickHandler = function(roomJid, user) {
                  return function(event) {
                      event.data.callback(event, roomJid, user);
                      $('#context-menu').hide()
                    }
                };
              for (id in menulinks) {
                if (menulinks.hasOwnProperty(id)) {
                  var link = menulinks[id],
                    html = Mustache.to_html(Candy.View.Template.Chat.Context.menulinks, {
                      roomId: roomId, 'class': link['class'], id: id, label: link.label
                    });
                  $('ul', menu).append(html);
                  $('#context-menu-' + id).bind('click', link, clickHandler(roomJid, user))
                }
              }
              if (id) {
                var pos = elem.offset(),
                  posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(menu, pos.left),
                  posTop = Candy.Util.getPosTopAccordingToWindowBounds(menu, pos.top);
                menu.css({
                  left: posLeft.px, top: posTop.px
                }).removeClass('left-top left-bottom right-top right-bottom').addClass(posLeft.backgroundPositionAlignment + '-' + posTop.backgroundPositionAlignment).fadeIn('fast');
                $(Candy).triggerHandler('candy:view.roster.after-context-menu', {
                  roomJid: roomJid, user: user, element: menu
                });
                return true
              }
            }, getMenuLinks: function(roomJid, user, elem) {
              var menulinks,
                id;
              var evtData = {
                  roomJid: roomJid, user: user, elem: elem, menulinks: this.initialMenuLinks(elem)
                };
              $(Candy).triggerHandler('candy:view.roster.context-menu', evtData);
              menulinks = evtData.menulinks;
              for (id in menulinks) {
                if (menulinks.hasOwnProperty(id) && menulinks[id].requiredPermission !== undefined && !menulinks[id].requiredPermission(user, self.Room.getUser(roomJid), elem)) {
                  delete menulinks[id]
                }
              }
              return menulinks
            }, initialMenuLinks: function() {
              return {
                  'private': {
                    requiredPermission: function(user, me) {
                      return me.getNick() !== user.getNick() && Candy.Core.getRoom(Candy.View.getCurrent().roomJid) && !Candy.Core.getUser().isInPrivacyList('ignore', user.getJid())
                    }, 'class': 'private', label: $.i18n._('privateActionLabel'), callback: function(e, roomJid, user) {
                        $('#user-' + Candy.Util.jidToId(roomJid) + '-' + Candy.Util.jidToId(user.getJid())).click()
                      }
                  }, ignore: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && !Candy.Core.getUser().isInPrivacyList('ignore', user.getJid())
                      }, 'class': 'ignore', label: $.i18n._('ignoreActionLabel'), callback: function(e, roomJid, user) {
                          Candy.View.Pane.Room.ignoreUser(roomJid, user.getJid())
                        }
                    }, unignore: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && Candy.Core.getUser().isInPrivacyList('ignore', user.getJid())
                      }, 'class': 'unignore', label: $.i18n._('unignoreActionLabel'), callback: function(e, roomJid, user) {
                          Candy.View.Pane.Room.unignoreUser(roomJid, user.getJid())
                        }
                    }, kick: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && me.isModerator() && !user.isModerator()
                      }, 'class': 'kick', label: $.i18n._('kickActionLabel'), callback: function(e, roomJid, user) {
                          self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
                            _label: $.i18n._('reason'), _submit: $.i18n._('kickActionLabel')
                          }), true);
                          $('#context-modal-field').focus();
                          $('#context-modal-form').submit(function() {
                            Candy.Core.Action.Jabber.Room.Admin.UserAction(roomJid, user.getJid(), 'kick', $('#context-modal-field').val());
                            self.Chat.Modal.hide();
                            return false
                          })
                        }
                    }, ban: {
                      requiredPermission: function(user, me) {
                        return me.getNick() !== user.getNick() && me.isModerator() && !user.isModerator()
                      }, 'class': 'ban', label: $.i18n._('banActionLabel'), callback: function(e, roomJid, user) {
                          self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
                            _label: $.i18n._('reason'), _submit: $.i18n._('banActionLabel')
                          }), true);
                          $('#context-modal-field').focus();
                          $('#context-modal-form').submit(function() {
                            Candy.Core.Action.Jabber.Room.Admin.UserAction(roomJid, user.getJid(), 'ban', $('#context-modal-field').val());
                            self.Chat.Modal.hide();
                            return false
                          })
                        }
                    }, subject: {
                      requiredPermission: function(user, me) {
                        return me.getNick() === user.getNick() && me.isModerator()
                      }, 'class': 'subject', label: $.i18n._('setSubjectActionLabel'), callback: function(e, roomJid) {
                          self.Chat.Modal.show(Mustache.to_html(Candy.View.Template.Chat.Context.contextModalForm, {
                            _label: $.i18n._('subject'), _submit: $.i18n._('setSubjectActionLabel')
                          }), true);
                          $('#context-modal-field').focus();
                          $('#context-modal-form').submit(function(e) {
                            Candy.Core.Action.Jabber.Room.Admin.SetSubject(roomJid, $('#context-modal-field').val());
                            self.Chat.Modal.hide();
                            e.preventDefault()
                          })
                        }
                    }
                }
            }, showEmoticonsMenu: function(elem) {
              elem = $(elem);
              var pos = elem.offset(),
                menu = $('#context-menu'),
                content = $('ul', menu),
                emoticons = '',
                i;
              $('#tooltip').hide();
              for (i = Candy.Util.Parser.emoticons.length - 1; i >= 0; i--) {
                emoticons = '<img src="' + Candy.Util.Parser._emoticonPath + Candy.Util.Parser.emoticons[i].image + '" alt="' + Candy.Util.Parser.emoticons[i].plain + '" />' + emoticons
              }
              content.html('<li class="emoticons">' + emoticons + '</li>');
              content.find('img').click(function() {
                var input = Candy.View.Pane.Room.getPane(Candy.View.getCurrent().roomJid, '.message-form').children('.field'),
                  value = input.val(),
                  emoticon = $(this).attr('alt') + ' ';
                input.val(value ? value + ' ' + emoticon : emoticon).focus()
              });
              var posLeft = Candy.Util.getPosLeftAccordingToWindowBounds(menu, pos.left),
                posTop = Candy.Util.getPosTopAccordingToWindowBounds(menu, pos.top);
              menu.css({
                left: posLeft.px, top: posTop.px
              }).removeClass('left-top left-bottom right-top right-bottom').addClass(posLeft.backgroundPositionAlignment + '-' + posTop.backgroundPositionAlignment).fadeIn('fast');
              return true
            }
        }
    };
    self.Room = {
      init: function(roomJid, roomName, roomType) {
        roomType = roomType || 'groupchat';
        roomJid = Candy.Util.unescapeJid(roomJid);
        var evtData = {
            roomJid: roomJid, type: roomType
          };
        if ($(Candy).triggerHandler('candy:view.room.before-add', evtData) === false) {
          return false
        }
        if (Candy.Util.isEmptyObject(self.Chat.rooms)) {
          self.Chat.Toolbar.show()
        }
        var roomId = Candy.Util.jidToId(roomJid);
        self.Chat.rooms[roomJid] = {
          id: roomId, usercount: 0, name: roomName, type: roomType, messageCount: 0, scrollPosition: -1
        };
        $('#chat-rooms').append(Mustache.to_html(Candy.View.Template.Room.pane, {
          roomId: roomId, roomJid: roomJid, roomType: roomType, form: {_messageSubmit: $.i18n._('messageSubmit')}, roster: {_userOnline: $.i18n._('userOnline')}
        }, {
          roster: Candy.View.Template.Roster.pane, messages: Mustache.to_html(Candy.View.Template.Message.pane, {}, {header: Candy.View.Template.Message.header}), form: Candy.View.Template.Room.form
        }));
        self.Chat.addTab(roomJid, roomName, roomType);
        self.Room.getPane(roomJid, '.message-form').submit(self.Message.submit);
        evtData.element = self.Room.getPane(roomJid);
        $(Candy).triggerHandler('candy:view.room.after-add', evtData);
        self.Chat.Toolbar.playSound("new_chat");
        return roomId
      }, show: function(roomJid) {
          var roomId = self.Chat.rooms[roomJid].id,
            evtData;
          $('.room-pane').each(function() {
            var elem = $(this);
            evtData = {
              roomJid: elem.attr('data-roomjid'), element: elem
            };
            if (elem.attr('id') === ('chat-room-' + roomId)) {
              elem.show();
              Candy.View.getCurrent().roomJid = roomJid;
              self.Chat.setActiveTab(roomJid);
              self.Chat.Toolbar.update(roomJid);
              self.Chat.clearUnreadMessages(roomJid);
              self.Room.setFocusToForm(roomJid);
              self.Room.scrollToBottom(roomJid);
              $(Candy).triggerHandler('candy:view.room.after-show', evtData)
            }
            else if (elem.is(':visible')) {
              elem.hide();
              $(Candy).triggerHandler('candy:view.room.after-hide', evtData)
            }
          })
        }, setSubject: function(roomJid, subject) {
          subject = Candy.Util.Parser.linkify(Candy.Util.Parser.escape(subject));
          var html = Mustache.to_html(Candy.View.Template.Room.subject, {
              subject: subject, roomName: self.Chat.rooms[roomJid].name, _roomSubject: $.i18n._('roomSubject'), time: Candy.Util.localizedTime((new Date).toGMTString())
            });
          self.Room.appendToMessagePane(roomJid, html);
          $(Candy).triggerHandler('candy:view.room.after-subject-change', {
            roomJid: roomJid, element: self.Room.getPane(roomJid), subject: subject
          })
        }, close: function(roomJid) {
          self.Chat.removeTab(roomJid);
          self.Window.clearUnreadMessages();
          self.Room.getPane(roomJid).remove();
          var openRooms = $('#chat-rooms').children();
          if (Candy.View.getCurrent().roomJid === roomJid) {
            Candy.View.getCurrent().roomJid = null;
            if (openRooms.length === 0) {
              self.Chat.allTabsClosed()
            }
            else {
              self.Room.show(openRooms.last().attr('data-roomjid'))
            }
          }
          delete self.Chat.rooms[roomJid];
          $(Candy).triggerHandler('candy:view.room.after-close', {roomJid: roomJid})
        }, insertInMessagePane: function(roomJid, html, id, seqId) {
          var inserted = false;
          var pane = self.Room.getPane(roomJid, ".message-pane");
          if (pane.children('li[data-id="' + id + '"]').length > 0) {
            return
          }
          pane.children().each(function() {
            var msg = $(this);
            if (Number(seqId) < Number(msg.attr("data-seqid"))) {
              msg.before(html);
              inserted = true;
              return false
            }
          });
          if (!inserted)
            self.Room.getPane(roomJid, ".message-pane").append(html)
        }, appendToMessagePane: function(roomJid, html) {
          self.Room.getPane(roomJid, '.message-pane').append(html);
          self.Chat.rooms[roomJid].messageCount++;
          self.Room.sliceMessagePane(roomJid);
          if (Candy.View.getCurrent().roomJid === roomJid) {
            self.Room.scrollToBottom(roomJid)
          }
        }, sliceMessagePane: function(roomJid) {
          if (self.Window.autoscroll) {
            var options = Candy.View.getOptions().messages;
            if (self.Chat.rooms[roomJid].messageCount > options.limit) {
              self.Room.getPane(roomJid, '.message-pane').children().slice(0, options.remove).remove();
              self.Chat.rooms[roomJid].messageCount -= options.remove
            }
          }
        }, scrollToBottom: function(roomJid) {
          self.Room.onScrollToBottom(roomJid)
        }, onScrollToBottom: function(roomJid) {
          var messagePane = self.Room.getPane(roomJid, '.message-pane-wrapper');
          messagePane.scrollTop(messagePane.prop('scrollHeight'))
        }, onScrollToStoredPosition: function(roomJid) {
          if (self.Chat.rooms[roomJid].scrollPosition > -1) {
            var messagePane = self.Room.getPane(roomJid, '.message-pane-wrapper');
            messagePane.scrollTop(self.Chat.rooms[roomJid].scrollPosition);
            self.Chat.rooms[roomJid].scrollPosition = -1
          }
        }, setFocusToForm: function(roomJid) {
          var pane = self.Room.getPane(roomJid, '.message-form');
          if (pane) {
            try {
              pane.children('.field')[0].focus()
            }
            catch(e) {}
          }
        }, setUser: function(roomJid, user) {
          self.Chat.rooms[roomJid].user = user;
          var roomPane = self.Room.getPane(roomJid),
            chatPane = $('#chat-pane');
          roomPane.attr('data-userjid', user.getJid());
          if (user.isModerator()) {
            if (user.getRole() === user.ROLE_MODERATOR) {
              chatPane.addClass('role-moderator')
            }
            if (user.getAffiliation() === user.AFFILIATION_OWNER) {
              chatPane.addClass('affiliation-owner')
            }
          }
          else {
            chatPane.removeClass('role-moderator affiliation-owner')
          }
          self.Chat.Context.init()
        }, getUser: function(roomJid) {
          return self.Chat.rooms[roomJid].user
        }, ignoreUser: function(roomJid, userJid) {
          Candy.Core.Action.Jabber.Room.IgnoreUnignore(userJid);
          Candy.View.Pane.Room.addIgnoreIcon(roomJid, userJid)
        }, unignoreUser: function(roomJid, userJid) {
          Candy.Core.Action.Jabber.Room.IgnoreUnignore(userJid);
          Candy.View.Pane.Room.removeIgnoreIcon(roomJid, userJid)
        }, addIgnoreIcon: function(roomJid, userJid) {
          if (Candy.View.Pane.Chat.rooms[userJid]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[userJid].id + '-' + Candy.Util.jidToId(userJid)).addClass('status-ignored')
          }
          if (Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)].id + '-' + Candy.Util.jidToId(userJid)).addClass('status-ignored')
          }
        }, removeIgnoreIcon: function(roomJid, userJid) {
          if (Candy.View.Pane.Chat.rooms[userJid]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[userJid].id + '-' + Candy.Util.jidToId(userJid)).removeClass('status-ignored')
          }
          if (Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)]) {
            $('#user-' + Candy.View.Pane.Chat.rooms[Strophe.getBareJidFromJid(roomJid)].id + '-' + Candy.Util.jidToId(userJid)).removeClass('status-ignored')
          }
        }, getPane: function(roomJid, subPane) {
          if (self.Chat.rooms[roomJid]) {
            if (subPane) {
              if (self.Chat.rooms[roomJid]['pane-' + subPane]) {
                return self.Chat.rooms[roomJid]['pane-' + subPane]
              }
              else {
                self.Chat.rooms[roomJid]['pane-' + subPane] = $('#chat-room-' + self.Chat.rooms[roomJid].id).find(subPane);
                return self.Chat.rooms[roomJid]['pane-' + subPane]
              }
            }
            else {
              return $('#chat-room-' + self.Chat.rooms[roomJid].id)
            }
          }
        }, changeDataUserJidIfUserIsMe: function(roomId, user) {
          if (user.getNick() === Candy.Core.getUser().getNick()) {
            var roomElement = $('#chat-room-' + roomId);
            roomElement.attr('data-userjid', Strophe.getBareJidFromJid(roomElement.attr('data-userjid')) + '/' + user.getNick())
          }
        }
    };
    self.PrivateRoom = {
      open: function(roomJid, roomName, switchToRoom, isNoConferenceRoomJid) {
        var user = isNoConferenceRoomJid ? Candy.Core.getUser() : self.Room.getUser(Strophe.getBareJidFromJid(roomJid)),
          evtData = {
            roomJid: roomJid, roomName: roomName, type: 'chat'
          };
        if ($(Candy).triggerHandler('candy:view.private-room.before-open', evtData) === false) {
          return false
        }
        if (Candy.Core.getUser().isInPrivacyList('ignore', roomJid)) {
          return false
        }
        if (!self.Chat.rooms[roomJid]) {
          if (self.Room.init(roomJid, roomName, 'chat') === false) {
            return false
          }
        }
        if (switchToRoom) {
          self.Room.show(roomJid)
        }
        self.Roster.update(roomJid, new Candy.Core.ChatUser(roomJid, roomName), 'join', user);
        self.Roster.update(roomJid, user, 'join', user);
        self.PrivateRoom.setStatus(roomJid, 'join');
        if (isNoConferenceRoomJid) {
          self.Chat.infoMessage(roomJid, $.i18n._('presenceUnknownWarningSubject'), $.i18n._('presenceUnknownWarning'))
        }
        evtData.element = self.Room.getPane(roomJid);
        $(Candy).triggerHandler('candy:view.private-room.after-open', evtData)
      }, setStatus: function(roomJid, status) {
          var messageForm = self.Room.getPane(roomJid, '.message-form');
          if (status === 'join') {
            self.Chat.getTab(roomJid).addClass('online').removeClass('offline');
            messageForm.children('.field').removeAttr('disabled');
            messageForm.children('.submit').removeAttr('disabled');
            self.Chat.getTab(roomJid)
          }
          else if (status === 'leave') {
            self.Chat.getTab(roomJid).addClass('offline').removeClass('online');
            messageForm.children('.field').attr('disabled', true);
            messageForm.children('.submit').attr('disabled', true)
          }
        }, changeNick: function changeNick(roomJid, user) {
          Candy.Core.log('[View:Pane:PrivateRoom] changeNick');
          var previousPrivateRoomJid = roomJid + '/' + user.getPreviousNick(),
            newPrivateRoomJid = roomJid + '/' + user.getNick(),
            previousPrivateRoomId = Candy.Util.jidToId(previousPrivateRoomJid),
            newPrivateRoomId = Candy.Util.jidToId(newPrivateRoomJid),
            room = self.Chat.rooms[previousPrivateRoomJid],
            roomElement,
            roomTabElement;
          if (self.Chat.rooms[newPrivateRoomJid]) {
            self.Room.close(newPrivateRoomJid)
          }
          if (room) {
            room.name = user.getNick(true);
            room.id = newPrivateRoomId;
            self.Chat.rooms[newPrivateRoomJid] = room;
            delete self.Chat.rooms[previousPrivateRoomJid];
            roomElement = $('#chat-room-' + previousPrivateRoomId);
            if (roomElement) {
              roomElement.attr('data-roomjid', newPrivateRoomJid);
              roomElement.attr('id', 'chat-room-' + newPrivateRoomId);
              roomTabElement = $('#chat-tabs li[data-roomjid="' + previousPrivateRoomJid + '"]');
              roomTabElement.attr('data-roomjid', newPrivateRoomJid);
              roomTabElement.children('a.label').text('@' + user.getNick(true));
              if (Candy.View.getCurrent().roomJid === previousPrivateRoomJid) {
                Candy.View.getCurrent().roomJid = newPrivateRoomJid
              }
            }
          }
          else {
            roomElement = $('.room-pane.roomtype-chat[data-userjid="' + previousPrivateRoomJid + '"]');
            if (roomElement.length) {
              previousPrivateRoomId = Candy.Util.jidToId(roomElement.attr('data-roomjid'));
              roomElement.attr('data-userjid', newPrivateRoomJid)
            }
          }
          if (roomElement && roomElement.length) {
            self.Roster.changeNick(previousPrivateRoomId, user)
          }
        }
    };
    self.Roster = {
      update: function(roomJid, user, action, currentUser) {
        Candy.Core.log('[View:Pane:Roster] ' + action);
        var roomId = self.Chat.rooms[roomJid].id,
          userId = Candy.Util.jidToId(user.getJid()),
          usercountDiff = -1,
          userElem = $('#user-' + roomId + '-' + userId),
          evtData = {
            roomJid: roomJid, user: user, action: action, element: userElem
          };
        $(Candy).triggerHandler('candy:view.roster.before-update', evtData);
        if (action === 'join') {
          usercountDiff = 1;
          var html = Mustache.to_html(Candy.View.Template.Roster.user, {
              roomId: roomId, userId: userId, userJid: user.getJid(), nick: user.getNick(), displayNick: Candy.Util.crop(user.getNick(true), Candy.View.getOptions().crop.roster.nickname), role: user.getRole(), affiliation: user.getAffiliation(), me: currentUser !== undefined && user.getNick() === currentUser.getNick(), tooltipRole: $.i18n._('tooltipRole'), tooltipIgnored: $.i18n._('tooltipIgnored')
            });
          if (userElem.length < 1) {
            var userInserted = false,
              rosterPane = self.Room.getPane(roomJid, '.roster-pane');
            if (rosterPane.children().length > 0) {
              var userSortCompare = user.getNick().toUpperCase();
              rosterPane.children().each(function() {
                var elem = $(this);
                if (elem.attr('data-nick').toUpperCase() > userSortCompare) {
                  elem.before(html);
                  userInserted = true;
                  return false
                }
                return true
              })
            }
            if (!userInserted) {
              rosterPane.append(html)
            }
            self.Roster.showJoinAnimation(user, userId, roomId, roomJid, currentUser);
            self.Roster.showJoinMessage(user, userId, roomId, roomJid, currentUser)
          }
          else {
            usercountDiff = 0;
            userElem.replaceWith(html);
            $('#user-' + roomId + '-' + userId).css({opacity: 1}).show();
            if (currentUser !== undefined && user.getNick() === currentUser.getNick() && self.Room.getUser(roomJid)) {
              self.Chat.Toolbar.update(roomJid)
            }
          }
          if (currentUser !== undefined && currentUser.getNick() === user.getNick()) {
            self.Room.setUser(roomJid, user)
          }
          else {
            $('#user-' + roomId + '-' + userId).click(self.Roster.userClick)
          }
          $('#user-' + roomId + '-' + userId + ' .context').click(function(e) {
            self.Chat.Context.show(e.currentTarget, roomJid, user);
            e.stopPropagation()
          });
          if (currentUser !== undefined && currentUser.isInPrivacyList('ignore', user.getJid())) {
            Candy.View.Pane.Room.addIgnoreIcon(roomJid, user.getJid())
          }
        }
        else if (action === "leave" || action === "kick" || action === "ban") {
          self.Roster.leaveAnimation('user-' + roomId + '-' + userId);
          if (self.Chat.rooms[roomJid].type === 'chat') {
            self.Chat.onInfoMessage(roomJid, $.i18n._('userLeftRoom', [user.getNick(true)]))
          }
          else {
            self.Chat.infoMessage(roomJid, $.i18n._('userLeftRoom', [user.getNick(true)]))
          }
        }
        else if (action === 'nickchange') {
          usercountDiff = 0;
          self.Roster.changeNick(roomId, user);
          self.Room.changeDataUserJidIfUserIsMe(roomId, user);
          self.PrivateRoom.changeNick(roomJid, user);
          var infoMessage = $.i18n._('userChangedNick', [user.getPreviousNick(), user.getNick(true)]);
          self.Chat.onInfoMessage(roomJid, infoMessage)
        }
        Candy.View.Pane.Chat.rooms[roomJid].usercount += usercountDiff;
        if (roomJid === Candy.View.getCurrent().roomJid) {
          Candy.View.Pane.Chat.Toolbar.updateUsercount(Candy.View.Pane.Chat.rooms[roomJid].usercount)
        }
        evtData.element = $('#user-' + roomId + '-' + userId);
        $(Candy).triggerHandler('candy:view.roster.after-update', evtData)
      }, userClick: function() {
          var elem = $(this);
          self.PrivateRoom.open(elem.attr('data-jid'), elem.attr('data-nick'), true)
        }, showJoinAnimation: function(user, userId, roomId, roomJid, currentUser) {
          var rosterUserId = 'user-' + roomId + '-' + userId,
            $rosterUserElem = $('#' + rosterUserId);
          if (!user.getPreviousNick() || !$rosterUserElem || $rosterUserElem.is(':visible') === false) {
            self.Roster.joinAnimation(rosterUserId)
          }
        }, showJoinMessage: function(user, userId, roomId, roomJid, currentUser) {
          if (!user.getPreviousNick()) {
            if (currentUser !== undefined && user.getNick() !== currentUser.getNick()) {
              if (!user.isModerator()) {
                self.Chat.onInfoMessage(roomJid, $.i18n._("userJoinedRoom", [user.getNick(true)]))
              }
            }
          }
        }, joinAnimation: function(elementId) {
          $('#' + elementId).stop(true).slideDown('normal', function() {
            $(this).animate({opacity: 1})
          })
        }, leaveAnimation: function(elementId) {
          $('#' + elementId).stop(true).attr('id', '#' + elementId + '-leaving').animate({opacity: 0}, {complete: function() {
              $(this).slideUp('normal', function() {
                $(this).remove()
              })
            }})
        }, changeNick: function(roomId, user) {
          Candy.Core.log('[View:Pane:Roster] changeNick');
          var previousUserJid = Strophe.getBareJidFromJid(user.getJid()) + '/' + user.getPreviousNick(),
            elementId = 'user-' + roomId + '-' + Candy.Util.jidToId(previousUserJid),
            el = $('#' + elementId);
          el.attr('data-nick', user.getNick());
          el.attr('data-jid', user.getJid());
          el.children('div.label').text(user.getNick());
          el.attr('id', 'user-' + roomId + '-' + Candy.Util.jidToId(user.getJid()))
        }
    };
    self.Message = {
      submit: function(event) {
        var roomJid = Candy.View.getCurrent().roomJid,
          roomType = Candy.View.Pane.Chat.rooms[roomJid].type,
          message = $(this).children('.field').val().substring(0, Candy.View.getOptions().crop.message.body),
          xhtmlMessage,
          evtData = {
            roomJid: roomJid, message: message, xhtmlMessage: xhtmlMessage
          };
        if ($(Candy).triggerHandler('candy:view.message.before-send', evtData) === false) {
          event.preventDefault();
          return
        }
        message = evtData.message;
        xhtmlMessage = evtData.xhtmlMessage;
        Candy.Core.Action.Jabber.Room.Message(roomJid, message, roomType, xhtmlMessage, Candies.getSource());
        if (roomType === 'chat' && message) {
          self.Message.show(roomJid, self.Room.getUser(roomJid).getNick(true), message)
        }
        $(this).children('.field').val('').trigger('change').focus();
        event.preventDefault()
      }, show: function(roomJid, name, message, xhtmlMessage, timestamp, attributes) {
          var raw = message;
          message = Candy.Util.Parser.all(message.substring(0, Candy.View.getOptions().crop.message.body));
          if (xhtmlMessage) {
            xhtmlMessage = Candy.Util.parseAndCropXhtml(xhtmlMessage, Candy.View.getOptions().crop.message.body)
          }
          var isHistoryMessage = !!timestamp;
          var evtData = {
              roomJid: roomJid, name: name, rawMessage: raw, attributes: attributes, message: message, xhtmlMessage: xhtmlMessage, history: isHistoryMessage
            };
          if ($(Candy).triggerHandler('candy:view.message.before-show', evtData) === false) {
            return
          }
          message = evtData.message;
          xhtmlMessage = evtData.xhtmlMessage;
          if (xhtmlMessage !== undefined && xhtmlMessage.length > 0) {
            message = xhtmlMessage
          }
          var now = new Date,
            user = self.Room.getUser(roomJid),
            nick = user && user.getNick();
          var renderEvtData = {
              rawMessage: raw, attributes: attributes, template: Candy.View.Template.Message.item, templateData: {
                  name: name, displayName: Candy.Util.getDisplayName(name), croppedDisplayName: Candy.Util.crop(Candy.Util.getDisplayName(name), Candy.View.getOptions().crop.message.nickname), message: message, time: Candy.Util.localizedTime(timestamp || now.toGMTString()), timestamp: timestamp || now.toISOString(), stamp: (timestamp && new Date(timestamp) || now).valueOf(), id: attributes.id || "", seqId: attributes.seqId || 0x8000000000000, roomJid: roomJid, sender: name === nick ? "sender-is-me" : "sender-is-other"
                }, history: isHistoryMessage
            };
          if ($(Candy).triggerHandler('candy:view.message.before-render', renderEvtData) === false) {
            return
          }
          var html = Mustache.to_html(renderEvtData.template, renderEvtData.templateData);
          if (isHistoryMessage) {
            self.Room.insertInMessagePane(roomJid, html, attributes.id, attributes.seqId)
          }
          else {
            self.Room.appendToMessagePane(roomJid, html);
            if (Candy.View.getCurrent().roomJid !== roomJid || !self.Window.hasFocus()) {
              self.Chat.increaseUnreadMessages(roomJid);
              self.Chat.Toolbar.playSound("new_message")
            }
          }
          var elem = self.Room.getPane(roomJid, '.message-pane').children().last();
          evtData.element = elem;
          $(Candy).triggerHandler('candy:view.message.after-show', evtData)
        }
    };
    return self
  }(Candy.View.Pane || {}, jQueryCandyInstance));
  Candy.View.Template = (function(self) {
    self.Window = {unreadmessages: '({{count}}) {{title}}'};
    self.Chat = {
      pane: '<div id="chat-pane">{{> tabs}}{{> toolbar}}{{> rooms}}</div>{{> modal}}', rooms: '<div id="chat-rooms" class="rooms"></div>', tabs: '<ul id="chat-tabs"></ul>', tab: '<li class="roomtype-{{roomType}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}">' + '<a href="#" class="label">{{#privateUserChat}}@{{/privateUserChat}}{{name}}</a>' + '<small class="transfer"></small><small class="unread"></small></li>', modal: '<div id="chat-modal"><a id="admin-message-cancel" class="close" href="#">\u00d7</a>' + '<span id="chat-modal-body"></span>' + '<span id="chat-modal-spinner-wrapper"><div id="chat-modal-spinner" /></span>' + '</div><div id="chat-modal-overlay"></div>', adminMessage: '<li><small data-stamp="{{stamp}}">{{time}}</small><div class="adminmessage">' + '<span class="label">{{sender}}</span>' + '<span class="spacer">\u25b8</span><span class="message">{{subject}} {{message}}</span></div></li>', infoMessage: '<li><small data-stamp="{{stamp}}">{{time}}</small><div class="infomessage">' + '<span class="spacer">\u2022</span><span class="message">{{subject}} {{message}}</span></div></li>', stateMessage: '<li name="chat-state-message"><div class="statemessage">{{subject}} {{message}}</div></li>', toolbar: '<ul id="chat-toolbar">' + '<li id="emoticons-icon" data-tooltip="{{tooltipEmoticons}}"></li>' + '<li id="chat-sound-control" class="checked" data-tooltip="{{tooltipSound}}"></li>' + '<li id="chat-autoscroll-control" class="checked" data-tooltip="{{tooltipAutoscroll}}"></li>' + '<li class="checked" id="chat-statusmessage-control" data-tooltip="{{tooltipStatusmessage}}">' + '</li><li class="context" data-tooltip="{{tooltipAdministration}}"></li>' + '<li class="usercount" data-tooltip="{{tooltipUsercount}}">' + '<span id="chat-usercount"></span></li></ul>', Context: {
          menu: '<div id="context-menu"><i class="arrow arrow-top"></i>' + '<ul></ul><i class="arrow arrow-bottom"></i></div>', menulinks: '<li class="{{class}}" id="context-menu-{{id}}">{{label}}</li>', contextModalForm: '<form action="#" id="context-modal-form">' + '<label for="context-modal-label">{{_label}}</label>' + '<input type="text" name="contextModalField" id="context-modal-field" />' + '<input type="submit" class="button" name="send" value="{{_submit}}" /></form>', adminMessageReason: '<a id="admin-message-cancel" class="close" href="#">\u00d7</a>' + '<p>{{_action}}</p>{{#reason}}<p>{{_reason}}</p>{{/reason}}'
        }, tooltip: '<div id="tooltip"><i class="arrow arrow-top"></i>' + '<div></div><i class="arrow arrow-bottom"></i></div>'
    };
    self.Room = {
      pane: '<div class="room-pane roomtype-{{roomType}}" id="chat-room-{{roomId}}" data-roomjid="{{roomJid}}" data-roomtype="{{roomType}}">' + '{{> roster}}{{> messages}}{{> form}}</div>', subject: '<li><small data-stamp="{{stamp}}">{{time}}</small><div class="subject">' + '<span class="label">{{roomName}}</span>' + '<span class="spacer">\u25b8</span>{{_roomSubject}} {{{subject}}}</div></li>', form: '<div class="message-form-wrapper">' + '<form method="post" class="message-form">' + '<input name="message" class="field" type="text" aria-label="Message Form Text Field" autocomplete="off" maxlength="1000" />' + '<input type="submit" class="submit" name="submit" value="{{_messageSubmit}}" /></form></div>'
    };
    self.Roster = {
      pane: '<div class="roster-pane"></div>', user: '<div class="user role-{{role}} affiliation-{{affiliation}}{{#me}} me{{/me}}"' + ' id="user-{{roomId}}-{{userId}}" data-jid="{{userJid}}"' + ' data-nick="{{nick}}" data-role="{{role}}" data-affiliation="{{affiliation}}">' + '<div class="label">{{displayNick}}</div><ul>' + '<li class="context" id="context-{{roomId}}-{{userId}}">&#x25BE;</li>' + '<li class="role role-{{role}} affiliation-{{affiliation}}" data-tooltip="{{tooltipRole}}"></li>' + '<li class="ignore" data-tooltip="{{tooltipIgnored}}"></li></ul></div>'
    };
    self.Message = {
      pane: '{{> header}}<div class="message-pane-wrapper"><ul class="message-pane"></ul></div>', item: '<li class="{{sender}}" data-id="{{id}}" data-seqid="{{seqId}}"><small data-stamp="{{stamp}}">{{time}}</small><div><a class="label name" href="#">{{croppedDisplayName}}</a>' + '<span class="spacer">\u25b8</span><span class="message">{{{message}}}</span></div></li>', header: '<div id="header"></div>'
    };
    self.Login = {form: '<form method="post" id="login-form" class="login-form">' + '{{#displayNickname}}<label for="username">{{_labelNickname}}</label><input type="text" id="username" name="username"/>{{/displayNickname}}' + '{{#displayUsername}}<label for="username">{{_labelUsername}}</label>' + '<input type="text" id="username" name="username"/>{{/displayUsername}}' + '{{#presetJid}}<input type="hidden" id="username" name="username" value="{{presetJid}}"/>{{/presetJid}}' + '{{#displayPassword}}<label for="password">{{_labelPassword}}</label>' + '<input type="password" id="password" name="password" />{{/displayPassword}}' + '<input type="submit" class="button" value="{{_loginSubmit}}" /></form>'};
    self.PresenceError = {
      enterPasswordForm: '<strong>{{_label}}</strong>' + '<form method="post" id="enter-password-form" class="enter-password-form">' + '<label for="password">{{_labelPassword}}</label><input type="password" id="password" name="password" />' + '<input type="submit" class="button" value="{{_joinSubmit}}" /></form>', nicknameConflictForm: '<strong>{{_label}}</strong>' + '<form method="post" id="nickname-conflict-form" class="nickname-conflict-form">' + '<label for="nickname">{{_labelNickname}}</label><input type="text" id="nickname" name="nickname" />' + '<input type="submit" class="button" value="{{_loginSubmit}}" /></form>', displayError: '<strong>{{_error}}</strong>'
    };
    return self
  }(Candy.View.Template || {}));
  Candy.View.Translation = {
    en: {
      status: 'Status: %s', statusConnecting: 'Connecting...', statusConnected: 'Connected', statusDisconnecting: 'Disconnecting...', statusDisconnected: 'Disconnected', statusAuthfail: 'Authentication failed', sessionRestored: 'Session restored', roomSubject: 'Subject:', messageSubmit: 'Send', labelUsername: 'Username:', labelNickname: 'Nickname:', labelPassword: 'Password:', loginSubmit: 'Login', loginInvalid: 'Invalid JID', reason: 'Reason:', subject: 'Subject:', reasonWas: 'Reason was: %s.', kickActionLabel: 'Kick', youHaveBeenKickedBy: 'You have been kicked from %2$s by %1$s', youHaveBeenKicked: 'You have been kicked from %s', banActionLabel: 'Ban', youHaveBeenBannedBy: 'You have been banned from %1$s by %2$s', youHaveBeenBanned: 'You have been banned from %s', privateActionLabel: 'Private chat', ignoreActionLabel: 'Ignore', unignoreActionLabel: 'Unignore', setSubjectActionLabel: 'Change Subject', administratorMessageSubject: 'Administrator', userJoinedRoom: '%s joined the room.', userLeftRoom: '%s left the room.', userHasBeenKickedFromRoom: '%s has been kicked from the room.', userHasBeenBannedFromRoom: '%s has been banned from the room.', userChangedNick: '%1$s has changed his nickname to %2$s.', presenceUnknownWarningSubject: 'Notice:', presenceUnknownWarning: 'This user might be offline. We can\'t track his presence.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'You ignore this user', tooltipEmoticons: 'Emoticons', tooltipSound: 'Play sound for new messages', tooltipAutoscroll: 'Autoscroll', tooltipStatusmessage: 'Display status messages', tooltipAdministration: 'Room Administration', tooltipUsercount: 'Room Occupants', enterRoomPassword: 'Room "%s" is password protected.', enterRoomPasswordSubmit: 'Join room', passwordEnteredInvalid: 'Invalid password for room "%s".', nicknameConflict: 'Username already in use. Please choose another one.', errorMembersOnly: 'You can\'t join room "%s": Insufficient rights.', errorMaxOccupantsReached: 'You can\'t join room "%s": Too many occupants.', errorAutojoinMissing: 'No autojoin parameter set in configuration. Please set one to continue.', antiSpamMessage: 'Please do not spam. You have been blocked for a short-time.'
    }, de: {
        status: 'Status: %s', statusConnecting: 'Verbinden...', statusConnected: 'Verbunden', statusDisconnecting: 'Verbindung trennen...', statusDisconnected: 'Verbindung getrennt', statusAuthfail: 'Authentifizierung fehlgeschlagen', sessionRestored: 'Session restored', roomSubject: 'Thema:', messageSubmit: 'Senden', labelUsername: 'Benutzername:', labelNickname: 'Spitzname:', labelPassword: 'Passwort:', loginSubmit: 'Anmelden', loginInvalid: 'Ung\u00fcltige JID', reason: 'Begr\u00fcndung:', subject: 'Titel:', reasonWas: 'Begr\u00fcndung: %s.', kickActionLabel: 'Kick', youHaveBeenKickedBy: 'Du wurdest soeben aus dem Raum %1$s gekickt (%2$s)', youHaveBeenKicked: 'Du wurdest soeben aus dem Raum %s gekickt', banActionLabel: 'Ban', youHaveBeenBannedBy: 'Du wurdest soeben aus dem Raum %1$s verbannt (%2$s)', youHaveBeenBanned: 'Du wurdest soeben aus dem Raum %s verbannt', privateActionLabel: 'Privater Chat', ignoreActionLabel: 'Ignorieren', unignoreActionLabel: 'Nicht mehr ignorieren', setSubjectActionLabel: 'Thema \u00e4ndern', administratorMessageSubject: 'Administrator', userJoinedRoom: '%s hat soeben den Raum betreten.', userLeftRoom: '%s hat soeben den Raum verlassen.', userHasBeenKickedFromRoom: '%s ist aus dem Raum gekickt worden.', userHasBeenBannedFromRoom: '%s ist aus dem Raum verbannt worden.', userChangedNick: '%1$s hat den Nicknamen zu %2$s ge\u00e4ndert.', presenceUnknownWarningSubject: 'Hinweis:', presenceUnknownWarning: 'Dieser Benutzer k\u00f6nnte bereits abgemeldet sein. Wir k\u00f6nnen seine Anwesenheit nicht verfolgen.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'Du ignorierst diesen Benutzer', tooltipEmoticons: 'Smileys', tooltipSound: 'Ton abspielen bei neuen Nachrichten', tooltipAutoscroll: 'Autoscroll', tooltipStatusmessage: 'Statusnachrichten anzeigen', tooltipAdministration: 'Raum Administration', tooltipUsercount: 'Anzahl Benutzer im Raum', enterRoomPassword: 'Raum "%s" ist durch ein Passwort gesch\u00fctzt.', enterRoomPasswordSubmit: 'Raum betreten', passwordEnteredInvalid: 'Inkorrektes Passwort f\u00fcr Raum "%s".', nicknameConflict: 'Der Benutzername wird bereits verwendet. Bitte w\u00e4hle einen anderen.', errorMembersOnly: 'Du kannst den Raum "%s" nicht betreten: Ungen\u00fcgende Rechte.', errorMaxOccupantsReached: 'Du kannst den Raum "%s" nicht betreten: Benutzerlimit erreicht.', errorAutojoinMissing: 'Keine "autojoin" Konfiguration gefunden. Bitte setze eine konfiguration um fortzufahren.', antiSpamMessage: 'Bitte nicht spammen. Du wurdest f\u00fcr eine kurze Zeit blockiert.'
      }, fr: {
        status: 'Status: %s', statusConnecting: 'Connexion\u2026', statusConnected: 'Connect\u00e9.', statusDisconnecting: 'D\u00e9connexion\u2026', statusDisconnected: 'D\u00e9connect\u00e9.', statusAuthfail: 'L\'authentification a \u00e9chou\u00e9', sessionRestored: 'Session restored', roomSubject: 'Sujet:', messageSubmit: 'Envoyer', labelUsername: 'Nom d\'utilisateur:', labelPassword: 'Mot de passe:', loginSubmit: 'Connexion', loginInvalid: 'JID invalide', reason: 'Motif:', subject: 'Titre:', reasonWas: 'Motif: %s.', kickActionLabel: 'Kick', youHaveBeenKickedBy: 'Vous avez \u00e9t\u00e9 expuls\u00e9 du salon %1$s (%2$s)', youHaveBeenKicked: 'Vous avez \u00e9t\u00e9 expuls\u00e9 du salon %s', banActionLabel: 'Ban', youHaveBeenBannedBy: 'Vous avez \u00e9t\u00e9 banni du salon %1$s (%2$s)', youHaveBeenBanned: 'Vous avez \u00e9t\u00e9 banni du salon %s', privateActionLabel: 'Chat priv\u00e9', ignoreActionLabel: 'Ignorer', unignoreActionLabel: 'Ne plus ignorer', setSubjectActionLabel: 'Changer le sujet', administratorMessageSubject: 'Administrateur', userJoinedRoom: '%s vient d\'entrer dans le salon.', userLeftRoom: '%s vient de quitter le salon.', userHasBeenKickedFromRoom: '%s a \u00e9t\u00e9 expuls\u00e9 du salon.', userHasBeenBannedFromRoom: '%s a \u00e9t\u00e9 banni du salon.', presenceUnknownWarningSubject: 'Note:', presenceUnknownWarning: 'Cet utilisateur n\'est malheureusement plus connect\u00e9, le message ne sera pas envoy\u00e9.', dateFormat: 'dd/mm/yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Mod\u00e9rateur', tooltipIgnored: 'Vous ignorez cette personne', tooltipEmoticons: 'Smileys', tooltipSound: 'Jouer un son lors de la r\u00e9ception de nouveaux messages', tooltipAutoscroll: 'D\u00e9filement automatique', tooltipStatusmessage: 'Messages d\'\u00e9tat', tooltipAdministration: 'Administration du salon', tooltipUsercount: 'Nombre d\'utilisateurs dans le salon', enterRoomPassword: 'Le salon "%s" est prot\u00e9g\u00e9 par un mot de passe.', enterRoomPasswordSubmit: 'Entrer dans le salon', passwordEnteredInvalid: 'Le mot de passe pour le salon "%s" est invalide.', nicknameConflict: 'Le nom d\'utilisateur est d\u00e9j\u00e0 utilis\u00e9. Veuillez en choisir un autre.', errorMembersOnly: 'Vous ne pouvez pas entrer dans le salon "%s": droits insuffisants.', errorMaxOccupantsReached: 'Vous ne pouvez pas entrer dans le salon "%s": Limite d\'utilisateur atteint.', antiSpamMessage: 'Merci de ne pas envoyer de spam. Vous avez \u00e9t\u00e9 bloqu\u00e9 pendant une courte p\u00e9riode..'
      }, nl: {
        status: 'Status: %s', statusConnecting: 'Verbinding maken...', statusConnected: 'Verbinding is gereed', statusDisconnecting: 'Verbinding verbreken...', statusDisconnected: 'Verbinding is verbroken', statusAuthfail: 'Authenticatie is mislukt', sessionRestored: 'Session restored', roomSubject: 'Onderwerp:', messageSubmit: 'Verstuur', labelUsername: 'Gebruikersnaam:', labelPassword: 'Wachtwoord:', loginSubmit: 'Inloggen', loginInvalid: 'JID is onjuist', reason: 'Reden:', subject: 'Onderwerp:', reasonWas: 'De reden was: %s.', kickActionLabel: 'Verwijderen', youHaveBeenKickedBy: 'Je bent verwijderd van %1$s door %2$s', youHaveBeenKicked: 'Je bent verwijderd van %s', banActionLabel: 'Blokkeren', youHaveBeenBannedBy: 'Je bent geblokkeerd van %1$s door %2$s', youHaveBeenBanned: 'Je bent geblokkeerd van %s', privateActionLabel: 'Prive gesprek', ignoreActionLabel: 'Negeren', unignoreActionLabel: 'Niet negeren', setSubjectActionLabel: 'Onderwerp wijzigen', administratorMessageSubject: 'Beheerder', userJoinedRoom: '%s komt de chat binnen.', userLeftRoom: '%s heeft de chat verlaten.', userHasBeenKickedFromRoom: '%s is verwijderd.', userHasBeenBannedFromRoom: '%s is geblokkeerd.', presenceUnknownWarningSubject: 'Mededeling:', presenceUnknownWarning: 'Deze gebruiker is waarschijnlijk offline, we kunnen zijn/haar aanwezigheid niet vaststellen.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'Je negeert deze gebruiker', tooltipEmoticons: 'Emotie-iconen', tooltipSound: 'Speel een geluid af bij nieuwe berichten.', tooltipAutoscroll: 'Automatisch scrollen', tooltipStatusmessage: 'Statusberichten weergeven', tooltipAdministration: 'Instellingen', tooltipUsercount: 'Gebruikers', enterRoomPassword: 'De Chatroom "%s" is met een wachtwoord beveiligd.', enterRoomPasswordSubmit: 'Ga naar Chatroom', passwordEnteredInvalid: 'Het wachtwoord voor de Chatroom "%s" is onjuist.', nicknameConflict: 'De gebruikersnaam is reeds in gebruik. Probeer a.u.b. een andere gebruikersnaam.', errorMembersOnly: 'Je kunt niet deelnemen aan de Chatroom "%s": Je hebt onvoldoende rechten.', errorMaxOccupantsReached: 'Je kunt niet deelnemen aan de Chatroom "%s": Het maximum aantal gebruikers is bereikt.', antiSpamMessage: 'Het is niet toegestaan om veel berichten naar de server te versturen. Je bent voor een korte periode geblokkeerd.'
      }, es: {
        status: 'Estado: %s', statusConnecting: 'Conectando...', statusConnected: 'Conectado', statusDisconnecting: 'Desconectando...', statusDisconnected: 'Desconectado', statusAuthfail: 'Fall\u00f3 la autenticaci\u00f3n', sessionRestored: 'Session restored', roomSubject: 'Asunto:', messageSubmit: 'Enviar', labelUsername: 'Usuario:', labelPassword: 'Clave:', loginSubmit: 'Entrar', loginInvalid: 'JID no v\u00e1lido', reason: 'Raz\u00f3n:', subject: 'Asunto:', reasonWas: 'La raz\u00f3n fue: %s.', kickActionLabel: 'Expulsar', youHaveBeenKickedBy: 'Has sido expulsado de %1$s por %2$s', youHaveBeenKicked: 'Has sido expulsado de %s', banActionLabel: 'Prohibir', youHaveBeenBannedBy: 'Has sido expulsado permanentemente de %1$s por %2$s', youHaveBeenBanned: 'Has sido expulsado permanentemente de %s', privateActionLabel: 'Chat privado', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'No ignorar', setSubjectActionLabel: 'Cambiar asunto', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s se ha unido a la sala.', userLeftRoom: '%s ha dejado la sala.', userHasBeenKickedFromRoom: '%s ha sido expulsado de la sala.', userHasBeenBannedFromRoom: '%s ha sido expulsado permanentemente de la sala.', presenceUnknownWarningSubject: 'Atenci\u00f3n:', presenceUnknownWarning: '\u00c9ste usuario podr\u00eda estar desconectado..', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Ignoras a \u00e9ste usuario', tooltipEmoticons: 'Emoticonos', tooltipSound: 'Reproducir un sonido para nuevos mensajes', tooltipAutoscroll: 'Desplazamiento autom\u00e1tico', tooltipStatusmessage: 'Mostrar mensajes de estado', tooltipAdministration: 'Administraci\u00f3n de la sala', tooltipUsercount: 'Usuarios en la sala', enterRoomPassword: 'La sala "%s" est\u00e1 protegida mediante contrase\u00f1a.', enterRoomPasswordSubmit: 'Unirse a la sala', passwordEnteredInvalid: 'Contrase\u00f1a incorrecta para la sala "%s".', nicknameConflict: 'El nombre de usuario ya est\u00e1 siendo utilizado. Por favor elija otro.', errorMembersOnly: 'No se puede unir a la sala "%s": no tiene privilegios suficientes.', errorMaxOccupantsReached: 'No se puede unir a la sala "%s": demasiados participantes.', antiSpamMessage: 'Por favor, no hagas spam. Has sido bloqueado temporalmente.'
      }, cn: {
        status: '\u72b6\u6001: %s', statusConnecting: '\u8fde\u63a5\u4e2d...', statusConnected: '\u5df2\u8fde\u63a5', statusDisconnecting: '\u65ad\u5f00\u8fde\u63a5\u4e2d...', statusDisconnected: '\u5df2\u65ad\u5f00\u8fde\u63a5', statusAuthfail: '\u8ba4\u8bc1\u5931\u8d25', sessionRestored: 'Session restored', roomSubject: '\u4e3b\u9898:', messageSubmit: '\u53d1\u9001', labelUsername: '\u7528\u6237\u540d:', labelPassword: '\u5bc6\u7801:', loginSubmit: '\u767b\u5f55', loginInvalid: '\u7528\u6237\u540d\u4e0d\u5408\u6cd5', reason: '\u539f\u56e0:', subject: '\u4e3b\u9898:', reasonWas: '\u539f\u56e0\u662f: %s.', kickActionLabel: '\u8e22\u9664', youHaveBeenKickedBy: '\u4f60\u5728 %1$s \u88ab\u7ba1\u7406\u8005 %2$s \u8bf7\u51fa\u623f\u95f4', banActionLabel: '\u7981\u8a00', youHaveBeenBannedBy: '\u4f60\u5728 %1$s \u88ab\u7ba1\u7406\u8005 %2$s \u7981\u8a00', privateActionLabel: '\u5355\u72ec\u5bf9\u8bdd', ignoreActionLabel: '\u5ffd\u7565', unignoreActionLabel: '\u4e0d\u5ffd\u7565', setSubjectActionLabel: '\u53d8\u66f4\u4e3b\u9898', administratorMessageSubject: '\u7ba1\u7406\u5458', userJoinedRoom: '%s \u52a0\u5165\u623f\u95f4', userLeftRoom: '%s \u79bb\u5f00\u623f\u95f4', userHasBeenKickedFromRoom: '%s \u88ab\u8bf7\u51fa\u8fd9\u4e2a\u623f\u95f4', userHasBeenBannedFromRoom: '%s \u88ab\u7ba1\u7406\u8005\u7981\u8a00', presenceUnknownWarningSubject: '\u6ce8\u610f:', presenceUnknownWarning: '\u8fd9\u4e2a\u4f1a\u5458\u53ef\u80fd\u5df2\u7ecf\u4e0b\u7ebf\uff0c\u4e0d\u80fd\u8ffd\u8e2a\u5230\u4ed6\u7684\u8fde\u63a5\u4fe1\u606f', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: '\u7ba1\u7406', tooltipIgnored: '\u4f60\u5ffd\u7565\u4e86\u8fd9\u4e2a\u4f1a\u5458', tooltipEmoticons: '\u8868\u60c5', tooltipSound: '\u65b0\u6d88\u606f\u53d1\u97f3', tooltipAutoscroll: '\u6eda\u52a8\u6761', tooltipStatusmessage: '\u7981\u7528\u72b6\u6001\u6d88\u606f', tooltipAdministration: '\u623f\u95f4\u7ba1\u7406', tooltipUsercount: '\u623f\u95f4\u5360\u6709\u8005', enterRoomPassword: '\u767b\u5f55\u623f\u95f4 "%s" \u9700\u8981\u5bc6\u7801.', enterRoomPasswordSubmit: '\u52a0\u5165\u623f\u95f4', passwordEnteredInvalid: '\u767b\u5f55\u623f\u95f4 "%s" \u7684\u5bc6\u7801\u4e0d\u6b63\u786e', nicknameConflict: '\u7528\u6237\u540d\u5df2\u7ecf\u5b58\u5728\uff0c\u8bf7\u53e6\u9009\u4e00\u4e2a', errorMembersOnly: '\u60a8\u7684\u6743\u9650\u4e0d\u591f\uff0c\u4e0d\u80fd\u767b\u5f55\u623f\u95f4 "%s" ', errorMaxOccupantsReached: '\u623f\u95f4 "%s" \u7684\u4eba\u6570\u5df2\u8fbe\u4e0a\u9650\uff0c\u60a8\u4e0d\u80fd\u767b\u5f55', antiSpamMessage: '\u56e0\u4e3a\u60a8\u5728\u77ed\u65f6\u95f4\u5185\u53d1\u9001\u8fc7\u591a\u7684\u6d88\u606f \u670d\u52a1\u5668\u8981\u963b\u6b62\u60a8\u4e00\u5c0f\u6bb5\u65f6\u95f4\u3002'
      }, ja: {
        status: '\u30b9\u30c6\u30fc\u30bf\u30b9: %s', statusConnecting: '\u63a5\u7d9a\u4e2d\u2026', statusConnected: '\u63a5\u7d9a\u3055\u308c\u307e\u3057\u305f', statusDisconnecting: '\u30c7\u30a3\u30b9\u30b3\u30cd\u30af\u30c8\u4e2d\u2026', statusDisconnected: '\u30c7\u30a3\u30b9\u30b3\u30cd\u30af\u30c8\u3055\u308c\u307e\u3057\u305f', statusAuthfail: '\u8a8d\u8a3c\u306b\u5931\u6557\u3057\u307e\u3057\u305f', sessionRestored: 'Session restored', roomSubject: '\u30c8\u30d4\u30c3\u30af\uff1a', messageSubmit: '\u9001\u4fe1', labelUsername: '\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\uff1a', labelPassword: '\u30d1\u30b9\u30ef\u30fc\u30c9\uff1a', loginSubmit: '\u30ed\u30b0\u30a4\u30f3', loginInvalid: '\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\u304c\u6b63\u3057\u304f\u3042\u308a\u307e\u305b\u3093', reason: '\u7406\u7531\uff1a', subject: '\u30c8\u30d4\u30c3\u30af\uff1a', reasonWas: '\u7406\u7531: %s\u3002', kickActionLabel: '\u30ad\u30c3\u30af', youHaveBeenKickedBy: '\u3042\u306a\u305f\u306f%2$s\u306b\u3088\u308a%1$s\u304b\u3089\u30ad\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002', youHaveBeenKicked: '\u3042\u306a\u305f\u306f%s\u304b\u3089\u30ad\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002', banActionLabel: '\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3', youHaveBeenBannedBy: '\u3042\u306a\u305f\u306f%2$s\u306b\u3088\u308a%1$s\u304b\u3089\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3\u3055\u308c\u307e\u3057\u305f\u3002', youHaveBeenBanned: '\u3042\u306a\u305f\u306f%s\u304b\u3089\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3\u3055\u308c\u307e\u3057\u305f\u3002', privateActionLabel: '\u30d7\u30e9\u30a4\u30d9\u30fc\u30c8\u30e1\u30c3\u30bb\u30fc\u30b8', ignoreActionLabel: '\u7121\u8996\u3059\u308b', unignoreActionLabel: '\u7121\u8996\u3092\u3084\u3081\u308b', setSubjectActionLabel: '\u30c8\u30d4\u30c3\u30af\u3092\u5909\u3048\u308b', administratorMessageSubject: '\u7ba1\u7406\u8005', userJoinedRoom: '%s\u306f\u5165\u5ba4\u3057\u307e\u3057\u305f\u3002', userLeftRoom: '%s\u306f\u9000\u5ba4\u3057\u307e\u3057\u305f\u3002', userHasBeenKickedFromRoom: '%s\u306f\u90e8\u5c4b\u304b\u3089\u30ad\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002', userHasBeenBannedFromRoom: '%s\u306f\u90e8\u5c4b\u304b\u3089\u30a2\u30ab\u30a6\u30f3\u30c8\u30d0\u30f3\u3055\u308c\u307e\u3057\u305f\u3002', presenceUnknownWarningSubject: '\u5fe0\u544a\uff1a', presenceUnknownWarning: '\u3053\u306e\u30e6\u30fc\u30b6\u30fc\u306e\u30b9\u30c6\u30fc\u30bf\u30b9\u306f\u4e0d\u660e\u3067\u3059\u3002', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: '\u30e2\u30c7\u30ec\u30fc\u30bf\u30fc', tooltipIgnored: '\u3053\u306e\u30e6\u30fc\u30b6\u30fc\u3092\u7121\u8996\u8a2d\u5b9a\u306b\u3057\u3066\u3044\u308b', tooltipEmoticons: '\u7d75\u6587\u5b57', tooltipSound: '\u65b0\u3057\u3044\u30e1\u30c3\u30bb\u30fc\u30b8\u304c\u5c4a\u304f\u305f\u3073\u306b\u97f3\u3092\u9cf4\u3089\u3059', tooltipAutoscroll: '\u30aa\u30fc\u30c8\u30b9\u30af\u30ed\u30fc\u30eb', tooltipStatusmessage: '\u30b9\u30c6\u30fc\u30bf\u30b9\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u8868\u793a', tooltipAdministration: '\u90e8\u5c4b\u306e\u7ba1\u7406', tooltipUsercount: '\u3053\u306e\u90e8\u5c4b\u306e\u53c2\u52a0\u8005\u306e\u6570', enterRoomPassword: '"%s"\u306e\u90e8\u5c4b\u306b\u5165\u308b\u306b\u306f\u30d1\u30b9\u30ef\u30fc\u30c9\u304c\u5fc5\u8981\u3067\u3059\u3002', enterRoomPasswordSubmit: '\u90e8\u5c4b\u306b\u5165\u308b', passwordEnteredInvalid: '"%s"\u306e\u30d1\u30b9\u30ef\u30fc\u30c9\u3068\u7570\u306a\u308b\u30d1\u30b9\u30ef\u30fc\u30c9\u3092\u5165\u529b\u3057\u307e\u3057\u305f\u3002', nicknameConflict: '\u3053\u306e\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\u306f\u3059\u3067\u306b\u5229\u7528\u3055\u308c\u3066\u3044\u308b\u305f\u3081\u3001\u5225\u306e\u30e6\u30fc\u30b6\u30fc\u30cd\u30fc\u30e0\u3092\u9078\u3093\u3067\u304f\u3060\u3055\u3044\u3002', errorMembersOnly: '"%s"\u306e\u90e8\u5c4b\u306b\u5165\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093: \u5229\u7528\u6a29\u9650\u3092\u6e80\u305f\u3057\u3066\u3044\u307e\u305b\u3093\u3002', errorMaxOccupantsReached: '"%s"\u306e\u90e8\u5c4b\u306b\u5165\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u305b\u3093: \u53c2\u52a0\u8005\u306e\u6570\u306f\u3059\u3067\u306b\u4e0a\u9650\u306b\u9054\u3057\u307e\u3057\u305f\u3002', antiSpamMessage: '\u30b9\u30d1\u30e0\u306a\u3069\u306e\u884c\u70ba\u306f\u3084\u3081\u3066\u304f\u3060\u3055\u3044\u3002\u3042\u306a\u305f\u306f\u4e00\u6642\u7684\u306b\u30d6\u30ed\u30c3\u30af\u3055\u308c\u307e\u3057\u305f\u3002'
      }, sv: {
        status: 'Status: %s', statusConnecting: 'Ansluter...', statusConnected: 'Ansluten', statusDisconnecting: 'Kopplar fr\u00e5n...', statusDisconnected: 'Fr\u00e5nkopplad', statusAuthfail: 'Autentisering misslyckades', sessionRestored: 'Session restored', roomSubject: '\u00c4mne:', messageSubmit: 'Skicka', labelUsername: 'Anv\u00e4ndarnamn:', labelPassword: 'L\u00f6senord:', loginSubmit: 'Logga in', loginInvalid: 'Ogiltigt JID', reason: 'Anledning:', subject: '\u00c4mne:', reasonWas: 'Anledningen var: %s.', kickActionLabel: 'Sparka ut', youHaveBeenKickedBy: 'Du har blivit utsparkad fr\u00e5n %2$s av %1$s', youHaveBeenKicked: 'Du har blivit utsparkad fr\u00e5n %s', banActionLabel: 'Bannlys', youHaveBeenBannedBy: 'Du har blivit bannlyst fr\u00e5n %1$s av %2$s', youHaveBeenBanned: 'Du har blivit bannlyst fr\u00e5n %s', privateActionLabel: 'Privat chatt', ignoreActionLabel: 'Blockera', unignoreActionLabel: 'Avblockera', setSubjectActionLabel: '\u00c4ndra \u00e4mne', administratorMessageSubject: 'Administrat\u00f6r', userJoinedRoom: '%s kom in i rummet.', userLeftRoom: '%s har l\u00e4mnat rummet.', userHasBeenKickedFromRoom: '%s har blivit utsparkad ur rummet.', userHasBeenBannedFromRoom: '%s har blivit bannlyst fr\u00e5n rummet.', presenceUnknownWarningSubject: 'Notera:', presenceUnknownWarning: 'Denna anv\u00e4ndare kan vara offline. Vi kan inte f\u00f6lja dennes n\u00e4rvaro.', dateFormat: 'yyyy-mm-dd', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderator', tooltipIgnored: 'Du blockerar denna anv\u00e4ndare', tooltipEmoticons: 'Smilies', tooltipSound: 'Spela upp ett ljud vid nytt meddelande', tooltipAutoscroll: 'Autoskrolla', tooltipStatusmessage: 'Visa statusmeddelanden', tooltipAdministration: 'Rumadministrering', tooltipUsercount: 'Antal anv\u00e4ndare i rummet', enterRoomPassword: 'Rummet "%s" \u00e4r l\u00f6senordsskyddat.', enterRoomPasswordSubmit: 'Anslut till rum', passwordEnteredInvalid: 'Ogiltigt l\u00f6senord f\u00f6r rummet "%s".', nicknameConflict: 'Upptaget anv\u00e4ndarnamn. Var god v\u00e4lj ett annat.', errorMembersOnly: 'Du kan inte ansluta till rummet "%s": Otillr\u00e4ckliga r\u00e4ttigheter.', errorMaxOccupantsReached: 'Du kan inte ansluta till rummet "%s": Rummet \u00e4r fullt.', antiSpamMessage: 'Var god avst\u00e5 fr\u00e5n att spamma. Du har blivit blockerad f\u00f6r en kort stund.'
      }, it: {
        status: 'Stato: %s', statusConnecting: 'Connessione...', statusConnected: 'Connessione', statusDisconnecting: 'Disconnessione...', statusDisconnected: 'Disconnesso', statusAuthfail: 'Autenticazione fallita', sessionRestored: 'Sessione ristabilita', roomSubject: 'Oggetto:', messageSubmit: 'Invia', labelUsername: 'Nome utente:', labelPassword: 'Password:', loginSubmit: 'Login', loginInvalid: 'JID non valido', reason: 'Ragione:', subject: 'Oggetto:', reasonWas: 'Ragione precedente: %s.', kickActionLabel: 'Espelli', youHaveBeenKickedBy: 'Sei stato espulso da %2$s da %1$s', youHaveBeenKicked: 'Sei stato espulso da %s', banActionLabel: 'Escluso', youHaveBeenBannedBy: 'Sei stato escluso da %1$s da %2$s', youHaveBeenBanned: 'Sei stato escluso da %s', privateActionLabel: 'Stanza privata', ignoreActionLabel: 'Ignora', unignoreActionLabel: 'Non ignorare', setSubjectActionLabel: 'Cambia oggetto', administratorMessageSubject: 'Amministratore', userJoinedRoom: '%s si \u00e8 unito alla stanza.', userLeftRoom: '%s ha lasciato la stanza.', userHasBeenKickedFromRoom: '%s \u00e8 stato espulso dalla stanza.', userHasBeenBannedFromRoom: '%s \u00e8 stato escluso dalla stanza.', presenceUnknownWarningSubject: 'Nota:', presenceUnknownWarning: 'Questo utente potrebbe essere offline. Non possiamo tracciare la sua presenza.', dateFormat: 'dd/mm/yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderatore', tooltipIgnored: 'Stai ignorando questo utente', tooltipEmoticons: 'Emoticons', tooltipSound: 'Riproduci un suono quando arrivano messaggi', tooltipAutoscroll: 'Autoscroll', tooltipStatusmessage: 'Mostra messaggi di stato', tooltipAdministration: 'Amministrazione stanza', tooltipUsercount: 'Partecipanti alla stanza', enterRoomPassword: 'La stanza "%s" \u00e8 protetta da password.', enterRoomPasswordSubmit: 'Unisciti alla stanza', passwordEnteredInvalid: 'Password non valida per la stanza "%s".', nicknameConflict: 'Nome utente gi\u00e0 in uso. Scegline un altro.', errorMembersOnly: 'Non puoi unirti alla stanza "%s": Permessi insufficienti.', errorMaxOccupantsReached: 'Non puoi unirti alla stanza "%s": Troppi partecipanti.', antiSpamMessage: 'Per favore non scrivere messaggi pubblicitari. Sei stato bloccato per un po\' di tempo.'
      }, pt: {
        status: 'Status: %s', statusConnecting: 'Conectando...', statusConnected: 'Conectado', statusDisconnecting: 'Desligando...', statusDisconnected: 'Desligado', statusAuthfail: 'Falha na autentica\u00e7\u00e3o', sessionRestored: 'Session restored', roomSubject: 'Assunto:', messageSubmit: 'Enviar', labelUsername: 'Usu\u00e1rio:', labelPassword: 'Senha:', loginSubmit: 'Entrar', loginInvalid: 'JID inv\u00e1lido', reason: 'Motivo:', subject: 'Assunto:', reasonWas: 'O motivo foi: %s.', kickActionLabel: 'Excluir', youHaveBeenKickedBy: 'Voc\u00ea foi excluido de %1$s por %2$s', youHaveBeenKicked: 'Voc\u00ea foi excluido de %s', banActionLabel: 'Bloquear', youHaveBeenBannedBy: 'Voc\u00ea foi excluido permanentemente de %1$s por %2$s', youHaveBeenBanned: 'Voc\u00ea foi excluido permanentemente de %s', privateActionLabel: 'Bate-papo privado', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'N\u00e3o ignorar', setSubjectActionLabel: 'Trocar Assunto', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s entrou na sala.', userLeftRoom: '%s saiu da sala.', userHasBeenKickedFromRoom: '%s foi excluido da sala.', userHasBeenBannedFromRoom: '%s foi excluido permanentemente da sala.', presenceUnknownWarning: 'Este usu\u00e1rio pode estar desconectado. N\u00e3o \u00e9 poss\u00edvel determinar o status.', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Voc\u00ea ignora este usu\u00e1rio', tooltipEmoticons: 'Emoticons', tooltipSound: 'Reproduzir o som para novas mensagens', tooltipAutoscroll: 'Deslocamento autom\u00e1tico', tooltipStatusmessage: 'Mostrar mensagens de status', tooltipAdministration: 'Administra\u00e7\u00e3o da sala', tooltipUsercount: 'Usu\u00e1rios na sala', enterRoomPassword: 'A sala "%s" \u00e9 protegida por senha.', enterRoomPasswordSubmit: 'Junte-se \u00e0 sala', passwordEnteredInvalid: 'Senha incorreta para a sala "%s".', nicknameConflict: 'O nome de usu\u00e1rio j\u00e1 est\u00e1 em uso. Por favor, escolha outro.', errorMembersOnly: 'Voc\u00ea n\u00e3o pode participar da sala "%s":  privil\u00e9gios insuficientes.', errorMaxOccupantsReached: 'Voc\u00ea n\u00e3o pode participar da sala "%s": muitos participantes.', antiSpamMessage: 'Por favor, n\u00e3o envie spam. Voc\u00ea foi bloqueado temporariamente.'
      }, pt_br: {
        status: 'Estado: %s', statusConnecting: 'Conectando...', statusConnected: 'Conectado', statusDisconnecting: 'Desconectando...', statusDisconnected: 'Desconectado', statusAuthfail: 'Autentica\u00e7\u00e3o falhou', sessionRestored: 'Session restored', roomSubject: 'Assunto:', messageSubmit: 'Enviar', labelUsername: 'Usu\u00e1rio:', labelPassword: 'Senha:', loginSubmit: 'Entrar', loginInvalid: 'JID inv\u00e1lido', reason: 'Motivo:', subject: 'Assunto:', reasonWas: 'Motivo foi: %s.', kickActionLabel: 'Derrubar', youHaveBeenKickedBy: 'Voc\u00ea foi derrubado de %2$s por %1$s', youHaveBeenKicked: 'Voc\u00ea foi derrubado de %s', banActionLabel: 'Banir', youHaveBeenBannedBy: 'Voc\u00ea foi banido de %1$s por %2$s', youHaveBeenBanned: 'Voc\u00ea foi banido de %s', privateActionLabel: 'Conversa privada', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'N\u00e3o ignorar', setSubjectActionLabel: 'Mudar Assunto', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s entrou na sala.', userLeftRoom: '%s saiu da sala.', userHasBeenKickedFromRoom: '%s foi derrubado da sala.', userHasBeenBannedFromRoom: '%s foi banido da sala.', presenceUnknownWarningSubject: 'Aviso:', presenceUnknownWarning: 'Este usu\u00e1rio pode estar desconectado.. N\u00e3o conseguimos rastrear sua presen\u00e7a..', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Voc\u00ea ignora este usu\u00e1rio', tooltipEmoticons: 'Emoticons', tooltipSound: 'Tocar som para novas mensagens', tooltipAutoscroll: 'Auto-rolagem', tooltipStatusmessage: 'Exibir mensagens de estados', tooltipAdministration: 'Administra\u00e7\u00e3o de Sala', tooltipUsercount: 'Participantes da Sala', enterRoomPassword: 'Sala "%s" \u00e9 protegida por senha.', enterRoomPasswordSubmit: 'Entrar na sala', passwordEnteredInvalid: 'Senha inv\u00e1ida para sala "%s".', nicknameConflict: 'Nome de usu\u00e1rio j\u00e1 em uso. Por favor escolha outro.', errorMembersOnly: 'Voc\u00ea n\u00e3o pode entrar na sala "%s": privil\u00e9gios insuficientes.', errorMaxOccupantsReached: 'Voc\u00ea n\u00e3o pode entrar na sala "%s": m\u00e1ximo de participantes atingido.', antiSpamMessage: 'Por favor, n\u00e3o fa\u00e7a spam. Voc\u00ea foi bloqueado temporariamente.'
      }, ru: {
        status: '\u0421\u0442\u0430\u0442\u0443\u0441: %s', statusConnecting: '\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435...', statusConnected: '\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u043e', statusDisconnecting: '\u041e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435...', statusDisconnected: '\u041e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u043e', statusAuthfail: '\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043b\u043e\u0433\u0438\u043d', sessionRestored: 'Session restored', roomSubject: '\u0422\u043e\u043f\u0438\u043a:', messageSubmit: '\u041f\u043e\u0441\u043b\u0430\u0442\u044c', labelUsername: '\u0418\u043c\u044f:', labelPassword: '\u041f\u0430\u0440\u043e\u043b\u044c:', loginSubmit: '\u041b\u043e\u0433\u0438\u043d', loginInvalid: '\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 JID', reason: '\u041f\u0440\u0438\u0447\u0438\u043d\u0430:', subject: '\u0422\u043e\u043f\u0438\u043a:', reasonWas: '\u041f\u0440\u0438\u0447\u0438\u043d\u0430 \u0431\u044b\u043b\u0430: %s.', kickActionLabel: '\u0412\u044b\u0431\u0440\u043e\u0441\u0438\u0442\u044c', youHaveBeenKickedBy: '\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c %1$s \u0432\u044b\u0431\u0440\u043e\u0441\u0438\u043b \u0432\u0430\u0441 \u0438\u0437 \u0447\u0430\u0442\u0430 %2$s', youHaveBeenKicked: '\u0412\u0430\u0441 \u0432\u044b\u0431\u0440\u043e\u0441\u0438\u043b\u0438 \u0438\u0437 \u0447\u0430\u0442\u0430 %s', banActionLabel: '\u0417\u0430\u043f\u0440\u0435\u0442\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f', youHaveBeenBannedBy: '\u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c %1$s \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u043b \u0432\u0430\u043c \u0434\u043e\u0441\u0442\u0443\u043f \u0432 \u0447\u0430\u0442 %2$s', youHaveBeenBanned: '\u0412\u0430\u043c \u0437\u0430\u043f\u0440\u0435\u0442\u0438\u043b\u0438 \u0434\u043e\u0441\u0442\u0443\u043f \u0432 \u0447\u0430\u0442 %s', privateActionLabel: '\u041e\u0434\u0438\u043d-\u043d\u0430-\u043e\u0434\u0438\u043d \u0447\u0430\u0442', ignoreActionLabel: '\u0418\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u0442\u044c', unignoreActionLabel: '\u041e\u0442\u043c\u0435\u043d\u0438\u0442\u044c \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435', setSubjectActionLabel: '\u0418\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0442\u043e\u043f\u0438\u043a', administratorMessageSubject: '\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440', userJoinedRoom: '%s \u0432\u043e\u0448\u0451\u043b \u0432 \u0447\u0430\u0442.', userLeftRoom: '%s \u0432\u044b\u0448\u0435\u043b \u0438\u0437 \u0447\u0430\u0442\u0430.', userHasBeenKickedFromRoom: '%s \u0432\u044b\u0431\u0440\u043e\u0448\u0435\u043d \u0438\u0437 \u0447\u0430\u0442\u0430.', userHasBeenBannedFromRoom: '%s \u0437\u0430\u043f\u0440\u0435\u0449\u0451\u043d \u0434\u043e\u0441\u0442\u0443\u043f \u0432 \u0447\u0430\u0442.', presenceUnknownWarningSubject: '\u0423\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0435:', presenceUnknownWarning: '\u042d\u0442\u043e\u0442 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u0435\u0435 \u0432\u0441\u0435\u0433\u043e \u043e\u0444\u0444\u043b\u0430\u0439\u043d.', dateFormat: 'mm.dd.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: '\u041c\u043e\u0434\u0435\u0440\u0430\u0442\u043e\u0440', tooltipIgnored: '\u0412\u044b \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442\u0435 \u044d\u0442\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.', tooltipEmoticons: '\u0421\u043c\u0430\u0439\u043b\u0438\u043a\u0438', tooltipSound: '\u041e\u0437\u0432\u0443\u0447\u0438\u0432\u0430\u0442\u044c \u043d\u043e\u0432\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435', tooltipAutoscroll: '\u0410\u0432\u0442\u043e-\u043f\u0440\u043e\u043a\u0440\u0443\u0447\u0438\u0432\u0430\u043d\u0438\u0435', tooltipStatusmessage: '\u041f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0441\u0442\u0430\u0442\u0443\u0441 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f', tooltipAdministration: '\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0447\u0430\u0442 \u043a\u043e\u043c\u043d\u0430\u0442\u044b', tooltipUsercount: '\u0423\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u0438 \u0447\u0430\u0442\u0430', enterRoomPassword: '\u0427\u0430\u0442 \u043a\u043e\u043c\u043d\u0430\u0442\u0430 "%s" \u0437\u0430\u0449\u0438\u0449\u0435\u043d\u0430 \u043f\u0430\u0440\u043e\u043b\u0435\u043c.', enterRoomPasswordSubmit: '\u0412\u043e\u0439\u0442\u0438 \u0432 \u0447\u0430\u0442', passwordEnteredInvalid: '\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0439 \u043f\u0430\u0440\u043e\u043b\u044c \u0434\u043b\u044f \u043a\u043e\u043c\u043d\u0430\u0442\u044b "%s".', nicknameConflict: '\u042d\u0442\u043e \u0438\u043c\u044f \u0443\u0436\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f. \u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430 \u0432\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u043e\u0435 \u0438\u043c\u044f.', errorMembersOnly: '\u0412\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u043e\u0439\u0442\u0438 \u0432 \u0447\u0430\u0442 "%s": \u041d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043f\u0440\u0430\u0432 \u0434\u043e\u0441\u0442\u0443\u043f\u0430.', errorMaxOccupantsReached: '\u0412\u044b \u043d\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u0432\u043e\u0439\u0442\u0438 \u0432 \u0447\u0430\u0442 "%s": \u0421\u043b\u0438\u0448\u043a\u043e\u043c \u043c\u043d\u043e\u0433\u043e \u0443\u0447\u0430\u0441\u0442\u043d\u0438\u043a\u043e\u0432.', antiSpamMessage: '\u041f\u043e\u0436\u0430\u043b\u0443\u0439\u0441\u0442\u0430 \u043d\u0435 \u0440\u0430\u0441\u0441\u044b\u043b\u0430\u0439\u0442\u0435 \u0441\u043f\u0430\u043c. \u0412\u0430\u0441 \u0437\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u043b\u0438 \u043d\u0430 \u043a\u043e\u0440\u043e\u0442\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f.'
      }, ca: {
        status: 'Estat: %s', statusConnecting: 'Connectant...', statusConnected: 'Connectat', statusDisconnecting: 'Desconnectant...', statusDisconnected: 'Desconnectat', statusAuthfail: 'Ha fallat la autenticaci\u00f3', sessionRestored: 'Session restored', roomSubject: 'Assumpte:', messageSubmit: 'Enviar', labelUsername: 'Usuari:', labelPassword: 'Clau:', loginSubmit: 'Entrar', loginInvalid: 'JID no v\u00e0lid', reason: 'Ra\u00f3:', subject: 'Assumpte:', reasonWas: 'La ra\u00f3 ha estat: %s.', kickActionLabel: 'Expulsar', youHaveBeenKickedBy: 'Has estat expulsat de %1$s per %2$s', youHaveBeenKicked: 'Has estat expulsat de %s', banActionLabel: 'Prohibir', youHaveBeenBannedBy: 'Has estat expulsat permanentment de %1$s per %2$s', youHaveBeenBanned: 'Has estat expulsat permanentment de %s', privateActionLabel: 'Xat privat', ignoreActionLabel: 'Ignorar', unignoreActionLabel: 'No ignorar', setSubjectActionLabel: 'Canviar assumpte', administratorMessageSubject: 'Administrador', userJoinedRoom: '%s ha entrat a la sala.', userLeftRoom: '%s ha deixat la sala.', userHasBeenKickedFromRoom: '%s ha estat expulsat de la sala.', userHasBeenBannedFromRoom: '%s ha estat expulsat permanentment de la sala.', presenceUnknownWarningSubject: 'Atenci\u00f3:', presenceUnknownWarning: 'Aquest usuari podria estar desconnectat ...', dateFormat: 'dd.mm.yyyy', timeFormat: 'HH:MM:ss', tooltipRole: 'Moderador', tooltipIgnored: 'Est\u00e0s ignorant aquest usuari', tooltipEmoticons: 'Emoticones', tooltipSound: 'Reproduir un so per a nous missatges', tooltipAutoscroll: 'Despla\u00e7ament autom\u00e0tic', tooltipStatusmessage: 'Mostrar missatges d\'estat', tooltipAdministration: 'Administraci\u00f3 de la sala', tooltipUsercount: 'Usuaris dins la sala', enterRoomPassword: 'La sala "%s" est\u00e0 protegida amb contrasenya.', enterRoomPasswordSubmit: 'Entrar a la sala', passwordEnteredInvalid: 'Contrasenya incorrecta per a la sala "%s".', nicknameConflict: 'El nom d\'usuari ja s\'est\u00e0 utilitzant. Si us plau, escolleix-ne un altre.', errorMembersOnly: 'No pots unir-te a la sala "%s": no tens prous privilegis.', errorMaxOccupantsReached: 'No pots unir-te a la sala "%s": hi ha masses participants.', antiSpamMessage: 'Si us plau, no facis spam. Has estat bloquejat temporalment.'
      }
  };
  window.Candy = Candy
}
;
function buildCandies(source) {
  if (!window.Candy)
    throw Ifm.Diagnostics.Errors.miss("Candy");
  _source = source;
  Candy.View.Translation.en.labelNickname = "Your name:";
  Candy.View.Translation.en.loginSubmit = "Enter chat";
  Candy.View.Translation.en.userJoinedRoom = "%s has entered the conversation.";
  Candy.View.Translation.en.userLeftRoom = "%s has left the conversation.";
  Candy.View.Translation.it.labelNickname = "Il tuo nome:";
  Candy.View.Translation.it.loginSubmit = "Entra in chat";
  Candy.View.Translation.it.userJoinedRoom = "%s \u00e8 entrato nella conversazione.";
  Candy.View.Translation.it.userLeftRoom = "%s ha lasciato la conversazione.";
  var baseInfoMessage = Candy.View.Pane.Chat.onInfoMessage;
  Candy.View.Pane.Chat.onInfoMessage = function(roomJid, subject, message) {
    if (!Candy.View.Pane.Room.getPane(roomJid))
      return;
    var lastmessage = Candy.View.Pane.Room.getPane(roomJid, ".message-pane").children().last().text();
    if (lastmessage.indexOf(subject) < 0 && lastmessage.indexOf(message) < 0) {
      baseInfoMessage(roomJid, subject, message)
    }
  };
  Candy.Core.isConnected = function() {
    const conn = Candy.Core.getConnection();
    return (conn && conn.connected) || false
  };
  Candy.Core.getUsername = function() {
    return Candy.Core.getUser().getNick()
  };
  Candy.Core.getRoomUserByName = function(roomJid, name) {
    var room = Candy.Core.getRoom(roomJid);
    if (room) {
      var users = room.roster.getAll();
      for (var i in users) {
        if (Strophe.getResourceFromJid(users[i].getJid()) === name) {
          return users[i]
        }
      }
    }
    return null
  };
  Candy.Core.available = function(target) {
    var presence = $pres({
        from: Candy.Core.getConnection().jid, to: target
      });
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] sending availability to", target);
    Candy.Core.getConnection().send(presence)
  };
  Candy.Core.subscribe = function(target, presencenick, presencestatus) {
    var id = "pres:" + Candy.Core.getConnection().getUniqueId();
    var presence = $pres({
        from: Candy.Core.getConnection().jid, to: target, id: id, type: "subscribe"
      });
    if (presencenick) {
      presence.c("nick", {xmlns: "http://jabber.org/protocol/nick"}, presencenick)
    }
    if (presencestatus) {
      presence.c("status", {}, presencestatus)
    }
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] requesting subscription to", target, "(id", id, ")", presencenick ? "as " + presencenick : "");
    Candy.Core.getConnection().send(presence)
  };
  Candy.Core.subscribed = function(target, replyid) {
    var id = replyid || "pres:" + Candy.Core.getConnection().getUniqueId();
    var presence = $pres({
        from: Candy.Core.getConnection().jid, to: target, id: id, type: "subscribed"
      });
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] replying subscription to", target, "(id", id, ")");
    Candy.Core.getConnection().send(presence)
  };
  Candy.Core.notifystate = function(roomJid, state) {
    var msg = $msg({
        from: Candy.Core.getConnection().jid, to: roomJid, type: "groupchat"
      }).c(state, {xmlns: "http://jabber.org/protocol/chatstates"});
    Ifm.Diagnostics.Debug.print("[Candy] [Extensions] sending", state, "notification");
    Candy.Core.getConnection().send(msg)
  };
  Candy.View.deletenotification = function(roomJid) {
    var pane = Candy.View.Pane.Room.getPane(roomJid);
    if (pane) {
      var messages = Candy.View.Pane.Room.getPane(roomJid, ".message-pane"),
        data = pane.data();
      if (data.resetnotificationtmr) {
        clearTimeout(data.resetnotificationtmr);
        data.resetnotificationtmr = 0
      }
      messages.find("[name=chat-state-message]").remove()
    }
  };
  Candy.View.movenotification = function(roomJid) {
    if (Candy.View.Pane.Room.getPane(roomJid)) {
      var messages = Candy.View.Pane.Room.getPane(roomJid, ".message-pane"),
        notification = messages.find("[name=chat-state-message]");
      if (notification.length) {
        messages.append(notification)
      }
    }
  };
  Candy.View.updatenotification = function(roomJid, displayName, state, message) {
    Candy.View.deletenotification(roomJid);
    var pane = Candy.View.Pane.Room.getPane(roomJid);
    if (pane) {
      var html = Mustache.to_html(Candy.View.Template.Chat.stateMessage, {
          subject: displayName, message: message
        });
      Candy.View.Pane.Room.appendToMessagePane(roomJid, html);
      pane.data({resetnotificationtmr: setTimeout(function() {
          Candy.View.deletenotification(roomJid)
        }, 10000)})
    }
  };
  window.Candies = window.Candies || {};
  Candies.appendToMessagePane = function(roomJid, message, sentFromHere, name) {
    name = name || "";
    var now = new Date,
      template = Candy.View.Template.Message.item,
      templateData = {
        name: name, displayName: Candy.Util.getDisplayName(name), croppedDisplayName: Candy.Util.crop(Candy.Util.getDisplayName(name), Candy.View.getOptions().crop.message.nickname), message: message, time: Candy.Util.localizedTime(now.toGMTString()), timestamp: now.toISOString(), stamp: now.valueOf(), id: "", seqId: 0x8000000000000, roomJid: roomJid, sender: sentFromHere ? "sender-is-me" : "sender-is-other"
      },
      html = Mustache.to_html(template, templateData);
    Candy.View.Pane.Room.appendToMessagePane(roomJid, html)
  };
  Candies.getSource = function() {
    return _source
  };
  Candies.send = function(roomJid, message) {
    Candy.Core.Action.Jabber.Room.Message(roomJid, message.toString(), undefined, undefined, _source)
  };
  Candies.sysMessage = function(roomJid, type, args) {
    var msg = new Ifm.Messaging.FStringMessageWriter(type);
    for (var i = 2; i < arguments.length; i++) {
      msg.add(arguments[i])
    }
    Candies.send(roomJid, msg.end())
  };
  Candies.getRoomHistory = function(roomJid) {
    Candy.Core.debug("Getting messages of room " + roomJid);
    var seqId = 0;
    Candy.Core.getConnection().mam.query(roomJid, {
      onMessage: function(message) {
        seqId += 1;
        var msg = $(message);
        var originalMsg = msg.find("forwarded message");
        var from = Candy.Util.unescapeJid(originalMsg.attr("from"));
        var name = Strophe.getResourceFromJid(from);
        var nom = {
            roomJid: roomJid, message: {
                name: name, body: originalMsg.children("body").text(), type: originalMsg.attr("type"), attributes: {
                    xmlns: originalMsg.attr("xmlns"), to: msg.attr("to"), type: originalMsg.attr("type"), id: originalMsg.attr("id"), from: from, seqId: seqId
                  }
              }, timestamp: msg.find("forwarded delay").attr("stamp")
          };
        Candy.View.Observer.Message(null, nom);
        return true
      }, onComplete: function(response) {
          Candy.Core.debug("[MAM] Response " + response);
          Candy.Core.debug("Got all messages of room " + roomJid);
          if (seqId === 0) {
            Candies.sysMessage(roomJid, "CONTINUITY")
          }
          Candy.View.Pane.Chat.onInfoMessage(roomJid, $.i18n._("sessionRestored"));
          Candy.View.Pane.Room.scrollToBottom(roomJid)
        }
    })
  };
  var _source
}
;
namespace("Ifm.Chat.Extras.FileTransfer", function() {
  this.transferFile = function(roomJid, ft, file, strings) {
    if (!file || !file.name || file.size === undefined || !file.type === undefined) {
      Ifm.Diagnostics.Debug.print("Invalid argument file");
      return
    }
    var isSender = !file.token ? true : false;
    var usize;
    if (file.size >= 1073741824)
      usize = Math.round(file.size / 1073741824) + " GB";
    else if (file.size >= 1048576)
      usize = Math.round(file.size / 1048576) + " MB";
    else if (file.size >= 1024)
      usize = Math.round(file.size / 1024) + " KB";
    else if (file.size > 1)
      usize = file.size + " bytes";
    else if (file.size === 1)
      usize = "1 byte";
    else
      usize = "0 bytes";
    ft.events.waiting = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data) {
        ft.cancel();
        return
      }
      if (isSender) {
        var tm = new Ifm.Messaging.FStringMessageWriter("FTTOKEN");
        tm.add(e.token).add(file.name).add(file.size).add(file.type).end();
        Candies.send(roomJid, tm)
      }
      var viewElementId = "ft-item-" + ft.id,
        viewElementHtml = "<span id='" + viewElementId + "'> " + "<span class='filetransfer-title'> " + strings.FileTransfer.TransferTitle + " </span> " + "<span class='filetransfer-file'> <b>" + file.name + "</b> </span> " + "<span class='filetransfer-status'> " + strings.FileTransfer.Waiting + " </span> " + "<a class='filetransfer-accept' href='#'> " + strings.FileTransfer.Accept + " </a> " + "<a class='filetransfer-cancel' href='#'> " + strings.FileTransfer.Cancel + " </a> " + "</span>";
      var template = Candy.View.Template.FileTransfer.item,
        templateData = {
          view: viewElementHtml, time: Candy.Util.localizedTime((new Date).toGMTString())
        },
        html = Mustache.to_html(template, templateData);
      Candy.View.Pane.Room.appendToMessagePane(roomJid, html);
      var tab = Candy.View.Pane.Chat.getTab(roomJid);
      tab.find(".transfer").show();
      var ve = $("#" + viewElementId);
      data.filetransfers[ft.id] = {
        filetransfer: ft, viewelement: ve
      };
      ve.find(".filetransfer-cancel").click(function() {
        ft.cancel();
        return false
      });
      if (isSender) {
        ve.find(".filetransfer-accept").remove()
      }
      else {
        ve.find(".filetransfer-status").text(usize);
        ve.find(".filetransfer-accept").click(function() {
          ft.accept();
          ve.find(".filetransfer-accept").remove();
          return false
        })
      }
    };
    ft.events.started = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      if (isSender) {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Sending)
      }
      else {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Receiving)
      }
      var tab = Candy.View.Pane.Chat.getTab(roomJid);
      tab.find(".transfer").hide()
    };
    ft.events.progress = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      ve.find(".filetransfer-status").text(e.percentage + "%")
    };
    ft.events.finished = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      ve.find(".filetransfer-cancel").remove();
      if (isSender) {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Sent);
        Candies.send(roomJid, strings.FileTransfer.TransferTitle + " " + file.name + " " + usize + " " + strings.FileTransfer.Complete)
      }
      else {
        ve.find(".filetransfer-status").text(strings.FileTransfer.Received);
        ve.append($("<a>", {
          "class": "filetransfer-open", click: e.openOrSaveFunc, href: "#", text: strings.FileTransfer.Open
        }))
      }
      Ifm.Chat.Extras.MediaPreview.generateThumbnail(roomJid, file.name, e.fileBlob, isSender)
    };
    ft.events.canceled = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      var ve = data.filetransfers[ft.id].viewelement;
      ve.find(".filetransfer-status").text(strings.FileTransfer.Canceled);
      ve.find(".filetransfer-cancel").remove();
      if (!isSender)
        ve.find(".filetransfer-accept").remove();
      var tab = Candy.View.Pane.Chat.getTab(roomJid);
      tab.find(".transfer").hide()
    };
    ft.events.error = function(ft, e) {
      var pane = Candy.View.Pane.Room.getPane(roomJid),
        data = pane && pane.data();
      if (!data)
        return;
      Candy.View.Pane.Chat.Modal.showError("File Transfer: " + e.reason);
      if (data.filetransfers[ft.id]) {
        var ve = data.filetransfers[ft.id].viewelement;
        ve.find(".filetransfer-status").text(strings.FileTransfer.Error);
        ve.find(".filetransfer-cancel").remove();
        if (!isSender)
          ve.find(".filetransfer-accept").remove();
        var tab = Candy.View.Pane.Chat.getTab(roomJid);
        tab.find(".transfer").hide()
      }
    };
    if (isSender) {
      ft.transfer(file)
    }
    else {
      ft.receive(file.token)
    }
  }
});
namespace("Ifm.Chat.Extras.MediaPreview", function() {
  this.generateThumbnail = function(roomJid, filename, fileBlob, isSender) {
    if (this.isTypeSupported(fileBlob)) {
      var url = URL.createObjectURL(fileBlob),
        type = fileBlob.type;
      if (type.startsWith("image/")) {
        var id = 'media-preview-thumbnail-' + (+new Date).toString(36);
        display(roomJid, '<img id="' + id + '" class="media-preview-thumbnail" src="' + url + '" alt="' + filename + '">', isSender);
        document.getElementById(id).onclick = function() {
          displayImageModalOnClick(id)
        }
      }
      else if (type.startsWith("audio/")) {
        display(roomJid, '<audio class="media-preview-player" controls><source src="' + url + '" type="' + fileBlob.type + '"></audio>', isSender)
      }
      else if (type.startsWith("video/")) {
        display(roomJid, '<video class="media-preview-player" controls><source src="' + url + '" type="' + fileBlob.type + '"></video>', isSender)
      }
    }
  };
  this.isTypeSupported = function(fileBlob) {
    var type = fileBlob.type;
    return type.startsWith("image/") || type.startsWith("audio/") || type.startsWith("video/")
  };
  function display(roomJid, html, isSender) {
    Candies.appendToMessagePane(roomJid, html, isSender)
  }
  function displayImageModalOnClick(id) {
    var img = document.getElementById(id);
    if (img) {
      var modalImg = getModalImage();
      modalImg.src = img.src;
      modalImg.alt = img.alt
    }
  }
  function getModalImage() {
    var modal = document.getElementById(ModalId),
      modalImg;
    if (!modal) {
      modal = document.createElement("div");
      modal.id = ModalId;
      modalImg = document.createElement("img");
      modalImg.id = ModalImgId;
      modal.appendChild(modalImg);
      document.body.appendChild(modal);
      var close = function() {
          modal.style.display = "none";
          modalImg.src = "";
          modalImg.alt = ""
        };
      modal.onclick = function() {
        close()
      };
      $("body").on("keydown", function(e) {
        if (e.which === 27 && !modal.style.display) {
          close()
        }
      })
    }
    else {
      modalImg = document.getElementById(ModalImgId)
    }
    modal.style.display = "";
    return modalImg
  }
  var ModalId = "media-preview-modal-div";
  var ModalImgId = "media-preview-modal-img"
});
namespace("Ifm.Chat.Extras.UrlPreview", function() {
  this.findAndGenerate = function(roomJid, message) {
    var authKey = this.settings && this.settings.authKey;
    if (authKey) {
      var linkRE = /<a[^>]*href\s*=\s*['"`]((?!javascript)[^\s#'"`]+?)['"`].*?>.*?<\/a\s*>/gi;
      if (linkRE.test(message)) {
        linkRE.lastIndex = 0;
        var originalMessage = message;
        var containerId = 'message-url-preview-' + (+new Date).toString(36);
        message = '<span id="' + containerId + '">' + originalMessage + '</span>';
        var match;
        while ((match = linkRE.exec(originalMessage)) !== null) {
          generate(authKey, match[1]).then(function(result) {
            replace(containerId, result.url, result.html)
          })
        }
        Candy.View.Pane.Room.scrollToBottom(roomJid)
      }
    }
    return message
  };
  function generate(authKey, url) {
    return new Promise(function(resolve) {
        $.ajax({
          url: 'https://api.linkpreview.net?key=' + authKey + '&q=' + url, success: function(result) {
              if (!result.title && !result.description || !result.image) {
                Ifm.Diagnostics.Debug.print("[Candy] [UrlPreview] preview not available for", url);
                return
              }
              var html = '<div class="message-url-preview-container">' + '<h1 class="message-url-preview-title">' + result.title + '</h1>' + '<h2 class="message-url-preview-subtitle">' + result.description + '</h2>' + '<img class="message-url-preview-img" src="' + result.image + '" alt="' + result.title + '">' + '</div>';
              resolve({
                url: url, html: html
              })
            }, error: function(error) {
              Ifm.Diagnostics.Debug.print("[Candy] [UrlPreview] review service returned an error:", error.statusText)
            }
        })
      })
  }
  function replace(containerId, url, html) {
    var containerElement = document.getElementById(containerId);
    if (containerElement) {
      var newLinkElement = '<a class="message-url" href="' + url + '" target="_blank">' + html + '</a>';
      var validREUrl = url.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1').replace(/&(?!amp;)/g, '&amp;');
      var oldLinkRE = new RegExp('<a[^>]*href\\s*=\\s*[\'"`]' + validREUrl + '[\'"`].*?>.*?<\\/a\\s*>', 'gi');
      if (containerElement.innerHTML.match(oldLinkRE)) {
        containerElement.innerHTML = containerElement.innerHTML.replace(oldLinkRE, newLinkElement)
      }
    }
  }
});
(function() {
  var ns = namespace("Ifm.PhoneBar.Media");
  ns.Xmpp = {events: defineEvents("initialized", "reachable", "unreachable", "newcall", "newmessage", "sysmessage", "callclosed", "filetransfer", "showtransferform")};
  ns.Xmpp.instance = (function() {
    if (!window.jQuery)
      throw Ifm.Diagnostics.Errors.miss("jQuery");
    if (!window.Strophe)
      throw Ifm.Diagnostics.Errors.miss("Candy/Libs");
    var _phonebar = null,
      PhoneBar = null;
    var _activeCalls = {},
      _activeRooms = {},
      _isInitialized = false;
    var strings;
    var events = Ifm.PhoneBar.Media.Xmpp.events;
    var config = {
        mediatypes: 0, service: "", server: "", ftservice: "", nickname: "", theme: "assets/xmpp/", language: "it", domain_nrt: "xmpp-nrt", domain_saf: "xmpp-saf", admin_nrt: "lxadmin-nrt", admin_saf: "lxadmin-saf", presence: "login", debug: false, showtransfer: true, areValidMediatypes: function() {
            var mediatypes = Ifm.Type.isNumber(this.mediatypes) ? this.mediatypes : parseInt(this.mediatypes);
            if (isFinite(mediatypes) && mediatypes == Ifm.PhoneBar.Mediatypes.NearRealTime || mediatypes == Ifm.PhoneBar.Mediatypes.StoreAndForward || mediatypes == Ifm.PhoneBar.Mediatypes.NearRealTime + Ifm.PhoneBar.Mediatypes.StoreAndForward) {
              return true
            }
            return false
          }, getAdmin_nrt: function() {
            return this.admin_nrt + '@' + this.server
          }, getAdmin_saf: function() {
            return this.admin_saf + '@' + this.server
          }, getDomain_nrt: function() {
            return this.domain_nrt + '.' + this.server
          }, getDomain_saf: function() {
            return this.domain_saf + '.' + this.server
          }, getPresence_nrt: function() {
            return this.presence + '@' + this.domain_nrt + '.' + this.server
          }, getPresence_saf: function() {
            return this.presence + '@' + this.domain_saf + '.' + this.server
          }, getAgentPre: function() {
            return "Agent_" + this.extension
          }, getUsername: function() {
            return (this.displayname || "Agent") + '_' + this.extension
          }
      };
    function setupCandy(windowInstance) {
      if (Ifm.Net.TimeProvider.settings && !Ifm.Net.TimeProvider.settings.service) {
        Ifm.Net.TimeProvider.settings.service = _phonebar.config.service
      }
      Strophe.timeProvider = Ifm.Net.TimeProvider.getDefault();
      const jQueryInstance = windowInstance.jQuery;
      const docInstance = windowInstance.document;
      if (!docInstance.getElementById("candy")) {
        var candybox = docInstance.createElement("div");
        candybox.id = "candy";
        candybox.style.display = "none";
        docInstance.body.appendChild(candybox)
      }
      if (config.theme) {
        if (!config.theme.endsWith('/'))
          config.theme += '/';
        docInstance.head.innerHTML += '<link rel="stylesheet" href="' + config.theme + 'default.css" />'
      }
      Candy.init(config.service, {
        core: {
          debug: config.debug, autojoin: [], disconnectWithoutTabs: false
        }, view: {
            assets: config.theme, language: config.language
          }
      });
      Candy.View.getOptions().crop.message.body = 1e6;
      strings = Ifm.Chat.Strings[config.language] || Ifm.Chat.Strings.it;
      var defaultUnloadHandler = window.onbeforeunload;
      if (window.addEventListener) {
        window.addEventListener("pagehide", defaultUnloadHandler);
        window.addEventListener("unload", defaultUnloadHandler)
      }
      else {
        window.attachEvent("onunload", defaultUnloadHandler)
      }
      window.onbeforeunload = null;
      Candy.View.Template.FileTransfer = {item: '<li><small>{{time}}</small><div class="filetransfer"><span class="spacer">\u2022</span><span class="message">{{{view}}}</span></div></li>'};
      Candy.View.Template.Message.header = '<div class="header-wrapper"><span class="chatstatus-text header-text"></span><span timerid="" class="chatduration-text header-text"></span><button class="header-button hangup-button"></button><button class="header-button chattransfer-button"></button><button class="header-button chatclosetab-button" style="display:none;"></button></div>';
      jQueryInstance(Candy).on('candy:core.chat.connection', function(evt, args) {
        switch (args.status) {
          case Strophe.Status.CONNECTING:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Connecting to XMPP server");
            break;
          case Strophe.Status.ATTACHED:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Connection restored with XMPP server");
            restoreSessionData();
            break;
          case Strophe.Status.CONNECTED:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Connected to XMPP server");
            setTimeout(function() {
              if (config.mediatypes & Ifm.PhoneBar.Mediatypes.NearRealTime) {
                Candy.Core.subscribe(config.getPresence_nrt(), config.getAgentPre(), config.presence);
                Candy.Core.subscribe(config.getDomain_nrt());
                Candy.Core.subscribe(config.getAdmin_nrt())
              }
              if (config.mediatypes & Ifm.PhoneBar.Mediatypes.StoreAndForward) {
                Candy.Core.subscribe(config.getPresence_saf(), config.getAgentPre(), config.presence);
                Candy.Core.subscribe(config.getDomain_saf());
                Candy.Core.subscribe(config.getAdmin_saf())
              }
            }, 100);
            break;
          case Strophe.Status.DISCONNECTING:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Disconnecting from XMPP server");
            break;
          case Strophe.Status.DISCONNECTED:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Disconnected from XMPP server");
            if (Candy.Core.keepconnected) {
              setTimeout(function() {
                Candy.Core.connect(config.server, null, config.getUsername())
              }, 200)
            }
            else {
              events.unreachable.raise(_phonebar, {reason: null})
            }
            break;
          case Strophe.Status.CONNFAIL:
          case Strophe.Status.AUTHFAIL:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Connection with XMPP server failed", args.status);
            events.unreachable.raise(_phonebar, {reason: "Connection with XMPP server failed"});
            break;
          default:
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Connection with XMPP server in status", args.status)
        }
      });
      jQueryInstance(Candy).on('candy:view.connection.status-6', function(evt, args) {
        Candy.View.Pane.Chat.Modal.hide();
        for (var roomJid in _activeRooms) {
          cancelAllFileTransfers(roomJid);
          Candy.View.Pane.Room.close(roomJid)
        }
        _activeCalls = {};
        _activeRooms = {};
        updateSessionData();
        return false
      });
      jQueryInstance(Candy).on('candy:view.connection.status-7', function(evt, args) {
        Candy.View.Pane.Chat.Modal.hide();
        return false
      });
      jQueryInstance(Candy).on('candy:core.presence', function(evt, args) {
        var msg = args.stanza,
          from = msg.attr("from"),
          id = msg.attr("id"),
          type = msg.attr("type") || "available";
        _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Got", type, "message from", from, "(id", id || "none", ")");
        switch (type) {
          case"subscribe":
            Candy.Core.subscribed(from, id);
            break;
          case"subscribed":
            Candy.Core.available(from);
            if (from.startsWith(config.presence)) {
              events.reachable.raise(_phonebar, {})
            }
            break
        }
      });
      jQueryInstance(Candy).on('candy:core:chat:invite', function(evt, args) {
        if (args.inviteType === undefined || args.inviteType === "DirectInvite") {
          var type = args.inviteType || "Invite";
          _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Got", type, "message from", args.roomJid);
          var roomJid = Candy.Util.unescapeJid(args.roomJid);
          Candy.Core.Action.Jabber.Room.Join(roomJid, null)
        }
      });
      jQueryInstance(Candy).on('candy:core.message.chatstate', function(evt, args) {
        if (!args.chatstate || args.name === Candy.Core.getUsername())
          return;
        if (args.chatstate === "composing")
          Candy.View.updatenotification(args.roomJid, args.displayName, args.chatstate, strings.ChatStateComposing);
        else
          Candy.View.deletenotification(args.roomJid)
      });
      jQueryInstance(Candy).on('candy:view.room.before-add', function(evt, args) {
        var roomJid = args.roomJid,
          callId,
          callGuid = roomJid.substr(1, 36).toUpperCase();
        if (!_activeRooms[roomJid] || !_activeCalls[_activeRooms[roomJid]]) {
          _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Matching conversation");
          var matched = false;
          for (callId in _activeCalls) {
            if (callGuid === _activeCalls[callId].callGuid) {
              _activeCalls[callId].roomJid = roomJid;
              _activeRooms[roomJid] = Number(callId);
              updateSessionData();
              matched = true;
              break
            }
          }
          if (!matched) {
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Unable to match, no active call for this conversation");
            return false
          }
        }
      });
      jQueryInstance(Candy).on('candy:view.room.after-add', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid];
        Candy.View.Pane.Chat.getTab(roomJid).find(".label").html(_activeCalls[callId].campaignName);
        var pane = Candy.View.Pane.Room.getPane(roomJid);
        var button = pane.find(".hangup-button");
        button.click(function() {
          self.close(callId)
        });
        button = pane.find(".chatclosetab-button");
        button.click(function() {
          self.ready(callId)
        });
        button = pane.find(".chattransfer-button");
        if (config.showtransfer) {
          button.click(function() {
            self.showTransferDialog(callId)
          })
        }
        else {
          button.hide()
        }
        var status = pane.find(".chatstatus-text");
        status.text(strings.ChatStateTalking);
        var myTimerId = setInterval(function() {
            var endDate = new Date;
            var timeDiff = Math.abs(startDate - endDate);
            var hh = Math.floor(timeDiff / 1000 / 60 / 60);
            if (hh < 10) {
              hh = '0' + hh
            }
            timeDiff -= hh * 1000 * 60 * 60;
            var mm = Math.floor(timeDiff / 1000 / 60);
            if (mm < 10) {
              mm = '0' + mm
            }
            timeDiff -= mm * 1000 * 60;
            var ss = Math.floor(timeDiff / 1000);
            if (ss < 10) {
              ss = '0' + ss
            }
            timer.text(hh + ":" + mm + ":" + ss)
          }, 1000);
        var timer = pane.find(".chatduration-text");
        var data = timer.data();
        data.timerid = myTimerId;
        var startDate = new Date;
        timer.text("00:00:00");
        var messageList = pane.find(".message-pane-wrapper")[0],
          messageText = pane.find("[name=message]")[0];
        data = pane.data();
        data.filetransfers = {};
        Candy.View.Pane.Chat.fitTabs();
        messageText.onchange = messageText.oninput = function() {
          if (messageText.value === '') {
            Candy.Core.notifystate(roomJid, "paused");
            data.lastnotificationsent = 0
          }
          else if (!data.lastnotificationsent || dT() - data.lastnotificationsent > 5000) {
            Candy.Core.notifystate(roomJid, "composing");
            data.lastnotificationsent = dT()
          }
        };
        messageList.ondragover = messageText.ondragover = function(evt) {
          evt || (evt = window.event);
          evt && evt.preventDefault()
        };
        messageList.ondrop = messageText.ondrop = function(evt) {
          evt || (evt = window.event);
          evt && evt.preventDefault();
          if (!Candy.Core.isConnected()) {
            return
          }
          if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
            return
          }
          if (evt.source === messageList || evt.source === messageText) {
            return
          }
          var text = evt.dataTransfer.getData("text");
          if (text) {
            messageText.value = text;
            messageText.select();
            return
          }
          var files = evt.dataTransfer.files;
          if (files && files.length > 0) {
            doFileTransfer(roomJid, files[0]);
            return
          }
        }
      });
      jQueryInstance(Candy).on('candy:view.pane.roster.after-update', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid];
        if (args.action === "join") {
          if (callId === undefined) {
            _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Discarding unmatched conversation notification");
            return
          }
          if (!_activeCalls[callId].externalPartyUserName) {
            var user = args.user,
              username = user.getNick();
            if (user.getRole() !== user.ROLE_MODERATOR && username !== Candy.Core.getUsername()) {
              _activeCalls[callId].externalPartyUserName = username;
              _activeCalls[callId].externalPartyDisplayName = user.getNick(true);
              updateSessionData();
              events.newcall.raise(_phonebar, {callId: callId})
            }
          }
        }
        else {
          Candy.View.deletenotification(roomJid)
        }
      });
      jQueryInstance(Candy).on('candy:view.message.before-show', function(evt, args) {
        if (args.message.startsWith("*begin*")) {
          if (!args.history && args.name !== Candy.Core.getUsername()) {
            var message = new Ifm.Messaging.FStringMessageReader(args.message);
            if (message.type === "FTTOKEN") {
              var file = {
                  token: message.data[0], name: message.data[1], size: Number(message.data[2]), type: message.data[3]
                };
              doFileTransfer(args.roomJid, file)
            }
            else if (message.type === "FTUNSUP") {
              cancelAllFileTransfers(args.roomJid);
              Candy.View.Pane.Chat.Modal.showError(strings.FileTransfer.NotAvailOther)
            }
            else {
              var roomJid = args.roomJid,
                callId = _activeRooms[roomJid];
              events.sysmessage.raise(_phonebar, {
                callId: callId, message: message
              })
            }
          }
          return false
        }
      });
      jQueryInstance(Candy).on('candy:view.message.before-render', function(evt, args) {
        var data = args.templateData,
          callId = _activeRooms[data.roomJid],
          sender = data.displayName,
          senderIsBot = sender.startsWith('Synthetic'),
          sentFromHere = data.name !== _activeCalls[callId].externalPartyUserName;
        if (senderIsBot && strings.BotNickname) {
          data.displayName = strings.BotNickname;
          data.croppedDisplayName = Candy.Util.crop(data.displayName, Candy.View.getOptions().crop.message.nickname)
        }
        var e = {
            callId: callId, displayName: data.displayName, sender: sender, senderIsBot: senderIsBot, sentFromHere: sentFromHere, rawMessage: args.rawMessage, message: data.message, time: data.time, timestamp: data.timestamp, history: args.history, attributes: args.attributes
          };
        data.sender = e.sentFromHere ? "sender-is-me" : "sender-is-other";
        if (senderIsBot)
          data.sender += " sender-is-bot";
        events.newmessage.raise(_phonebar, e);
        if (e.displayName && e.displayName !== data.displayName) {
          data.displayName = e.displayName;
          data.croppedDisplayName = Candy.Util.crop(data.displayName, Candy.View.getOptions().crop.message.nickname)
        }
        data.message = Ifm.Chat.Extras.UrlPreview.findAndGenerate(args.templateData.roomJid, e.message);
        if (!data.message)
          return false
      });
      jQueryInstance(Candy).on('candy:view.message.after-show', function(evt, args) {
        if (args.name === Candy.Core.getUsername())
          return;
        var e = args.element;
        e.addClass("new-message-highlight");
        setTimeout(function() {
          e.removeClass("new-message-highlight")
        }, 4000);
        Candy.View.movenotification(args.roomJid)
      });
      jQueryInstance(Candy).on('candy:view.presence', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid],
          transferred = _activeCalls[callId] && _activeCalls[callId].transferred,
          pane = Candy.View.Pane.Room.getPane(roomJid);
        Candy.View.deletenotification(roomJid);
        cancelAllFileTransfers(roomJid);
        if (transferred) {
          Candy.View.Pane.Room.close(roomJid)
        }
        else if (pane) {
          Candy.View.Pane.Chat.getTab(roomJid).addClass("closed");
          pane.find(".message-form-wrapper").css({visibility: "hidden"});
          pane.find(".message-pane-wrapper").css({opacity: ".80"});
          pane.find(".hangup-button").hide();
          pane.find(".chattransfer-button").hide();
          pane.find(".chatclosetab-button").show();
          var timer = pane.find(".chatduration-text");
          var data = timer.data();
          clearInterval(data.timerid);
          var status = pane.find(".chatstatus-text");
          status.text(strings.ChatStateClosed)
        }
        if (_activeCalls[callId] && _activeCalls[callId].callClosed !== true) {
          events.callclosed.raise(_phonebar, {callId: callId});
          _activeCalls[callId].callClosed = true;
          updateSessionData()
        }
      });
      jQueryInstance(Candy).on('candy:view.room.after-close', function(evt, args) {
        var roomJid = args.roomJid,
          callId = _activeRooms[roomJid];
        if (_activeCalls[callId] && _activeCalls[callId].callClosed !== true) {
          events.callclosed.raise(_phonebar, {callId: callId});
          _activeCalls[callId].callClosed = true
        }
        delete _activeCalls[callId];
        delete _activeRooms[roomJid];
        updateSessionData()
      })
    }
    function restoreSessionData() {
      var data = window.sessionStorage.getItem('chat-session-calls');
      if (data) {
        _activeCalls = JSON.parse(data)
      }
      data = window.sessionStorage.getItem('chat-session-rooms');
      if (data) {
        _activeRooms = JSON.parse(data)
      }
    }
    function updateSessionData() {
      window.sessionStorage.setItem('chat-session-calls', JSON.stringify(_activeCalls));
      window.sessionStorage.setItem('chat-session-rooms', JSON.stringify(_activeRooms))
    }
    function doFileTransfer(roomJid, file) {
      if (roomJid === undefined || _activeRooms[roomJid] === undefined) {
        _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Invalid conversation");
        return
      }
      var callId = _activeRooms[roomJid];
      if (_activeCalls[callId].mediatype !== Ifm.PhoneBar.Mediatypes.NearRealTime) {
        Ifm.Diagnostics.Debug.print("Unsupported mediatype of call", callId);
        return
      }
      if (!Ifm.Net.Services.FileTransfer.isSupported() || !config.ftservice) {
        if (isSender) {
          Candy.View.Pane.Chat.Modal.showError(strings.FileTransfer.NotAvailable)
        }
        else {
          var um = new Ifm.Messaging.FStringMessageWriter("FTUNSUP").end();
          Candies.send(roomJid, um)
        }
        return
      }
      var ft = Ifm.Net.Services.FileTransfer.create(config.ftservice);
      Ifm.Chat.Extras.FileTransfer.transferFile(roomJid, ft, file, strings);
      events.filetransfer.raise(_phonebar, {
        callId: _activeRooms[roomJid], file: file, filetransfer: ft
      })
    }
    function cancelAllFileTransfers(roomJid) {
      var pane = Candy.View.Pane.Room.getPane(roomJid);
      var data = pane && pane.data();
      if (data && data.filetransfers) {
        for (var id in data.filetransfers) {
          data.filetransfers[id].filetransfer.cancel();
          delete data.filetransfers[id]
        }
      }
    }
    function hangup(callId, close) {
      if (!callId || !_activeCalls[callId]) {
        return
      }
      var roomJid = _activeCalls[callId].roomJid;
      if (!roomJid || !_activeRooms[roomJid]) {
        return
      }
      Candy.Core.Action.Jabber.Room.Leave(roomJid);
      if (close) {
        if (Candy.View.Pane.Room.getPane(roomJid)) {
          cancelAllFileTransfers(roomJid);
          Candy.View.Pane.Room.close(roomJid)
        }
      }
    }
    function onAssignment(phonebar, e) {
      if (e.mediatype === Ifm.PhoneBar.Mediatypes.NearRealTime || e.mediatype === Ifm.PhoneBar.Mediatypes.StoreAndForward) {
        phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Assignment event");
        _activeCalls[e.callId] = e;
        updateSessionData()
      }
    }
    function onCallFailure(phonebar, e) {
      if (_activeCalls[e.callId]) {
        phonebar.log("PhoneBar.Media.Xmpp", "Debug", "CallFailure event");
        hangup(e.callId, true)
      }
    }
    function buildCandyAsync() {
      return new Promise(function(resolve) {
          if (Ifm.Photon && Ifm.Photon.app.isHosted) {
            const url = 'popup.html';
            const html = '<div id="candy"></div>';
            const newWindow = Ifm.Dom.Photon.Cards.show(html, 'chat-window', true, null, 0, 'Chat', {
                left: screen.availWidth - 470, top: 200, width: 450, height: 450, minimizeOnClose: true, showInTaskbar: true
              });
            if (newWindow) {
              Ifm.Dom.whenWindowNavigates(newWindow, url, function(newDocument) {
                newWindow.jQuery.i18n = jQuery.i18n;
                buildCandyCore(newWindow.jQuery);
                events.reachable = function() {
                  newWindow.document.title = strings.WindowTitle
                };
                events.unreachable = function() {
                  newWindow.document.title = strings.TerminalUnregistered
                };
                resolve(newWindow)
              })
            }
            else {
              throw new Error("Could not create a window for chat terminal.");
            }
          }
          else {
            buildCandyCore(jQuery);
            resolve(window)
          }
        })
    }
    function buildCandyCore(jQueryInstance) {
      buildCandy(jQueryInstance);
      buildCandies('internal')
    }
    return {
        isConnected: function() {
          return Candy.Core.isConnected()
        }, activeCalls: function() {
            throw new Error("Obsolete. Use Ifm.PhoneBar.instance.calls() instead.");
          }, getCall: function(id) {
            throw new Error("Obsolete. Use Ifm.PhoneBar.instance.calls() instead.");
          }, initialize: function(pb, conf, PhoneBarNS) {
            if (!pb)
              throw Ifm.Diagnostics.Errors.arg("pb");
            _phonebar = pb;
            PhoneBar = PhoneBarNS || Ifm.PhoneBar;
            if (!conf)
              throw Error("Invalid configuration.");
            function customOrDefault(propertyName) {
              return conf.hasOwnProperty(propertyName) ? conf[propertyName] : config[propertyName]
            }
            function customOrError(propertyName) {
              if (!conf[propertyName])
                throw Error("Invalid configuration, argument '" + propertyName + "' is missing.");
              return conf[propertyName]
            }
            config.service = customOrError("service");
            config.server = customOrError("server");
            config.mediatypes = customOrError("mediatypes");
            config.ftservice = customOrDefault("ftservice");
            config.nickname = customOrDefault("nickname");
            config.theme = customOrDefault("theme");
            config.language = customOrDefault("language");
            config.domain_nrt = customOrDefault("domain_nrt");
            config.domain_saf = customOrDefault("domain_saf");
            config.admin_nrt = customOrDefault("admin_nrt");
            config.admin_saf = customOrDefault("admin_saf");
            config.presence = customOrDefault("presence");
            config.debug = customOrDefault("debug");
            config.showtransfer = customOrDefault("showtransfer");
            if (!config.areValidMediatypes())
              throw Error("Invalid mediatype(s).");
            config.mediatypes = +config.mediatypes;
            PhoneBar.events.assignment.addHandler(onAssignment);
            PhoneBar.events.callfailure.addHandler(onCallFailure);
            return new Promise(function(resolve) {
                if (!_isInitialized) {
                  buildCandyAsync().then(function(windowInstance) {
                    setupCandy(windowInstance);
                    _isInitialized = true;
                    events.initialized.raise(_phonebar, {});
                    resolve()
                  })
                }
                else {
                  events.initialized.raise(_phonebar, {});
                  resolve()
                }
              })
          }, terminate: function() {
            if (this.isConnected())
              throw Ifm.Diagnostics.Errors.op("must be disconnected");
            PhoneBar.events.assignment.removeHandler(onAssignment);
            PhoneBar.events.callfailure.removeHandler(onCallFailure)
          }, connect: function() {
            var newext = _phonebar.agent.extension;
            var newfirstname = _phonebar.agent.firstName;
            var newlastname = _phonebar.agent.lastName;
            if (!newext) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Can't connect without an extension specified");
              Candy.Core.keepconnected = false;
              Candy.Core.disconnect();
              return
            }
            var oldext = config.extension || null;
            config.extension = newext;
            var oldname = config.firstname || null;
            config.firstname = newfirstname;
            var olddisplayname = config.displayname || null;
            config.displayname = config.nickname || config.firstname;
            var wasConnected = Candy.Core.isConnected();
            if (newext !== oldext || config.displayname !== olddisplayname) {
              if (wasConnected) {
                Candy.Core.keepconnected = true;
                Candy.Core.disconnect()
              }
            }
            if (!wasConnected) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Connecting as", config.displayname);
              Candy.Core.keepconnected = true;
              Candy.Core.connect(config.server, null, config.getUsername())
            }
          }, disconnect: function() {
            if (!this.isConnected())
              return;
            for (var roomJid in _activeRooms) {
              Candy.Core.Action.Jabber.Room.Leave(roomJid)
            }
            setTimeout(function() {
              var attempt = 0;
              var check = setInterval(function() {
                  var calls = Ifm.Enum.getLength(_activeRooms);
                  if (calls > 0 && ++attempt < 10) {
                    _phonebar.log("PhoneBar.Media.Xmpp", "Debug", "Waiting for calls to close:", calls, "remaining");
                    return
                  }
                  clearInterval(check);
                  for (var roomJid in _activeRooms) {
                    cancelAllFileTransfers(roomJid);
                    if (Candy.View.Pane.Room.getPane(roomJid)) {
                      Candy.View.Pane.Room.close(roomJid)
                    }
                  }
                  Candy.Core.keepconnected = false;
                  Candy.Core.disconnect()
                }, 100)
            }, 100)
          }, handled: function(callId) {
            if (this.sendSysMessage(callId, "HANDLED")) {
              _activeCalls[callId].handled = true;
              updateSessionData();
              return true
            }
            return false
          }, send: function(callId, message) {
            if (!this.isConnected()) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Cannot send messages while disconnected from XMPP server");
              return false
            }
            if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
              return false
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
              return false
            }
            Candies.send(roomJid, message);
            return true
          }, sendCallInfo: function(callId, data) {
            var msg = new Ifm.Messaging.FStringMessageWriter("CALLINFO");
            for (var i in data) {
              msg.add(i + ':' + data[i])
            }
            return this.send(callId, msg.end().toString())
          }, sendSysMessage: function(callId, type, args) {
            var msg = new Ifm.Messaging.FStringMessageWriter(type);
            for (var i = 2; i < arguments.length; i++) {
              msg.add(arguments[i])
            }
            return this.send(callId, msg.end().toString())
          }, showTransferDialog: function(callId) {
            try {
              Ifm.PhoneBar.UI.Commands.showTransferForm(callId)
            }
            catch(err) {}
            events.showtransferform.raise(_phonebar, {callId: callId})
          }, close: function(callId) {
            if (!this.isConnected())
              return;
            if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
              return
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
              return
            }
            Candy.Core.Action.Jabber.Room.Leave(roomJid)
          }, ready: function(callId) {
            if (_phonebar.calls(callId) && _phonebar.calls(callId).postcall) {
              _phonebar.ready(callId)
            }
            if (!Candy.Core.isConnected())
              return;
            if (_activeCalls[callId] === undefined) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
              return
            }
            if (!_activeCalls[callId].terminated) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Call not yet terminated", callId);
              return
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
              return
            }
            if (Candy.View.Pane.Room.getPane(roomJid)) {
              cancelAllFileTransfers(roomJid);
              Candy.View.Pane.Room.close(roomJid)
            }
          }, append: function(callId, html) {
            console.warn("Obsolete. Use xmpp.conversation.append() instead");
            self.conversation.append(callId, html)
          }, conversation: {
            append: function(callId, html) {
              if (_activeCalls[callId] === undefined) {
                _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
                return
              }
              var roomJid = _activeCalls[callId].roomJid;
              if (roomJid === undefined) {
                _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
                return
              }
              Candy.View.Pane.Chat.onInfoMessage(roomJid, "{{message}}");
              var pane = Candy.View.Pane.Room.getPane(roomJid),
                lastmessage = pane.find(".message-pane").children().last(),
                templatedhtml = lastmessage.html();
              lastmessage.html(templatedhtml.replace("{{message}}", html))
            }, html: function(callId) {
                if (_activeCalls[callId] === undefined) {
                  _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
                  return
                }
                var roomJid = _activeCalls[callId].roomJid;
                if (roomJid === undefined) {
                  _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
                  return
                }
                var pane = Candy.View.Pane.Room.getPane(roomJid);
                return pane.find(".message-pane").html()
              }, prepend: function(callId, html) {
                if (_activeCalls[callId] === undefined) {
                  _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
                  return
                }
                var roomJid = _activeCalls[callId].roomJid;
                if (roomJid === undefined) {
                  _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
                  return
                }
                if (html) {
                  var pane = Candy.View.Pane.Room.getPane(roomJid);
                  pane.find(".message-pane").prepend(html)
                }
              }, select: function(callId) {
                if (_activeCalls[callId] === undefined) {
                  _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
                  return
                }
                var roomJid = _activeCalls[callId].roomJid;
                if (roomJid === undefined) {
                  _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
                  return
                }
                Candy.View.Pane.Room.show(roomJid)
              }
          }, queryFileTransfer: function(callback) {
            if (!Ifm.Type.isFunction(callback)) {
              throw Ifm.Diagnostics.Errors.func("callback");
            }
            if (!Ifm.Net.Services.FileTransfer.isSupported() || !config.ftservice) {
              callback(false);
              return
            }
            var ft = Ifm.Net.Services.FileTransfer.create(config.ftservice);
            ft.enabled(callback)
          }, requestFileTransfer: function(callId, file) {
            if (_activeCalls[callId] === undefined || _activeCalls[callId].terminated) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Invalid callId", callId);
              return
            }
            if (_activeCalls[callId].mediatype !== Ifm.PhoneBar.Mediatypes.NearRealTime) {
              Ifm.Diagnostics.Debug.print("Unsupported mediatype of call", callId);
              return
            }
            var roomJid = _activeCalls[callId].roomJid;
            if (roomJid === undefined) {
              _phonebar.log("PhoneBar.Media.Xmpp", "Warn", "Session not yet created for call", callId);
              return
            }
            if (!file || !file.name || file.size === undefined || !file.type) {
              var i = document.createElement("input");
              i.type = "file";
              i.style.cssText = "display:none!important;";
              document.body.appendChild(i);
              i.click();
              document.body.removeChild(i);
              i.onchange = function(e) {
                if (i.files && i.files.length > 0) {
                  doFileTransfer(roomJid, i.files[0])
                }
              };
              return
            }
          }
      }
  })();
  var self = ns.Xmpp.instance
})();
namespace("Ifm.Chat.Strings");
(function(ns) {
  ns.en = {
    ChatStateComposing: "is writing...", ChatStateTalking: "Chatting", ChatStateClosed: "Chat terminated", TerminalRegistered: "Chat connected", TerminalUnregistered: "Chat not connected", WindowTitle: "Chat", BotNickname: "Synthetic", FileTransfer: {
        NotAvailable: "File transfer not available", NotAvailOther: "File transfer not available with this user", TransferTitle: "File", Complete: "transferred", Accept: "Accept", Cancel: "Cancel", Open: "Open", Waiting: "waiting", Canceled: "canceled", Error: "error", Receiving: "receiving", Sending: "sending", Received: "received", Sent: "sent"
      }
  };
  ns.it = {
    ChatStateComposing: "sta scrivendo...", ChatStateTalking: "In conversazione", ChatStateClosed: "Conversazione chiusa", TerminalRegistered: "Chat connessa", TerminalUnregistered: "Chat non connessa", WindowTitle: "Chat", BotNickname: "Synthetic", FileTransfer: {
        NotAvailable: "Trasferimento file non disponibile", NotAvailOther: "Trasferimento file non disponibile con questo utente", TransferTitle: "File", Complete: "trasferito", Accept: "Accetta", Cancel: "Annulla", Open: "Apri", Waiting: "in attesa", Canceled: "annullato", Error: "errore", Receiving: "ricezione", Sending: "invio", Received: "ricevuto", Sent: "inviato"
      }
  }
})(Ifm.Chat.Strings);
;
namespace("Ifm.ChromeBar.Strings", {en: {
    InfoNotificationPopupTitle: "ChromeBar", WarningNotificationPopupTitle: "ChromeBar - Warning", ErrorNotificationPopupTitle: "ChromeBar - Error", RequestRefused: "Request refused", NoBrowserSupport: "This browser does not have the features needed to run the ChromeBar", InvalidConfig_MissingPhonesServer: "Configuration error: at least one #phones server must be defined", InvalidConfig_InvalidServerFormat: "Configuration error: the #phones server name does not respect the expected format (ws://server:port/)", InvalidConfig_MissingExtension: "Configuration error: invalid extension", InvalidConfig_MissingSPCService: "Configuration error: SPC service is missing or invalid", InvalidConfig_MissingSPCDomain: "Configuration error: SPC domain is missing or invalid", ConfigNotSaved: "Configuration not saved: new configuration is invalid or ChromeBar is active", ConfigNotSaved_Locked: "Configuration not saved: operation not allowed", ConfigurationSaved: "Configuration succesfully saved", ConfigurationPartiallySaved: "The ChormeBar is active: only the 'Options' parameters have been saved", PanicSent: "Panic request sent", BusyInOtherMediaCallMessage: "Engaged in non-telephonic calls", MicrophoneWarningMessage1: "Warning", MicrophoneWarningMessage2: "Audio Capture permission not granted!", VirtualPhoneTabLabel: "Virtual Phone", QueueInfoTabLabel: "Queue Info", AssignedCampaignsTabLabel: "Assigned Campaigns", ActiveCallsTabLabel: "Active Calls", HandledCallsTabLabel: "Handled Calls", FailedCallsTabLabel: "Failed Calls", SoftPhoneNotConnectedStateLabel: "{0}: not connected", SoftPhoneNotRegisteredStateLabel: "{0}: not registered", SoftPhoneRegisteredStateLabel: "{0}: registered", SoftPhoneRegisteredNoMediaStateLabel: "{0}: registered, media device access not granted", XmppNotConnectedStateLabel: "XMPP server: not connected", XmppConnectedStateLabel: "XMPP Server: connected", TooltipShowRecordingPanelButton: "Show/Hide recording commands", TooltipAddCueSheetButton: "Add CueSheet in the recording file", TooltipCueSheetText: "CueSheet text", TooltipPickup: "Click to answer", TooltipSwitchToExtendedView: "Switch to extended view", TooltipSwitchToCompactView: "Switch to classic view", PageTitle: "ChromeBar", MainMenuEntry: "General", Oauth2Entry: "Single sign-on", OptionsMenuEntry: "Options", ScriptsMenuEntry: "Scripts", SPCConfigMenuEntry: "SoftPhone", WebRTCConfigMenuEntry: "WebRTC", XMPPConfigMenuEntry: "XMPP", MainTabTitle: "General", AgentTabTitle: "Agent", Oauth2TabTitle: "Single sign-on", OptionsTabTitle: "Options", ScriptsTabTitle: "Scripts", PluginsTabTitle: "Plugins", SoftPhoneConfigTabTitle: "SPC Connection Parameters", WebRTCConfigTabTitle: "WebRTC Server Connection Parameters", XmppConfigTabTitle: "XMPP Server Connection Parameters", CommonTabSubtitle: "Parameters marked with '*' are optional: leave unset to use default values", ProvisionLoginInstructionLabel: "Log in with your account credentials to continue", ProvisionedConfigurationLabel: "Enable configuration provisioning", IsRemoteOperatorLabel: "Agent is remote:", WebSocketGatewayServiceLabel: "WebSocketGateway services:", ExtensionLabel: "Extension:", PhoneDeviceTypeLabel: "Telephone device:", RecordingPathLabel: "Recording folder:", LanguageLabel: "Language:", SkinLabel: "Skin:", EnableOauth2LoginLabel: "Enable OAuth2 login:", IsAdfsLabel: "Authority is ADFS:", AuthorityUrlLabel: "Authority URL:", ClientIdLabel: "Client Id:", ScopesLabel: "Scopes:", HideClockWhenPausedLabel: "Hide the time spent in the pause state:", HidePausedAgentsLabel: "Hide the paused agents in the transfer call dialog:", ShowPopupForManualCallsLabel: "Display information popup for icoming manual calls:", ShowCampaignNameForVoiceCallsLabel: "Display campaign name for voice calls:", EnableAbortCallLabel: "Enalbe 'Abort' button for outbound calls:", DisableManualCallLabel: "Disable manual call:", AutoAnswerPhoneLabel: "Automatically answer these calls:", AutoAnswerPhone0Label: "none (do not answer automatically)", AutoAnswerPhone1Label: "#phones outbound calls", AutoAnswerPhone2Label: "#phones inbound and outbound calls", AutoAnswerPhone3Label: "all calls (#phones and manual)", AutoAnswerRingsLabel: "Number of rings before automatic answer:", CallingNumberLabel: "Calling number for outbound calls:", RemeberCredentialLabel: "Enable saving of credentials in a cookie:", RemeberCredential0Label: "don't save anything (delete previous saves)", RemeberCredential1Label: "save credentials without password", RemeberCredential2Label: "save credentials with password", ShowPopoupIncomingCallLabel: "Display information popup for incoming calls of the specified media types:", NoPopupLabel: "none", VoiceCallsLabel: "voice calls", NrtCallsLabel: "near real-time calls (chat)", SafCallsLabel: "store and forward calls (mail/social)", VoiceAndNrtCallsLabel: "voice and near real-time (chat) calls", VoiceAndSafCallsLabel: "voice and store and forward (mail/social) calls", NrtAndSafCallsLabel: "near real-time (chat) and store and forward (mail/social) calls", AllCallsLabel: "all calls", PopupTypeForIncomingCallLabel: "Type of information popup for incoming calls (for selected media only):", WindowsNotificationLabel: "show Windows notifications (if enabled)", ChromeBarPopupLabel: "shows ChromeBar popup as topmost window", BothPopupTypeLabel: "show both", EnableCallHistoryLogLabel: "Enable call history log for specified outcomes:", SaveNoneLabel: "none", SaveConnectedCallsOnlyLabel: "saves only connected calls", SaveFailedCallsOnlyLabel: "saves only failed calls", SaveBothCallsTypeLabel: "saves both types of calls", CallHistoryLogLenLabel: "Maximum number of calls to be stored in the log (for each type)", ClearCallHistoryOnLogout: "Clear call history log on logout:", AutoConnectToXMPP: "Automatically connect to the XMPP server:", HideCallerNumberLabel: "Hide the caller number:", EnableExternalRing: "Enable external ring:", ExternalRingFileWavUri: "URL wav file for external ring:", EnabledColumnHeaderLabel: "Enabled", UrlColumnHeaderLabel: "URL", PopupColumnHeaderLabel: "Popup", WinHeightColumnHeaderLabel: "Window Height", WinWidthColumnHeaderLabel: "Window Width", IconNameColumnHeaderLabel: "Icon Name", SoftPhoneControllerUrl: "SPC URL:", SoftPhoneRegistrarDomain: "Registrar domain:", WebRtcDomain: "Domain:", WebRtcWebRtcAddresses: "Addresses:", WebRtcIceServers: "ICE Servers:", WebRtcUseDomainOfLoggedUser: "Use domain of logged user:", UseBuiltinChatAgentWindow: "Use built-in chat window:", ChatServiceUrl: "Chat serice URL:", XmppServerName: "XMPP server name:", FileTransferServiceUrl: "File transfer service URL:", MediaType: "Media type:", AgentNickNameOverride: "Agent nickname: *", NrtDomainName: "Near real-time domain name: *", NrtAdminName: "Near real-time domain administrator: *", SafDomainName: "Store and forward domain name: *", SafAdminName: "Store and forward domain administrator: *", YesLabel: "Yes", NoLabel: "No", TrueLabel: "True", FalseLabel: "False", SaveButton: "Save configuration", VersionLabel: "Version: {0} - Copyright \u00A9 Base Digitale Platform", InvalidConfig: "Invalid configuration", TooltipOptions: "Configuration", TootltipAbortCall: "Abort Call", QueuedNumberText: "Calls currently queued", QueuedMaxTimeText: "Max queue time", QueuedAvgTimeText: "Avg queue time", CampaignName: "Campaign name", CampaignDirection: "Direction", CampaignState: "Active", CampaignStateActive: "Yes", CampaignStateInactive: "No", LoginUserName: "User Name:", LoginSiteSelection: "Site: ", CallId: "Id", CallMediaType: "Type", CallCampaignName: "Campaign Name", IsRecording: "Rec", InPostCall: "PCW", DateTime: "Date/Time", PhoneNumber: "Number", DisplayName: "Name", Audio_MediaType: "Voice", NRT_MediaType: "NRT", SAF_MediaType: "SAF"
  }});
;
namespace("Ifm.ChromeBar.Strings", {it: {
    InfoNotificationPopupTitle: "ChromeBar", WarningNotificationPopupTitle: "ChromeBar - Avviso", ErrorNotificationPopupTitle: "ChromeBar - Errore", RequestRefused: "Richiesta rifiutata", NoBrowserSupport: "Questo browser non ha le funzionalit\u00E0 necessarie a eseguire la ChromeBar", InvalidConfig_MissingPhonesServer: "Errore di configurazione: deve essere definito almeno un server #phones", InvalidConfig_InvalidServerFormat: "Errore di configurazione: il nome del server #phones non rispetta il formato atteso (ws://server:port/)", InvalidConfig_MissingExtension: "Errore di configurazione: interno telefonico non valido", InvalidConfig_MissingSPCService: "Errore di configurazione: servzio SPC mancante o non valido", InvalidConfig_MissingSPCDomain: "Errore di configurazione: dominio SPC mancante o non valido", ConfigNotSaved: "Configurazione non salvata: nuova configurazione non valida o ChromeBar attiva", ConfigNotSaved_Locked: "Configurazione non salvata: operazione non consentita", ConfigurationSaved: "La configurazione \u00E8 stata salvata con successo", ConfigurationPartiallySaved: "La ChormeBar \u00E8 attiva: solo i parametri relativi alle 'Opzioni' sono stati salvati", PanicSent: "Richiesta di assistenza inviata", BusyInOtherMediaCallMessage: "Impegnato in chiamate non telefoniche", MicrophoneWarningMessage1: "Attenzione!", MicrophoneWarningMessage2: "Non \u00E8 stato possibile ottenere i diritti a usare il microfono!", VirtualPhoneTabLabel: "Telefono Virtuale", QueueInfoTabLabel: "Code", AssignedCampaignsTabLabel: "Campagne assegnate", ActiveCallsTabLabel: "Chiamate attive", HandledCallsTabLabel: "Chiamate gestite", FailedCallsTabLabel: "Chiamate fallite", SoftPhoneNotConnectedStateLabel: "{0}: non connesso", SoftPhoneNotRegisteredStateLabel: "{0}: non registrato", SoftPhoneRegisteredStateLabel: "{0}: registrato", SoftPhoneRegisteredNoMediaStateLabel: "{0}: registrato, senza accesso al microfono", XmppNotConnectedStateLabel: "Server XMPP: non connesso", XmppConnectedStateLabel: "Server XMPP: connesso", TooltipShowRecordingPanelButton: "Mostra/Nascondi comandi registrazione", TooltipAddCueSheetButton: "Inserisci label nel file registrato", TooltipCueSheetText: "Testo della label da inserire nel file registrato", TooltipPickup: "Clicca sulla notifica per rispondere", TooltipSwitchToExtendedView: "Passa a modalit\u00E0 estesa", TooltipSwitchToCompactView: "Passa a modalit\u00E0 compatta", PageTitle: "ChromeBar", MainMenuEntry: "Generale", Oauth2Entry: "Single sign-on", OptionsMenuEntry: "Opzioni", ScriptsMenuEntry: "Script", SPCConfigMenuEntry: "SoftPhone", WebRTCConfigMenuEntry: "WebRTC", XMPPConfigMenuEntry: "XMPP", MainTabTitle: "Generale", AgentTabTitle: "Agente", Oauth2TabTitle: "Single sign-on", OptionsTabTitle: "Opzioni", ScriptsTabTitle: "Script", PluginsTabTitle: "Plugin", SoftPhoneConfigTabTitle: "SoftPhone controller", WebRTCConfigTabTitle: "Server WebRTC", XmppConfigTabTitle: "Server XMPP", CommonTabSubtitle: "I parametri con '*' sono opzionali: possono essere lasciati vuoti per usare i valori predefiniti", ProvisionLoginInstructionLabel: "Accedi con le credenziali del tuo account per proseguire", ProvisionedConfigurationLabel: "La configurazione \u00E8 fornita dal server?", IsRemoteOperatorLabel: "L'agente \u00E8 remoto:", WebSocketGatewayServiceLabel: "WebSocketGateway services:", ExtensionLabel: "Interno telefonico:", PhoneDeviceTypeLabel: "Dispositivo telefonico:", RecordingPathLabel: "Folder in cui salvare le registrazioni:", LanguageLabel: "Lingua:", SkinLabel: "Skin:", EnableOauth2LoginLabel: "Abilita login tramite Oauth2:", IsAdfsLabel: "L'authority \u00E8 di tipo ADFS:", AuthorityUrlLabel: "Authority URL:", ClientIdLabel: "Client Id:", ScopesLabel: "Scope (lista di valori separati da virgola):", HideClockWhenPausedLabel: "Nascondi il tempo di permanenza nello stato di pausa:", HidePausedAgentsLabel: "Nascondi gli agenti in stato 'Pausa' nel pannello di trasferimento:", ShowPopupForManualCallsLabel: "Visualizza popup informativo per le chiamate manuali in ingresso:", ShowCampaignNameForVoiceCallsLabel: "Visualizza il nome della campagna per le chiamate telefoniche:", EnableAbortCallLabel: "Abilita bottone 'abort' per le chiamate outbound:", DisableManualCallLabel: "Disabilita le chiamate manuali:", AutoAnswerPhoneLabel: "Rispondi automaticamente a queste chiamate:", AutoAnswerPhone0Label: "nessuna", AutoAnswerPhone1Label: "chiamate #phones di outbound", AutoAnswerPhone2Label: "chiamate #phones di inbound e outbound", AutoAnswerPhone3Label: "tutte (#phones e manuali)", AutoAnswerRingsLabel: "Numero di squilli prima di eseguire la risposta automatica:", CallingNumberLabel: "Numero chiamante per le chiamate outbound:", RemeberCredentialLabel: "Abilita il salvataggio delle credenziali in un cookie:", RemeberCredential0Label: "non salvare nulla (cancella precedenti salvataggi)", RemeberCredential1Label: "salva le credenziali senza password", RemeberCredential2Label: "salva le credenziali compresa password", ShowPopoupIncomingCallLabel: "Visualizza popup informativo per le chiamate in arrivo dei media type specificati:", NoPopupLabel: "nessuna", VoiceCallsLabel: "solo chiamate vocali", NrtCallsLabel: "solo chiamate near real-time (chat)", SafCallsLabel: "solo chiamate store and forward (mail/social)", VoiceAndNrtCallsLabel: "chiamate vocali e near real-time (chat)", VoiceAndSafCallsLabel: "chiamate vocali e store and forward (mail/social)", NrtAndSafCallsLabel: "chiamate near real-time (chat) e store and forward (mail/social)", AllCallsLabel: "tutte le chiamate", PopupTypeForIncomingCallLabel: "Tipo di popup informativo per le chiamate in arrivo (solo per i media selezionati):", WindowsNotificationLabel: "mostra notifiche Windows (se abilitate nelle impostazioni)", ChromeBarPopupLabel: "mostra ChromeBar in primo piano", BothPopupTypeLabel: "mostra entrambe", EnableCallHistoryLogLabel: "Abilita il registro delle chiamate per i seguenti esiti:", SaveNoneLabel: "nessuno", SaveConnectedCallsOnlyLabel: "solo chiamate connesse", SaveFailedCallsOnlyLabel: "solo chiamate fallite", SaveBothCallsTypeLabel: "tutte indipendentemente dall'esito", CallHistoryLogLenLabel: "Numero massimo di chiamate nello storico (per ogni tipo):", ClearCallHistoryOnLogout: "Svuota lo storico delle chiamate sul logout:", AutoConnectToXMPP: "Connetti automaticamente al server XMPP:", HideCallerNumberLabel: "Non visualizzare numero chiamante:", EnableExternalRing: "Abilita ring esterno:", ExternalRingFileWavUri: "URL file wav per ring esterno:", EnabledColumnHeaderLabel: "Abilitato", UrlColumnHeaderLabel: "URL", PopupColumnHeaderLabel: "Popup", WinHeightColumnHeaderLabel: "Altezza finestra", WinWidthColumnHeaderLabel: "Larghezza finestra", IconNameColumnHeaderLabel: "Nome icona", SoftPhoneControllerUrl: "URL del SPC:", SoftPhoneRegistrarDomain: "Dominio di registrazione:", WebRtcDomain: "Dominio:", WebRtcWebRtcAddresses: "Indirizzi:", WebRtcIceServers: "Lista server ICE:", WebRtcUseDomainOfLoggedUser: "Usa dominio dell'utente loggato:", UseBuiltinChatAgentWindow: "Usa la finestra di chat integrata:", ChatServiceUrl: "URL del servizio chat:", XmppServerName: "Nome del server XMPP:", FileTransferServiceUrl: "URL del servizio di file transfer:", MediaType: "Media type:", AgentNickNameOverride: "Nickname dell'agente: *", NrtDomainName: "Nome del dominio near real-time: *", NrtAdminName: "Amministratore del dominio near real-time: *", SafDomainName: "Nome del dominio store and forward: *", SafAdminName: "Amministratore del dominio store and forward: *", YesLabel: "Si", NoLabel: "No", TrueLabel: "Vero", FalseLabel: "Falso", SaveButton: "Salva configurazione", VersionLabel: "Versione: {0} - Copyright \u00A9 Base Digitale Platform", InvalidConfig: "Configurazione non valida", TooltipOptions: "Configurazione", TootltipAbortCall: "Interrompi chiamata", QueuedNumberText: "Attualmente accodate", QueuedMaxTimeText: "Tempo massimo", QueuedAvgTimeText: "Tempo medio", CampaignName: "Nome Campagna", CampaignDirection: "Direzione", CampaignState: "Attiva", CampaignStateActive: "Si", CampaignStateInactive: "No", LoginUserName: "Nome utente:", LoginSiteSelection: "Sede:", CallId: "Id", CallMediaType: "Tipo", CallCampaignName: "Campagna", IsRecording: "Rec", InPostCall: "PCW", DateTime: "Data/Ora", PhoneNumber: "Numero", DisplayName: "Nome", Audio_MediaType: "Voce", NRT_MediaType: "NRT", SAF_MediaType: "SAF"
  }});
;
jQuery.fn.extend({
  enable: function() {
    return this.each(function() {
        jQuery(this).prop("disabled", false);
        jQuery(this).removeAttr("disabled")
      })
  }, disable: function() {
      return this.each(function() {
          jQuery(this).prop("disabled", true);
          jQuery(this).attr("disabled", "")
        })
    }, enabled: function(state) {
      return this.each(function() {
          if (state)
            jQuery(this).enable();
          else
            jQuery(this).disable()
        })
    }
});
var Ifm = Ifm || {};
function namespace(globalNamespace, entities) {
  var ns = Ifm,
    parts = globalNamespace.split('.');
  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    ns[part] = ns[part] || {};
    ns = ns[part]
  }
  for (var e in entities) {
    ns[e] = entities[e]
  }
  return ns
}
namespace("Ifm.ChromeBar.Constants").CallFailureCauseResources = {
  1: "CallFailureNoDialTone", 2: "CallFailureNoRingback", 3: "CallFailureLineBusy", 4: "CallFailureNoAnswer", 5: "CallFailureFaxTone", 6: "CallFailureRemoteHangUp", 7: "CallFailureAgentNoDialTone", 8: "CallFailureAgentNoRingback", 9: "CallFailureAgentBusy", 10: "CallFailureAgentNoAnswer", 255: "CallFailureUnknown"
};
namespace("Ifm.ChromeBar.Constants").LogLevels = {
  Debug: "DEBUG", Warn: "WARN", Error: "ERROR", Fatal: "FATAL"
};
namespace("Ifm.ChromeBar.Constants").Skins = {
  beach: "Beach", dark: "Dark", flowers: "Flowers", forest: "Forest", nexgen: "NexGen", pastel: "Pastel", portofino: "Portofino", purple: "Purple", red: "Red", sand: "Sand", sky: "Sky", wood: "Wood"
};
namespace("Ifm.ChromeBar.Constants").Languages = {
  en: "English", it: "Italiano"
};
namespace("Ifm.ChromeBar.Constants").PhoneDevices = {
  SPC: "SoftPhone", WebRTC: "WebRTC", Teams: "Teams", NoDevice: "NoDevice"
};
namespace("Ifm.ChromeBar.Constants").MessageCodes = {
  ChromeBarStatusChangedEvent: "chromeBarStatusChangedEvent", ChromeBarStatusTimerChangedEvent: "chromeBarStatusTimerChangedEvent", ChromeBarUpdateVuMetersEvent: "updateVuMetersEvent", ChromeBarDialTextBoxUpdateEvent: "dialTextBoxUpdateEvent", GetConfigurationRequest: "getConfigurationRequest", GetConfigurationReply: "getConfigurationReply", SetConfigurationRequest: "setConfigurationRequest", SetConfigurationReply: "setConfigurationReply", ConfigurationChangedEvent: "configurationChangedEvent", DumpRequest: "dump", ShowNotificationRequest: "showNotification", DialPadStateChangedEvent: "dialpadStateChangedEvent", QueueInfoUpdateEvent: "queueInfoUpdateEvent", ToggleQueueInfoRequest: "toggleQueueInfoRequest", ToggleQueueInfoReply: "toggleQueueInfoReply", SetCampaigPanelVisibilityEvent: "setCampaignPanelVisibilityEvent", InitializeRequest: "initializeRequest", DeregisterRequest: "deregisterRequest", GetCallsRequest: "getCallsRequest", GetCallsReply: "getCallsReply", ConnectionLostEvent: "connectionLostEvent", ProxyCommandExecutionResult: "proxyCommandExecutionResult", ChatClientConnectedEvent: "chatClientConnectedEvent", ChatClientDisconnectedEvent: "chatClientDisconnectedEvent", PopupChatWindowRequest: "popupChatWindowRequest", OpenChatWindowRequest: "openChatWindowRequest", DetachPopupWindowRequest: "detachPopupWindowRequest", CommunicationPortClosedEvent: "communicationPortClosed", GetProductVersionRequest: "getProductVersionRequest", GetProductVersionReply: "getProductVersionReply", CallDataChangedEvent: "callDataChangedEvent", EnableChromeBarButtonRequest: "enableChromeBarButtonRequest", EnableChromeBarButtonReply: "enableChromeBarButtonReply", ToggleRecordingPanelRequest: "toggleRecordingPanelRequest", ToggleRecordingPanelReply: "toggleRecordingPanelReply", MediaAccessGrantedEvent: "mediaAccessGrantedEvent", GetCallHistoryLogRequest: "getCallHistoryLogRequest", GetCallHistoryLogReply: "getCallHistoryLogReply", ClearCallHistoryLogRequest: "clearCallHistoryLogRequest", ToggleExternalPluginPopupRequest: "toggleExternalPluginPopupRequest", ToggleExternalPluginPopupReply: "toggleExternalPluginPopupRequest", OpenLoginDialogRequest: "openLoginDialogRequest", CloseLoginDialogRequest: "closeLoginDialogRequest", SetPopupTypeEvent: "setPopupTypeEvent", SavePopupWindowStateRequest: "savePopupWindowStateRequest", SelectedTabChangedEvent: "selectedTabChangedEvent", InitializeOffScreenPageRequest: "initializeOffScreenPageRequest", NoMoreChromePageAliveEvent: "noMoreChromePageAliveEvent", OnNotificationClickedEvent: "onNotificationClickedEvent", OnTabRemovedEvent: "onTabRemovedEvent", OnWindowRemovedEvent: "onWindowRemovedEvent", OpenOptionsPageRequest: "openOptionPageRequest", KeepAliveRequest: "keepAliveRequest", KeepAliveReply: "keepAliveReply", SetBadgeTextRequest: "setBadgeTextRequest", SetCallHistoryLogRequest: "setCallHistoryLogRequest", SetIconRequest: "setIconRequest", NotificationsClearRequest: "clearNotification", CreateWindowRequest: "createWindowRequest", CreateWindowReply: "createWindowReply", CloseWindowRequest: "closeWindowRequest", UpdateWindowRequest: "updateWindowRequest", GetOauth2TokenRequest: "getOauth2TokenRequest", GetOauth2TokenReply: "getOauth2TokenReply", Oauth2LogoutRequest: "oauth2LogoutRequest", LoginRequest: "loginRequest", LoginExRequest: "loginExRequest", LoginWithTokenRequest: "loginWithToken", Oauth2LoginRequest: "oath2LoginRequest", ProvisioningAndLoginRequest: "provisioningAndLoginRequest", ProvisioningAndLoginReply: "provisioningAndLoginReply", RefreshTokenRequest: "refreshTokenRequest", LoginReply: "loginReply", LogoutRequest: "logoutRequest", LogoutReply: "logoutReply", PauseRequest: "pauseRequest", PauseReply: "pauseReply", ReadyRequest: "readyRequest", ReadyReply: "readyReply", MakePhonesCallRequest: "makeCallRequest", MakePhonesCallReply: "makeCallReply", AbortCallRequest: "abortCallRequest", AbortCallReply: "abortCallReply", GetAgentListRequest: "agentListRequest", GetAgentListReply: "agentListReply", GetTransferAgentListRequest: "transferAgentListRequest", GetTransferAgentListReply: "transferAgentListReply", GetCampaignListRequest: "campaignListRequest", GetCampaignListReply: "campaignListReply", GetAssignedCampaignListRequest: "assignedCampaignListRequest", GetAssignedCampaignListReply: "assignedCampaignListReply", GetOutboundCampaignListRequest: "outboundCampaignListRequest", GetOutboundCampaignListReply: "outboundCampaignListReply", GetTransferCampaignListRequest: "getTransferCampaignListRequest", GetTransferCampaignListReply: "getTransferCampaignListReply", GetPauseReasonsRequest: "pauseReasonsRequest", GetPauseReasonsReply: "pauseReasonsReply", GetQueueInfoRequest: "queueInfoRequest", GetQueueInfoReply: "queueInfoReply", PanicEvent: "panicEvent", LogEvent: "logEvent", StartRecordingRequest: "startRecordingRequest", StopRecordingRequest: "stopRecordingRequest", MuteRecordingRequest: "muteRecordingRequest", TagRecordingRequest: "tagCallRecordingRequest", TransferCallRequest: "transferCallRequest", TransferCallReply: "transferCallReply", AddCallDataRequest: "addCallDataRequest", SetCallDataRequest: "setCallDataRequest", SaveCallDataRequest: "saveCallDataRequest", SwapCallRequest: "swapCallRequest", StartDTMFMaskingRequest: "startDTMFMasking", StopDTMFMaskingRequest: "stopDTMFMasking", MaskedDigitReceivedEvent: "maskedDigitReceivedEvent", MaskedPayloadReceivedEvent: "maskedPayloadReceivedEvent", GetAuthorityInfoRequest: "getAuthorityInfoRequest", GetAuthorityInfoReply: "getAuthorityInfoReply", GetProvisioningSiteListRequest: "getProvisioningSiteListRequest", GetProvisioningSiteListReply: "getProvisioningSiteListReply", GetModuleConfigurationRequest: "getModuleConfigurationRequest", GetModuleConfigurationReply: "getModuleConfigurationReply", InitializedEvent: "initializedEvent", BookedEvent: "bookedEvent", AssignmentEvent: "assignmentEvent", AlertingEvent: "alertingEvent", AnsweredEvent: "answeredEvent", CallFailureEvent: "callFailureEvent", OtherCallEvent: "othercallEvent", PauseBookedEvent: "pauseBookedEvent", PauseEvent: "pauseEvent", ReadyEvent: "readyEvent", ReadyForDetachEvent: "readyForDetachEvent", ReadyForTransferEvent: "readyForTransferEvent", TerminatedEvent: "terminatedEvent", RecordingStartedEvent: "recordingStartedEvent", RecordingMuteChangedEvent: "recordingMuteChangedEvent", RecordingStoppedEvent: "recordingStoppedEvent", StateChangedEvent: "stateChangedEvent", StateTimeChangedEvent: "stateTimeChangedEvent", SupervisorMessageEvent: "supervisorMessageEvent", CallTransferInitiatedEvent: "callTransferInitiatedEvent", DialNumberRequest: "dialNumberRequest", DialNumberReply: "dialNumberReply", EnterConferenceRequest: "enterConferenceRequest", EnterConferenceReply: "enterConferenceReply", LeaveConferenceRequest: "leaveConferenceRequest", LeaveConferenceReply: "leaveConferenceReply", HangupRequest: "hangupRequest", HangupReply: "hangupReply", MakeManualCallRequest: "makeManualCallRequest", MakeManualCallReply: "makeManualCallReply", MicrophoneOffRequest: "microphoneOffRequest", MicrophoneOffReply: "microphoneOffReply", MicrophoneOnRequest: "microphoneOnRequest", MicrophoneOnReply: "microphoneOnReply", PickupRequest: "pickupRequest", PickupReply: "pickupReply", SelectLineRequest: "selectLineRequest", SelectLineReply: "selectLineReply", SwitchLineRequest: "switchLineRequest", SwitchLineReply: "switchLineReply", SendDtmfRequest: "sendDigitRequest", SendDtmfReply: "sendDigitReply", RegisterRequest: "registerRequest", RegisterReply: "registerReply", UnregisterRequest: "unregisterRequest", UnregisterReply: "unregisterReply", PhoneLineStateChangedEvent: "phoneLineStateChangedEvent", PhoneLineSelectedEvent: "phoneLineSelectedEvent", PhoneInitializedEvent: "phoneInitializedEvent", PhoneConnectedEvent: "phoneConnectedEvent", PhoneDisconnectedEvent: "phoneDisconnectedEvent", PhoneRegisteredStateChangedEvent: "phoneRegisteredStateChangedEvent", PhoneConferenceStateChangedEvent: "phoneConferenceStateChangedEvent", PhoneCallingEvent: "phoneCallingEvent", PhoneCallConnectedEvent: "phoneCallConnectedEvent", PhoneCallDisconnectedEvent: "phoneCallDisconnectedEvent", PhoneDisplayNameEvent: "phoneDispayNameEvent", PhoneIncomingCallEvent: "phoneIncomingCallEvent", PhoneRingingEvent: "phoneRingingEvent", PhoneMuteChangedEvent: "phoneMuteChangedEvent", PhoneVUMeterEvent: "phoneVUMeterEvent", ConnectedEvent: "connectedEvent", DisconnectedEvent: "disconnectedEvent", RegisterClientPageRequest: "registerClientPageRequest", RegisterClientPageReply: "registerClientPageReply", OnPhonesbarEvent: "onPhonebarEvent", CheckExtensionRequest: "checkExtensionRequest", CheckExtensionReply: "checkExtensionReply", ExtensionConnectionFailedEvent: "extensionConnectionFailedEvent"
};
namespace("Ifm.ChromeBar.Constants").UIElementClasses = {
  PopupBody: ".chromebar-popup-body", PopupBodyExpanded: ".chromebar-popup-body-expanded", PopupBodyLeftPanel: ".chromebar-left-popup-body", PopupBodyRightPanel: ".chromebar-right-popup-body", PopupBodyMenuPanel: ".chromebar-menu-popup-body", ChromeBarPanelContainer: ".chromebar-panels-container", ChromeBarRightPanelContainer: ".chromebar-panels-right-container", ChromeBarMainPanel: ".chromebar-main-panel", ChromeBarSecondaryPanel: ".chromebar-secondary-panel", ChromeBarMenuPanel: ".chromebar-menu-panel", QueueInfoPanel: ".chromebar-queue-info-panel", CampaignInfoPanel: ".chromebar-campaign-info-panel", CampaignInfoPanelCard: ".chromebar-campaign-info-panel-card", RecordingCmdsPanel: ".chromebar-recording-commands-panel", PanelContainerId: "panel-container", MainToolbar: ".phonebar-toolbar", PhoneToolbar: ".phonebar-phone-toolbar", PhoneDialPad: ".phonebar-phone-dialpad", LogText: ".phonebar-log-text", MarqueeLabel: ".phonebar-state-text", TimerLabel: ".phonebar-state-time-text", PhoneStateText: ".phonebar-phone-state-text", RecordingStateText: ".phonebar-recording-state-text", DialedDigitsLabel: ".phonebar-dialed-digits", NumberLabel: ".phonebar-number-label", NumberInput: ".phonebar-number-input", QueueInfoLabel: ".chromebar-queue-info-label", CueSheetInput: ".phonebar-cuesheet-text-input", LoginButton: ".phonebar-login-button", LoginOrReadyButton: ".phonebar-login-ready-button", ReadyButton: ".phonebar-ready-button", PauseButton: ".phonebar-pause-button", LogoutButton: ".phonebar-logout-button", CallButton: ".phonebar-call-button", AbortCallButton: ".phonebar-abort-call-button", TransferButton: ".phonebar-transfer-button", CampaignListButton: ".phonebar-campaignlist-button", QueueInfoButton: ".phonebar-queueinfo-button", PanicButton: ".phonebar-panic-button", StartRecordingButton: ".phonebar-start-recording-button", StopRecordingButton: ".phonebar-stop-recording-button", MuteRecordingButton: ".phonebar-mute-recording-button", UnmuteRecordingButton: ".phonebar-unmute-recording-button", AddCueSheetButton: ".phonebar-add-cuesheet-button", ShowRecordingPanelButton: ".phonebar-recording-button", ExternalPlugin1Button: ".phonebar-plugin1-button", ExternalPlugin2Button: ".phonebar-plugin2-button", ExternalPlugin3Button: ".phonebar-plugin3-button", ColapseButton: ".phonebar-colapse-button", TogglePopupTypeButton: ".phonebar-toggle-popup-type-button", CloseButton: ".phonebar-close-button", HangupButton: ".phonebar-phone-hangup-button", PickupButton: ".phonebar-phone-pickup-button", FlashButton: ".phonebar-phone-flash-button", ManualTransferButton: ".phonebar-phone-manual-transfer-button", Line1Button: ".phonebar-phone-line1-button", Line2Button: ".phonebar-phone-line2-button", EnterConferenceButton: ".phonebar-phone-enter-conference-button", LeaveConferenceButton: ".phonebar-phone-leave-conference-button", MicrophoneVULabel: ".phonebar-phone-microphone-label", MicrophoneVUMeter: ".phonebar-phone-microphone-meter", SpeakersVULabel: ".phonebar-phone-speakers-label", SpeakersVUMeter: ".phonebar-phone-speakers-meter", MicrophoneOffButton: ".phonebar-phone-microphone-off-button", MicrophoneOnButton: ".phonebar-phone-microphone-on-button", HideDialPadButton: ".phonebar-phone-dialpad-hide-button", ShowDialPadButton: ".phonebar-phone-dialpad-show-button", SoftPhoneStateLabel: ".phonebar-phone-softphone-state-label", XmppStateLabel: ".phonebar-phone-xmpp-state-label", DialpadDigit0Button: ".phonebar-phone-key-digit0", DialpadDigit1Button: ".phonebar-phone-key-digit1", DialpadDigit2Button: ".phonebar-phone-key-digit2", DialpadDigit3Button: ".phonebar-phone-key-digit3", DialpadDigit4Button: ".phonebar-phone-key-digit4", DialpadDigit5Button: ".phonebar-phone-key-digit5", DialpadDigit6Button: ".phonebar-phone-key-digit6", DialpadDigit7Button: ".phonebar-phone-key-digit7", DialpadDigit8Button: ".phonebar-phone-key-digit8", DialpadDigit9Button: ".phonebar-phone-key-digit9", DialpadHashButton: ".phonebar-phone-key-hash", DialpadStarButton: ".phonebar-phone-key-star", TransferCampaignList: ".phonebar-transfer-campaign-list", TransferAgentList: ".phonebar-transfer-agent-list", TransferMandatoryCheck: ".phonebar-transfer-mandatory-check", PauseTableRefresButton: ".stop-refresh-button", ActiveCallsTab: "#tab-link-active-calls", HandledCallsTab: "#tab-link-handled-calls", FailedCallsTab: "#tab-link-failed-calls"
};
namespace("Ifm.ChromeBar.Constants").Templates = {
  QueueInfoLabel: '{number}\t{queuedNumberText} | {maxTime}\t{queuedMaxTimeText} | {avgTime}\t{queuedAvgTimeText}', QueueInfoCard: '<div class="phonebar-queueinfo-card-content">' + '<div><b>{number}</b> {queuedNumberText}</div>' + '<div><b>{maxTime}</b> {queuedMaxTimeText}</div>' + '<div><b>{avgTime}</b> {queuedAvgTimeText}</div>' + '</div>', QueueInfoCardEx: '<div class="phonebar-queueinfo-card-content">' + '<table id="options" style="width: 100%;">' + '<colgroup>' + '<col span="1" style="width: 60%;">' + '<col span="1" style="width: 40%;">' + '</colgroup>' + '<tbody>' + '<tr class="spaceUnder">' + '<td>' + '<label class="queued-call-count-label" id="queuedcallscountlbl">{queuedNumberText}:</label>' + '</td>' + '<td>' + '<label class="queued-call-count-value" id="queuedcallscountvalue">{number}</label>' + '</td>' + '</tr>' + '<tr class="spaceUnder">' + '<td>' + '<label class="queued-call-maxtime-label" id="queuedcallsmaxtimelbl">{queuedMaxTimeText}:</label>' + '</td>' + '<td>' + '<label class="queued-call-maxtime-value" id="queuedcallsmaxtimevalue">{maxTime}</label>' + '</td>' + '</tr>' + '<tr class="spaceUnder">' + '<td>' + '<label class="queued-call-avgtime-label" id="queuedcallsavgtimelbl">{queuedAvgTimeText}:</label>' + '</td>' + '<td>' + '<label class="queued-call-avgtime-value" id="queuedcallsavgtimevalue">{avgTime}</label>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</div>', CallListCard: '<div class="phonebar-campaignlist-card-content">' + '<table class="phonebar-calllist-card-table" id="mycalllisttable">' + '<thead><tr><th style="width: 60px;">{mediatypeth}</th><th style="width: 400px;">{campaignth}</th><th style="width: 60px;">{isrecordingth}</th><th style="width: 60px;">{inpostcallth}</th></tr></thead>' + '<tbody>{body}</tbody></table>' + '</div>', CallHistoryListRow: '<tr><td class="phonebar-campaignlist-card-table-element">{datetime}</td>' + '<td class="phonebar-campaignlist-card-table-element">{campaign}</td>' + '<td class="phonebar-campaignlist-card-table-element"><p class="callhistory-number-element">{phonenumber}</p></td>' + '<td class="phonebar-campaignlist-card-table-element">{displayname}</td></tr>', CallHistoryListCard: '<div class="phonebar-campaignlist-card-content">' + '<table class="phonebar-calllist-card-table" id="mytableid">' + '<thead><tr><th style="width: 90px;">{datetimeth}</th><th style="width: 180px;">{campaignth}</th><th style="width: 80px;">{phonenumberth}</th><th style="width: 80px;">{displaynameth}</th></tr></thead>' + '<tbody>{body}</tbody></table>' + '</div>', CallListRow: '<tr><td class="phonebar-campaignlist-card-table-element">{mediatype}</td>' + '<td class="phonebar-campaignlist-card-table-element">{campaign}</td>' + '<td class="phonebar-campaignlist-card-table-element">{isrecording}</td>' + '<td class="phonebar-campaignlist-card-table-element">{inpostcall}</td></tr>', CampaignListCard: '<div class="phonebar-campaignlist-card-content">' + '<table class="phonebar-campaignlist-card-table">' + '<thead><tr><th style="width: 70%;">{nameth}</th><th>{boundnessth}</th><th>{stateth}</th></tr></thead>' + '<tbody>{body}</tbody></table>' + '</div>', CampaignListCardEx: '<div class="phonebar-campaignlist-card-content" style="overflow-y: scroll;">' + '<table class="phonebar-campaignlist-card-table">' + '<thead><tr><th>{nameth}</th><th>{boundnessth}</th><th>{stateth}</th></tr></thead>' + '<tbody>{body}</tbody></table>' + '</div>', CampaignListRow: '<tr><td class="phonebar-campaignlist-card-table-element">{name}</td>' + '<td class="phonebar-campaignlist-card-table-element">{boundness}</td>' + '<td class="phonebar-campaignlist-card-table-element">{state}</td></tr>', IncomingCallCard: '<div class="phonebar-incoming-call-card-content">' + '<div class="phonebar-incoming-call-text">{incomingCallText}</div>' + '<div class="phonebar-incoming-call-number">{incomingCallNumber}</div>' + '<div class="phonebar-incoming-call-campaign">{campaignName}</div>' + '</div>', LoginDialog: '<fieldset>' + '<div>' + '<label class="phonebar-form-label" for="firstnametxt">{firstNameLabel}</label>' + '<input class="phonebar-form-input" type="text" id="firstnametxt" value="{firstName}">' + '</div><div>' + '<label class="phonebar-form-label" for="lastnametxt">{lastNameLabel}</label>' + '<input class="phonebar-form-input" type="text" id="lastnametxt" value="{lastName}">' + '</div><div>' + '<label class="phonebar-form-label" for="passwordtxt">{passwordLabel}</label>' + '<input class="phonebar-form-input" type="password" id="passwordtxt" value="{password}">' + '</div>' + '</fieldset>', LoginDialogBtnTable: '<div>' + '<hr />' + '<table id="table2" style="width: 100%" >' + '<colgroup>' + '<col span="1" style="width: 70%;">' + '<col span="1" style="width: 20%;">' + '<col span="1" style="width: 10%;">' + '</colgroup>' + '<tbody style="border: none">' + '<tr>' + '<td align="left">' + '<button id="changepasswordbtn" class="dialog-button" value="ChangePassword">{changePasswordBtn}</button>' + '</td>' + '<td>' + '<button id="cancelloginbtn" class="dialog-button" value="Cancel">{cancelBtn}</button>' + '</td>' + '<td>' + '<button id="submitloginbtn" type="submit" class="dialog-button">{okBtn}</button>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</div>', Login2Dialog: '<fieldset>' + '<div>' + '<label class="phonebar-form-label" for="firstnametxt">{firstNameLabel}</label>' + '<input class="phonebar-form-input" type="text" id="firstnametxt" value="{firstName}">' + '</div><div>' + '<label class="phonebar-form-label" for="lastnametxt">{lastNameLabel}</label>' + '<input class="phonebar-form-input" type="text" id="lastnametxt" value="{lastName}">' + '</div><div>' + '<label class="phonebar-form-label" for="oldPasswordtxt">{oldPasswordLabel}</label>' + '<input class="phonebar-form-input" type="password" id="oldPasswordtxt" value="{oldPassword}">' + '</div><div>' + '<label class="phonebar-form-label" for="newPasswordtxt">{newPasswordLabel}</label>' + '<input class="phonebar-form-input" type="password" id="newPasswordtxt" value="{newPassword}">' + '</div><div>' + '<label class="phonebar-form-label" for="confirmPasswordtxt">{confirmPasswordLabel}</label>' + '<input class="phonebar-form-input" type="password" id="confirmPasswordtxt" value="{confirmPassword}">' + '</div>' + '</fieldset>', Login2DialogBtnTable: '<div>' + '<hr />' + '<table id="table2" style="width: 100%" >' + '<colgroup>' + '<col span="1" style="width: 70%;">' + '<col span="1" style="width: 20%;">' + '<col span="1" style="width: 10%;">' + '</colgroup>' + '<tbody>' + '<tr>' + '<td>' + '</td>' + '<td>' + '<button id="cancelloginbtn" class="dialog-button" value="Cancel">{cancelBtn}</button>' + '</td>' + '<td>' + '<button id="submitloginbtn" type="submit" class="dialog-button">{okBtn}</button>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</div>', Login3Dialog: '<fieldset>' + '<div>' + '<label class="phonebar-form-label" for="usernametxt">{userNameLabel}</label>' + '<input class="phonebar-form-input" type="text" id="usernametxt" value="{userName}">' + '</div>' + '</fieldset>', Login4Dialog: '<fieldset>' + '<div>' + '<label class="phonebar-form-label" for="sitenametxt">{siteNameLabel}</label>' + '<select class="cfginputtextshort" id="sitenametxt">{sitesList}</select>' + '</div>' + '</fieldset>', MessageCard: '<div class="phonebar-message-{severity}"><i class="material-icons">{icon}</i>' + ' <span class="phonebar-message-title">{title}</span></div>' + '<div class="phonebar-message-text">{message}</div>', SupervisorMessageCard: '<div class="phonebar-supervisor-message-{severity}"><i class="material-icons">{icon}</i>' + ' <span class="phonebar-supervisor-message-title">{title}</span></div>' + '<div class="phonebar-supervisor-message-text">{message}</div>', TransferCallCard: '<div class="phonebar-transfercall-card-content" style="height:{height}px">' + '<select class="phonebar-transfer-campaign-list"></select>' + '<br>' + '<select class="phonebar-transfer-agent-list" size="10" style="height: {selectHeight}px"></select>' + '<label><input type="checkbox" class="phonebar-transfer-mandatory-check" checked>{mandatoryLabel}</label>' + '</div>', TransferCallAgentListItem: '<option class="phonebar-transfer-agent-list-item" firstName="{0}" lastName="{1}" agentState="{2}">{0} {1} {2}</option>', TransferCallCampaignListItem: '<option class="phonebar-transfer-campaign-list-item" campaignName="{0}">{1}</option>', TransferDialogBtnTable: '<div class="phonebar-transfercall-botton-div">' + '<hr />' + '<table id="table2" style="width: 100%" >' + '<colgroup>' + '<col span="1" style="width: 35%;">' + '<col span="1" style="width: 35%;">' + '<col span="1" style="width: 30%;">' + '</colgroup>' + '<tbody style="border: none">' + '<tr>' + '<td align="left">' + '<button id="refreshbtn" class="dialog-button" value="Refresh">{refreshBtn}</button>' + '</td>' + '<td>' + '<button id="cancelbtn" class="dialog-button" value="Cancel">{cancelBtn}</button>' + '</td>' + '<td>' + '<button id="submitbtn" type="submit" class="dialog-button">{transferBtn}</button>' + '</td>' + '</tr>' + '</tbody>' + '</table>' + '</div>'
};
var helpers = {
    areArrayEquals: function(array1, array2) {
      return (array1.length === array2.length) && array1.every((value, index) => value === array2[index])
    }, arrayToString: function(array) {
        var rc = "";
        if (array && helpers.isArray(array)) {
          try {
            array.forEach(element =>  {
                if (rc.length > 0) {
                  rc += ", "
                }
                rc += element
              })
          }
          catch(err) {}
        }
        return rc
      }, friendlyTime: function(dT, ms) {
        if (ms)
          dT = dT / 1000;
        var seconds = Math.floor(dT % 60);
        dT = dT / 60;
        var minutes = Math.floor(dT % 60);
        dT = dT / 60;
        var hours = Math.floor(dT % 24);
        var days = Math.floor(dT / 24);
        var timestr = "";
        if (days > 0)
          timestr += days + " d ";
        if (hours > 0)
          timestr += hours + " h ";
        if (minutes > 0)
          timestr += minutes + " m ";
        if (seconds > 0)
          timestr += seconds + " s ";
        return timestr
      }, getChromeVersion: function() {
        var raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
        return raw ? parseInt(raw[2], 10) : false
      }, getPopupWindowWidth: function(isExpanded) {
        if (isExpanded) {
          return 787
        }
        else {
          return 312
        }
      }, isArray: function(o) {
        return Object.prototype.toString.call(o) === "[object Array]"
      }, isBoolean: function(o) {
        return typeof o === "boolean"
      }, isFunction: function(o) {
        return typeof o === 'function'
      }, isLoggedInState: function(currentState) {
        return (currentState !== "[Initialization]" && currentState !== "[Not Logged In]" && currentState !== "[Connecting]")
      }, isNull: function(s) {
        if (s === null) {
          return true
        }
        if (s === undefined) {
          return true
        }
        return false
      }, isNullOrEmpty: function(s) {
        if (s === null) {
          return true
        }
        if (s === undefined) {
          return true
        }
        if (s === '') {
          return true
        }
        return false
      }, isValidLanguage: function(language) {
        return Ifm.ChromeBar.Constants.Languages[language] !== undefined
      }, isValidPhoneDevice: function(device) {
        return (Ifm.ChromeBar.Constants.PhoneDevices[device] !== undefined || device === "")
      }, isValidSkin: function(skin) {
        return Ifm.ChromeBar.Constants.Skins[skin] !== undefined
      }, isValidServicesList: function(servicesList) {
        var services = servicesList;
        var valid = true;
        if (!helpers.isArray(servicesList)) {
          services = servicesList.split(",")
        }
        services.forEach(service =>  {
            valid = valid & helpers.isValidServiceUrl(service)
          });
        return valid
      }, isValidServiceUrl: function(serviceUrl) {
        var r = /^((ws{1,2}:\/\/)|(\*\.))[a-zA-Z0-9-.]+/ig;
        var match = r.exec(serviceUrl);
        return (match && match.length > 0)
      }, log: function(message) {
        var line = message;
        if (arguments.length > 1) {
          line = Array.prototype.splice.call(arguments, 0).join(" ")
        }
        console.log(line)
      }, parseInt: function(val, defaultValue) {
        var rc = parseInt(val);
        if (isNaN(rc)) {
          return defaultValue
        }
        return rc
      }, postMessage: function(port, request) {
        try {
          if (port !== null) {
            port.postMessage(request);
            return true
          }
        }
        catch(err) {
          try {
            port.postMessage(JSON.parse(JSON.stringify(request)));
            return true
          }
          catch(err) {
            return false
          }
        }
        return false
      }, showNotification: function(title, message, contextMessage, icon, requireInteraction, notificationId, buttons, priority) {
        var options = {
            type: "basic", title: title, message: message, contextMessage: contextMessage || 'ChromeBar', requireInteraction: requireInteraction || false, iconUrl: icon || "./assets/icons/96.png", buttons: buttons, priority: priority || 2
          };
        if (notificationId) {
          chrome.notifications.create(String(notificationId), options, undefined)
        }
        else {
          chrome.notifications.create(options, undefined)
        }
      }, stringify: function(obj) {
        let cache = [];
        let str = JSON.stringify(obj, function(key, value) {
            if (typeof value === "object" && value !== null) {
              if (cache.indexOf(value) !== -1) {
                return
              }
              cache.push(value)
            }
            return value
          });
        cache = null;
        return str
      }
  };
namespace("Ifm.ChromeBar").Proxy = {
  about: {
    product: "#phones", title: "ChromeBarProxy", version: "1.4.17.4670"
  }, events: defineEvents("initialized", "disconnected", "connected", "connectionFailure", "saveConfigReply", "configChangedEvent", "buttonStateChangedEvent", "booked", "assignment", "alerting", "answered", "callfailure", "othercall", "pausebooked", "pause", "ready", "readyfordetach", "readyfortransfer", "terminated", "recordingstarted", "recordingmutechanged", "recordingstopped", "maskeddigitreceived", "maskedpayloadreceived", "statechanged", "statetimechanged", "supervisormessage", "onconnected", "ondisconnected", "onabortcallreply", "onalertingevent", "onansweredevent", "onassignmentrequest", "onrecordingcompletedevent", "onrecordingmutedevent", "onrecordingstartedevent", "onbookedevent", "oncallfailureevent", "oncalltransferinitiatedevent", "onconnectionremovedevent", "ondeviceinfochangedevent", "ondisplaynamechangedevent", "onphonebarclosedevent", "onloginreply", "onlogoutreply", "onnewcallreply", "onothercallevent", "onpauseevent", "onpausereply", "onphonebarconnectionlostevent", "onpostcallworkevent", "onreadyevent", "onreadyfordetachevent", "onreadyreply", "onreadyfortransferevent", "onretrievecallreply", "onrejectableassignmentrequest", "onterminatedevent", "ontransferreply", "onsupervisormessageevent", "onmaskeddigitreceivedevent", "onmaskedpayloadreceivedevent", "onqueueinforeply", "onagentslistreply", "oncampaignslistreply", "onpausereasonslistreply", "onagentdetailsreply", "ongetcallhistorylogreply", "oncommandexecutedevent"), AgentInfoMask: {
      NotAvailable: 0x00000001, Available: 0x00000002, Assigned: 0x00000004, Booked: 0x00000008, Talking: 0x00000010, Paused: 0x00000020, PostCallWork: 0x00000040, OtherCall: 0x00000080, AnyAvailable: 0x000000FE, AnyCampaign: 0x00, SpecificCampaign: 0x100, OmitSynthetics: 0x200, OmitHumans: 0x400
    }, CampaignInfoMask: {
      Inactive: 0x1, Active: 0x2, Suspended: 0x4, StatusMask: 0x7, Inbound: 0x8, Outbound: 0x10, BoundnessMask: 0x18, NotAssigned: 0x20, Assigned: 0x40, AssignmentMask: 0x60, PostCallWork: 0x80, HideTransferNotAllowed: 0x100, ExcludeSyntheticCampaigns: 0x200, ExcludeHumanCampaigns: 0x400
    }, RecordingStates: {
      Inactive: 0x00, Active: 0x01, TxChannelMuted: 0x02, RxChannelMuted: 0x04
    }, States: {
      Initialization: "[Initialization]", NotLoggedIn: "[Not Logged In]", Connecting: "[Connecting]", LoggedIn: "[Logged In]", Paused: "[Paused]", Ready: "[Ready]", Alerting: "[Alerting]", Talking: "[Talking]", PostCall: "[Post Call]", OtherCall: "[Other Call]", Assigned: "[Assigned]", WaitingOutbound: "[Waiting Outbound]", WaitingTransfer: "[Waiting Transfer]"
    }, MediaTypes: {
      Voice: 1, AtPhones: 2, Video: 4, VoiceAndVideo: 5, NearRealTime: 8, StoreAndForward: 16
    }, LoginReplyFailureCauses: {
      Unspecified: 0, AccountLockout: 1, ExpiredPassword: 2, WrongUsernameOrPassword: 3, InvalidNewPassword: 4, PasswordChangeNotAllowed: 5, WrongState: 6, InvalidExtension: 7, ExtensionAlreadyInUse: 8, TokenBasedLoginNotAvailable: 9, InvalidToken: 10, ExtensionTranslationError: 0x80
    }, AgentStates: {
      0x1: "[Not Available]", 0x2: "[Available]", 0x4: "[Assigned]", 0x8: "[Booked]", 0x10: "[Talking]", 0x20: "[Paused]", 0x40: "[Post-Call]", 0x80: "[Manual Call]"
    }, CallFailureCauses: {
      1: "[No Dial Tone]", 2: "[No Ringback]", 3: "[Line Busy]", 4: "[No Answer]", 5: "[Fax Tone]", 6: "[Remote Hangup]", 7: "[Agent: No Dial Tone]", 8: "[Agent: No Ringback]", 9: "[Agent: Line Busy]", 10: "[Agent: No Answer]", 255: "[Unknown]"
    }, CallFailureCauseResources: {
      1: "CallFailureNoDialTone", 2: "CallFailureNoRingback", 3: "CallFailureLineBusy", 4: "CallFailureNoAnswer", 5: "CallFailureFaxTone", 6: "CallFailureRemoteHangUp", 7: "CallFailureAgentNoDialTone", 8: "CallFailureAgentNoRingback", 9: "CallFailureAgentBusy", 10: "CallFailureAgentNoAnswer", 255: "CallFailureUnknown"
    }, UpdateConfigurationFailureCauses: {
      1: "[Invalid Configuration]", 2: "[Wrong ChromeBar State]"
    }, ChromeBarButtonIndexes: {
      btnLogin: 1, btnPause: 2, btnLogout: 3, btnCall: 4, btnTransfer: 5, btnAssignment: 6, btnFlashDial: 7, btnHookstate: 8, btnFlash: 9, btnRetake: 10, btnMute: 11, btnLine1: 12, btnLine2: 13, btnConference: 14, btnStartRecording: 15, btnStopRecording: 16, brnMuteRecording: 17, btnMuteRecording: 17, btnDialPad: 18, btnQueueInfo: 19, btnPanic: 20
    }, canRun: function() {
      return true
    }, run: function(config, options) {
      this.run = function() {
        self.log("PhoneBar", "Debug", "Already running")
      };
      this.instance.initialize()
    }, instance: (function() {
      var instance = {};
      var messageCodes = Ifm.ChromeBar.Constants['MessageCodes'];
      var strings = Ifm.ChromeBar.Strings;
      var el = Ifm.ChromeBar.Constants['UIElementClasses'];
      var t = Ifm.ChromeBar.Constants['Templates'];
      var self,
        states;
      var chromebarState;
      var chromebarConfiguration;
      var currentState = "[Initialization]";
      var currentStateTime = 0;
      var currentStateReason = "";
      var activeCalls;
      var stringsPh;
      var language;
      var numberOfLines;
      var supportsConference;
      var hasAlreaySetTheListener = false;
      var chromebarVersion;
      var phonebarVersion;
      var checkCallback = null;
      var checkTimer = null;
      let connectTimeoutTmr;
      var callbacks = {
          login: [], logout: [], pause: [], ready: [], make: [], transfer: [], getAgents: [], getCampaigns: [], getPauseReasons: [], getQueueInfo: [], getOutboundCampaigns: [], getTransferAgents: [], getAssignedCampaigns: [], getTransferCampaigns: [], getCallHistoryLog: [], getSiteListFromProvisioning: [], getModuleConfiguration: [], getAuthorityInfo: [], setConfiguration: []
        };
      function decodeMessage(e) {
        var message = e.data.details;
        var callback;
        var campaignName;
        var campaigns,
          agents,
          i;
        if (!message)
          return;
        if (message.command === messageCodes.CheckExtensionReply) {
          if (checkCallback) {
            checkCallback(true);
            clearTimeout(checkTimer);
            checkTimer = null;
            checkCallback = null
          }
        }
        if (!self)
          return;
        switch (message.command) {
          case messageCodes.DumpRequest:
            console.log(message.message);
            break;
          case messageCodes.ExtensionConnectionFailed:
            self.events.connectionFailure.raise(self);
            break;
          case messageCodes.RegisterClientPageReply:
            if (connectTimeoutTmr) {
              console.log("[Proxy] RegisterClientPageReply received: Stopping connection timeout");
              clearTimeout(connectTimeoutTmr)
            }
            currentState = message.state.CurrentState;
            chromebarConfiguration = message.configuration;
            currentStateReason = message.currentStateReason;
            currentStateTime = message.state.CurrentStateTime;
            chromebarState = message.state;
            stringsPh = message.stringPh;
            language = message.language;
            numberOfLines = message.numberOfLines;
            supportsConference = message.supportsConference;
            activeCalls = {};
            for (var i = 0; i < message.calls.length; i++) {
              var callData = new Ifm.Messaging.FPropertyList(message.calls[i].callData.originalString);
              callData.save = function() {
                self.savecalldata(callId)
              };
              callData.events.changed = function(fpl, params) {
                window.postMessage({
                  type: 'chromebarProxy', params: messageCodes.SetCallDataRequest, callId: callId, key: params.key, value: params.value
                }, "*")
              };
              message.calls[i].callData = callData;
              activeCalls[message.calls[i].callId] = message.calls[i]
            }
            if (message.phone) {
              self.media.phone = new Ifm.ChromeBar.Proxy.Media.Phone(self);
              self.media.phone.numberOfLines = message.numberOfLines;
              self.media.phone.supportsConference = message.supportsConference
            }
            self.agent.firstName = message.agentInfo.firstName;
            self.agent.lastName = message.agentInfo.lastName;
            self.agent.username = message.agentInfo.username;
            self.agent.extension = message.agentInfo.extension;
            self.agent.password = message.agentInfo.password;
            self.agent.id = message.agentInfo.agentId;
            self.config.service = message.configuration.config.service;
            chromebarVersion = message.chromebarVersion;
            phonebarVersion = message.phonebarVersion;
            self.media.xmpp = Ifm.PhoneBar.Media.Xmpp.instance;
            try {
              if (self.isLoggedIn() && chromebarConfiguration.options.autoConnectToXmppServer) {
                self.media.xmpp.initialize(self, chromebarConfiguration.xmppconfig, Ifm.ChromeBar.Proxy)
              }
            }
            catch(error) {}
            if (self.scriptControlMode) {
              self.events.onconnected.raise()
            }
            else {
              initializeUI();
              self.events.initialized.raise(self, {
                accepted: message.accepted, reasonCode: message.reasonCode
              })
            }
            if (!self.scriptControlMode) {
              updateUI(message.state, true);
              self.events.statechanged.raise(self, {
                previousState: "[Initialization]", currentState: currentState
              });
              self.events.statetimechanged.raise(self, {
                stateTime: message.state.CurrentStateTime, startTimer: message.state.StartTimer
              })
            }
            if (self.media.phone) {
              self.media.phone._onLineSelected(message.lineSelected);
              self.media.phone._onLineStateChanged(0, message.lineState0);
              if (numberOfLines > 1) {
                self.media.phone._onLineStateChanged(1, message.lineState1)
              }
            }
            break;
          case messageCodes.DisconnectedEvent:
          case messageCodes.ConnectionLostEvent:
            resetSessionData();
            if (self.scriptControlMode) {
              self.events.onphonebarclosedevent.raise({})
            }
            else {
              if (message.command === messageCodes.ConnectionLostEvent) {
                self.events.disconnected.raise(self, {
                  clean: false, failed: false, lost: true
                })
              }
              else {
                self.events.disconnected.raise(self, message.message)
              }
              resetUI()
            }
            break;
          case messageCodes.ProxyCommandExecutionResult:
            if (self.scriptControlMode) {
              self.events.oncommandexecutedevent.raise({
                commandcode: message.message.commandCode, result: message.message.result
              })
            }
            break;
          case messageCodes.ChromeBarStatusChangedEvent:
            currentState = message.message.CurrentState;
            chromebarState = message.message;
            if (message.message.stateOnly) {
              var stateOnly = message.message.stateOnly
            }
            if (!self.scriptControlMode) {
              updateUI(chromebarState, false, stateOnly)
            }
            break;
          case messageCodes.ChromeBarUpdateVuMetersEvent:
            if (!self.scriptControlMode) {
              jQuery(el.SpeakersVUMeter).val(message.message.speakers);
              jQuery(el.MicrophoneVUMeter).val(message.message.microphone)
            }
            break;
          case messageCodes.ChromeBarStatusTimerChangedEvent:
            if (!self.scriptControlMode) {
              jQuery(el.TimerLabel).html(message.message).change()
            }
            break;
          case messageCodes.ChromeBarDialTextBoxUpdateEvent:
            if (!self.scriptControlMode) {
              jQuery(el.NumberInput).val(message.text).change()
            }
            break;
          case messageCodes.SetConfigurationReply:
            self.events.saveConfigReply.raise(self, {
              accepted: message.updated, cause: message.reason
            });
            callback = callbacks.setConfiguration.shift();
            callback && callback(message.updated, message.reason);
            break;
          case messageCodes.ConfigurationChangedEvent:
            chromebarConfiguration = message.message;
            self.events.configChangedEvent.raise(self, {configuration: chromebarConfiguration});
            break;
          case messageCodes.LoginReply:
            self.agent.extension = message.extension;
            self.agent.id = message.agentId;
            self.agent.firstName = message.firstName || "";
            self.agent.lastName = message.lastName || "";
            self.agent.username = message.username || "";
            if (chromebarConfiguration.options.autoConnectToXmppServer) {
              if (message.message.accepted) {
                self.media.xmpp.initialize(self, chromebarConfiguration.xmppconfig, Ifm.ChromeBar.Proxy)
              }
            }
            callback = callbacks.login.shift();
            callback && callback(message.message);
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onloginreply.raise({
                  accepted: message.message.accepted, failureCause: message.message.failureCause
                })
              }
            }
            break;
          case messageCodes.LogoutReply:
            callback = callbacks.logout.shift();
            callback && callback(message.message);
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onlogoutreply.raise({accepted: message.message.accepted})
              }
            }
            break;
          case messageCodes.PauseReply:
            callback = callbacks.pause.shift();
            callback && callback(message.message);
            if (message.accepted !== 3) {
              if (self.scriptControlMode) {
                if (notifyEventScriptControlMode(true, false, '')) {
                  self.events.onpausereply.raise({
                    accepted: message.message.accepted, reasonid: message.message.reasonId, description: message.message.reasonText
                  })
                }
              }
            }
            break;
          case messageCodes.ReadyReply:
            callback = callbacks.ready.shift();
            callback && callback(message.message);
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, '*')) {
                self.events.onreadyreply.raise({accepted: message.message.accepted})
              }
            }
            break;
          case messageCodes.MakePhonesCallReply:
            callback = callbacks.make.shift();
            callback && callback(message.message);
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaign)) {
                self.events.onnewcallreply.raise({
                  campaign: message.message.campaign, callid: message.message.callId, accepted: message.message.accepted
                })
              }
            }
            break;
          case messageCodes.AbortCallReply:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaign)) {
                self.events.onabortcallreply.raise({
                  campaign: message.message.campaign, callid: message.message.callId, accepted: message.message.accepted
                })
              }
            }
            break;
          case messageCodes.TransferCallReply:
            callback = callbacks.transfer.shift();
            callback && callback(message.message);
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaign, getCallMediaType(message.message.callId))) {
                self.events.ontransferreply.raise({
                  campaign: message.message.campaign, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId), accepted: message.message.accepted
                })
              }
            }
            break;
          case messageCodes.CallTransferInitiated:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaign, getCallMediaType(message.message.callId))) {
                self.events.oncalltransferinitiatedevent.raise({
                  campaign: message.message.campaign, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                })
              }
            }
            break;
          case messageCodes.GetAgentListReply:
            callback = callbacks.getAgents.shift().callback;
            sendNextAgentListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetPauseReasonsReply:
            callback = callbacks.getPauseReasons.shift();
            sendNextPauseReasonListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetTransferAgentListReply:
            callback = callbacks.getTransferAgents.shift().callback;
            sendNextTransferAgentListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetCampaignListReply:
            callback = callbacks.getCampaigns.shift().callback;
            sendNextCampaignListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetAssignedCampaignListReply:
            callback = callbacks.getAssignedCampaigns.shift();
            sendNextAssignedCampaignListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetOutboundCampaignListReply:
            callback = callbacks.getOutboundCampaigns.shift();
            sendNextOutboundCampaignListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetTransferCampaignListReply:
            callback = callbacks.getTransferCampaigns.shift().callback;
            sendNextTransferCampaignListRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetCallHistoryLogReply:
            callback = callbacks.getCallHistoryLog.shift();
            sendNextCallHistoryLogRequest();
            callback && callback(message.callHistoryLog);
            break;
          case messageCodes.GetQueueInfoReply:
            callback = callbacks.getQueueInfo.shift().callback;
            sendNextQueueInfoRequest();
            callback && callback(message.message);
            break;
          case messageCodes.GetAuthorityInfoReply:
            callback = callbacks.getAuthorityInfo.shift().callback;
            sendNextGetAuthorityInfoRequest();
            callback && callback(message.accepted, message.authInfo);
            break;
          case messageCodes.GetProvisioningSiteListReply:
            callback = callbacks.getSiteListFromProvisioning.shift().callback;
            sendNextGetSiteListRequest();
            callback && callback(message.sites);
            break;
          case messageCodes.GetModuleConfigurationReply:
            callback = callbacks.getModuleConfiguration.shift().callback;
            sendNextGetModuleConfigurationRequest();
            callback && callback(message.moduleName, message.parameters);
            break;
          case messageCodes.BookedEvent:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '', message.message.mediatype)) {
                self.events.onbookedevent.raise({
                  campaign: message.message.campaignName, mediatype: message.message.mediatype
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(true) || notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.booked.raise(self, message.message)
              }
            }
            break;
          case messageCodes.AssignmentEvent:
            var callData = new Ifm.Messaging.FPropertyList(message.message.callData.originalString);
            var callId = message.message.callId;
            callData.save = function() {
              self.savecalldata(callId)
            };
            callData.events.changed = function(fpl, params) {
              window.postMessage({
                type: 'chromebarProxy', params: messageCodes.SetCallDataRequest, callId: callId, key: params.key, value: params.value
              }, "*")
            };
            var call = activeCalls[callId] = {
                callId: callId, callGuid: callData.get("GUID").toUpperCase(), mediatype: message.message.mediatype, hideNumber: message.message.hideNumber, displayNumber: message.message.displayNumber, campaignName: message.message.campaignName, callData: callData, otherData: {
                    serviceId: message.message.otherData.serviceId, campaignId: message.message.otherData.campaignId, scriptName: message.message.otherData.scriptName, scriptParameters: message.message.otherData.scriptParameters
                  }, isRecording: message.message.isRecording, recordingData: {
                    fileName: message.message.recordingData.fileName, settings: message.message.recordingData.settings, rxChannelMuted: message.message.recordingData.rxChannelMuted, txChannelMuted: message.message.recordingData.txChannelMuted
                  }
              };
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                var recordingState = message.message.isRecording ? 1 : 0;
                if (message.message.recordingData.txChannelMuted)
                  recordingState += 2;
                if (message.message.recordingData.rxChannelMuted)
                  recordingState += 4;
                self.events.onassignmentrequest.raise({
                  campaign: message.message.campaignName, callid: callId, mediatype: call.mediatype, calldata: message.message.callData.originalString, recordingstate: recordingState
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.assignment.raise(self, call)
              }
            }
            break;
          case messageCodes.AlertingEvent:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                self.events.onalertingevent.raise({
                  campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.alerting.raise(self, message.message)
              }
            }
            break;
          case messageCodes.AnsweredEvent:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                self.events.onansweredevent.raise({
                  campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.answered.raise(self, message.message)
              }
            }
            break;
          case messageCodes.CallFailureEvent:
            if (activeCalls[message.message.callId]) {
              activeCalls[message.message.callId].terminated = true
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                self.events.oncallfailureevent.raise({
                  campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId), reasoncode: message.message.cause, protocolterminationcause: message.message.protocolTerminationCause, protocolterminationdescription: message.message.protocolTerminationDescription, detectedcontentcode: message.message.detectedContentCode, detectedcontentdescription: message.message.detectedContentDescription
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.callfailure.raise(self, message.message)
              }
            }
            if (activeCalls[message.message.callId]) {
              delete activeCalls[message.message.callId]
            }
            break;
          case messageCodes.OtherCallEvent:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onothercallevent.raise({})
              }
            }
            else {
              if (notifyEventPhoneBarMode(true)) {
                self.events.othercall.raise(self, message.message)
              }
            }
            break;
          case messageCodes.PauseBookedEvent:
            if (!self.scriptControlMode) {
              if (notifyEventPhoneBarMode(true)) {
                self.events.pausebooked.raise(self, message.message)
              }
            }
            break;
          case messageCodes.PauseEvent:
            currentStateReason = message.message.reasonText;
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onpauseevent.raise({
                  reasonid: message.message.reasonId, description: message.message.reasonText
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(true)) {
                self.events.pause.raise(self, message.message)
              }
            }
            break;
          case messageCodes.ReadyEvent:
            if (message.message.callId && activeCalls[message.message.callId]) {
              activeCalls[message.message.callId].postcall = false;
              activeCalls[message.message.callId].terminated = true
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '', getCallMediaType(message.message.callId))) {
                self.events.onreadyevent.raise({
                  callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(true)) {
                self.events.ready.raise(self, message.message)
              }
            }
            if (message.message.callId && activeCalls[message.message.callId]) {
              delete activeCalls[message.message.callId]
            }
            Object.values(activeCalls).forEach(function(c) {
              if (c.transferred) {
                delete activeCalls[c.callId]
              }
            });
            break;
          case messageCodes.ReadyForDetachEvent:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                self.events.onreadyfordetachevent.raise({
                  campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId), callterminated: message.message.callTerminated, protocolterminationcause: message.message.protocolTerminationCause, protocolterminationdescription: message.message.protocolTerminationDescription, detectedcontentcode: message.message.detectedContentCode, detectedcontentdescription: message.message.detectedContentDescription
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.readyfordetach.raise(self, message.message)
              }
            }
            if (activeCalls[message.message.callId] && activeCalls[message.message.callId].transferred && activeCalls[message.message.callId].mediatype > Ifm.ChromeBar.Proxy.MediaTypes.Voice) {
              delete activeCalls[message.message.callId]
            }
            break;
          case messageCodes.ReadyForTransferEvent:
            activeCalls[message.message.callId].transferred = true;
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(false, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                self.events.onreadyfortransferevent.raise({
                  campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.readyfortransfer.raise(self, message.message)
              }
            }
            break;
          case messageCodes.TerminatedEvent:
            activeCalls[message.message.callId].terminated = true;
            if (message.message.postCallWork === 1) {
              activeCalls[message.message.callId].postcall = true
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, true, message.message.campaignName, getCallMediaType(message.message.callId))) {
                self.events.onterminatedevent.raise({
                  campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                });
                if (message.message.postCallWork) {
                  self.events.onpostcallworkevent.raise({
                    campaign: message.message.campaignName, callid: message.message.callId, mediatype: getCallMediaType(message.message.callId)
                  })
                }
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, message.message.campaignName)) {
                self.events.terminated.raise(self, message.message)
              }
            }
            if (!activeCalls[message.message.callId].postcall) {
              delete activeCalls[message.message.callId]
            }
            break;
          case messageCodes.CallDataChangedEvent:
            if (activeCalls[message.message.callId]) {
              if (message.message.value !== undefined) {
                activeCalls[message.message.callId].callData.set(message.message.key, message.message.value)
              }
              else {
                activeCalls[message.message.callId].callData.remove(message.message.key)
              }
            }
            break;
          case messageCodes.RecordingStartedEvent:
            campaignName = "undefined";
            if (activeCalls[message.message.callId]) {
              activeCalls[message.message.callId].isRecording = true;
              activeCalls[message.message.callId].recordingData.fileName = message.message.fileName;
              campaignName = activeCalls[message.message.callId].campaignName
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onrecordingstartedevent.raise({
                  callid: message.message.callId, recfilename: message.message.fileName
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, campaignName)) {
                self.events.recordingstarted.raise(self, message.message)
              }
            }
            break;
          case messageCodes.RecordingMuteChangedEvent:
            campaignName = "undefined";
            if (activeCalls[message.message.callId]) {
              activeCalls[message.message.callId].recordingData.rxChannelMuted = message.message.rxChannelMuted;
              activeCalls[message.message.callId].recordingData.txChannelMuted = message.message.txChannelMuted;
              campaignName = activeCalls[message.message.callId].campaignName
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onrecordingmutedevent.raise({
                  callid: message.message.callId, txchannelmuted: message.message.txChannelMuted, rxchannelmuted: message.message.rxChannelMuted
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, campaignName)) {
                self.events.recordingmutechanged.raise(self, message.message)
              }
            }
            break;
          case messageCodes.RecordingStoppedEvent:
            campaignName = "undefined";
            if (activeCalls[message.message.callId]) {
              activeCalls[message.message.callId].isRecording = false;
              campaignName = activeCalls[message.message.callId].campaignName
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onrecordingcompletedevent.raise({
                  callid: message.message.callId, result: message.message.result
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, campaignName)) {
                self.events.recordingstopped.raise(self, message.message)
              }
            }
            break;
          case messageCodes.MaskedDigitReceivedEvent:
            campaignName = "undefined";
            if (activeCalls[message.message.callId]) {
              campaignName = activeCalls[message.message.callId].campaignName
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onmaskeddigitreceivedevent.raise({callid: message.message.callId})
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, campaignName)) {
                self.events.maskeddigitreceived.raise(self, message.message)
              }
            }
            break;
          case messageCodes.MaskedPayloadReceivedEvent:
            campaignName = "undefined";
            if (activeCalls[message.message.callId]) {
              campaignName = activeCalls[message.message.callId].campaignName
            }
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onmaskedpayloadreceivedevent.raise({
                  callid: message.message.callId, payload: message.message.payload, result: message.message.result
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(false, campaignName)) {
                self.events.maskedpayloadreceived.raise(self, message.message)
              }
            }
            break;
          case messageCodes.StateChangedEvent:
            currentState = message.message.currentState;
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.statechanged.raise({
                  previousState: message.message.previousState, state: message.message.currentState
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(true)) {
                self.events.statechanged.raise(self, message.message)
              }
            }
            break;
          case messageCodes.StateTimeChangedEvent:
            currentStateTime = message.message.stateTime;
            if (!self.scriptControlMode) {
              if (notifyEventPhoneBarMode(true)) {
                self.events.statetimechanged.raise(self, message.message)
              }
            }
            break;
          case messageCodes.SupervisorMessageEvent:
            if (self.scriptControlMode) {
              if (notifyEventScriptControlMode(true, false, '')) {
                self.events.onsupervisormessageevent.raise({
                  severity: message.message.severity, message: message.message.message
                })
              }
            }
            else {
              if (notifyEventPhoneBarMode(true)) {
                self.events.supervisormessage.raise(self, message.message)
              }
            }
            break;
          case messageCodes.PhoneLineStateChangedEvent:
            if (self.media.phone) {
              self.media.phone._onLineStateChanged(message.message.lineId, message.message.state)
            }
            break;
          case messageCodes.PhoneLineSelectedEvent:
            if (self.media.phone) {
              self.media.phone._onLineSelected(message.message.lineId)
            }
            break;
          case messageCodes.PhoneInitilizedEvent:
            if (self.media.phone) {
              self.media.phone._onInitialized()
            }
            break;
          case messageCodes.PhoneConnectedEvent:
            if (self.media.phone) {
              self.media.phone._onConnected()
            }
            break;
          case messageCodes.PhoneDisconnectedEvent:
            if (self.media.phone) {
              self.media.phone._onDisconnected(message.message.clean)
            }
            break;
          case messageCodes.PhoneRegisteredStateChangedEvent:
            if (self.media.phone) {
              self.media.phone._onRegisteredStateChanged(message.message.isRegistered)
            }
            break;
          case messageCodes.PhoneConferenceStateChangedEvent:
            if (self.media.phone) {
              self.media.phone._onConferenceStateChanged(message.message.inConference)
            }
            break;
          case messageCodes.PhoneCallingEvent:
            if (self.media.phone) {
              self.media.phone._onCalling(message.message.lineId)
            }
            break;
          case messageCodes.PhoneCallConnectedEvent:
            if (self.media.phone) {
              self.media.phone._onCallConnected(message.message.lineId)
            }
            break;
          case messageCodes.PhoneCallDisconnectedEvent:
            if (self.media.phone) {
              self.media.phone._onCallDisconnected(message.message.lineId, message.message.sipCode, message.message.sipCause)
            }
            break;
          case messageCodes.PhoneDisplayNameEvent:
            if (self.media.phone) {
              self.media.phone._onDisplayName(message.message.lineId, message.message.displayName)
            }
            break;
          case messageCodes.PhoneIncomingCallEvent:
            if (self.media.phone) {
              self.media.phone._onIncomingCall(message.message.lineId)
            }
            break;
          case messageCodes.PhoneRingingEvent:
            if (self.media.phone) {
              self.media.phone._onRinging(message.message.lineId, message.message.rings)
            }
            break;
          case messageCodes.PhoneMuteChangedEvent:
            if (self.media.phone) {
              self.media.phone._onMuteChanged(message.message.isMuted)
            }
            break;
          case messageCodes.PhoneVUMeterEvent:
            if (self.media.phone) {
              self.media.phone._onVUMeter(message.message.microphone, message.message.speakers)
            }
            break;
          case messageCodes.ConnectedEvent:
            self.events.connected.raise(self);
            break;
          case messageCodes.EnableChromeBarButtonReply:
            self.events.buttonStateChangedEvent.raise(self, {
              buttonIdx: message.buttonIdx, accepted: message.accepted, buttonState: message.buttonState
            });
            break
        }
      }
      function notifyEventScriptControlMode(campaignLess, campaignDependent, campaignName, mediatype) {
        if (mediatype !== undefined && mediatype > 5 && self.filterNonPhoneCallEvents === true) {
          return false
        }
        if (campaignLess === true) {
          return self.isSCPRegisteredForCLEvents
        }
        if (campaignDependent === true && campaignName) {
          if (campaignName === "*") {
            return self.registeredCampaignList.length > 0
          }
          else {
            return self.registeredCampaignList.indexOf(campaignName) > -1
          }
        }
        return false
      }
      function notifyEventPhoneBarMode(campaignLess, campaignName) {
        if (campaignLess === true) {
          return self.isPBPRegisteredForCLEvents
        }
        else {
          if (self.registeredCampaignList.length > 0) {
            if (campaignName === "*") {
              return true
            }
            else {
              return self.registeredCampaignList.indexOf(campaignName) > -1
            }
          }
          return true
        }
      }
      function getCallMediaType(callId) {
        if (callId && activeCalls[callId]) {
          return activeCalls[callId].mediatype
        }
        return undefined
      }
      function initializeUI() {
        jQuery(el.NumberInput).on("change input", function(e) {
          var filtered = jQuery(el.NumberInput).val().replace(/([^0-9#*])/g, '');
          jQuery(el.NumberInput).val(filtered);
          if (self.currentState() === states.LoggedIn || self.currentState() === states.Ready || self.currentState() === states.Paused) {
            jQuery(el.CallButton).enabled(filtered.length > 0);
            jQuery(el.ManualTransferButton).disable()
          }
          else if (self.currentState() === states.Talking || self.currentState() === states.OtherCall) {
            jQuery(el.CallButton).enabled(filtered.length > 0);
            jQuery(el.ManualTransferButton).enabled(filtered.length > 0)
          }
          else {
            jQuery(el.CallButton + ", " + el.ManualTransferButton).disable()
          }
        }).on("keydown", function(e) {
          if (e.which === 13) {
            if (self.currentState() === states.LoggedIn || self.currentState() === states.Ready || self.currentState() === states.Paused) {
              self.showMakeCallPopup(jQuery(el.NumberInput).val())
            }
            return false
          }
          if (e.which === 27) {
            jQuery(el.NumberInput).val("").change();
            return false
          }
        })
      }
      function resetUI() {
        jQuery(el.PhoneToolbar).show();
        jQuery(el.PhoneDialPad).hide();
        jQuery(el.LoginButton).disable();
        jQuery(el.LoginOrReadyButton).disable();
        jQuery(el.ReadyButton).disable();
        jQuery(el.PauseButton).disable();
        jQuery(el.LogoutButton).disable();
        jQuery(el.CallButton).disable();
        jQuery(el.TransferButton).disable();
        jQuery(el.CampaignListButton).disable();
        jQuery(el.StartRecordingButton).disable();
        jQuery(el.QueueInfoButton).disable();
        jQuery(el.StopRecordingButton).disable();
        jQuery(el.MuteRecordingButton).disable();
        jQuery(el.UnmuteRecordingButton).disable();
        jQuery(el.PanicButton).disable();
        jQuery(el.HideDialPadButton).disable();
        jQuery(el.ShowDialPadButton).disable();
        jQuery(el.PickupButton).disable();
        jQuery(el.HangupButton).disable();
        jQuery(el.FlashButton).disable();
        jQuery(el.ManualTransferButton).disable();
        jQuery(el.MicrophoneOnButton).disable();
        jQuery(el.MicrophoneOffButton).disable();
        jQuery(el.Line1Button).disable();
        jQuery(el.Line2Button).disable();
        jQuery(el.EnterConferenceButton).disable();
        jQuery(el.LeaveConferenceButton).disable();
        jQuery(el.MarqueeLabel).html("Connection Lost").change();
        jQuery(el.TimerLabel).html("").change();
        jQuery(el.NumberInput).val("").change();
        jQuery(el.SoftPhoneStateLabel).removeClass("device-ready").removeClass("device-warning").removeClass("device-error").removeClass("blink").addClass("device-disabled");
        jQuery(el.XmppStateLabel).removeClass("device-ready").removeClass("device-warning").removeClass("device-error").removeClass("blink").addClass("device-disabled")
      }
      function updateUIStateOnly(state) {
        state.MarqueeLabel.Disabled ? jQuery(el.MarqueeLabel).disable() : jQuery(el.MarqueeLabel).enable();
        state.MarqueeLabel.Hidden ? jQuery(el.MarqueeLabel).hide() : jQuery(el.MarqueeLabel).show();
        state.MarqueeLabel.IsTemporary ? jQuery(el.MarqueeLabel).addClass("phonebar-state-error-text") : jQuery(el.MarqueeLabel).removeClass("phonebar-state-error-text");
        jQuery(el.MarqueeLabel).html(state.MarqueeLabel.Text).change();
        state.TimerLabel.Disabled ? jQuery(el.TimerLabel).disable() : jQuery(el.TimerLabel).enable();
        state.TimerLabel.Hidden ? jQuery(el.TimerLabel).hide() : jQuery(el.TimerLabel).show();
        jQuery(el.TimerLabel).html(state.TimerLabel.Text).change();
        state.NumberInput.Disabled ? jQuery(el.NumberInput).disable() : jQuery(el.NumberInput).enable();
        state.NumberInput.Hidden ? jQuery(el.NumberInput).hide() : jQuery(el.NumberInput).show();
        if (state.CurrentState === states.NotLoggedIn) {
          jQuery(el.SoftPhoneStateLabel).removeClass("device-ready").removeClass("device-warning").removeClass("device-error").removeClass("blink").addClass("device-disabled");
          jQuery(el.XmppStateLabel).removeClass("device-ready").removeClass("device-warning").removeClass("device-error").removeClass("blink").addClass("device-disabled")
        }
        else {
          jQuery(el.SoftPhoneStateLabel).removeClass("device-disabled");
          jQuery(el.XmppStateLabel).removeClass("device-disabled");
          if (state.PhoneDevice.IsConfigured) {
            if (!state.PhoneDevice.IsConnected) {
              jQuery(el.SoftPhoneStateLabel).attr("title", strings[language].SoftPhoneNotConnectedStateLabel.replace('{0}', chromebarConfiguration.config.phoneDevice));
              jQuery(el.SoftPhoneStateLabel).removeClass("device-ready").removeClass("device-warning").addClass("device-error").addClass("blink")
            }
            else if (state.PhoneDevice.IsRegistered) {
              if (state.PhoneDevice.HasAccessToMediaDevice) {
                jQuery(el.SoftPhoneStateLabel).attr("title", strings[language].SoftPhoneRegisteredStateLabel.replace('{0}', chromebarConfiguration.config.phoneDevice));
                jQuery(el.SoftPhoneStateLabel).addClass("device-ready").removeClass("device-warning").removeClass("device-error").removeClass("blink")
              }
              else {
                jQuery(el.SoftPhoneStateLabel).attr("title", strings[language].SoftPhoneRegisteredNoMediaStateLabel.replace('{0}', chromebarConfiguration.config.phoneDevice));
                jQuery(el.SoftPhoneStateLabel).addClass("device-ready").addClass("device-warning").removeClass("device-error").addClass("blink")
              }
            }
            else {
              jQuery(el.SoftPhoneStateLabel).attr("title", strings[language].SoftPhoneNotRegisteredStateLabel.replace('{0}', chromebarConfiguration.config.phoneDevice));
              jQuery(el.SoftPhoneStateLabel).removeClass("device-ready").addClass("device-warning").removeClass("device-error").removeClass("blink")
            }
          }
          else {
            jQuery(el.SoftPhoneStateLabel).removeClass("device-ready").removeClass("device-warning").removeClass("device-error").removeClass("blink").addClass("device-disabled")
          }
          if (state.XmppState) {
            jQuery(el.XmppStateLabel).attr("title", strings[language].XmppConnectedStateLabel);
            jQuery(el.XmppStateLabel).addClass("device-ready").removeClass("device-error").removeClass("blink")
          }
          else {
            jQuery(el.XmppStateLabel).attr("title", strings[language].XmppNotConnectedStateLabel);
            jQuery(el.XmppStateLabel).removeClass("device-ready").addClass("device-error").addClass("blink")
          }
        }
      }
      function updateUI(state, full, stateOnly) {
        if (stateOnly === true) {
          updateUIStateOnly(state);
          return
        }
        state.PhoneToolbar.Hidden ? jQuery(el.PhoneToolbar).hide() : jQuery(el.PhoneToolbar).show();
        state.PhoneDialPad.Hidden ? jQuery(el.PhoneDialPad).hide() : jQuery(el.PhoneDialPad).show();
        state.LoginButton.Disabled ? jQuery(el.LoginButton).disable() : jQuery(el.LoginButton).enable();
        state.LoginButton.Hidden ? jQuery(el.LoginButton).hide() : jQuery(el.LoginButton).show();
        state.LoginButton.Blink ? jQuery(el.LoginButton).addClass("blink") : jQuery(el.LoginButton).removeClass("blink");
        state.LoginButton.Highlight ? jQuery(el.LoginButton).addClass("highlight") : jQuery(el.LoginButton).removeClass("highlight");
        state.LoginButton.Selected ? jQuery(el.LoginButton).addClass("selected") : jQuery(el.LoginButton).removeClass("selected");
        state.LoginOrReadyButton.Disabled ? jQuery(el.LoginOrReadyButton).disable() : jQuery(el.LoginOrReadyButton).enable();
        state.LoginOrReadyButton.Hidden ? jQuery(el.LoginOrReadyButton).hide() : jQuery(el.LoginOrReadyButton).show();
        state.LoginOrReadyButton.Blink ? jQuery(el.LoginOrReadyButton).addClass("blink") : jQuery(el.LoginOrReadyButton).removeClass("blink");
        state.LoginOrReadyButton.Highlight ? jQuery(el.LoginOrReadyButton).addClass("highlight") : jQuery(el.LoginOrReadyButton).removeClass("highlight");
        state.LoginOrReadyButton.Selected ? jQuery(el.LoginOrReadyButton).addClass("selected") : jQuery(el.LoginOrReadyButton).removeClass("selected");
        state.ReadyButton.Disabled ? jQuery(el.ReadyButton).disable() : jQuery(el.ReadyButton).enable();
        state.ReadyButton.Hidden ? jQuery(el.ReadyButton).hide() : jQuery(el.ReadyButton).show();
        state.ReadyButton.Blink ? jQuery(el.ReadyButton).addClass("blink") : jQuery(el.ReadyButton).removeClass("blink");
        state.ReadyButton.Highlight ? jQuery(el.ReadyButton).addClass("highlight") : jQuery(el.ReadyButton).removeClass("highlight");
        state.ReadyButton.Selected ? jQuery(el.ReadyButton).addClass("selected") : jQuery(el.ReadyButton).removeClass("selected");
        state.PauseButton.Disabled ? jQuery(el.PauseButton).disable() : jQuery(el.PauseButton).enable();
        state.PauseButton.Hidden ? jQuery(el.PauseButton).hide() : jQuery(el.PauseButton).show();
        state.PauseButton.Blink ? jQuery(el.PauseButton).addClass("blink") : jQuery(el.PauseButton).removeClass("blink");
        state.PauseButton.Highlight ? jQuery(el.PauseButton).addClass("highlight") : jQuery(el.PauseButton).removeClass("highlight");
        state.PauseButton.Selected ? jQuery(el.PauseButton).addClass("selected") : jQuery(el.PauseButton).removeClass("selected");
        state.LogoutButton.Disabled ? jQuery(el.LogoutButton).disable() : jQuery(el.LogoutButton).enable();
        state.LogoutButton.Hidden ? jQuery(el.LogoutButton).hide() : jQuery(el.LogoutButton).show();
        state.LogoutButton.Blink ? jQuery(el.LogoutButton).addClass("blink") : jQuery(el.LogoutButton).removeClass("blink");
        state.LogoutButton.Highlight ? jQuery(el.LogoutButton).addClass("highlight") : jQuery(el.LogoutButton).removeClass("highlight");
        state.LogoutButton.Selected ? jQuery(el.LogoutButton).addClass("selected") : jQuery(el.LogoutButton).removeClass("selected");
        if (full) {
          state.CallButton.Disabled ? jQuery(el.CallButton).disable() : jQuery(el.CallButton).enable();
          state.CallButton.Hidden ? jQuery(el.CallButton).hide() : jQuery(el.CallButton).show();
          state.CallButton.Blink ? jQuery(el.CallButton).addClass("blink") : jQuery(el.CallButton).removeClass("blink");
          state.CallButton.Highlight ? jQuery(el.CallButton).addClass("highlight") : jQuery(el.CallButton).removeClass("highlight");
          state.CallButton.Selected ? jQuery(el.CallButton).addClass("selected") : jQuery(el.CallButton).removeClass("selected")
        }
        state.AbortCallButton.Disabled ? jQuery(el.AbortCallButton).disable() : jQuery(el.AbortCallButton).enable();
        state.AbortCallButton.Hidden ? jQuery(el.AbortCallButton).hide() : jQuery(el.AbortCallButton).show();
        state.AbortCallButton.Blink ? jQuery(el.AbortCallButton).addClass("blink") : jQuery(el.AbortCallButton).removeClass("blink");
        state.AbortCallButton.Highlight ? jQuery(el.AbortCallButton).addClass("highlight") : jQuery(el.AbortCallButton).removeClass("highlight");
        state.AbortCallButton.Selected ? jQuery(el.AbortCallButton).addClass("selected") : jQuery(el.AbortCallButton).removeClass("selected");
        state.TransferButton.Disabled ? jQuery(el.TransferButton).disable() : jQuery(el.TransferButton).enable();
        state.TransferButton.Hidden ? jQuery(el.TransferButton).hide() : jQuery(el.TransferButton).show();
        state.TransferButton.Blink ? jQuery(el.TransferButton).addClass("blink") : jQuery(el.TransferButton).removeClass("blink");
        state.TransferButton.Highlight ? jQuery(el.TransferButton).addClass("highlight") : jQuery(el.TransferButton).removeClass("highlight");
        state.TransferButton.Selected ? jQuery(el.TransferButton).addClass("selected") : jQuery(el.TransferButton).removeClass("selected");
        state.CampaignListButton.Disabled ? jQuery(el.CampaignListButton).disable() : jQuery(el.CampaignListButton).enable();
        state.CampaignListButton.Hidden ? jQuery(el.CampaignListButton).hide() : jQuery(el.CampaignListButton).show();
        state.CampaignListButton.Blink ? jQuery(el.CampaignListButton).addClass("blink") : jQuery(el.CampaignListButton).removeClass("blink");
        state.CampaignListButton.Highlight ? jQuery(el.CampaignListButton).addClass("highlight") : jQuery(el.CampaignListButton).removeClass("highlight");
        state.CampaignListButton.Selected ? jQuery(el.CampaignListButton).addClass("selected") : jQuery(el.CampaignListButton).removeClass("selected");
        state.StartRecordingButton.Disabled ? jQuery(el.StartRecordingButton).disable() : jQuery(el.StartRecordingButton).enable();
        state.StartRecordingButton.Hidden ? jQuery(el.StartRecordingButton).hide() : jQuery(el.StartRecordingButton).show();
        state.StartRecordingButton.Blink ? jQuery(el.StartRecordingButton).addClass("blink") : jQuery(el.StartRecordingButton).removeClass("blink");
        state.StartRecordingButton.Highlight ? jQuery(el.StartRecordingButton).addClass("highlight") : jQuery(el.StartRecordingButton).removeClass("highlight");
        state.StartRecordingButton.Selected ? jQuery(el.StartRecordingButton).addClass("selected") : jQuery(el.StartRecordingButton).removeClass("selected");
        state.QueueInfoButton.Disabled ? jQuery(el.QueueInfoButton).disable() : jQuery(el.QueueInfoButton).enable();
        state.QueueInfoButton.Hidden ? jQuery(el.QueueInfoButton).hide() : jQuery(el.QueueInfoButton).show();
        state.QueueInfoButton.Blink ? jQuery(el.QueueInfoButton).addClass("blink") : jQuery(el.QueueInfoButton).removeClass("blink");
        state.QueueInfoButton.Highlight ? jQuery(el.QueueInfoButton).addClass("highlight") : jQuery(el.QueueInfoButton).removeClass("highlight");
        state.QueueInfoButton.Selected ? jQuery(el.QueueInfoButton).addClass("selected") : jQuery(el.QueueInfoButton).removeClass("selected");
        state.StopRecordingButton.Disabled ? jQuery(el.StopRecordingButton).disable() : jQuery(el.StopRecordingButton).enable();
        state.StopRecordingButton.Hidden ? jQuery(el.StopRecordingButton).hide() : jQuery(el.StopRecordingButton).show();
        state.StopRecordingButton.Blink ? jQuery(el.StopRecordingButton).addClass("blink") : jQuery(el.StopRecordingButton).removeClass("blink");
        state.StopRecordingButton.Highlight ? jQuery(el.StopRecordingButton).addClass("highlight") : jQuery(el.StopRecordingButton).removeClass("highlight");
        state.StopRecordingButton.Selected ? jQuery(el.StopRecordingButton).addClass("selected") : jQuery(el.StopRecordingButton).removeClass("selected");
        state.MuteRecordingButton.Disabled ? jQuery(el.MuteRecordingButton).disable() : jQuery(el.MuteRecordingButton).enable();
        state.MuteRecordingButton.Hidden ? jQuery(el.MuteRecordingButton).hide() : jQuery(el.MuteRecordingButton).show();
        state.MuteRecordingButton.Blink ? jQuery(el.MuteRecordingButton).addClass("blink") : jQuery(el.MuteRecordingButton).removeClass("blink");
        state.MuteRecordingButton.Highlight ? jQuery(el.MuteRecordingButton).addClass("highlight") : jQuery(el.MuteRecordingButton).removeClass("highlight");
        state.MuteRecordingButton.Selected ? jQuery(el.MuteRecordingButton).addClass("selected") : jQuery(el.MuteRecordingButton).removeClass("selected");
        state.UnmuteRecordingButton.Disabled ? jQuery(el.UnmuteRecordingButton).disable() : jQuery(el.UnmuteRecordingButton).enable();
        state.UnmuteRecordingButton.Hidden ? jQuery(el.UnmuteRecordingButton).hide() : jQuery(el.UnmuteRecordingButton).show();
        state.UnmuteRecordingButton.Blink ? jQuery(el.UnmuteRecordingButton).addClass("blink") : jQuery(el.UnmuteRecordingButton).removeClass("blink");
        state.UnmuteRecordingButton.Highlight ? jQuery(el.UnmuteRecordingButton).addClass("highlight") : jQuery(el.UnmuteRecordingButton).removeClass("highlight");
        state.UnmuteRecordingButton.Selected ? jQuery(el.UnmuteRecordingButton).addClass("selected") : jQuery(el.UnmuteRecordingButton).removeClass("selected");
        state.PanicButton.Disabled ? jQuery(el.PanicButton).disable() : jQuery(el.PanicButton).enable();
        state.PanicButton.Hidden ? jQuery(el.PanicButton).hide() : jQuery(el.PanicButton).show();
        state.PanicButton.Blink ? jQuery(el.PanicButton).addClass("blink") : jQuery(el.PanicButton).removeClass("blink");
        state.PanicButton.Highlight ? jQuery(el.PanicButton).addClass("highlight") : jQuery(el.PanicButton).removeClass("highlight");
        state.PanicButton.Selected ? jQuery(el.PanicButton).addClass("selected") : jQuery(el.PanicButton).removeClass("selected");
        state.HideDialPadButton.Disabled ? jQuery(el.HideDialPadButton).disable() : jQuery(el.HideDialPadButton).enable();
        state.HideDialPadButton.Hidden ? jQuery(el.HideDialPadButton).hide() : jQuery(el.HideDialPadButton).show();
        state.HideDialPadButton.Blink ? jQuery(el.HideDialPadButton).addClass("blink") : jQuery(el.HideDialPadButton).removeClass("blink");
        state.HideDialPadButton.Highlight ? jQuery(el.HideDialPadButton).addClass("highlight") : jQuery(el.HideDialPadButton).removeClass("highlight");
        state.HideDialPadButton.Selected ? jQuery(el.HideDialPadButton).addClass("selected") : jQuery(el.HideDialPadButton).removeClass("selected");
        state.ShowDialPadButton.Disabled ? jQuery(el.ShowDialPadButton).disable() : jQuery(el.ShowDialPadButton).enable();
        state.ShowDialPadButton.Hidden ? jQuery(el.ShowDialPadButton).hide() : jQuery(el.ShowDialPadButton).show();
        state.ShowDialPadButton.Blink ? jQuery(el.ShowDialPadButton).addClass("blink") : jQuery(el.ShowDialPadButton).removeClass("blink");
        state.ShowDialPadButton.Highlight ? jQuery(el.ShowDialPadButton).addClass("highlight") : jQuery(el.ShowDialPadButton).removeClass("highlight");
        state.ShowDialPadButton.Selected ? jQuery(el.ShowDialPadButton).addClass("selected") : jQuery(el.ShowDialPadButton).removeClass("selected");
        state.PickupButton.Disabled ? jQuery(el.PickupButton).disable() : jQuery(el.PickupButton).enable();
        state.PickupButton.Hidden ? jQuery(el.PickupButton).hide() : jQuery(el.PickupButton).show();
        state.PickupButton.Blink ? jQuery(el.PickupButton).addClass("blink") : jQuery(el.PickupButton).removeClass("blink");
        state.PickupButton.Highlight ? jQuery(el.PickupButton).addClass("highlight") : jQuery(el.PickupButton).removeClass("highlight");
        state.PickupButton.Selected ? jQuery(el.PickupButton).addClass("selected") : jQuery(el.PickupButton).removeClass("selected");
        state.HangupButton.Disabled ? jQuery(el.HangupButton).disable() : jQuery(el.HangupButton).enable();
        state.HangupButton.Hidden ? jQuery(el.HangupButton).hide() : jQuery(el.HangupButton).show();
        state.HangupButton.Blink ? jQuery(el.HangupButton).addClass("blink") : jQuery(el.HangupButton).removeClass("blink");
        state.HangupButton.Highlight ? jQuery(el.HangupButton).addClass("highlight") : jQuery(el.HangupButton).removeClass("highlight");
        state.HangupButton.Selected ? jQuery(el.HangupButton).addClass("selected") : jQuery(el.HangupButton).removeClass("selected");
        state.FlashButton.Disabled ? jQuery(el.FlashButton).disable() : jQuery(el.FlashButton).enable();
        state.FlashButton.Hidden ? jQuery(el.FlashButton).hide() : jQuery(el.FlashButton).show();
        state.FlashButton.Blink ? jQuery(el.FlashButton).addClass("blink") : jQuery(el.FlashButton).removeClass("blink");
        state.FlashButton.Highlight ? jQuery(el.FlashButton).addClass("highlight") : jQuery(el.FlashButton).removeClass("highlight");
        state.FlashButton.Selected ? jQuery(el.FlashButton).addClass("selected") : jQuery(el.FlashButton).removeClass("selected");
        state.ManualTransferButton.Disabled ? jQuery(el.ManualTransferButton).disable() : jQuery(el.ManualTransferButton).enable();
        state.ManualTransferButton.Hidden ? jQuery(el.ManualTransferButton).hide() : jQuery(el.ManualTransferButton).show();
        state.ManualTransferButton.Blink ? jQuery(el.ManualTransferButton).addClass("blink") : jQuery(el.ManualTransferButton).removeClass("blink");
        state.ManualTransferButton.Highlight ? jQuery(el.ManualTransferButton).addClass("highlight") : jQuery(el.ManualTransferButton).removeClass("highlight");
        state.ManualTransferButton.Selected ? jQuery(el.ManualTransferButton).addClass("selected") : jQuery(el.ManualTransferButton).removeClass("selected");
        state.MicrophoneOnButton.Disabled ? jQuery(el.MicrophoneOnButton).disable() : jQuery(el.MicrophoneOnButton).enable();
        state.MicrophoneOnButton.Hidden ? jQuery(el.MicrophoneOnButton).hide() : jQuery(el.MicrophoneOnButton).show();
        state.MicrophoneOnButton.Blink ? jQuery(el.MicrophoneOnButton).addClass("blink") : jQuery(el.MicrophoneOnButton).removeClass("blink");
        state.MicrophoneOnButton.Highlight ? jQuery(el.MicrophoneOnButton).addClass("highlight") : jQuery(el.MicrophoneOnButton).removeClass("highlight");
        state.MicrophoneOnButton.Selected ? jQuery(el.MicrophoneOnButton).addClass("selected") : jQuery(el.MicrophoneOnButton).removeClass("selected");
        state.MicrophoneOffButton.Disabled ? jQuery(el.MicrophoneOffButton).disable() : jQuery(el.MicrophoneOffButton).enable();
        state.MicrophoneOffButton.Hidden ? jQuery(el.MicrophoneOffButton).hide() : jQuery(el.MicrophoneOffButton).show();
        state.MicrophoneOffButton.Blink ? jQuery(el.MicrophoneOffButton).addClass("blink") : jQuery(el.MicrophoneOffButton).removeClass("blink");
        state.MicrophoneOffButton.Highlight ? jQuery(el.MicrophoneOffButton).addClass("highlight") : jQuery(el.MicrophoneOffButton).removeClass("highlight");
        state.MicrophoneOffButton.Selected ? jQuery(el.MicrophoneOffButton).addClass("selected") : jQuery(el.MicrophoneOffButton).removeClass("selected");
        state.Line1Button.Disabled ? jQuery(el.Line1Button).disable() : jQuery(el.Line1Button).enable();
        state.Line1Button.Hidden ? jQuery(el.Line1Button).hide() : jQuery(el.Line1Button).show();
        state.Line1Button.Blink ? jQuery(el.Line1Button).addClass("blink") : jQuery(el.Line1Button).removeClass("blink");
        state.Line1Button.Highlight ? jQuery(el.Line1Button).addClass("highlight") : jQuery(el.Line1Button).removeClass("highlight");
        state.Line1Button.Selected ? jQuery(el.Line1Button).addClass("selected") : jQuery(el.Line1Button).removeClass("selected");
        state.Line2Button.Disabled ? jQuery(el.Line2Button).disable() : jQuery(el.Line2Button).enable();
        state.Line2Button.Hidden ? jQuery(el.Line2Button).hide() : jQuery(el.Line2Button).show();
        state.Line2Button.Blink ? jQuery(el.Line2Button).addClass("blink") : jQuery(el.Line2Button).removeClass("blink");
        state.Line2Button.Highlight ? jQuery(el.Line2Button).addClass("highlight") : jQuery(el.Line2Button).removeClass("highlight");
        state.Line2Button.Selected ? jQuery(el.Line2Button).addClass("selected") : jQuery(el.Line2Button).removeClass("selected");
        state.EnterConferenceButton.Disabled ? jQuery(el.EnterConferenceButton).disable() : jQuery(el.EnterConferenceButton).enable();
        state.EnterConferenceButton.Hidden ? jQuery(el.EnterConferenceButton).hide() : jQuery(el.EnterConferenceButton).show();
        state.EnterConferenceButton.Blink ? jQuery(el.EnterConferenceButton).addClass("blink") : jQuery(el.EnterConferenceButton).removeClass("blink");
        state.EnterConferenceButton.Highlight ? jQuery(el.EnterConferenceButton).addClass("highlight") : jQuery(el.EnterConferenceButton).removeClass("highlight");
        state.EnterConferenceButton.Selected ? jQuery(el.EnterConferenceButton).addClass("selected") : jQuery(el.EnterConferenceButton).removeClass("selected");
        state.LeaveConferenceButton.Disabled ? jQuery(el.LeaveConferenceButton).disable() : jQuery(el.LeaveConferenceButton).enable();
        state.LeaveConferenceButton.Hidden ? jQuery(el.LeaveConferenceButton).hide() : jQuery(el.LeaveConferenceButton).show();
        state.LeaveConferenceButton.Blink ? jQuery(el.LeaveConferenceButton).addClass("blink") : jQuery(el.LeaveConferenceButton).removeClass("blink");
        state.LeaveConferenceButton.Highlight ? jQuery(el.LeaveConferenceButton).addClass("highlight") : jQuery(el.LeaveConferenceButton).removeClass("highlight");
        state.LeaveConferenceButton.Selected ? jQuery(el.LeaveConferenceButton).addClass("selected") : jQuery(el.LeaveConferenceButton).removeClass("selected");
        state.DialpadDigit0Button.Disabled ? jQuery(el.DialpadDigit0Button).disable() : jQuery(el.DialpadDigit0Button).enable();
        state.DialpadDigit0Button.Hidden ? jQuery(el.DialpadDigit0Button).hide() : jQuery(el.DialpadDigit0Button).show();
        state.DialpadDigit0Button.Blink ? jQuery(el.DialpadDigit0Button).addClass("blink") : jQuery(el.DialpadDigit0Button).removeClass("blink");
        state.DialpadDigit0Button.Highlight ? jQuery(el.DialpadDigit0Button).addClass("highlight") : jQuery(el.DialpadDigit0Button).removeClass("highlight");
        state.DialpadDigit0Button.Selected ? jQuery(el.DialpadDigit0Button).addClass("selected") : jQuery(el.DialpadDigit0Button).removeClass("selected");
        state.DialpadDigit1Button.Disabled ? jQuery(el.DialpadDigit1Button).disable() : jQuery(el.DialpadDigit1Button).enable();
        state.DialpadDigit1Button.Hidden ? jQuery(el.DialpadDigit1Button).hide() : jQuery(el.DialpadDigit1Button).show();
        state.DialpadDigit1Button.Blink ? jQuery(el.DialpadDigit1Button).addClass("blink") : jQuery(el.DialpadDigit1Button).removeClass("blink");
        state.DialpadDigit1Button.Highlight ? jQuery(el.DialpadDigit1Button).addClass("highlight") : jQuery(el.DialpadDigit1Button).removeClass("highlight");
        state.DialpadDigit1Button.Selected ? jQuery(el.DialpadDigit1Button).addClass("selected") : jQuery(el.DialpadDigit1Button).removeClass("selected");
        state.DialpadDigit2Button.Disabled ? jQuery(el.DialpadDigit2Button).disable() : jQuery(el.DialpadDigit2Button).enable();
        state.DialpadDigit2Button.Hidden ? jQuery(el.DialpadDigit2Button).hide() : jQuery(el.DialpadDigit2Button).show();
        state.DialpadDigit2Button.Blink ? jQuery(el.DialpadDigit2Button).addClass("blink") : jQuery(el.DialpadDigit2Button).removeClass("blink");
        state.DialpadDigit2Button.Highlight ? jQuery(el.DialpadDigit2Button).addClass("highlight") : jQuery(el.DialpadDigit2Button).removeClass("highlight");
        state.DialpadDigit2Button.Selected ? jQuery(el.DialpadDigit2Button).addClass("selected") : jQuery(el.DialpadDigit2Button).removeClass("selected");
        state.DialpadDigit3Button.Disabled ? jQuery(el.DialpadDigit3Button).disable() : jQuery(el.DialpadDigit3Button).enable();
        state.DialpadDigit3Button.Hidden ? jQuery(el.DialpadDigit3Button).hide() : jQuery(el.DialpadDigit3Button).show();
        state.DialpadDigit3Button.Blink ? jQuery(el.DialpadDigit3Button).addClass("blink") : jQuery(el.DialpadDigit3Button).removeClass("blink");
        state.DialpadDigit3Button.Highlight ? jQuery(el.DialpadDigit3Button).addClass("highlight") : jQuery(el.DialpadDigit3Button).removeClass("highlight");
        state.DialpadDigit3Button.Selected ? jQuery(el.DialpadDigit3Button).addClass("selected") : jQuery(el.DialpadDigit3Button).removeClass("selected");
        state.DialpadDigit4Button.Disabled ? jQuery(el.DialpadDigit4Button).disable() : jQuery(el.DialpadDigit4Button).enable();
        state.DialpadDigit4Button.Hidden ? jQuery(el.DialpadDigit4Button).hide() : jQuery(el.DialpadDigit4Button).show();
        state.DialpadDigit4Button.Blink ? jQuery(el.DialpadDigit4Button).addClass("blink") : jQuery(el.DialpadDigit4Button).removeClass("blink");
        state.DialpadDigit4Button.Highlight ? jQuery(el.DialpadDigit4Button).addClass("highlight") : jQuery(el.DialpadDigit4Button).removeClass("highlight");
        state.DialpadDigit4Button.Selected ? jQuery(el.DialpadDigit4Button).addClass("selected") : jQuery(el.DialpadDigit4Button).removeClass("selected");
        state.DialpadDigit5Button.Disabled ? jQuery(el.DialpadDigit5Button).disable() : jQuery(el.DialpadDigit5Button).enable();
        state.DialpadDigit5Button.Hidden ? jQuery(el.DialpadDigit5Button).hide() : jQuery(el.DialpadDigit5Button).show();
        state.DialpadDigit5Button.Blink ? jQuery(el.DialpadDigit5Button).addClass("blink") : jQuery(el.DialpadDigit5Button).removeClass("blink");
        state.DialpadDigit5Button.Highlight ? jQuery(el.DialpadDigit5Button).addClass("highlight") : jQuery(el.DialpadDigit5Button).removeClass("highlight");
        state.DialpadDigit5Button.Selected ? jQuery(el.DialpadDigit5Button).addClass("selected") : jQuery(el.DialpadDigit5Button).removeClass("selected");
        state.DialpadDigit6Button.Disabled ? jQuery(el.DialpadDigit6Button).disable() : jQuery(el.DialpadDigit6Button).enable();
        state.DialpadDigit6Button.Hidden ? jQuery(el.DialpadDigit6Button).hide() : jQuery(el.DialpadDigit6Button).show();
        state.DialpadDigit6Button.Blink ? jQuery(el.DialpadDigit6Button).addClass("blink") : jQuery(el.DialpadDigit6Button).removeClass("blink");
        state.DialpadDigit6Button.Highlight ? jQuery(el.DialpadDigit6Button).addClass("highlight") : jQuery(el.DialpadDigit6Button).removeClass("highlight");
        state.DialpadDigit6Button.Selected ? jQuery(el.DialpadDigit6Button).addClass("selected") : jQuery(el.DialpadDigit6Button).removeClass("selected");
        state.DialpadDigit7Button.Disabled ? jQuery(el.DialpadDigit7Button).disable() : jQuery(el.DialpadDigit7Button).enable();
        state.DialpadDigit7Button.Hidden ? jQuery(el.DialpadDigit7Button).hide() : jQuery(el.DialpadDigit7Button).show();
        state.DialpadDigit7Button.Blink ? jQuery(el.DialpadDigit7Button).addClass("blink") : jQuery(el.DialpadDigit7Button).removeClass("blink");
        state.DialpadDigit7Button.Highlight ? jQuery(el.DialpadDigit7Button).addClass("highlight") : jQuery(el.DialpadDigit7Button).removeClass("highlight");
        state.DialpadDigit7Button.Selected ? jQuery(el.DialpadDigit7Button).addClass("selected") : jQuery(el.DialpadDigit7Button).removeClass("selected");
        state.DialpadDigit8Button.Disabled ? jQuery(el.DialpadDigit8Button).disable() : jQuery(el.DialpadDigit8Button).enable();
        state.DialpadDigit8Button.Hidden ? jQuery(el.DialpadDigit8Button).hide() : jQuery(el.DialpadDigit8Button).show();
        state.DialpadDigit8Button.Blink ? jQuery(el.DialpadDigit8Button).addClass("blink") : jQuery(el.DialpadDigit8Button).removeClass("blink");
        state.DialpadDigit8Button.Highlight ? jQuery(el.DialpadDigit8Button).addClass("highlight") : jQuery(el.DialpadDigit8Button).removeClass("highlight");
        state.DialpadDigit8Button.Selected ? jQuery(el.DialpadDigit8Button).addClass("selected") : jQuery(el.DialpadDigit8Button).removeClass("selected");
        state.DialpadDigit9Button.Disabled ? jQuery(el.DialpadDigit9Button).disable() : jQuery(el.DialpadDigit9Button).enable();
        state.DialpadDigit9Button.Hidden ? jQuery(el.DialpadDigit9Button).hide() : jQuery(el.DialpadDigit9Button).show();
        state.DialpadDigit9Button.Blink ? jQuery(el.DialpadDigit9Button).addClass("blink") : jQuery(el.DialpadDigit9Button).removeClass("blink");
        state.DialpadDigit9Button.Highlight ? jQuery(el.DialpadDigit9Button).addClass("highlight") : jQuery(el.DialpadDigit9Button).removeClass("highlight");
        state.DialpadDigit9Button.Selected ? jQuery(el.DialpadDigit9Button).addClass("selected") : jQuery(el.DialpadDigit9Button).removeClass("selected");
        state.DialpadHashButton.Disabled ? jQuery(el.DialpadHashButton).disable() : jQuery(el.DialpadHashButton).enable();
        state.DialpadHashButton.Hidden ? jQuery(el.DialpadHashButton).hide() : jQuery(el.DialpadHashButton).show();
        state.DialpadHashButton.Blink ? jQuery(el.DialpadHashButton).addClass("blink") : jQuery(el.DialpadHashButton).removeClass("blink");
        state.DialpadHashButton.Highlight ? jQuery(el.DialpadHashButton).addClass("highlight") : jQuery(el.DialpadHashButton).removeClass("highlight");
        state.DialpadHashButton.Selected ? jQuery(el.DialpadHashButton).addClass("selected") : jQuery(el.DialpadHashButton).removeClass("selected");
        state.DialpadStarButton.Disabled ? jQuery(el.DialpadStarButton).disable() : jQuery(el.DialpadStarButton).enable();
        state.DialpadStarButton.Hidden ? jQuery(el.DialpadStarButton).hide() : jQuery(el.DialpadStarButton).show();
        state.DialpadStarButton.Blink ? jQuery(el.DialpadStarButton).addClass("blink") : jQuery(el.DialpadStarButton).removeClass("blink");
        state.DialpadStarButton.Highlight ? jQuery(el.DialpadStarButton).addClass("highlight") : jQuery(el.DialpadStarButton).removeClass("highlight");
        state.DialpadStarButton.Selected ? jQuery(el.DialpadStarButton).addClass("selected") : jQuery(el.DialpadStarButton).removeClass("selected");
        updateUIStateOnly(state);
        jQuery(el.SpeakersVUMeter).val(state.SpeakersVUMeter.Value);
        jQuery(el.MicrophoneVUMeter).val(state.MicrophoneVUMeter.Value)
      }
      function resetSessionData() {
        activeCalls = {};
        callbacks = {
          login: [], logout: [], pause: [], ready: [], make: [], transfer: [], getAgents: [], getCampaigns: [], getPauseReasons: [], getQueueInfo: [], getOutboundCampaigns: [], getTransferAgents: [], getAssignedCampaigns: [], getTransferCampaigns: [], getCallHistoryLog: [], getSiteListFromProvisioning: [], getModuleConfiguration: [], getAuthorityInfo: [], setConfiguration: []
        }
      }
      function sendNextAgentListRequest() {
        if (callbacks.getAgents.length) {
          var request = callbacks.getAgents[0],
            campaignName = request.campaignName,
            mask = request.mask;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetAgentListRequest, campaignName: campaignName, mask: mask
          }, "*")
        }
      }
      function sendNextPauseReasonListRequest() {
        if (callbacks.getPauseReasons.length) {
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetPauseReasonsRequest
          }, "*")
        }
      }
      function sendNextTransferAgentListRequest() {
        if (callbacks.getTransferAgents.length) {
          var request = callbacks.getTransferAgents[0],
            campaignName = request.campaignName;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetTransferAgentListRequest, campaignName: campaignName
          }, "*")
        }
      }
      function sendNextCampaignListRequest() {
        if (callbacks.getCampaigns.length) {
          var request = callbacks.getCampaigns[0],
            mask = request.mask,
            callId = request.callId,
            mediaType = request.mediatype;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetCampaignListRequest, mask: mask, callId: callId, mediaType: mediaType
          }, "*")
        }
      }
      function sendNextAssignedCampaignListRequest() {
        if (callbacks.getAssignedCampaigns.length) {
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetAssignedCampaignListRequest
          }, "*")
        }
      }
      function sendNextOutboundCampaignListRequest() {
        if (callbacks.getOutboundCampaigns.length) {
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetOutboundCampaignListRequest
          }, "*")
        }
      }
      function sendNextTransferCampaignListRequest() {
        if (callbacks.getTransferCampaigns.length) {
          var request = callbacks.getTransferCampaigns[0],
            callId = request.callId;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetTransferCampaignListRequest, callId: callId
          }, "*")
        }
      }
      function sendNextCallHistoryLogRequest() {
        if (callbacks.getCallHistoryLog.length) {
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetCallHistoryLogRequest
          }, "*")
        }
      }
      function sendNextQueueInfoRequest() {
        if (callbacks.getQueueInfo.length) {
          var request = callbacks.getQueueInfo[0],
            campaignName = request.campaignName;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetQueueInfoRequest, campaignName: campaignName
          }, "*")
        }
      }
      function sendNextGetAuthorityInfoRequest() {
        if (callbacks.getAuthorityInfo.length) {
          var request = callbacks.getAuthorityInfo[0],
            userName = request.userName;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetAuthorityInfoRequest, userName: userName
          }, "*")
        }
      }
      function sendNextGetSiteListRequest() {
        if (callbacks.getSiteListFromProvisioning.length) {
          var request = callbacks.getSiteListFromProvisioning[0],
            userName = request.userName,
            token = request.token;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetProvisioningSiteListRequest, userName: userName, token: token
          }, "*")
        }
      }
      function sendNextGetModuleConfigurationRequest() {
        if (callbacks.getModuleConfiguration.length) {
          var request = callbacks.getModuleConfiguration[0],
            name = request.moduleName;
          window.postMessage({
            type: 'chromebarProxy', params: messageCodes.GetModuleConfigurationRequest, moduleName: name
          }, "*")
        }
      }
      Ifm.ChromeBar.checkIfRunning = function(callback) {
        if (checkTimer != null) {
          return
        }
        checkCallback = callback;
        if (hasAlreaySetTheListener === false) {
          hasAlreaySetTheListener = true;
          window.addEventListener("message", function(e) {
            console.log("[ContentScript] [DEBUG] New Message Received", e);
            if (!e.isTrusted || e.source !== window) {
              console.log("[ContentScript] [WARN] Invalid Message Received", e);
              return
            }
            if (e.data.type === "chromebarContentScript") {
              decodeMessage(e)
            }
          })
        }
        window.postMessage({
          type: 'chromebarProxy', params: messageCodes.CheckExtensionRequest
        }, "*");
        checkTimer = setTimeout(function() {
          checkCallback(false);
          clearTimeout(checkTimer);
          checkTimer = null;
          checkCallback = null
        }, 200)
      };
      Ifm.PhoneBar.Media.Xmpp.events.initialized = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: initialized event received")
      };
      Ifm.PhoneBar.Media.Xmpp.events.reachable = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: reachable event received");
        window.postMessage({
          type: 'chromebarProxy', params: messageCodes.ChatClientConnectedEvent
        }, "*")
      };
      Ifm.PhoneBar.Media.Xmpp.events.unreachable = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: unreachable event received");
        window.postMessage({
          type: 'chromebarProxy', params: messageCodes.ChatClientDisconnectedEvent
        }, "*")
      };
      Ifm.PhoneBar.Media.Xmpp.events.newcall = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: newcall event received")
      };
      Ifm.PhoneBar.Media.Xmpp.events.newmessage = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: newmessage event received")
      };
      Ifm.PhoneBar.Media.Xmpp.events.callclosed = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: callclosed event received")
      };
      Ifm.PhoneBar.Media.Xmpp.events.filetransfer = function(ph, e) {
        console.log("[ContentScript] [DEBUG] XMPP: filetransfer event received")
      };
      instance = {
        agent: {
          firstName: "", lastName: "", username: "", password: "", extension: "", id: "", getName: function() {
              return this.firstName + ' ' + this.lastName
            }
        }, config: {service: ""}, options: {
            autoAnswerPhone: function(value) {
              if (value === undefined) {
                return chromebarConfiguration.options.autoAnswerPhone
              }
              if (value >= 0 && value <= 3) {
                chromebarConfiguration.options.autoAnswerPhone = value;
                self.setConfiguration({options: {autoAnswerPhone: chromebarConfiguration.options.autoAnswerPhone}})
              }
            }, autoAnswerRings: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.autoAnswerRings
                }
                if (value >= 0 && value <= 50) {
                  chromebarConfiguration.options.autoAnswerRings = value;
                  self.setConfiguration({options: {autoAnswerRings: chromebarConfiguration.options.autoAnswerRings}})
                }
              }, autoConnectToXmpp: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.autoConnectToXmpp
                }
                chromebarConfiguration.options.autoConnectToXmpp = !!value;
                chromebarConfiguration.options.autoConnectToXmppServer = !!value;
                self.setConfiguration({options: {
                    autoConnectToXmpp: chromebarConfiguration.options.autoConnectToXmpp, autoConnectToXmppServer: chromebarConfiguration.options.autoConnectToXmppServer
                  }})
              }, callingNumber: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.callingNumber
                }
                chromebarConfiguration.options.callingNumber = value;
                self.setConfiguration({options: {callingNumber: chromebarConfiguration.options.callingNumber}})
              }, enableAbortCall: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.enableAbortCall
                }
                chromebarConfiguration.options.enableAbortCall = !!value;
                self.setConfiguration({options: {enableAbortCall: chromebarConfiguration.options.enableAbortCall}})
              }, hideClockInPause: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.hideClockInPause
                }
                chromebarConfiguration.options.hideClockInPause = !!value;
                self.setConfiguration({options: {hideClockInPause: chromebarConfiguration.options.hideClockInPause}})
              }, hidePausedAgents: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.hidePausedAgents
                }
                chromebarConfiguration.options.hidePausedAgents = !!value;
                self.setConfiguration({options: {hidePausedAgents: chromebarConfiguration.options.hidePausedAgents}})
              }, popupIncomingCall: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.popupIncomingCall
                }
                if (Ifm.Type.isNumber(value)) {
                  chromebarConfiguration.options.popupIncomingCall = !!value;
                  self.setConfiguration({options: {popupIncomingCall: chromebarConfiguration.options.popupIncomingCall}})
                }
              }, rememberCredentials: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.rememberCredentials
                }
                if (value === 0 || value === 1 || value === 2) {
                  chromebarConfiguration.options.rememberCredentials = value;
                  var newCfg = {
                      options: {rememberCredentials: chromebarConfiguration.options.rememberCredentials}, parameters: {
                          firstName: chromebarConfiguration.parameters.firstName, lastName: chromebarConfiguration.parameters.lastName, username: chromebarConfiguration.parameters.username, password: chromebarConfiguration.parameters.password
                        }
                    };
                  if (value < 2) {
                    this.forgetPassword();
                    newCfg.parameters.password = ""
                  }
                  if (value < 1) {
                    newCfg.parameters.firstName = "";
                    newCfg.parameters.lastName = "";
                    newCfg.parameters.username = "";
                    newCfg.parameters.password = "";
                    self.agent.firstName = "";
                    self.agent.lastName = "";
                    self.agent.username = "";
                    self.agent.password = ""
                  }
                  self.setConfiguration(newCfg)
                }
              }, showInfoPopupForManualCalls: function(value) {
                if (value === undefined) {
                  return chromebarConfiguration.options.showInfoPopupForManualCalls
                }
                chromebarConfiguration.options.showInfoPopupForManualCalls = !!value;
                self.setConfiguration({options: {showInfoPopupForManualCalls: chromebarConfiguration.options.showInfoPopupForManualCalls}})
              }, forgetPassword: function() {
                self.agent.password = ""
              }
          }, calls: function(filter) {
            var predicate = typeof filter === "function" ? filter : null;
            if (arguments.length > 0 && predicate === null) {
              return activeCalls[filter] || null
            }
            var c = Object.values(activeCalls);
            if (predicate) {
              return c.filter(predicate)
            }
            return c
          }, chromeBarVersion: function() {
            return chromebarVersion
          }, clearCallHistoryLog: function(callId) {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.ClearCallHistoryLogRequest, callId: callId
            }, "*")
          }, currentState: function() {
            return currentState
          }, currentStateReason: function() {
            return currentStateReason
          }, currentStateTime: function() {
            return currentStateTime
          }, getAgentList: function(campaignName, mask, callback) {
            if (arguments.length !== 3)
              throw Ifm.Diagnostics.Errors.argsno("3");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callbacks.getAgents.push({
              campaignName: campaignName, mask: mask, callback: callback
            });
            if (callbacks.getAgents.length === 1) {
              sendNextAgentListRequest()
            }
          }, getAssignedCampaignList: function(callback) {
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getAssignedCampaigns.push(callback);
            if (callbacks.getAssignedCampaigns.length === 1) {
              sendNextAssignedCampaignListRequest()
            }
          }, getAudioCall: function() {
            return self.calls(function(call) {
                return call.mediatype < 6
              })[0] || null
          }, getAuthorityInfo: function(userName, callback) {
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getAuthorityInfo.push({
              userName: userName, callback: callback
            });
            if (callbacks.getAuthorityInfo.length === 1) {
              sendNextGetAuthorityInfoRequest()
            }
          }, getCallHistoryLog: function(callback) {
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getCallHistoryLog.push(callback);
            if (callbacks.getCallHistoryLog.length === 1) {
              sendNextCallHistoryLogRequest()
            }
          }, getCampaignList: function(callId, mediatype, mask, callback) {
            if (arguments.length !== 4)
              throw Ifm.Diagnostics.Errors.argsno("4");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callbacks.getCampaigns.push({
              callId: callId, mediatype: mediatype, mask: mask, callback: callback
            });
            if (callbacks.getCampaigns.length === 1) {
              sendNextCampaignListRequest()
            }
          }, getConfiguration: function() {
            return chromebarConfiguration
          }, getModuleConfiguration: function(moduleName, callback) {
            if (arguments.length !== 2)
              throw Ifm.Diagnostics.Errors.argsno("2");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callbacks.getModuleConfiguration.push({
              moduleName: moduleName, callback: callback
            });
            if (callbacks.getModuleConfiguration.length === 1) {
              sendNextGetModuleConfigurationRequest()
            }
          }, getOutboundCampaignList: function(callback) {
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getOutboundCampaigns.push(callback);
            if (callbacks.getOutboundCampaigns.length === 1) {
              sendNextOutboundCampaignListRequest()
            }
          }, getPauseReasons: function(callback) {
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getPauseReasons.push(callback);
            if (callbacks.getPauseReasons.length === 1) {
              sendNextPauseReasonListRequest()
            }
          }, getQueueInfo: function(campaignName, callback) {
            if (arguments.length !== 2)
              throw Ifm.Diagnostics.Errors.argsno("2");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callbacks.getQueueInfo.push({
              campaignName: campaignName, callback: callback
            });
            if (callbacks.getQueueInfo.length === 1) {
              sendNextQueueInfoRequest()
            }
          }, getSiteList: function(userName, token, callback) {
            if (arguments.length !== 3)
              throw Ifm.Diagnostics.Errors.argsno("3");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callbacks.getSiteListFromProvisioning.push({
              userName: userName, token: token, callback: callback
            });
            if (callbacks.getSiteListFromProvisioning.length === 1) {
              sendNextGetSiteListRequest()
            }
          }, getSiteListFromProvisioning: function(userName, token, callback) {
            if (arguments.length !== 3)
              throw Ifm.Diagnostics.Errors.argsno("3");
            if (!Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callbacks.getSiteListFromProvisioning.push({
              userName: userName, token: token, callback: callback
            });
            if (callbacks.getSiteListFromProvisioning.length === 1) {
              sendNextGetSiteListRequest()
            }
          }, getTransferAgentList: function(campaignName, callback) {
            if (arguments.length !== 2)
              throw Ifm.Diagnostics.Errors.argsno("2");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getTransferAgents.push({
              campaignName: campaignName, callback: callback
            });
            if (callbacks.getTransferAgents.length === 1) {
              sendNextTransferAgentListRequest()
            }
          }, getTransferCampaignList: function(callId, callback) {
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.getTransferCampaigns.push({
              callId: callId, callback: callback
            });
            if (callbacks.getTransferCampaigns.length === 1) {
              sendNextTransferCampaignListRequest()
            }
          }, hideDialPad: function() {
            jQuery(el.PhoneDialPad + ", " + el.HideDialPadButton).disable().hide();
            jQuery(el.ShowDialPadButton).enable().show();
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.DialPadStateChangedEvent, hidden: true
            }, "*")
          }, initialize: function() {
            self = this;
            self.scriptControlMode = false;
            self.filterNonPhoneCallEvents = false;
            self.isSCPRegisteredForCLEvents = false;
            self.isPBPRegisteredForCLEvents = true;
            self.registeredCampaignList = [];
            console.log("ChromeBarProxy - Initializing");
            self.scriptControlMode = false;
            self.events = Ifm.ChromeBar.Proxy.events;
            states = Ifm.ChromeBar.Proxy.States;
            jQuery('[class^="phonebar-phone"]').hide();
            jQuery(el.NumberInput).attr("maxlength", 255);
            jQuery(el.PhoneDialPad).hide();
            resetSessionData();
            if (hasAlreaySetTheListener === false) {
              hasAlreaySetTheListener = true;
              window.addEventListener("message", function(e) {
                if (!e.isTrusted || e.source !== window) {
                  console.log("[ContentScript] [WARN] Invalid Message Received", e);
                  return
                }
                if (e.data.type === "chromebarContentScript") {
                  decodeMessage(e)
                }
              })
            }
            self.sendInitializeRequest()
          }, initializeXmpp: function(xmppConfig) {
            self.media.xmpp.initialize(self, xmppConfig || chromebarConfiguration.xmppconfig, Ifm.ChromeBar.Proxy)
          }, isLoggedIn: function() {
            return currentState !== undefined && currentState !== states.NotLoggedIn && currentState !== states.Connecting && currentState !== states.Initialization
          }, language: function(lang) {
            return language
          }, log: function(context, severity, message) {
            if (arguments.length < 3)
              throw Ifm.Diagnostics.Errors.argsno("3+");
            var lineId = "";
            if (context) {
              lineId += "[" + context + "] "
            }
            else {
              lineId += "[ChromeBarProxy] "
            }
            if (severity) {
              lineId += "[" + severity.toUpperCase() + "] "
            }
            else {
              lineId += "[DEBUG] "
            }
            lineId += Array.prototype.splice.call(arguments, 2).join(" ");
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.DumpRequest, level: severity.toUpperCase(), message: lineId
            }, "*")
          }, login: function(firstName, lastName, password, extension, callback) {
            if (arguments.length < 3 || arguments.length > 5)
              throw Ifm.Diagnostics.Errors.argsno("3 (+2)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.login.push(callback);
            self.agent.firstName = firstName;
            self.agent.lastName = lastName;
            self.agent.password = password;
            self.agent.extension = extension;
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.LoginRequest, firstName: firstName, lastName: lastName, password: password, extension: extension
            }, "*")
          }, loginEx: function(firstName, lastName, oldPassword, newPassword, callback) {
            if (arguments.length < 4 || arguments.length > 5)
              throw Ifm.Diagnostics.Errors.argsno("4 (+1)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.login.push(callback);
            self.agent.firstName = firstName;
            self.agent.lastName = lastName;
            self.agent.password = newPassword;
            self.agent.extension = undefined;
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.LoginExRequest, firstName: firstName, lastName: lastName, oldPassword: oldPassword, newPassword: newPassword
            }, "*")
          }, loginWithProvisioning: function(userName, token, extension, callback) {
            if (arguments.length < 1 || arguments.length > 4)
              throw Ifm.Diagnostics.Errors.argsno("1 (+4)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.login.push(callback);
            self.agent.firstName = "\t";
            self.agent.lastName = "\t";
            self.agent.password = token;
            self.agent.extension = extension;
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.ProvisioningAndLoginRequest, userName: userName, extension: extension, token: token
            }, "*")
          }, loginWithProvisioningForSite: function(userName, site, token, extension, callback) {
            if (arguments.length < 2 || arguments.length > 5)
              throw Ifm.Diagnostics.Errors.argsno("2 (+3)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.login.push(callback);
            self.agent.firstName = "\t";
            self.agent.lastName = "\t";
            self.agent.password = token;
            self.agent.extension = extension;
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.ProvisioningAndLoginRequest, userName: userName, site: site, extension: extension, token: token
            }, "*")
          }, loginWithToken: function(token, extension, userName, callback) {
            if (arguments.length < 1 || arguments.length > 4)
              throw Ifm.Diagnostics.Errors.argsno("1 (+3)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.login.push(callback);
            if (token && token.length > 0) {
              self.agent.firstName = "\t";
              self.agent.lastName = "\t";
              self.agent.password = token;
              self.agent.extension = extension;
              self.agent.userName = userName;
              window.postMessage({
                type: 'chromebarProxy', params: messageCodes.LoginWithTokenRequest, userName: userName, token: token, extension: self.agent.extension
              }, "*")
            }
            else {
              window.postMessage({
                type: 'chromebarProxy', params: messageCodes.Oauth2LoginRequest, extension: self.agent.extension, userName: userName
              }, "*")
            }
          }, logout: function(callback) {
            if (arguments.length > 1)
              throw Ifm.Diagnostics.Errors.argsno("0 (+1)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.logout.push(callback);
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.LogoutRequest
            }, "*")
          }, makeCall: function(phoneNumber, campaignName, callingNumber, callback) {
            if (arguments.length < 2 || arguments.length > 4)
              throw Ifm.Diagnostics.Errors.argsno("2 (+2)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.make.push(callback);
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.MakePhonesCallRequest, phoneNumber: phoneNumber, campaign: campaignName, callingNumber: callingNumber
            }, "*")
          }, muteRecording: function(callId, muteRxChannel, muteTxChannel, tag) {
            if (arguments.length < 3 || arguments.length > 4)
              throw Ifm.Diagnostics.Errors.argsno("3+1");
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call || call.mediatype > 5) {
              throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.MuteRecordingRequest, callId: call.callId, muteRxChannel: muteRxChannel, muteTxChannel: muteTxChannel, tag: tag
            }, "*")
          }, numberOfLines: function() {
            return numberOfLines
          }, panic: function() {
            window.postMessage({
              type: 'chromebarProxy', params: 'panicEvent'
            }, "*")
          }, pause: function(reasonId, callback) {
            if (arguments.length > 2)
              throw Ifm.Diagnostics.Errors.argsno("0 (+2)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.pause.push(callback);
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.PauseRequest, reasonId: reasonId
            }, "*")
          }, phoneBarVersion: function() {
            return phonebarVersion
          }, proxyVersion: function() {
            return Ifm.ChromeBar.Proxy.about
          }, ready: function(callId, callback) {
            if (arguments.length > 2)
              throw Ifm.Diagnostics.Errors.argsno("0 (+2)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.ready.push(callback);
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.ReadyRequest, callId: callId
            }, "*")
          }, sendInitializeRequest: function() {
            if (connectTimeoutTmr !== undefined) {
              console.log("[Proxy] Timeout waiting for RegisterClientPageReply")
            }
            console.log("[Proxy] Sending InitializeRequest");
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.InitializeRequest
            }, "*");
            connectTimeoutTmr = setTimeout(self.sendInitializeRequest, 500)
          }, setConfiguration: function(configuration, callback) {
            if (arguments.length < 1 || arguments.length > 2)
              throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.setConfiguration.push(callback);
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.SetConfigurationRequest, newConfiguration: configuration
            }, "*")
          }, showAssignedCampaignsList: function() {
            self.getAssignedCampaignList(function(e) {
              var rows = "";
              for (var i = 0; i < e.campaigns.length; i++) {
                rows += t.CampaignListRow.replace("{name}", e.campaigns[i].name).replace("{boundness}", e.campaigns[i].boundness).replace("{state}", e.campaigns[i].active ? strings[language].CampaignStateActive : strings[language].CampaignStateInactive)
              }
              var html = t.CampaignListCardEx.replace("{nameth}", strings[language].CampaignName).replace("{boundnessth}", strings[language].CampaignDirection).replace("{stateth}", strings[language].CampaignState).replace("{body}", rows);
              var update = Ifm.Dom.Cards.isShown("campaignlist-card"),
                card = Ifm.Dom.Cards.show(html, "campaignlist-card", true);
              if (!update) {
                card.timer = setInterval(self.showAssignedCampaignsList, 5000);
                card.onclick = function() {
                  card.close()
                };
                card.onclosed = function() {
                  clearInterval(card.timer)
                }
              }
            })
          }, showDialPad: function() {
            jQuery(el.PhoneDialPad + ", " + el.HideDialPadButton).enable().show();
            jQuery(el.ShowDialPadButton).disable().hide();
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.DialPadStateChangedEvent, hidden: false
            }, "*")
          }, showLoginDialog: function(useLastValidCredential, useLastValidPassword) {
            if (chromebarConfiguration && chromebarConfiguration.config.enableProvisioning) {
              var html = templ.Login3Dialog.replace("{userNameLabel}", strings[language].LoginUserName).replace("{userName}", useLastValidCredential ? chromebarState.LastValidUsername || '' : '');
              Ifm.Dom.Cards.showDialog(html, "login2-dialog", stringsPh.LoginTitle, [{
                  text: stringsPh.ButtonOK, click: function() {
                      var userName = usernametxt.value;
                      self.getSiteListFromProvisioning(usernametxt.value, undefined, function(sites) {
                        if (sites != undefined) {
                          var options = "";
                          sites.forEach(site =>  {
                              options += `<option class="combobox-entry" value="${site}">${site}</option>`
                            });
                          var html = templ.Login4Dialog.replace("{siteNameLabel}", strings[language].LoginSiteSelection).replace("{sitesList}", options);
                          Ifm.Dom.Cards.showDialog(html, "login4-dialog", stringsPh.LoginTitle, [{
                              text: stringsPh.ButtonOK, click: function() {
                                  self.loginWithProvisioningForSite(userName, sitenametxt.value, "-")
                                }
                            }, {text: stringsPh.ButtonCancel}])
                        }
                        else {
                          self.loginWithProvisioningForSite(userName, undefined, "-")
                        }
                      })
                    }
                }, {text: stringsPh.ButtonCancel}])
            }
            else if (chromebarConfiguration && chromebarConfiguration.config.oauth2.enableOAuth2) {
              self.loginWithToken('')
            }
            else {
              var html = t.LoginDialog.replace("{firstNameLabel}", stringsPh.LoginFirstName).replace("{lastNameLabel}", stringsPh.LoginLastName).replace("{passwordLabel}", stringsPh.LoginPassword).replace("{firstName}", useLastValidCredential ? chromebarState.LastValidFirstName || '' : '').replace("{lastName}", useLastValidCredential ? chromebarState.LastValidLastName || '' : '').replace("{password}", useLastValidPassword ? chromebarState.LastValidPassword || '' : '');
              Ifm.Dom.Cards.showDialog(html, "login-dialog", stringsPh.LoginTitle, [{
                  text: stringsPh.ButtonChangePassword, cssText: "margin-right:50px;", click: function() {
                      self.showLoginExDialog(useLastValidCredential)
                    }
                }, {
                  text: stringsPh.ButtonOK, click: function() {
                      self.login(firstnametxt.value, lastnametxt.value, passwordtxt.value)
                    }
                }, {text: stringsPh.ButtonCancel}])
            }
          }, showLoginExDialog: function(useLastValidCredential) {
            var html = t.Login2Dialog.replace("{firstNameLabel}", stringsPh.LoginFirstName).replace("{lastNameLabel}", stringsPh.LoginLastName).replace("{passwordLabel}", stringsPh.LoginPassword).replace("{oldPasswordLabel}", stringsPh.LoginOldPassword).replace("{newPasswordLabel}", stringsPh.LoginNewPassword).replace("{confirmPasswordLabel}", stringsPh.LoginConfirmPassword).replace("{firstName}", useLastValidCredential ? chromebarState.LastValidFirstName : '').replace("{lastName}", useLastValidCredential ? chromebarState.LastValidLastName : '').replace("{oldPassword}", '').replace("{newPassword}", '').replace("{confirmPassword}", '');
            Ifm.Dom.Cards.showDialog(html, "login2-dialog", stringsPh.LoginTitle, [{
                text: stringsPh.ButtonOK, click: function() {
                    if (newPasswordtxt.value !== confirmPasswordtxt.value) {
                      confirmPasswordtxt.focus();
                      self.showMessage(stringsPh.PasswordsDontMatch);
                      return false
                    }
                    self.loginEx(firstnametxt.value, lastnametxt.value, oldPasswordtxt.value, newPasswordtxt.value)
                  }
              }, {text: stringsPh.ButtonCancel}])
          }, showMakeCallPopup: function(phoneNumber, callingNumber) {
            if (!phoneNumber && !jQuery(el.NumberInput).val())
              return;
            self.getOutboundCampaignList(function(e) {
              e.campaigns.unshift({name: stringsPh.OutboundManualCall});
              if (e.campaigns.length > 0) {
                var choices = [];
                for (var i = 0; i < e.campaigns.length; i++) {
                  choices.push({
                    label: e.campaigns[i].serviceName || e.campaigns[i].name, value: e.campaigns[i].name
                  })
                }
                (new Ifm.Dom.Menu).choose(choices, function(campaign) {
                  if (campaign === stringsPh.OutboundManualCall) {
                    if (self.media.phone) {
                      self.media.phone.dial(jQuery(el.NumberInput).val())
                    }
                  }
                  else {
                    self.makeCall(jQuery(el.NumberInput).val(), campaign, callingNumber)
                  }
                })
              }
            })
          }, showMessage: function(content, severity, heading) {
            if (jQuery.toast) {
              jQuery.toast({
                text: content, icon: severity, heading: heading, allowToastClose: true, hideAfter: 5000, position: 'top-center', loader: false
              })
            }
            else {
              var band = Ifm.Dom.Band.show();
              var html = '<div class="phonebar-message" ' + 'style="line-height:' + band.clientHeight + 'px;"' + '>' + content + '</div>';
              band.innerHTML = html
            }
          }, showPauseMenu: function() {
            self.getPauseReasons(function(e) {
              if (e.reasons.length === 0) {
                self.pause()
              }
              else {
                e.reasons.unshift({
                  text: stringsPh.PauseGenericReason, value: 0
                });
                var choices = [];
                for (var i = 0; i < e.reasons.length; i++) {
                  choices.push({
                    label: e.reasons[i].text, value: e.reasons[i].id
                  })
                }
                (new Ifm.Dom.Menu).choose(choices, function(id) {
                  self.pause(id)
                })
              }
            })
          }, showQueueInfo: function(campaignName) {
            self.getQueueInfo(campaignName, function(e) {
              var html = t.QueueInfoCard.replace("{number}", e.calls).replace("{queuedNumberText}", stringsPh.queuedNumberText).replace("{maxTime}", e.maxTime || "--").replace("{queuedMaxTimeText}", stringsPh.queuedMaxTimeText).replace("{avgTime}", e.avgTime || "--").replace("{queuedAvgTimeText}", stringsPh.queuedAvgTimeText);
              var update = Ifm.Dom.Cards.isShown("queueinfo-card"),
                card = Ifm.Dom.Cards.show(html, "queueinfo-card", true);
              if (!update) {
                card.className += " phonebar-queueinfo-card";
                card.timer = setInterval(self.showQueueInfo, 5000);
                card.onclick = function() {
                  card.close()
                };
                card.onclosed = function() {
                  clearInterval(card.timer)
                }
              }
            })
          }, showTransferForm: function(callId) {
            var html = t.TransferCallCard.replace("{mandatoryLabel}", stringsPh.TransferMandatory);
            var card = Ifm.Dom.Cards.showDialog(html, "transfercall-card", stringsPh.TransferTitle, [{
                  text: stringsPh.ButtonRefresh, click: function() {
                      var campaignList = jQuery(el.TransferCampaignList)[0];
                      if (campaignList && campaignList.selectedIndex >= 0) {
                        var campaignName = campaignList[campaignList.selectedIndex].getAttribute("campaignName");
                        self.getTransferAgentList(campaignName, function(e) {
                          var opts = t.TransferCallAgentListItem.format(stringsPh.TransferAnybody);
                          for (var i = 0, a; i < e.agents.length, a = e.agents[i]; i++) {
                            opts += t.TransferCallAgentListItem.format(a.firstName, a.lastName, a.state !== 2 ? "(" + stringsPh.GenericBusyState + ")" : "")
                          }
                          jQuery(el.TransferAgentList).html(opts)
                        })
                      }
                      return false
                    }
                }, {
                  text: stringsPh.ButtonTransfer, click: function() {
                      var campaignList = jQuery(el.TransferCampaignList)[0];
                      var campaignName = "";
                      if (campaignList && campaignList.selectedIndex >= 0) {
                        campaignName = campaignList[campaignList.selectedIndex].getAttribute("campaignName")
                      }
                      var agentList = jQuery(el.TransferAgentList)[0];
                      var firstName = "",
                        lastName = "",
                        mandatory = false;
                      if (agentList && agentList.selectedIndex > 0) {
                        firstName = agentList[agentList.selectedIndex].getAttribute("firstName");
                        lastName = agentList[agentList.selectedIndex].getAttribute("lastName");
                        mandatory = jQuery(el.TransferMandatoryCheck).prop("checked")
                      }
                      self.transferCall(callId, campaignName, firstName, lastName, mandatory, 1, function(e) {
                        if (e.accepted)
                          Ifm.Dom.Cards.close("transfercall-card")
                      });
                      return false
                    }
                }, {text: stringsPh.ButtonCancel}]);
            jQuery(".phonebar-transfercall-card-content").find(".phonebar-transfer-campaign-list").on("input", function(e) {
              var campaignList = jQuery(el.TransferCampaignList)[0];
              if (campaignList && campaignList.selectedIndex >= 0) {
                var campaignName = campaignList[campaignList.selectedIndex].getAttribute("campaignName");
                self.getTransferAgentList(campaignName, function(e) {
                  var opts = t.TransferCallAgentListItem.format(stringsPh.TransferAnybody);
                  for (var i = 0, a; i < e.agents.length, a = e.agents[i]; i++) {
                    opts += t.TransferCallAgentListItem.format(a.firstName, a.lastName, a.state !== 2 ? "(" + stringsPh.GenericBusyState + ")" : "")
                  }
                  jQuery(el.TransferAgentList).html(opts)
                })
              }
            });
            var call = callId ? self.calls(callId) : self.getAudioCall();
            var campaignName = "";
            if (call) {
              campaignName = call.campaignName;
              callId = call.callId
            }
            else {
              callId = 0
            }
            self.getTransferCampaignList(callId, function(e) {
              var lastValue = jQuery(el.TransferCampaignList).val();
              var opts1 = "",
                opts2 = "",
                servs = [];
              for (var i = 0, c = null; i < e.campaigns.length, c = e.campaigns[i]; i++) {
                if (campaignName.startsWith(c.serviceName + '/')) {
                  opts1 += t.TransferCallCampaignListItem.format(c.name, c.campaignName)
                }
                else {
                  if (!servs[c.serviceName]) {
                    opts2 += t.TransferCallCampaignListItem.format(c.name, c.serviceName);
                    servs[c.serviceName] = true
                  }
                }
              }
              if (opts1)
                opts1 = '<optgroup label="' + stringsPh.TransferCampaign + '">' + opts1 + '</optgroup>';
              if (opts2)
                opts2 = '<optgroup label="' + stringsPh.TransferService + '">' + opts2 + '</optgroup>';
              jQuery(el.TransferCampaignList).html(opts1 + opts2);
              if (lastValue)
                jQuery(el.TransferCampaignList).val(lastValue);
              self.getTransferAgentList(campaignName, function(e) {
                var opts = t.TransferCallAgentListItem.format(stringsPh.TransferAnybody);
                for (var i = 0, a; i < e.agents.length, a = e.agents[i]; i++) {
                  opts += t.TransferCallAgentListItem.format(a.firstName, a.lastName, a.state !== 2 ? "(" + stringsPh.GenericBusyState + ")" : "")
                }
                jQuery(el.TransferAgentList).html(opts)
              })
            })
          }, startDTMFMasking: function(callId, numberOfDigits, terminationDigit) {
            if (arguments.length !== 3)
              throw Ifm.Diagnostics.Errors.argsno("3");
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call || call.mediatype > 5) {
              throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support DTMFMasking");
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.StartDTMFMaskingRequest, callId: call.callId, numberOfDigits: numberOfDigits, terminationDigit: terminationDigit
            }, "*")
          }, startRecording: function(callId, fileName, settings) {
            if (arguments.length > 3)
              throw Ifm.Diagnostics.Errors.argsno("0+3");
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call || call.mediatype > 5) {
              throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.StartRecordingRequest, callId: call.callId, fileName: fileName, settings: settings
            }, "*")
          }, stopDTMFMasking: function(callId) {
            if (arguments.length !== 1)
              throw Ifm.Diagnostics.Errors.argsno("1");
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call || call.mediatype > 5) {
              throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support DTMFMasking");
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.StopDTMFMaskingRequest, callId: call.callId
            }, "*")
          }, stopRecording: function(callId) {
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call || call.mediatype > 5) {
              throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.StopRecordingRequest, callId: call.callId
            }, "*")
          }, supportsAbortCall: function() {
            return chromebarConfiguration.options.enableAbortCall
          }, supportsConference: function() {
            return supportsConference
          }, tagRecording: function(callId, tag) {
            if (arguments.length !== 2)
              throw Ifm.Diagnostics.Errors.argsno("2");
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call || call.mediatype > 5) {
              throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.TagRecordingRequest, callId: call.callId, tag: tag
            }, "*")
          }, transferCall: function(callId, campaignName, agentFirstName, agentLastName, mandatory, mode, callback) {
            if (arguments.length < 2 || arguments.length > 7)
              throw Ifm.Diagnostics.Errors.argsno("2 (+5)");
            if (callback && !Ifm.Type.isFunction(callback))
              throw Ifm.Diagnostics.Errors.func("callback");
            callback && callbacks.transfer.push(callback);
            var call = callId ? self.calls(callId) : self.getAudioCall();
            if (!call) {
              return
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.TransferCallRequest, callId: call.callId, campaignName: campaignName, agentFirstName: agentFirstName, agentLastName: agentLastName, mandatory: mandatory, mode: mode
            }, "*")
          }, updateToken: function(token, userName) {
            if (arguments.length < 1 || arguments.length > 2)
              throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
            self.agent.password = token;
            if (userName) {
              self.agent.userName = userName
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.RefreshTokenRequest, token: self.agent.password, username: userName
            }, "*")
          }, media: {}, abortcall: function() {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.AbortCallRequest
            }, "*")
          }, acceptrejectassignment: function(accepted) {
            console.log("WARNING - ChromeBar.Proxy: function 'acceptrejectassignment' not implemented in current version.")
          }, addcalldata: function(name, value, callid) {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.AddCallDataRequest, name: name, value: value, callid: callid
            }, "*")
          }, addcampaignlessconnection: function() {
            self.isSCPRegisteredForCLEvents = true;
            self.isPBPRegisteredForCLEvents = true
          }, addconnection: function(campaignName) {
            if (self.registeredCampaignList.indexOf(campaignName) < 0) {
              self.registeredCampaignList.push(campaignName)
            }
          }, appendcuesheet: function(tag) {
            if (arguments.length !== 1)
              throw Ifm.Diagnostics.Errors.argsno("1");
            self.tagRecording(undefined, tag)
          }, conferencecall: function(enabled) {
            if (arguments.length !== 1)
              throw Ifm.Diagnostics.Errors.argsno("1");
            if (self.media.phone) {
              if (enabled === 1) {
                self.media.phone.enterConference()
              }
              else if (enabled === 0) {
                self.media.phone.leaveConference()
              }
            }
          }, connect: function() {
            self = this;
            self.initialize = function(){};
            self.connect = function(){};
            console.log("ChromeBarProxy - Connecting");
            self.scriptControlMode = true;
            self.events = Ifm.ChromeBar.Proxy.events;
            states = Ifm.ChromeBar.Proxy.States;
            self.registeredCampaignList = [];
            jQuery('[class^="phonebar-phone"]').hide();
            jQuery(el.NumberInput).attr("maxlength", 255);
            jQuery(el.PhoneDialPad).hide();
            resetSessionData();
            if (hasAlreaySetTheListener === false) {
              hasAlreaySetTheListener = true;
              window.addEventListener("message", function(e) {
                if (!e.isTrusted || e.source !== window) {
                  console.log("[ContentScript] [WARN] Invalid Message Received", e);
                  return
                }
                if (e.data.type === "chromebarContentScript") {
                  decodeMessage(e)
                }
              })
            }
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.InitializeRequest
            }, "*")
          }, filternonphonecallevents: function(disable) {
            self.filterNonPhoneCallEvents = disable
          }, disconnect: function() {
            self.scriptControlMode = false;
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.DeregisterRequest
            }, "*");
            self.events.ondisconnected.raise()
          }, dump: function(message){}, getagentslist: function(mask, campaign) {
            if (arguments.length < 1 || arguments.length > 2)
              throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
            self.getAgentList(campaign, mask, function(e) {
              if (self.scriptControlMode) {
                if (notifyEventScriptControlMode(true, true, "*")) {
                  var agents = [];
                  for (var i = 0, a = null; i < e.agents.length, a = e.agents[i]; i++) {
                    agents.push({
                      firstname: e.agents[i].firstName, lastname: e.agents[i].lastName, state: e.agents[i].state, time: e.agents[i].time, campaign: e.agents[i].campaignName
                    })
                  }
                  self.events.onagentslistreply.raise({
                    agentsnum: agents.length, agentslist: agents
                  })
                }
              }
            })
          }, getcampaignslist: function(mask, callid, mediatype) {
            if (arguments.length < 1 || arguments.length > 3)
              throw Ifm.Diagnostics.Errors.argsno("1 (+2)");
            self.getCampaignList(callid, mediatype, mask, function(e) {
              if (self.scriptControlMode) {
                if (notifyEventScriptControlMode(true, true, "*")) {
                  var campaigns = [];
                  for (var i = 0, c = null; i < e.campaigns.length, c = e.campaigns[i]; i++) {
                    campaigns.push({
                      name: e.campaigns[i].name, state: e.campaigns[i].status, boundness: e.campaigns[i].boundness, assigned: e.campaigns[i].assigned, transfernotallowed: e.campaigns[i].transfer, flags: e.campaigns[i].flags
                    })
                  }
                  self.events.oncampaignslistreply.raise({
                    campaignsnum: campaigns.length, campaignslist: campaigns
                  })
                }
              }
            })
          }, getcurrentagentdetails: function() {
            if (self.agent) {
              if (self.scriptControlMode) {
                if (notifyEventScriptControlMode(true, true, "*")) {
                  self.events.onagentdetailsreply.raise({
                    firstname: self.agent.firstName, lastname: self.agent.lastName, extension: self.agent.extension, id: self.agent.id, state: currentState
                  })
                }
              }
            }
          }, getpausereasonslist: function() {
            self.getPauseReasons(function(e) {
              if (self.scriptControlMode) {
                if (notifyEventScriptControlMode(true, true, "*")) {
                  var choices = [];
                  for (var i = 0; i < e.reasons.length; i++) {
                    choices.push({
                      description: e.reasons[i].text, code: e.reasons[i].id
                    })
                  }
                  self.events.onpausereasonslistreply.raise({
                    pausereasonsnum: e.reasons.length, pausereasonslist: choices
                  })
                }
              }
            })
          }, getqueueinfo: function(campaign) {
            self.getQueueInfo(campaign, function(e) {
              if (self.scriptControlMode) {
                if (notifyEventScriptControlMode(true, true, "*")) {
                  self.events.onqueueinforeply.raise({
                    campaign: e.campaignName, callsnum: e.calls, maxtime: e.maxTime, avgtime: e.avgTime
                  })
                }
              }
            })
          }, makecall: function(number, campaign, callingnumber, scripttype) {
            if (arguments.length < 2 || arguments.length > 4)
              throw Ifm.Diagnostics.Errors.argsno("2 (+2)");
            self.makeCall(number, campaign, callingnumber)
          }, makedialercall: function(campaign, hint) {
            console.log("WARNING - ChromeBar.Proxy: function 'makedialercall' not implemented in current version.")
          }, makemanualcall: function(lineId, number, video) {
            if (arguments.length < 2 || arguments.length > 3)
              throw Ifm.Diagnostics.Errors.argsno("2 (+1)");
            if (self.media.phone) {
              self.media.phone.selectLine(lineId - 1);
              self.media.phone.dial(number)
            }
          }, muteaudiorecording: function(mutetx, muterx, appendcuesheet, cuesheet) {
            if (arguments.length < 2 || arguments.length > 4)
              throw Ifm.Diagnostics.Errors.argsno("2 (+2)");
            self.muteRecording(undefined, muterx, mutetx, appendcuesheet ? cuesheet : undefined)
          }, playlocalfile: function(filefullpath) {
            console.log("WARNING - ChromeBar.Proxy: function 'playlocalfile' not implemented in current version.")
          }, removecampaignlessconnection: function() {
            self.isSCPRegisteredForCLEvents = false;
            self.isPBPRegisteredForCLEvents = false
          }, removeconnection: function(campaignName) {
            if (self.registeredCampaignList.indexOf(campaignName) > -1) {
              self.registeredCampaignList.splice(self.registeredCampaignList.indexOf(campaignName), 1)
            }
          }, retrievecall: function() {
            console.log("WARNING - ChromeBar.Proxy: function 'retrievecall' not implemented in current version.")
          }, savecalldata: function(calldata, callid) {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.SaveCallDataRequest, calldatastr: calldata, callid: callid
            }, "*")
          }, sethookstate: function(hookstate) {
            if (hookstate !== 0) {
              if (self.media.phone) {
                self.media.phone.drop()
              }
            }
            else if (hookstate !== 1) {
              if (self.media.phone) {
                self.media.phone.answer()
              }
            }
            else {
              throw Ifm.Diagnostics.Errors.func("hookstate");
            }
          }, setmutestate: function(muted) {
            if (muted === 1 || muted === true) {
              window.postMessage({
                type: 'chromebarProxy', params: messageCodes.MicrophoneOffRequest
              }, "*")
            }
            else {
              window.postMessage({
                type: 'chromebarProxy', params: messageCodes.MicrophoneOnRequest
              }, "*")
            }
          }, setphonebarbuttonenabled: function(buttonindex, enabled) {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.EnableChromeBarButtonRequest, buttonIdx: buttonindex, enabled: enabled
            }, "*")
          }, showcalltransferform: function(callId) {
            self.showTransferForm(callId)
          }, showinformationpopup: function(messagetext, timespan) {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.ShowNotificationRequest, title: "", message: messagetext, timeout: timespan
            }, "*")
          }, startaudiorecording: function(filename, settings) {
            if (arguments.length < 1 || arguments.length > 2)
              throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
            self.startRecording(undefined, filename, settings)
          }, stopaudiorecording: function() {
            self.stopRecording()
          }, stopplaylocalfile: function() {
            console.log("WARNING - ChromeBar.Proxy: function 'stopplaylocalfile' not implemented in current version.")
          }, swapcall: function() {
            var call = self.getAudioCall();
            if (call) {
              window.postMessage({
                type: 'chromebarProxy', params: messageCodes.SwapCallRequest, callid: call.callId
              }, "*")
            }
            else {
              self.events.oncommandexecutedevent.raise({
                commandcode: messageCodes.SwapCallRequest, result: 0
              })
            }
          }, switchactiveline: function() {
            window.postMessage({
              type: 'chromebarProxy', params: messageCodes.SwitchLineRequest
            }, "*")
          }, transfercall: function(campaign, firstname, lastname, mandatory, mode) {
            if (arguments.length < 1 || arguments.length > 5)
              throw Ifm.Diagnostics.Errors.argsno("1 (+4)");
            self.transferCall(undefined, campaign, firstname, lastname, mandatory, mode)
          }
      };
      return instance
    })()
};
(function() {
  var ns = namespace("Ifm.ChromeBar.Proxy.Media");
  function Phone(phonebar) {
    if (!(this instanceof Phone))
      throw Ifm.Diagnostics.Errors.ctor();
    this.phonebar = phonebar;
    this._isConnected = false;
    this._isRegistered = false;
    this._lineStates = [];
    for (var i = 0; i < this.numberOfLines; i++) {
      this._lineStates.push(Phone.States.Idle)
    }
    this._selectedLineId = 0;
    this._isInConference = false
  }
  Phone.events = defineEvents("initialized", "connected", "disconnected", "registeredstatechanged", "linestatechanged", "conferencestatechanged", "lineselected", "calling", "callconnected", "calldisconnected", "displayname", "incomingcall", "ringing", "mutechanged", "vumeter");
  Phone.States = {
    Idle: '[Idle]', Incoming: '[Incoming]', Calling: '[Calling]', Talking: '[Talking]'
  };
  Phone.prototype.numberOfLines = 1;
  Phone.prototype.supportsConference = false;
  Object.defineProperties(Phone.prototype, {
    isConnected: {get: function() {
        return this._isConnected
      }}, isInConference: {get: function() {
          return this._isInConference
        }}, isRegistered: {get: function() {
          return this._isRegistered
        }}, selectedLineId: {get: function() {
          return this._selectedLineId
        }}, state: {get: function() {
          return this._lineStates[this._selectedLineId]
        }}
  });
  Phone.prototype.initialize = function(config){};
  Phone.prototype.connect = function(){};
  Phone.prototype.disconnect = function(){};
  Phone.prototype.answer = function() {
    this.phonebar.log(THIS, DEBUG, "Answering");
    this._answer()
  };
  Phone.prototype.canConference = function() {
    if (!this.supportsConference) {
      return false
    }
    for (var i = 0, count = 0; i < this.numberOfLines; i++) {
      if (this._lineStates[i] === Phone.States.Talking)
        count++
    }
    return count > 1
  };
  Phone.prototype.dial = function(number) {
    if (!number && number !== 0) {
      this.phonebar.log(THIS, WARN, "No number to dial");
      return
    }
    if (this.state === Phone.States.Ringing) {
      this.phonebar.log(THIS, WARN, "Can't dial in current state");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Dialing number", number);
    if (this.state === Phone.States.Idle) {
      this._dial(number)
    }
    else {
      this._dtmf(number)
    }
  };
  Phone.prototype.dtmf = function(tones) {
    if (!tones && tones !== 0) {
      this.phonebar.log(THIS, WARN, "No dtmf to dial");
      return
    }
    if (this.state === Phone.States.Idle || this.state === Phone.States.Ringing) {
      this.phonebar.log(THIS, WARN, "Can't dial in current state");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Dialing tones", tones);
    this._dtmf(tones)
  };
  Phone.prototype.drop = function() {
    this.phonebar.log(THIS, DEBUG, "Dropping");
    this._drop()
  };
  Phone.prototype.enterConference = function() {
    if (!this.supportsConference) {
      this.phonebar.log(THIS, WARN, "Device doesn't support conference");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Entering conference");
    this._enterConference()
  };
  Phone.prototype.getLineState = function(lineId) {
    if (!(lineId >= 0 && lineId < this.numberOfLines)) {
      this.phonebar.log(THIS, WARN, "Invalid lineId specified:", lineId);
      return
    }
    return this._lineStates[lineId]
  };
  Phone.prototype.leaveConference = function() {
    if (!this.supportsConference) {
      this.phonebar.log(THIS, WARN, "Device doesn't support conference");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Leaving conference");
    this._leaveConference()
  };
  Phone.prototype.mute = function() {
    this.phonebar.log(THIS, DEBUG, "Muting microphone");
    this._mute()
  };
  Phone.prototype.register = function() {
    var domain = this.domain,
      extension = this.phonebar.agent.extension;
    if (!domain || !extension) {
      this.phonebar.log(THIS, WARN, "Can't register without domain or extension")
    }
    this.phonebar.log(THIS, DEBUG, "Registering device to", domain, extension);
    this._register(domain, extension)
  };
  Phone.prototype.selectLine = function(lineId) {
    if (this.numberOfLines < 2) {
      this.phonebar.log(THIS, WARN, "Device doesn't support multiple lines");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Selecting line", lineId);
    this._selectLine(lineId)
  };
  Phone.prototype.unmute = function() {
    this.phonebar.log(THIS, DEBUG, "Unmuting microphone");
    this._unmute()
  };
  Phone.prototype.unregister = function() {
    this.phonebar.log(THIS, DEBUG, "Unregistering device");
    this._unregister()
  };
  Phone.prototype._answer = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.PickupRequest
    }, "*")
  };
  Phone.prototype._dial = function(number) {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.DialNumberRequest, number: number
    }, "*")
  };
  Phone.prototype._dtmf = function(tones) {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.SendDtmfRequest, dtmf: tones
    }, "*")
  };
  Phone.prototype._drop = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.HangupRequest
    }, "*")
  };
  Phone.prototype._enterConference = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.EnterConferenceRequest
    }, "*")
  };
  Phone.prototype._leaveConference = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.LeaveConferenceRequest
    }, "*")
  };
  Phone.prototype._mute = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.MicrophoneOffRequest
    }, "*")
  };
  Phone.prototype._register = function(domain, extension) {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.RegisterRequest, domain: domain, extension: extension
    }, "*")
  };
  Phone.prototype._selectLine = function(lineId) {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.SelectLineRequest, lineId: lineId
    }, "*")
  };
  Phone.prototype._unmute = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.MicrophoneOnRequest
    }, "*")
  };
  Phone.prototype._unregister = function() {
    window.postMessage({
      type: 'chromebarProxy', params: messageCodes.UnregisterRequest
    }, "*")
  };
  Phone.prototype._onInitialized = function() {
    this.phonebar.log(THIS, DEBUG, "Initialized");
    Phone.events.initialized.raise(this, {})
  };
  Phone.prototype._onConnected = function() {
    this.phonebar.log(THIS, DEBUG, "Connected");
    this._isConnected = true;
    Phone.events.connected.raise(this, {})
  };
  Phone.prototype._onDisconnected = function(clean) {
    this.phonebar.log(THIS, DEBUG, "Disconnected");
    this._isConnected = false;
    Phone.events.disconnected.raise(this, {clean: clean})
  };
  Phone.prototype._onRegisteredStateChanged = function(isRegistered) {
    this.phonebar.log(THIS, INFO, "Device is", isRegistered ? "" : "not", "registered");
    this._isRegistered = isRegistered;
    Phone.events.registeredstatechanged.raise(this, {isRegistered: isRegistered})
  };
  Phone.prototype._onLineStateChanged = function(lineId, state) {
    this.phonebar.log(THIS, INFO, "Line", lineId + 1, "in state", state);
    this._lineStates[lineId] = state;
    Phone.events.linestatechanged.raise(this, {
      lineId: lineId, state: state
    })
  };
  Phone.prototype._onConferenceStateChanged = function(inConference) {
    this.phonebar.log(THIS, DEBUG, "Lines are", inConference ? "" : "not", "in conference");
    this._isInConference = inConference;
    Phone.events.conferencestatechanged.raise(this, {inConference: inConference})
  };
  Phone.prototype._onLineSelected = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Line", lineId + 1, "selected");
    this._selectedLineId = lineId;
    Phone.events.lineselected.raise(this, {lineId: lineId})
  };
  Phone.prototype._onCalling = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Calling on line", lineId + 1);
    Phone.events.calling.raise(this, {lineId: lineId})
  };
  Phone.prototype._onCallConnected = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Call connected on line", lineId + 1);
    Phone.events.callconnected.raise(this, {lineId: lineId})
  };
  Phone.prototype._onCallDisconnected = function(lineId, sipCode, sipCause) {
    this.phonebar.log(THIS, DEBUG, "Call disconnected on line", lineId + 1, "; sip code:", sipCode, "sip cause:", sipCause);
    Phone.events.calldisconnected.raise(this, {
      lineId: lineId, sipCode: sipCode, sipCause: sipCause
    })
  };
  Phone.prototype._onDisplayName = function(lineId, displayName) {
    this.phonebar.log(THIS, DEBUG, "Got display name", displayName, "for incoming call on line", lineId + 1);
    Phone.events.displayname.raise(this, {
      lineId: lineId, displayName: displayName
    })
  };
  Phone.prototype._onIncomingCall = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Incoming call on line", lineId + 1);
    Phone.events.incomingcall.raise(this, {lineId: lineId})
  };
  Phone.prototype._onRinging = function(lineId, rings) {
    this.phonebar.log(THIS, DEBUG, "Line", lineId + 1, "is ringing;", rings, "ring(s)");
    Phone.events.ringing.raise(this, {
      lineId: lineId, rings: rings
    })
  };
  Phone.prototype._onMuteChanged = function(isMuted) {
    this.phonebar.log(THIS, DEBUG, "Microphone is", isMuted ? "" : "not", "muted");
    Phone.events.mutechanged.raise(this, {isMuted: isMuted})
  };
  Phone.prototype._onVUMeter = function(microphone, speakers) {
    Phone.events.vumeter.raise(this, {
      microphone: microphone, speakers: speakers
    })
  };
  var THIS = "ChromeBar.Media.Phone",
    DEBUG = 'Debug',
    INFO = 'Info',
    WARN = 'Warn';
  var messageCodes = Ifm.ChromeBar.Constants['MessageCodes'];
  ns.Phone = Phone
})();
;
namespace("Ifm.ChromeBar.PhoneBar").Proxy = {
  events: defineEvents("initialized", "disconnected", "connected", "connectionFailure", "saveConfigReply", "configChangedEvent", "buttonStateChangedEvent", "booked", "assignment", "alerting", "answered", "callfailure", "othercall", "pausebooked", "pause", "ready", "readyfordetach", "readyfortransfer", "terminated", "recordingstarted", "recordingmutechanged", "recordingstopped", "maskeddigitreceived", "maskedpayloadreceived", "statechanged", "statetimechanged", "supervisormessage"), canRun: function() {
      return Ifm.ChromeBar.Proxy.canRun()
    }, run: function(config, options) {
      this.run = function() {
        self.log("PhoneBar", "Debug", "Already running")
      };
      this.instance.initialize()
    }, instance: (function() {
      var instance = {};
      var proxy = Ifm.ChromeBar.Proxy.instance;
      var self;
      Ifm.ChromeBar.Proxy.events.initialized = function(pb, params) {
        if (self) {
          self.events.initialized.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.disconnected = function(pb, params) {
        if (self) {
          self.events.disconnected.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.connected = function(pb, params) {
        if (self) {
          self.events.connected.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.connectionFailure = function(pb, params) {
        if (self) {
          self.events.connectionFailure.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.saveConfigReply = function(pb, params) {
        if (self) {
          self.events.saveConfigReply.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.configChangedEvent = function(pb, params) {
        if (self) {
          self.events.configChangedEvent.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.buttonStateChangedEvent = function(pb, params) {
        if (self) {
          self.events.buttonStateChangedEvent.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.booked = function(pb, params) {
        if (self) {
          self.events.booked.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.assignment = function(pb, params) {
        if (self) {
          self.events.assignment.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.alerting = function(pb, params) {
        if (self) {
          self.events.alerting.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.answered = function(pb, params) {
        if (self) {
          self.events.answered.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.callfailure = function(pb, params) {
        if (self) {
          self.events.callfailure.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.othercall = function(pb, params) {
        if (self) {
          self.events.othercall.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.pausebooked = function(pb, params) {
        if (self) {
          self.events.pausebooked.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.pause = function(pb, params) {
        if (self) {
          self.events.pause.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.ready = function(pb, params) {
        if (self) {
          self.events.ready.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.readyfordetach = function(pb, params) {
        if (self) {
          self.events.readyfordetach.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.readyfortransfer = function(pb, params) {
        if (self) {
          self.events.readyfortransfer.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.terminated = function(pb, params) {
        if (self) {
          self.events.terminated.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.recordingstarted = function(pb, params) {
        if (self) {
          self.events.recordingstarted.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.recordingmutechanged = function(pb, params) {
        if (self) {
          self.events.recordingmutechanged.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.recordingstopped = function(pb, params) {
        if (self) {
          self.events.recordingstopped.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.maskeddigitreceived = function(pb, params) {
        if (self) {
          self.events.maskeddigitreceived.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.maskedpayloadreceived = function(pb, params) {
        if (self) {
          self.events.maskedpayloadreceived.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.statechanged = function(pb, params) {
        if (self) {
          self.events.statechanged.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.statetimechanged = function(pb, params) {
        if (self) {
          self.events.statetimechanged.raise(self, params)
        }
      };
      Ifm.ChromeBar.Proxy.events.supervisormessage = function(pb, params) {
        if (self) {
          self.events.supervisormessage.raise(self, params)
        }
      };
      instance = {
        agent: proxy.agent, media: proxy.media, options: proxy.options, addCampaignLessConnection: function() {
            return proxy.addcampaignlessconnection()
          }, addConnection: function(campaignName) {
            return proxy.addconnection(campaignName)
          }, removeCampaignLessConnection: function() {
            return proxy.removecampaignlessconnection()
          }, removeConnection: function(campaignName) {
            return proxy.removeconnection(campaignName)
          }, abortCall: function() {
            return proxy.abortCall()
          }, calls: function(filter) {
            if (arguments.length === 0) {
              return proxy.calls()
            }
            return proxy.calls(filter)
          }, chromeBarVersion: function() {
            return proxy.chromeBarVersion()
          }, clearCallHistoryLog: function(callId) {
            return proxy.clearCallHistoryLog(callId)
          }, currentState: function() {
            return proxy.currentState()
          }, currentStateReason: function() {
            return proxy.currentStateReason()
          }, currentStateTime: function() {
            return proxy.currentStateTime()
          }, getAgentList: function(campaignName, mask, callback) {
            return proxy.getAgentList(campaignName, mask, callback)
          }, getAssignedCampaignList: function(callback) {
            return proxy.getAssignedCampaignList(callback)
          }, getAudioCall: function() {
            return proxy.getAudioCall()
          }, getAuthorityInfo: function(userName, callback) {
            return proxy.getAuthorityInfo(userName, callback)
          }, getCallHistoryLog: function(callback) {
            return proxy.getCallHistoryLog(callback)
          }, getCampaignList: function(callId, mediatype, mask, callback) {
            return proxy.getCampaignList(callId, mediatype, mask, callback)
          }, getConfiguration: function() {
            return proxy.getConfiguration()
          }, getOutboundCampaignList: function(callback) {
            return proxy.getOutboundCampaignList(callback)
          }, getPauseReasons: function(callback) {
            return proxy.getPauseReasons(callback)
          }, getQueueInfo: function(campaignName, callback) {
            return proxy.getQueueInfo(campaignName, callback)
          }, getSiteListFromProvisioning: function(userName, token, callback) {
            return proxy.getSiteListFromProvisioning(userName, token, callback)
          }, getModuleConfiguration: function(moduleName, callback) {
            return proxy.getModuleConfiguration(moduleName, callback)
          }, getTransferAgentList: function(campaignName, callback) {
            return proxy.getTransferAgentList(campaignName, callback)
          }, getTransferCampaignList: function(callId, callback) {
            return proxy.getTransferCampaignList(callId, callback)
          }, hideDialPad: function() {
            return proxy.hideDialPad()
          }, initialize: function() {
            self = this;
            self.events = Ifm.ChromeBar.PhoneBar.Proxy.events;
            return proxy.initialize()
          }, initializeXmpp: function(xmppConfig) {
            return proxy.initializeXmpp(xmppConfig)
          }, isLoggedIn: function() {
            return proxy.isLoggedIn()
          }, language: function(lang) {
            return proxy.language(lang)
          }, log: function(context, severity, message) {
            return proxy.log(context, severity, message)
          }, login: function(firstName, lastName, password, extension, callback) {
            return proxy.login(firstName, lastName, password, extension, callback)
          }, loginEx: function(firstName, lastName, oldPassword, newPassword, callback) {
            return proxy.loginEx(firstName, lastName, oldPassword, newPassword, callback)
          }, loginWithToken: function(token, extension, userName, callback) {
            return proxy.loginWithToken(token, extension, userName, callback)
          }, updateToken: function(token, userName) {
            return proxy.updateToken(token, userName)
          }, logout: function(callback) {
            return proxy.logout(callback)
          }, makeCall: function(phoneNumber, campaignName, callingNumber, callback) {
            return proxy.makeCall(phoneNumber, campaignName, callingNumber, callback)
          }, muteRecording: function(callId, muteRxChannel, muteTxChannel, tag) {
            return proxy.muteRecording(callId, muteRxChannel, muteTxChannel, tag)
          }, numberOfLines: function() {
            return proxy.numberOfLines()
          }, panic: function() {
            return proxy.panic()
          }, pause: function(reasonId, callback) {
            return proxy.pause(reasonId, callback)
          }, phoneBarVersion: function() {
            return proxy.phoneBarVersion()
          }, loginWithProvisioning: function(userName, token, callback) {
            return proxy.loginWithProvisioning(userName, token, undefined, callback)
          }, loginWithProvisioningEx: function(userName, token, extension, callback) {
            return proxy.loginWithProvisioning(userName, token, extension, callback)
          }, loginWithProvisioningForSite: function(userName, site, token, callback) {
            return proxy.loginWithProvisioningForSite(userName, site, token, undefined, callback)
          }, loginWithProvisioningForSiteEx: function(userName, site, token, extension, callback) {
            return proxy.loginWithProvisioningForSite(userName, site, token, extension, callback)
          }, proxyVersion: function() {
            return proxy.proxyVersion()
          }, ready: function(callId, callback) {
            return proxy.ready(callId, callback)
          }, setConfiguration: function(configuration) {
            return proxy.setConfiguration(configuration)
          }, showAssignedCampaignsList: function() {
            return proxy.showAssignedCampaignsList()
          }, showDialPad: function() {
            return proxy.showDialPad()
          }, showLoginDialog: function(useLastValidCredential, useLastValidPassword) {
            return proxy.showLoginDialog(useLastValidCredential, useLastValidPassword)
          }, showLoginExDialog: function(useLastValidCredential) {
            return proxy.showLoginExDialog(useLastValidCredential)
          }, showMakeCallPopup: function(phoneNumber, callingNumber) {
            return proxy.showMakeCallPopup(phoneNumber, callingNumber)
          }, showMessage: function(content, severity, heading) {
            return proxy.showMessage(content, severity, heading)
          }, showPauseMenu: function() {
            return proxy.showPauseMenu()
          }, showQueueInfo: function(campaignName) {
            return proxy.showQueueInfo(campaignName)
          }, showTransferForm: function(callId) {
            return proxy.showTransferForm(callId)
          }, startDTMFMasking: function(callId, numberOfDigits, terminationDigit) {
            return proxy.startDTMFMasking(callId, numberOfDigits, terminationDigit)
          }, stopDTMFMasking: function(callId) {
            return proxy.stopDTMFMasking(callId)
          }, startRecording: function(callId, fileName, settings) {
            return proxy.startRecording(callId, fileName, settings)
          }, stopRecording: function(callId) {
            return proxy.stopRecording(callId)
          }, supportsAbortCall: function() {
            return proxy.supportsAbortCall()
          }, supportsConference: function() {
            return proxy.supportsConference()
          }, tagRecording: function(callId, tag) {
            return proxy.tagRecording(callId, tag)
          }, transferCall: function(callId, campaignName, agentFirstName, agentLastName, mandatory, mode, callback) {
            return proxy.transferCall(callId, campaignName, agentFirstName, agentLastName, mandatory, mode, callback)
          }, setChromeBarButtonEnabled: function(buttonindex, enabled) {
            return proxy.setphonebarbuttonenabled(buttonindex, enabled)
          }
      };
      return instance
    })()
};
namespace("Ifm.ChromeBar.ScriptControl").Proxy = {
  events: defineEvents("onconnected", "ondisconnected", "onabortcallreply", "onalertingevent", "onansweredevent", "onassignmentrequest", "onrecordingcompletedevent", "onrecordingmutedevent", "onrecordingstartedevent", "onbookedevent", "oncallfailureevent", "oncalltransferinitiatedevent", "onconnectionremovedevent", "ondeviceinfochangedevent", "ondisplaynamechangedevent", "onphonebarclosedevent", "onloginreply", "onlogoutreply", "onnewcallreply", "onothercallevent", "onpauseevent", "onpausereply", "onphonebarconnectionlostevent", "onpostcallworkevent", "onreadyevent", "onreadyfordetachevent", "onreadyreply", "onreadyfortransferevent", "onretrievecallreply", "onrejectableassignmentrequest", "onterminatedevent", "ontransferreply", "onsupervisormessageevent", "onmaskeddigitreceivedevent", "onmaskedpayloadreceivedevent", "onqueueinforeply", "onagentslistreply", "oncampaignslistreply", "onpausereasonslistreply", "onagentdetailsreply", "oncommandexecutedevent"), canRun: function() {
      return Ifm.ChromeBar.Proxy.canRun()
    }, run: function(config, options) {
      this.run = function() {
        self.log("PhoneBar", "Debug", "Already running")
      };
      this.instance.initialize()
    }, instance: (function() {
      var instance = {};
      var proxy = Ifm.ChromeBar.Proxy.instance;
      var self = this;
      Ifm.ChromeBar.Proxy.events.onconnected = function(e) {
        if (self) {
          self.events.onconnected.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.ondisconnected = function(e) {
        if (self) {
          self.events.ondisconnected.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onabortcallreply = function(e) {
        if (self) {
          self.events.onabortcallreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onalertingevent = function(e) {
        if (self) {
          self.events.onalertingevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onansweredevent = function(e) {
        if (self) {
          self.events.onansweredevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onassignmentrequest = function(e) {
        if (self) {
          self.events.onassignmentrequest.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onrecordingcompletedevent = function(e) {
        if (self) {
          self.events.onrecordingcompletedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onrecordingmutedevent = function(e) {
        if (self) {
          self.events.onrecordingmutedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onrecordingstartedevent = function(e) {
        if (self) {
          self.events.onrecordingstartedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onbookedevent = function(e) {
        if (self) {
          self.events.onbookedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.oncallfailureevent = function(e) {
        if (self) {
          self.events.oncallfailureevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.oncalltransferinitiatedevent = function(e) {
        if (self) {
          self.events.oncalltransferinitiatedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onconnectionremovedevent = function(e) {
        if (self) {
          self.events.onconnectionremovedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.ondeviceinfochangedevent = function(e) {
        if (self) {
          self.events.ondeviceinfochangedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.ondisplaynamechangedevent = function(e) {
        if (self) {
          self.events.ondisplaynamechangedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onphonebarclosedevent = function(e) {
        if (self) {
          self.events.onphonebarclosedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onloginreply = function(e) {
        if (self) {
          self.events.onloginreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onlogoutreply = function(e) {
        if (self) {
          self.events.onlogoutreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onnewcallreply = function(e) {
        if (self) {
          self.events.onnewcallreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onothercallevent = function(e) {
        if (self) {
          self.events.onothercallevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onpauseevent = function(e) {
        if (self) {
          self.events.onpauseevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onpausereply = function(e) {
        if (self) {
          self.events.onpausereply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onphonebarconnectionlostevent = function(e) {
        if (self) {
          self.events.onphonebarconnectionlostevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onpostcallworkevent = function(e) {
        if (self) {
          self.events.onpostcallworkevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onreadyevent = function(e) {
        if (self) {
          self.events.onreadyevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onreadyfordetachevent = function(e) {
        if (self) {
          self.events.onreadyfordetachevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onreadyreply = function(e) {
        if (self) {
          self.events.onreadyreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onreadyfortransferevent = function(e) {
        if (self) {
          self.events.onreadyfortransferevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onretrievecallreply = function(e) {
        if (self) {
          self.events.onretrievecallreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onrejectableassignmentrequest = function(e) {
        if (self) {
          self.events.onrejectableassignmentrequest.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onterminatedevent = function(e) {
        if (self) {
          self.events.onterminatedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.ontransferreply = function(e) {
        if (self) {
          self.events.ontransferreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onsupervisormessageevent = function(e) {
        if (self) {
          self.events.onsupervisormessageevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onmaskeddigitreceivedevent = function(e) {
        if (self) {
          self.events.onmaskeddigitreceivedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onmaskedpayloadreceivedevent = function(e) {
        if (self) {
          self.events.onmaskedpayloadreceivedevent.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onqueueinforeply = function(e) {
        if (self) {
          self.events.onqueueinforeply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onagentslistreply = function(e) {
        if (self) {
          self.events.onagentslistreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.oncampaignslistreply = function(e) {
        if (self) {
          self.events.oncampaignslistreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onpausereasonslistreply = function(e) {
        if (self) {
          self.events.onpausereasonslistreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.onagentdetailsreply = function(e) {
        if (self) {
          self.events.onagentdetailsreply.raise(e)
        }
      };
      Ifm.ChromeBar.Proxy.events.oncommandexecutedevent = function(e) {
        if (self) {
          self.events.oncommandexecutedevent.raise(e)
        }
      };
      instance = {
        abortcall: function() {
          return proxy.abortcall()
        }, acceptrejectassignment: function(accepted) {
            return proxy.acceptrejectassignment(accepted)
          }, addcalldata: function(name, value, callid) {
            return proxy.addcalldata(name, value, callid)
          }, addcampaignlessconnection: function() {
            return proxy.addcampaignlessconnection()
          }, addconnection: function(campaignName) {
            return proxy.addconnection(campaignName)
          }, appendcuesheet: function(tag) {
            return proxy.appendcuesheet(tag)
          }, chromebarversion: function() {
            return proxy.chromeBarVersion()
          }, clearcallhistorylog: function(callId) {
            return proxy.clearCallHistoryLog(callId)
          }, conferencecall: function(enabled) {
            return proxy.conferencecall(enabled)
          }, connect: function() {
            self = this;
            self.events = Ifm.ChromeBar.ScriptControl.Proxy.events;
            return proxy.connect()
          }, filternonphonecallevents: function(disable) {
            return proxy.filternonphonecallevents(disable)
          }, disconnect: function() {
            return proxy.disconnect()
          }, dump: function(message) {
            return proxy.dump(message)
          }, getagentslist: function(mask, campaign) {
            return proxy.getagentslist(mask, campaign)
          }, getcallhistorylog: function(callback) {
            return proxy.getCallHistoryLog(callback)
          }, getcampaignslist: function(mask, callid, mediatype) {
            return proxy.getcampaignslist(mask, callid, mediatype)
          }, getcurrentagentdetails: function() {
            return proxy.getcurrentagentdetails()
          }, getpausereasonslist: function() {
            return proxy.getpausereasonslist()
          }, getqueueinfo: function(campaign) {
            return proxy.getqueueinfo(campaign)
          }, getsitelistfromprovisioning: function(username, token, callback) {
            return proxy.getSiteListFromProvisioning(username, token, callback)
          }, isloggedin: function() {
            return proxy.isLoggedIn()
          }, language: function(lang) {
            return proxy.language(lang)
          }, login: function(firstname, lastname, password, extension) {
            return proxy.login(firstname, lastname, password, extension)
          }, loginwithtoken: function(token, extension, userName, callback) {
            return proxy.loginWithToken(token, extension, userName, callback)
          }, loginwithprovisioning: function(username, token, callback) {
            return proxy.loginWithProvisioning(username, token, callback)
          }, loginwithprovisioningforsite: function(username, site, token, callback) {
            return proxy.loginWithProvisioningForSite(username, site, token, callback)
          }, loginwithprovisioningex: function(username, token, extension, callback) {
            return proxy.loginWithProvisioning(username, token, extension, callback)
          }, loginwithprovisioningforsiteex: function(username, site, token, extension, callback) {
            return proxy.loginWithProvisioningForSite(username, site, token, extension, callback)
          }, updatetoken: function(token, username) {
            return proxy.updateToken(token, username)
          }, logout: function() {
            return proxy.logout()
          }, makecall: function(number, campaign, callingnumber, scripttype) {
            return proxy.makecall(number, campaign, callingnumber, scripttype)
          }, makedialercall: function(campaign, hint) {
            return proxy.makedialercall(campaign, hint)
          }, makemanualcall: function(lineId, number, video) {
            return proxy.makemanualcall(lineId, number, video)
          }, muteaudiorecording: function(mutetx, muterx, appendcuesheet, cuesheet) {
            return proxy.muteaudiorecording(mutetx, muterx, appendcuesheet, cuesheet)
          }, numberoflines: function() {
            return proxy.numberOfLines()
          }, pause: function(reasonId) {
            return proxy.pause(reasonId)
          }, phonebarversion: function() {
            return proxy.phoneBarVersion()
          }, playlocalfile: function(filefullpath) {
            return proxy.playlocalfile(filefullpath)
          }, proxyversion: function() {
            return proxy.proxyVersion()
          }, ready: function() {
            return proxy.ready()
          }, removecampaignlessconnection: function() {
            return proxy.removecampaignlessconnection()
          }, removeconnection: function(campaignName) {
            return proxy.removeconnection(campaignName)
          }, retrievecall: function() {
            return proxy.retrievecall()
          }, savecalldata: function(calldata, callid) {
            return proxy.savecalldata(calldata, callid)
          }, sethookstate: function(hookstate) {
            return proxy.sethookstate(hookstate)
          }, setmutestate: function(muted) {
            return proxy.setmutestate(muted)
          }, setphonebarbuttonenabled: function(buttonindex, enabled) {
            return proxy.setphonebarbuttonenabled(buttonindex, enabled)
          }, showcalltransferform: function(callId) {
            return proxy.showcalltransferform(callId)
          }, showinformationpopup: function(messagetext, timespan) {
            return proxy.showinformationpopup(messagetext, timespan)
          }, startdtmfmasking: function(callid, numberofdigits, terminationdigit) {
            return proxy.startDTMFMasking(callid, numberofdigits, terminationdigit)
          }, stopdtmfmasking: function(callid) {
            return proxy.stopDTMFMasking(callid)
          }, startaudiorecording: function(filename, settings) {
            return proxy.startaudiorecording(filename, settings)
          }, stopaudiorecording: function() {
            return proxy.stopaudiorecording()
          }, stopplaylocalfile: function() {
            return proxy.stopplaylocalfile()
          }, supportsabortcall: function() {
            return proxy.supportsAbortCall()
          }, supportsconference: function() {
            return proxy.supportsConference()
          }, swapcall: function() {
            return proxy.swapcall()
          }, switchactiveline: function() {
            return proxy.switchactiveline()
          }, transfercall: function(campaign, firstname, lastname, mandatory, mode) {
            return proxy.transfercall(campaign, firstname, lastname, mandatory, mode)
          }
      };
      return instance
    })()
}
