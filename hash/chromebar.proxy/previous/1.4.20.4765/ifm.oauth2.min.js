
/*!============================================================================

 * Ifm.OAuth2/1.0.7-4668
 * Copyright (c) Base Digitale Platform. All rights reserved.

 ============================================================================*/

"use strict";
/*! @azure/msal-browser v2.22.1 2022-03-07 */
(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.msal = {}))
}(this, (function(exports) {
  /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */
  var extendStatics$1 = function(d, b) {
      extendStatics$1 = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
        d.__proto__ = b
      }) || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p]
      };
      return extendStatics$1(d, b)
    };
  function __extends$1(d, b) {
    extendStatics$1(d, b);
    function __() {
      this.constructor = d
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
  }
  var __assign$1 = function() {
      __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p]
        }
        return t
      };
      return __assign$1.apply(this, arguments)
    };
  function __awaiter$1(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
          resolve(value)
        })
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value))
          }
          catch(e) {
            reject(e)
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value))
          }
          catch(e) {
            reject(e)
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected)
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next())
      })
  }
  function __generator$1(thisArg, body) {
    var _ = {
        label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1]
          }, trys: [], ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
        next: verb(0), "throw": verb(1), "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this
      }), g;
    function verb(n) {
      return function(v) {
          return step([n, v])
        }
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                  value: op[1], done: false
                };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue
              }
              if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                _.label = op[1];
                break
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue
          }
          op = body.call(thisArg, _)
        }
        catch(e) {
          op = [6, e];
          y = 0
        }
        finally {
          f = t = 0
        }
      if (op[0] & 5)
        throw op[1];
      return {
          value: op[0] ? op[1] : void 0, done: true
        }
    }
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o),
      r,
      ar = [],
      e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value)
    }
    catch(error) {
      e = {error: error}
    }
    finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i)
      }
      finally {
        if (e)
          throw e.error;
      }
    }
    return ar
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar
  }
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  /*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** */
  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || ({__proto__: []} instanceof Array && function(d, b) {
        d.__proto__ = b
      }) || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p]
      };
      return extendStatics(d, b)
    };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __)
  }
  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p]
        }
        return t
      };
      return __assign.apply(this, arguments)
    };
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
          resolve(value)
        })
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value))
          }
          catch(e) {
            reject(e)
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value))
          }
          catch(e) {
            reject(e)
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected)
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next())
      })
  }
  function __generator(thisArg, body) {
    var _ = {
        label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1]
          }, trys: [], ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
        next: verb(0), "throw": verb(1), "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this
      }), g;
    function verb(n) {
      return function(v) {
          return step([n, v])
        }
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return {
                  value: op[1], done: false
                };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue
              }
              if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                _.label = op[1];
                break
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue
          }
          op = body.call(thisArg, _)
        }
        catch(e) {
          op = [6, e];
          y = 0
        }
        finally {
          f = t = 0
        }
      if (op[0] & 5)
        throw op[1];
      return {
          value: op[0] ? op[1] : void 0, done: true
        }
    }
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r
  }
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var Constants = {
      LIBRARY_NAME: "MSAL.JS", SKU: "msal.js.common", CACHE_PREFIX: "msal", DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/", DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com", DEFAULT_COMMON_TENANT: "common", ADFS: "adfs", AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=", RESOURCE_DELIM: "|", NO_ACCOUNT: "NO_ACCOUNT", CLAIMS: "claims", CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad", OPENID_SCOPE: "openid", PROFILE_SCOPE: "profile", OFFLINE_ACCESS_SCOPE: "offline_access", EMAIL_SCOPE: "email", CODE_RESPONSE_TYPE: "code", CODE_GRANT_TYPE: "authorization_code", RT_GRANT_TYPE: "refresh_token", FRAGMENT_RESPONSE_MODE: "fragment", S256_CODE_CHALLENGE_METHOD: "S256", URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8", AUTHORIZATION_PENDING: "authorization_pending", NOT_DEFINED: "not_defined", EMPTY_STRING: "", FORWARD_SLASH: "/", IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location", IMDS_VERSION: "2020-06-01", IMDS_TIMEOUT: 2000, AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect", REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com", KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"]
    };
  var OIDC_DEFAULT_SCOPES = [Constants.OPENID_SCOPE, Constants.PROFILE_SCOPE, Constants.OFFLINE_ACCESS_SCOPE];
  var OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [Constants.EMAIL_SCOPE]);
  var HeaderNames;
  (function(HeaderNames) {
    HeaderNames["CONTENT_TYPE"] = "Content-Type";
    HeaderNames["RETRY_AFTER"] = "Retry-After";
    HeaderNames["CCS_HEADER"] = "X-AnchorMailbox";
    HeaderNames["WWWAuthenticate"] = "WWW-Authenticate";
    HeaderNames["AuthenticationInfo"] = "Authentication-Info"
  })(HeaderNames || (HeaderNames = {}));
  var PersistentCacheKeys;
  (function(PersistentCacheKeys) {
    PersistentCacheKeys["ID_TOKEN"] = "idtoken";
    PersistentCacheKeys["CLIENT_INFO"] = "client.info";
    PersistentCacheKeys["ADAL_ID_TOKEN"] = "adal.idtoken";
    PersistentCacheKeys["ERROR"] = "error";
    PersistentCacheKeys["ERROR_DESC"] = "error.description";
    PersistentCacheKeys["ACTIVE_ACCOUNT"] = "active-account"
  })(PersistentCacheKeys || (PersistentCacheKeys = {}));
  var AADAuthorityConstants;
  (function(AADAuthorityConstants) {
    AADAuthorityConstants["COMMON"] = "common";
    AADAuthorityConstants["ORGANIZATIONS"] = "organizations";
    AADAuthorityConstants["CONSUMERS"] = "consumers"
  })(AADAuthorityConstants || (AADAuthorityConstants = {}));
  var AADServerParamKeys;
  (function(AADServerParamKeys) {
    AADServerParamKeys["CLIENT_ID"] = "client_id";
    AADServerParamKeys["REDIRECT_URI"] = "redirect_uri";
    AADServerParamKeys["RESPONSE_TYPE"] = "response_type";
    AADServerParamKeys["RESPONSE_MODE"] = "response_mode";
    AADServerParamKeys["GRANT_TYPE"] = "grant_type";
    AADServerParamKeys["CLAIMS"] = "claims";
    AADServerParamKeys["SCOPE"] = "scope";
    AADServerParamKeys["ERROR"] = "error";
    AADServerParamKeys["ERROR_DESCRIPTION"] = "error_description";
    AADServerParamKeys["ACCESS_TOKEN"] = "access_token";
    AADServerParamKeys["ID_TOKEN"] = "id_token";
    AADServerParamKeys["REFRESH_TOKEN"] = "refresh_token";
    AADServerParamKeys["EXPIRES_IN"] = "expires_in";
    AADServerParamKeys["STATE"] = "state";
    AADServerParamKeys["NONCE"] = "nonce";
    AADServerParamKeys["PROMPT"] = "prompt";
    AADServerParamKeys["SESSION_STATE"] = "session_state";
    AADServerParamKeys["CLIENT_INFO"] = "client_info";
    AADServerParamKeys["CODE"] = "code";
    AADServerParamKeys["CODE_CHALLENGE"] = "code_challenge";
    AADServerParamKeys["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
    AADServerParamKeys["CODE_VERIFIER"] = "code_verifier";
    AADServerParamKeys["CLIENT_REQUEST_ID"] = "client-request-id";
    AADServerParamKeys["X_CLIENT_SKU"] = "x-client-SKU";
    AADServerParamKeys["X_CLIENT_VER"] = "x-client-VER";
    AADServerParamKeys["X_CLIENT_OS"] = "x-client-OS";
    AADServerParamKeys["X_CLIENT_CPU"] = "x-client-CPU";
    AADServerParamKeys["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
    AADServerParamKeys["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
    AADServerParamKeys["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
    AADServerParamKeys["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
    AADServerParamKeys["ID_TOKEN_HINT"] = "id_token_hint";
    AADServerParamKeys["DEVICE_CODE"] = "device_code";
    AADServerParamKeys["CLIENT_SECRET"] = "client_secret";
    AADServerParamKeys["CLIENT_ASSERTION"] = "client_assertion";
    AADServerParamKeys["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
    AADServerParamKeys["TOKEN_TYPE"] = "token_type";
    AADServerParamKeys["REQ_CNF"] = "req_cnf";
    AADServerParamKeys["OBO_ASSERTION"] = "assertion";
    AADServerParamKeys["REQUESTED_TOKEN_USE"] = "requested_token_use";
    AADServerParamKeys["ON_BEHALF_OF"] = "on_behalf_of";
    AADServerParamKeys["FOCI"] = "foci";
    AADServerParamKeys["CCS_HEADER"] = "X-AnchorMailbox";
    AADServerParamKeys["RETURN_SPA_CODE"] = "return_spa_code";
    AADServerParamKeys["LOGOUT_HINT"] = "logout_hint"
  })(AADServerParamKeys || (AADServerParamKeys = {}));
  var ClaimsRequestKeys;
  (function(ClaimsRequestKeys) {
    ClaimsRequestKeys["ACCESS_TOKEN"] = "access_token";
    ClaimsRequestKeys["XMS_CC"] = "xms_cc"
  })(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
  var PromptValue = {
      LOGIN: "login", SELECT_ACCOUNT: "select_account", CONSENT: "consent", NONE: "none", CREATE: "create"
    };
  var SSOTypes;
  (function(SSOTypes) {
    SSOTypes["ACCOUNT"] = "account";
    SSOTypes["SID"] = "sid";
    SSOTypes["LOGIN_HINT"] = "login_hint";
    SSOTypes["ID_TOKEN"] = "id_token";
    SSOTypes["DOMAIN_HINT"] = "domain_hint";
    SSOTypes["ORGANIZATIONS"] = "organizations";
    SSOTypes["CONSUMERS"] = "consumers";
    SSOTypes["ACCOUNT_ID"] = "accountIdentifier";
    SSOTypes["HOMEACCOUNT_ID"] = "homeAccountIdentifier"
  })(SSOTypes || (SSOTypes = {}));
  var CodeChallengeMethodValues = {
      PLAIN: "plain", S256: "S256"
    };
  var ResponseMode;
  (function(ResponseMode) {
    ResponseMode["QUERY"] = "query";
    ResponseMode["FRAGMENT"] = "fragment";
    ResponseMode["FORM_POST"] = "form_post"
  })(ResponseMode || (ResponseMode = {}));
  var GrantType;
  (function(GrantType) {
    GrantType["IMPLICIT_GRANT"] = "implicit";
    GrantType["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
    GrantType["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
    GrantType["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
    GrantType["REFRESH_TOKEN_GRANT"] = "refresh_token";
    GrantType["DEVICE_CODE_GRANT"] = "device_code";
    GrantType["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer"
  })(GrantType || (GrantType = {}));
  var CacheAccountType;
  (function(CacheAccountType) {
    CacheAccountType["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
    CacheAccountType["ADFS_ACCOUNT_TYPE"] = "ADFS";
    CacheAccountType["MSAV1_ACCOUNT_TYPE"] = "MSA";
    CacheAccountType["GENERIC_ACCOUNT_TYPE"] = "Generic"
  })(CacheAccountType || (CacheAccountType = {}));
  var Separators;
  (function(Separators) {
    Separators["CACHE_KEY_SEPARATOR"] = "-";
    Separators["CLIENT_INFO_SEPARATOR"] = "."
  })(Separators || (Separators = {}));
  var CredentialType;
  (function(CredentialType) {
    CredentialType["ID_TOKEN"] = "IdToken";
    CredentialType["ACCESS_TOKEN"] = "AccessToken";
    CredentialType["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
    CredentialType["REFRESH_TOKEN"] = "RefreshToken"
  })(CredentialType || (CredentialType = {}));
  var CacheSchemaType;
  (function(CacheSchemaType) {
    CacheSchemaType["ACCOUNT"] = "Account";
    CacheSchemaType["CREDENTIAL"] = "Credential";
    CacheSchemaType["ID_TOKEN"] = "IdToken";
    CacheSchemaType["ACCESS_TOKEN"] = "AccessToken";
    CacheSchemaType["REFRESH_TOKEN"] = "RefreshToken";
    CacheSchemaType["APP_METADATA"] = "AppMetadata";
    CacheSchemaType["TEMPORARY"] = "TempCache";
    CacheSchemaType["TELEMETRY"] = "Telemetry";
    CacheSchemaType["UNDEFINED"] = "Undefined";
    CacheSchemaType["THROTTLING"] = "Throttling"
  })(CacheSchemaType || (CacheSchemaType = {}));
  var CacheType;
  (function(CacheType) {
    CacheType[CacheType["ADFS"] = 1001] = "ADFS";
    CacheType[CacheType["MSA"] = 1002] = "MSA";
    CacheType[CacheType["MSSTS"] = 1003] = "MSSTS";
    CacheType[CacheType["GENERIC"] = 1004] = "GENERIC";
    CacheType[CacheType["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
    CacheType[CacheType["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
    CacheType[CacheType["ID_TOKEN"] = 2003] = "ID_TOKEN";
    CacheType[CacheType["APP_METADATA"] = 3001] = "APP_METADATA";
    CacheType[CacheType["UNDEFINED"] = 9999] = "UNDEFINED"
  })(CacheType || (CacheType = {}));
  var APP_METADATA = "appmetadata";
  var CLIENT_INFO = "client_info";
  var THE_FAMILY_ID = "1";
  var AUTHORITY_METADATA_CONSTANTS = {
      CACHE_KEY: "authority-metadata", REFRESH_TIME_SECONDS: 3600 * 24
    };
  var AuthorityMetadataSource;
  (function(AuthorityMetadataSource) {
    AuthorityMetadataSource["CONFIG"] = "config";
    AuthorityMetadataSource["CACHE"] = "cache";
    AuthorityMetadataSource["NETWORK"] = "network"
  })(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
  var SERVER_TELEM_CONSTANTS = {
      SCHEMA_VERSION: 5, MAX_CUR_HEADER_BYTES: 80, MAX_LAST_HEADER_BYTES: 330, MAX_CACHED_ERRORS: 50, CACHE_KEY: "server-telemetry", CATEGORY_SEPARATOR: "|", VALUE_SEPARATOR: ",", OVERFLOW_TRUE: "1", OVERFLOW_FALSE: "0", UNKNOWN_ERROR: "unknown_error"
    };
  exports.AuthenticationScheme = void 0;
  (function(AuthenticationScheme) {
    AuthenticationScheme["BEARER"] = "Bearer";
    AuthenticationScheme["POP"] = "pop";
    AuthenticationScheme["SSH"] = "ssh-cert"
  })(exports.AuthenticationScheme || (exports.AuthenticationScheme = {}));
  var ThrottlingConstants = {
      DEFAULT_THROTTLE_TIME_SECONDS: 60, DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600, THROTTLING_PREFIX: "throttling", X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
    };
  var Errors = {
      INVALID_GRANT_ERROR: "invalid_grant", CLIENT_MISMATCH_ERROR: "client_mismatch"
    };
  var PasswordGrantConstants;
  (function(PasswordGrantConstants) {
    PasswordGrantConstants["username"] = "username";
    PasswordGrantConstants["password"] = "password"
  })(PasswordGrantConstants || (PasswordGrantConstants = {}));
  var ResponseCodes;
  (function(ResponseCodes) {
    ResponseCodes[ResponseCodes["httpSuccess"] = 200] = "httpSuccess";
    ResponseCodes[ResponseCodes["httpBadRequest"] = 400] = "httpBadRequest"
  })(ResponseCodes || (ResponseCodes = {}));
  var RegionDiscoverySources;
  (function(RegionDiscoverySources) {
    RegionDiscoverySources["FAILED_AUTO_DETECTION"] = "1";
    RegionDiscoverySources["INTERNAL_CACHE"] = "2";
    RegionDiscoverySources["ENVIRONMENT_VARIABLE"] = "3";
    RegionDiscoverySources["IMDS"] = "4"
  })(RegionDiscoverySources || (RegionDiscoverySources = {}));
  var RegionDiscoveryOutcomes;
  (function(RegionDiscoveryOutcomes) {
    RegionDiscoveryOutcomes["CONFIGURED_MATCHES_DETECTED"] = "1";
    RegionDiscoveryOutcomes["CONFIGURED_NO_AUTO_DETECTION"] = "2";
    RegionDiscoveryOutcomes["CONFIGURED_NOT_DETECTED"] = "3";
    RegionDiscoveryOutcomes["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
    RegionDiscoveryOutcomes["AUTO_DETECTION_REQUESTED_FAILED"] = "5"
  })(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
  var CacheOutcome;
  (function(CacheOutcome) {
    CacheOutcome["NO_CACHE_HIT"] = "0";
    CacheOutcome["FORCE_REFRESH"] = "1";
    CacheOutcome["NO_CACHED_ACCESS_TOKEN"] = "2";
    CacheOutcome["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
    CacheOutcome["REFRESH_CACHED_ACCESS_TOKEN"] = "4"
  })(CacheOutcome || (CacheOutcome = {}));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthErrorMessage = {unexpectedError: {
        code: "unexpected_error", desc: "Unexpected error in authentication."
      }};
  var AuthError = (function(_super) {
      __extends(AuthError, _super);
      function AuthError(errorCode, errorMessage, suberror) {
        var _this = this;
        var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
        _this = _super.call(this, errorString) || this;
        Object.setPrototypeOf(_this, AuthError.prototype);
        _this.errorCode = errorCode || Constants.EMPTY_STRING;
        _this.errorMessage = errorMessage || "";
        _this.subError = suberror || "";
        _this.name = "AuthError";
        return _this
      }
      AuthError.prototype.setCorrelationId = function(correlationId) {
        this.correlationId = correlationId
      };
      AuthError.createUnexpectedError = function(errDesc) {
        return new AuthError(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc)
      };
      return AuthError
    }(Error));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var DEFAULT_CRYPTO_IMPLEMENTATION = {
      createNewGuid: function() {
        var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
        throw AuthError.createUnexpectedError(notImplErr);
      }, base64Decode: function() {
          var notImplErr = "Crypto interface - base64Decode() has not been implemented";
          throw AuthError.createUnexpectedError(notImplErr);
        }, base64Encode: function() {
          var notImplErr = "Crypto interface - base64Encode() has not been implemented";
          throw AuthError.createUnexpectedError(notImplErr);
        }, generatePkceCodes: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }, getPublicKeyThumbprint: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }, removeTokenBindingKey: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }, clearKeystore: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Crypto interface - clearKeystore() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }, signJwt: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Crypto interface - signJwt() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }, hashString: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Crypto interface - hashString() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }
    };
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ClientAuthErrorMessage = {
      clientInfoDecodingError: {
        code: "client_info_decoding_error", desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
      }, clientInfoEmptyError: {
          code: "client_info_empty_error", desc: "The client info was empty. Please review the trace to determine the root cause."
        }, tokenParsingError: {
          code: "token_parsing_error", desc: "Token cannot be parsed. Please review stack trace to determine root cause."
        }, nullOrEmptyToken: {
          code: "null_or_empty_token", desc: "The token is null or empty. Please review the trace to determine the root cause."
        }, endpointResolutionError: {
          code: "endpoints_resolution_error", desc: "Error: could not resolve endpoints. Please check network and try again."
        }, networkError: {
          code: "network_error", desc: "Network request failed. Please check network trace to determine root cause."
        }, unableToGetOpenidConfigError: {
          code: "openid_config_error", desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
        }, hashNotDeserialized: {
          code: "hash_not_deserialized", desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
        }, blankGuidGenerated: {
          code: "blank_guid_generated", desc: "The guid generated was blank. Please review the trace to determine the root cause."
        }, invalidStateError: {
          code: "invalid_state", desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
        }, stateMismatchError: {
          code: "state_mismatch", desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
        }, stateNotFoundError: {
          code: "state_not_found", desc: "State not found"
        }, nonceMismatchError: {
          code: "nonce_mismatch", desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
        }, nonceNotFoundError: {
          code: "nonce_not_found", desc: "nonce not found"
        }, noTokensFoundError: {
          code: "no_tokens_found", desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
        }, multipleMatchingTokens: {
          code: "multiple_matching_tokens", desc: "The cache contains multiple tokens satisfying the requirements. " + "Call AcquireToken again providing more requirements such as authority or account."
        }, multipleMatchingAccounts: {
          code: "multiple_matching_accounts", desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
        }, multipleMatchingAppMetadata: {
          code: "multiple_matching_appMetadata", desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
        }, tokenRequestCannotBeMade: {
          code: "request_cannot_be_made", desc: "Token request cannot be made without authorization code or refresh token."
        }, appendEmptyScopeError: {
          code: "cannot_append_empty_scope", desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
        }, removeEmptyScopeError: {
          code: "cannot_remove_empty_scope", desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
        }, appendScopeSetError: {
          code: "cannot_append_scopeset", desc: "Cannot append ScopeSet due to error."
        }, emptyInputScopeSetError: {
          code: "empty_input_scopeset", desc: "Empty input ScopeSet cannot be processed."
        }, DeviceCodePollingCancelled: {
          code: "device_code_polling_cancelled", desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
        }, DeviceCodeExpired: {
          code: "device_code_expired", desc: "Device code is expired."
        }, DeviceCodeUnknownError: {
          code: "device_code_unknown_error", desc: "Device code stopped polling for unknown reasons."
        }, NoAccountInSilentRequest: {
          code: "no_account_in_silent_request", desc: "Please pass an account object, silent flow is not supported without account information"
        }, invalidCacheRecord: {
          code: "invalid_cache_record", desc: "Cache record object was null or undefined."
        }, invalidCacheEnvironment: {
          code: "invalid_cache_environment", desc: "Invalid environment when attempting to create cache entry"
        }, noAccountFound: {
          code: "no_account_found", desc: "No account found in cache for given key."
        }, CachePluginError: {
          code: "no cache plugin set on CacheManager", desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
        }, noCryptoObj: {
          code: "no_crypto_object", desc: "No crypto object detected. This is required for the following operation: "
        }, invalidCacheType: {
          code: "invalid_cache_type", desc: "Invalid cache type"
        }, unexpectedAccountType: {
          code: "unexpected_account_type", desc: "Unexpected account type."
        }, unexpectedCredentialType: {
          code: "unexpected_credential_type", desc: "Unexpected credential type."
        }, invalidAssertion: {
          code: "invalid_assertion", desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
        }, invalidClientCredential: {
          code: "invalid_client_credential", desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
        }, tokenRefreshRequired: {
          code: "token_refresh_required", desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
        }, userTimeoutReached: {
          code: "user_timeout_reached", desc: "User defined timeout for device code polling reached"
        }, tokenClaimsRequired: {
          code: "token_claims_cnf_required_for_signedjwt", desc: "Cannot generate a POP jwt if the token_claims are not populated"
        }, noAuthorizationCodeFromServer: {
          code: "authorization_code_missing_from_server_response", desc: "Server response does not contain an authorization code to proceed"
        }, noAzureRegionDetected: {
          code: "no_azure_region_detected", desc: "No azure region was detected and no fallback was made available"
        }, accessTokenEntityNullError: {
          code: "access_token_entity_null", desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
        }, bindingKeyNotRemovedError: {
          code: "binding_key_not_removed", desc: "Could not remove the credential's binding key from storage."
        }, logoutNotSupported: {
          code: "end_session_endpoint_not_supported", desc: "Provided authority does not support logout."
        }
    };
  var ClientAuthError = (function(_super) {
      __extends(ClientAuthError, _super);
      function ClientAuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientAuthError";
        Object.setPrototypeOf(_this, ClientAuthError.prototype);
        return _this
      }
      ClientAuthError.createClientInfoDecodingError = function(caughtError) {
        return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError)
      };
      ClientAuthError.createClientInfoEmptyError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc)
      };
      ClientAuthError.createTokenParsingError = function(caughtExtractionError) {
        return new ClientAuthError(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError)
      };
      ClientAuthError.createTokenNullOrEmptyError = function(invalidRawTokenString) {
        return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString)
      };
      ClientAuthError.createEndpointDiscoveryIncompleteError = function(errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail)
      };
      ClientAuthError.createNetworkError = function(endpoint, errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0])
      };
      ClientAuthError.createUnableToGetOpenidConfigError = function(errDetail) {
        return new ClientAuthError(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail)
      };
      ClientAuthError.createHashNotDeserializedError = function(hashParamObj) {
        return new ClientAuthError(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj)
      };
      ClientAuthError.createInvalidStateError = function(invalidState, errorString) {
        return new ClientAuthError(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString)
      };
      ClientAuthError.createStateMismatchError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc)
      };
      ClientAuthError.createStateNotFoundError = function(missingState) {
        return new ClientAuthError(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState)
      };
      ClientAuthError.createNonceMismatchError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc)
      };
      ClientAuthError.createNonceNotFoundError = function(missingNonce) {
        return new ClientAuthError(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce)
      };
      ClientAuthError.createMultipleMatchingTokensInCacheError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".")
      };
      ClientAuthError.createMultipleMatchingAccountsInCacheError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc)
      };
      ClientAuthError.createMultipleMatchingAppMetadataInCacheError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc)
      };
      ClientAuthError.createTokenRequestCannotBeMadeError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc)
      };
      ClientAuthError.createAppendEmptyScopeToSetError = function(givenScope) {
        return new ClientAuthError(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope)
      };
      ClientAuthError.createRemoveEmptyScopeFromSetError = function(givenScope) {
        return new ClientAuthError(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope)
      };
      ClientAuthError.createAppendScopeSetError = function(appendError) {
        return new ClientAuthError(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError)
      };
      ClientAuthError.createEmptyInputScopeSetError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc)
      };
      ClientAuthError.createDeviceCodeCancelledError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc)
      };
      ClientAuthError.createDeviceCodeExpiredError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc)
      };
      ClientAuthError.createDeviceCodeUnknownError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc)
      };
      ClientAuthError.createNoAccountInSilentRequestError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc)
      };
      ClientAuthError.createNullOrUndefinedCacheRecord = function() {
        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc)
      };
      ClientAuthError.createInvalidCacheEnvironmentError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc)
      };
      ClientAuthError.createNoAccountFoundError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc)
      };
      ClientAuthError.createCachePluginError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc)
      };
      ClientAuthError.createNoCryptoObjectError = function(operationName) {
        return new ClientAuthError(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName)
      };
      ClientAuthError.createInvalidCacheTypeError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc)
      };
      ClientAuthError.createUnexpectedAccountTypeError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc)
      };
      ClientAuthError.createUnexpectedCredentialTypeError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc)
      };
      ClientAuthError.createInvalidAssertionError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc)
      };
      ClientAuthError.createInvalidCredentialError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc)
      };
      ClientAuthError.createRefreshRequiredError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc)
      };
      ClientAuthError.createUserTimeoutReachedError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc)
      };
      ClientAuthError.createTokenClaimsRequiredError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc)
      };
      ClientAuthError.createNoAuthCodeInServerResponseError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc)
      };
      ClientAuthError.createBindingKeyNotRemovedError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc)
      };
      ClientAuthError.createLogoutNotSupportedError = function() {
        return new ClientAuthError(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc)
      };
      return ClientAuthError
    }(AuthError));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var StringUtils = (function() {
      function StringUtils(){}
      StringUtils.decodeAuthToken = function(authToken) {
        if (StringUtils.isEmpty(authToken)) {
          throw ClientAuthError.createTokenNullOrEmptyError(authToken);
        }
        var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
        var matches = tokenPartsRegex.exec(authToken);
        if (!matches || matches.length < 4) {
          throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
        }
        var crackedToken = {
            header: matches[1], JWSPayload: matches[2], JWSSig: matches[3]
          };
        return crackedToken
      };
      StringUtils.isEmpty = function(str) {
        return (typeof str === "undefined" || !str || 0 === str.length)
      };
      StringUtils.isEmptyObj = function(strObj) {
        if (strObj && !StringUtils.isEmpty(strObj)) {
          try {
            var obj = JSON.parse(strObj);
            return Object.keys(obj).length === 0
          }
          catch(e) {}
        }
        return true
      };
      StringUtils.startsWith = function(str, search) {
        return str.indexOf(search) === 0
      };
      StringUtils.endsWith = function(str, search) {
        return (str.length >= search.length) && (str.lastIndexOf(search) === (str.length - search.length))
      };
      StringUtils.queryStringToObject = function(query) {
        var obj = {};
        var params = query.split("&");
        var decode = function(s) {
            return decodeURIComponent(s.replace(/\+/g, " "))
          };
        params.forEach(function(pair) {
          if (pair.trim()) {
            var _a = pair.split(/=(.+)/g, 2),
              key = _a[0],
              value = _a[1];
            if (key && value) {
              obj[decode(key)] = decode(value)
            }
          }
        });
        return obj
      };
      StringUtils.trimArrayEntries = function(arr) {
        return arr.map(function(entry) {
            return entry.trim()
          })
      };
      StringUtils.removeEmptyStringsFromArray = function(arr) {
        return arr.filter(function(entry) {
            return !StringUtils.isEmpty(entry)
          })
      };
      StringUtils.jsonParseHelper = function(str) {
        try {
          return JSON.parse(str)
        }
        catch(e) {
          return null
        }
      };
      StringUtils.matchPattern = function(pattern, input) {
        var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\\?"));
        return regex.test(input)
      };
      return StringUtils
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  exports.LogLevel = void 0;
  (function(LogLevel) {
    LogLevel[LogLevel["Error"] = 0] = "Error";
    LogLevel[LogLevel["Warning"] = 1] = "Warning";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
    LogLevel[LogLevel["Trace"] = 4] = "Trace"
  })(exports.LogLevel || (exports.LogLevel = {}));
  var Logger = (function() {
      function Logger(loggerOptions, packageName, packageVersion) {
        this.level = exports.LogLevel.Info;
        var defaultLoggerCallback = function() {
            return
          };
        this.localCallback = loggerOptions.loggerCallback || defaultLoggerCallback;
        this.piiLoggingEnabled = loggerOptions.piiLoggingEnabled || false;
        this.level = typeof(loggerOptions.logLevel) === "number" ? loggerOptions.logLevel : exports.LogLevel.Info;
        this.correlationId = loggerOptions.correlationId || "";
        this.packageName = packageName || Constants.EMPTY_STRING;
        this.packageVersion = packageVersion || Constants.EMPTY_STRING
      }
      Logger.prototype.clone = function(packageName, packageVersion, correlationId) {
        return new Logger({
            loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId
          }, packageName, packageVersion)
      };
      Logger.prototype.logMessage = function(logMessage, options) {
        if ((options.logLevel > this.level) || (!this.piiLoggingEnabled && options.containsPii)) {
          return
        }
        var timestamp = (new Date).toUTCString();
        var logHeader;
        if (!StringUtils.isEmpty(options.correlationId)) {
          logHeader = "[" + timestamp + "] : [" + options.correlationId + "]"
        }
        else if (!StringUtils.isEmpty(this.correlationId)) {
          logHeader = "[" + timestamp + "] : [" + this.correlationId + "]"
        }
        else {
          logHeader = "[" + timestamp + "]"
        }
        var log = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + exports.LogLevel[options.logLevel] + " - " + logMessage;
        this.executeCallback(options.logLevel, log, options.containsPii || false)
      };
      Logger.prototype.executeCallback = function(level, message, containsPii) {
        if (this.localCallback) {
          this.localCallback(level, message, containsPii)
        }
      };
      Logger.prototype.error = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Error, containsPii: false, correlationId: correlationId || ""
        })
      };
      Logger.prototype.errorPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Error, containsPii: true, correlationId: correlationId || ""
        })
      };
      Logger.prototype.warning = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Warning, containsPii: false, correlationId: correlationId || ""
        })
      };
      Logger.prototype.warningPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Warning, containsPii: true, correlationId: correlationId || ""
        })
      };
      Logger.prototype.info = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Info, containsPii: false, correlationId: correlationId || ""
        })
      };
      Logger.prototype.infoPii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Info, containsPii: true, correlationId: correlationId || ""
        })
      };
      Logger.prototype.verbose = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Verbose, containsPii: false, correlationId: correlationId || ""
        })
      };
      Logger.prototype.verbosePii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Verbose, containsPii: true, correlationId: correlationId || ""
        })
      };
      Logger.prototype.trace = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Trace, containsPii: false, correlationId: correlationId || ""
        })
      };
      Logger.prototype.tracePii = function(message, correlationId) {
        this.logMessage(message, {
          logLevel: exports.LogLevel.Trace, containsPii: true, correlationId: correlationId || ""
        })
      };
      Logger.prototype.isPiiLoggingEnabled = function() {
        return this.piiLoggingEnabled || false
      };
      return Logger
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var name$1 = "@azure/msal-common";
  var version$1 = "6.1.0";
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  exports.AzureCloudInstance = void 0;
  (function(AzureCloudInstance) {
    AzureCloudInstance[AzureCloudInstance["None"] = 0] = "None";
    AzureCloudInstance["AzurePublic"] = "https://login.microsoftonline.com";
    AzureCloudInstance["AzureChina"] = "https://login.chinacloudapi.cn";
    AzureCloudInstance["AzureGermany"] = "https://login.microsoftonline.de";
    AzureCloudInstance["AzureUsGovernment"] = "https://login.microsoftonline.us"
  })(exports.AzureCloudInstance || (exports.AzureCloudInstance = {}));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var CredentialEntity = (function() {
      function CredentialEntity(){}
      CredentialEntity.prototype.generateAccountId = function() {
        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment)
      };
      CredentialEntity.prototype.generateCredentialId = function() {
        return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId)
      };
      CredentialEntity.prototype.generateTarget = function() {
        return CredentialEntity.generateTargetForCacheKey(this.target)
      };
      CredentialEntity.prototype.generateCredentialKey = function() {
        return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash)
      };
      CredentialEntity.prototype.generateType = function() {
        switch (this.credentialType) {
          case CredentialType.ID_TOKEN:
            return CacheType.ID_TOKEN;
          case CredentialType.ACCESS_TOKEN:
          case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
            return CacheType.ACCESS_TOKEN;
          case CredentialType.REFRESH_TOKEN:
            return CacheType.REFRESH_TOKEN;
          default:
            {
              throw ClientAuthError.createUnexpectedCredentialTypeError();
            }
        }
      };
      CredentialEntity.getCredentialType = function(key) {
        if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {
          if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {
            return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME
          }
          return CredentialType.ACCESS_TOKEN
        }
        else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {
          return CredentialType.ID_TOKEN
        }
        else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {
          return CredentialType.REFRESH_TOKEN
        }
        return Constants.NOT_DEFINED
      };
      CredentialEntity.generateCredentialCacheKey = function(homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
        var credentialKey = [this.generateAccountIdForCacheKey(homeAccountId, environment), this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId), this.generateTargetForCacheKey(target), this.generateClaimsHashForCacheKey(requestedClaimsHash), this.generateSchemeForCacheKey(tokenType)];
        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase()
      };
      CredentialEntity.generateAccountIdForCacheKey = function(homeAccountId, environment) {
        var accountId = [homeAccountId, environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase()
      };
      CredentialEntity.generateCredentialIdForCacheKey = function(credentialType, clientId, realm, familyId) {
        var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;
        var credentialId = [credentialType, clientOrFamilyId, realm || "", ];
        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase()
      };
      CredentialEntity.generateTargetForCacheKey = function(scopes) {
        return (scopes || "").toLowerCase()
      };
      CredentialEntity.generateClaimsHashForCacheKey = function(requestedClaimsHash) {
        return (requestedClaimsHash || "").toLowerCase()
      };
      CredentialEntity.generateSchemeForCacheKey = function(tokenType) {
        return (tokenType && tokenType.toLowerCase() !== exports.AuthenticationScheme.BEARER.toLowerCase()) ? tokenType.toLowerCase() : ""
      };
      return CredentialEntity
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ClientConfigurationErrorMessage = {
      redirectUriNotSet: {
        code: "redirect_uri_empty", desc: "A redirect URI is required for all calls, and none has been set."
      }, postLogoutUriNotSet: {
          code: "post_logout_uri_empty", desc: "A post logout redirect has not been set."
        }, claimsRequestParsingError: {
          code: "claims_request_parsing_error", desc: "Could not parse the given claims request object."
        }, authorityUriInsecure: {
          code: "authority_uri_insecure", desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
        }, urlParseError: {
          code: "url_parse_error", desc: "URL could not be parsed into appropriate segments."
        }, urlEmptyError: {
          code: "empty_url_error", desc: "URL was empty or null."
        }, emptyScopesError: {
          code: "empty_input_scopes_error", desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
        }, nonArrayScopesError: {
          code: "nonarray_input_scopes_error", desc: "Scopes cannot be passed as non-array."
        }, clientIdSingleScopeError: {
          code: "clientid_input_scopes_error", desc: "Client ID can only be provided as a single scope."
        }, invalidPrompt: {
          code: "invalid_prompt_value", desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create' and 'none'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest"
        }, invalidClaimsRequest: {
          code: "invalid_claims", desc: "Given claims parameter must be a stringified JSON object."
        }, tokenRequestEmptyError: {
          code: "token_request_empty", desc: "Token request was empty and not found in cache."
        }, logoutRequestEmptyError: {
          code: "logout_request_empty", desc: "The logout request was null or undefined."
        }, invalidCodeChallengeMethod: {
          code: "invalid_code_challenge_method", desc: "code_challenge_method passed is invalid. Valid values are \"plain\" and \"S256\"."
        }, invalidCodeChallengeParams: {
          code: "pkce_params_missing", desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
        }, invalidCloudDiscoveryMetadata: {
          code: "invalid_cloud_discovery_metadata", desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
        }, invalidAuthorityMetadata: {
          code: "invalid_authority_metadata", desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
        }, untrustedAuthority: {
          code: "untrusted_authority", desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
        }, invalidAzureCloudInstance: {
          code: "invalid_azure_cloud_instance", desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
        }, missingSshJwk: {
          code: "missing_ssh_jwk", desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
        }, missingSshKid: {
          code: "missing_ssh_kid", desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
        }, missingNonceAuthenticationHeader: {
          code: "missing_nonce_authentication_header", desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
        }, invalidAuthenticationHeader: {
          code: "invalid_authentication_header", desc: "Invalid authentication header provided"
        }
    };
  var ClientConfigurationError = (function(_super) {
      __extends(ClientConfigurationError, _super);
      function ClientConfigurationError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "ClientConfigurationError";
        Object.setPrototypeOf(_this, ClientConfigurationError.prototype);
        return _this
      }
      ClientConfigurationError.createRedirectUriEmptyError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc)
      };
      ClientConfigurationError.createPostLogoutRedirectUriEmptyError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc)
      };
      ClientConfigurationError.createClaimsRequestParsingError = function(claimsRequestParseError) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError)
      };
      ClientConfigurationError.createInsecureAuthorityUriError = function(urlString) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString)
      };
      ClientConfigurationError.createUrlParseError = function(urlParseError) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError)
      };
      ClientConfigurationError.createUrlEmptyError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc)
      };
      ClientConfigurationError.createEmptyScopesArrayError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc)
      };
      ClientConfigurationError.createClientIdSingleScopeError = function(inputScopes) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes)
      };
      ClientConfigurationError.createInvalidPromptError = function(promptValue) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue)
      };
      ClientConfigurationError.createInvalidClaimsRequestError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc)
      };
      ClientConfigurationError.createEmptyLogoutRequestError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc)
      };
      ClientConfigurationError.createEmptyTokenRequestError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc)
      };
      ClientConfigurationError.createInvalidCodeChallengeMethodError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc)
      };
      ClientConfigurationError.createInvalidCodeChallengeParamsError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc)
      };
      ClientConfigurationError.createInvalidCloudDiscoveryMetadataError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc)
      };
      ClientConfigurationError.createInvalidAuthorityMetadataError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc)
      };
      ClientConfigurationError.createUntrustedAuthorityError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc)
      };
      ClientConfigurationError.createInvalidAzureCloudInstanceError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc)
      };
      ClientConfigurationError.createMissingSshJwkError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc)
      };
      ClientConfigurationError.createMissingSshKidError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc)
      };
      ClientConfigurationError.createMissingNonceAuthenticationHeadersError = function() {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc)
      };
      ClientConfigurationError.createInvalidAuthenticationHeaderError = function(invalidHeaderName, details) {
        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details)
      };
      return ClientConfigurationError
    }(ClientAuthError));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ScopeSet = (function() {
      function ScopeSet(inputScopes) {
        var _this = this;
        var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
        var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
        this.validateInputScopes(filteredInput);
        this.scopes = new Set;
        filteredInput.forEach(function(scope) {
          return _this.scopes.add(scope)
        })
      }
      ScopeSet.fromString = function(inputScopeString) {
        var scopeString = inputScopeString || "";
        var inputScopes = scopeString.split(" ");
        return new ScopeSet(inputScopes)
      };
      ScopeSet.prototype.validateInputScopes = function(inputScopes) {
        if (!inputScopes || inputScopes.length < 1) {
          throw ClientConfigurationError.createEmptyScopesArrayError();
        }
      };
      ScopeSet.prototype.containsScope = function(scope) {
        var lowerCaseScopes = this.printScopesLowerCase().split(" ");
        var lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);
        return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false
      };
      ScopeSet.prototype.containsScopeSet = function(scopeSet) {
        var _this = this;
        if (!scopeSet || scopeSet.scopes.size <= 0) {
          return false
        }
        return (this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function(scope) {
            return _this.containsScope(scope)
          }))
      };
      ScopeSet.prototype.containsOnlyOIDCScopes = function() {
        var _this = this;
        var defaultScopeCount = 0;
        OIDC_SCOPES.forEach(function(defaultScope) {
          if (_this.containsScope(defaultScope)) {
            defaultScopeCount += 1
          }
        });
        return this.scopes.size === defaultScopeCount
      };
      ScopeSet.prototype.appendScope = function(newScope) {
        if (!StringUtils.isEmpty(newScope)) {
          this.scopes.add(newScope.trim())
        }
      };
      ScopeSet.prototype.appendScopes = function(newScopes) {
        var _this = this;
        try {
          newScopes.forEach(function(newScope) {
            return _this.appendScope(newScope)
          })
        }
        catch(e) {
          throw ClientAuthError.createAppendScopeSetError(e);
        }
      };
      ScopeSet.prototype.removeScope = function(scope) {
        if (StringUtils.isEmpty(scope)) {
          throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
        }
        this.scopes.delete(scope.trim())
      };
      ScopeSet.prototype.removeOIDCScopes = function() {
        var _this = this;
        OIDC_SCOPES.forEach(function(defaultScope) {
          _this.scopes.delete(defaultScope)
        })
      };
      ScopeSet.prototype.unionScopeSets = function(otherScopes) {
        if (!otherScopes) {
          throw ClientAuthError.createEmptyInputScopeSetError();
        }
        var unionScopes = new Set;
        otherScopes.scopes.forEach(function(scope) {
          return unionScopes.add(scope.toLowerCase())
        });
        this.scopes.forEach(function(scope) {
          return unionScopes.add(scope.toLowerCase())
        });
        return unionScopes
      };
      ScopeSet.prototype.intersectingScopeSets = function(otherScopes) {
        if (!otherScopes) {
          throw ClientAuthError.createEmptyInputScopeSetError();
        }
        if (!otherScopes.containsOnlyOIDCScopes()) {
          otherScopes.removeOIDCScopes()
        }
        var unionScopes = this.unionScopeSets(otherScopes);
        var sizeOtherScopes = otherScopes.getScopeCount();
        var sizeThisScopes = this.getScopeCount();
        var sizeUnionScopes = unionScopes.size;
        return sizeUnionScopes < (sizeThisScopes + sizeOtherScopes)
      };
      ScopeSet.prototype.getScopeCount = function() {
        return this.scopes.size
      };
      ScopeSet.prototype.asArray = function() {
        var array = [];
        this.scopes.forEach(function(val) {
          return array.push(val)
        });
        return array
      };
      ScopeSet.prototype.printScopes = function() {
        if (this.scopes) {
          var scopeArr = this.asArray();
          return scopeArr.join(" ")
        }
        return ""
      };
      ScopeSet.prototype.printScopesLowerCase = function() {
        return this.printScopes().toLowerCase()
      };
      return ScopeSet
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  function buildClientInfo(rawClientInfo, crypto) {
    if (StringUtils.isEmpty(rawClientInfo)) {
      throw ClientAuthError.createClientInfoEmptyError();
    }
    try {
      var decodedClientInfo = crypto.base64Decode(rawClientInfo);
      return JSON.parse(decodedClientInfo)
    }
    catch(e) {
      throw ClientAuthError.createClientInfoDecodingError(e);
    }
  }
  function buildClientInfoFromHomeAccountId(homeAccountId) {
    if (StringUtils.isEmpty(homeAccountId)) {
      throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
    }
    var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
    return {
        uid: clientInfoParts[0], utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
      }
  }
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthorityType;
  (function(AuthorityType) {
    AuthorityType[AuthorityType["Default"] = 0] = "Default";
    AuthorityType[AuthorityType["Adfs"] = 1] = "Adfs"
  })(AuthorityType || (AuthorityType = {}));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AccountEntity = (function() {
      function AccountEntity(){}
      AccountEntity.prototype.generateAccountId = function() {
        var accountId = [this.homeAccountId, this.environment];
        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase()
      };
      AccountEntity.prototype.generateAccountKey = function() {
        return AccountEntity.generateAccountCacheKey({
            homeAccountId: this.homeAccountId, environment: this.environment, tenantId: this.realm, username: this.username, localAccountId: this.localAccountId
          })
      };
      AccountEntity.prototype.generateType = function() {
        switch (this.authorityType) {
          case CacheAccountType.ADFS_ACCOUNT_TYPE:
            return CacheType.ADFS;
          case CacheAccountType.MSAV1_ACCOUNT_TYPE:
            return CacheType.MSA;
          case CacheAccountType.MSSTS_ACCOUNT_TYPE:
            return CacheType.MSSTS;
          case CacheAccountType.GENERIC_ACCOUNT_TYPE:
            return CacheType.GENERIC;
          default:
            {
              throw ClientAuthError.createUnexpectedAccountTypeError();
            }
        }
      };
      AccountEntity.prototype.getAccountInfo = function() {
        return {
            homeAccountId: this.homeAccountId, environment: this.environment, tenantId: this.realm, username: this.username, localAccountId: this.localAccountId, name: this.name, idTokenClaims: this.idTokenClaims
          }
      };
      AccountEntity.generateAccountCacheKey = function(accountInterface) {
        var accountKey = [accountInterface.homeAccountId, accountInterface.environment || "", accountInterface.tenantId || "", ];
        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase()
      };
      AccountEntity.createAccount = function(clientInfo, homeAccountId, idToken, authority, oboAssertion, cloudGraphHostName, msGraphHost, environment) {
        var _a,
          _b,
          _c,
          _d,
          _e,
          _f;
        var account = new AccountEntity;
        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
        account.clientInfo = clientInfo;
        account.homeAccountId = homeAccountId;
        var env = environment || (authority && authority.getPreferredCache());
        if (!env) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        account.environment = env;
        account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || "";
        account.oboAssertion = oboAssertion;
        if (idToken) {
          account.idTokenClaims = idToken.claims;
          account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || "";
          account.username = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username) || (((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : "");
          account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name
        }
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account
      };
      AccountEntity.createGenericAccount = function(homeAccountId, idToken, authority, oboAssertion, cloudGraphHostName, msGraphHost, environment) {
        var _a,
          _b,
          _c,
          _d;
        var account = new AccountEntity;
        account.authorityType = (authority && authority.authorityType === AuthorityType.Adfs) ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;
        account.homeAccountId = homeAccountId;
        account.realm = "";
        account.oboAssertion = oboAssertion;
        var env = environment || authority && authority.getPreferredCache();
        if (!env) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        if (idToken) {
          account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || "";
          account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || "";
          account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || "";
          account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims
        }
        account.environment = env;
        account.cloudGraphHostName = cloudGraphHostName;
        account.msGraphHost = msGraphHost;
        return account
      };
      AccountEntity.generateHomeAccountId = function(serverClientInfo, authType, logger, cryptoObj, idToken) {
        var _a;
        var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;
        if (authType === AuthorityType.Adfs) {
          return accountId
        }
        if (serverClientInfo) {
          try {
            var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
            if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
              return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid
            }
          }
          catch(e) {}
        }
        logger.verbose("No client info in response");
        return accountId
      };
      AccountEntity.isAccountEntity = function(entity) {
        if (!entity) {
          return false
        }
        return (entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("localAccountId") && entity.hasOwnProperty("username") && entity.hasOwnProperty("authorityType"))
      };
      AccountEntity.accountInfoIsEqual = function(accountA, accountB, compareClaims) {
        if (!accountA || !accountB) {
          return false
        }
        var claimsMatch = true;
        if (compareClaims) {
          var accountAClaims = (accountA.idTokenClaims || {});
          var accountBClaims = (accountB.idTokenClaims || {});
          claimsMatch = (accountAClaims.iat === accountBClaims.iat) && (accountAClaims.nonce === accountBClaims.nonce)
        }
        return (accountA.homeAccountId === accountB.homeAccountId) && (accountA.localAccountId === accountB.localAccountId) && (accountA.username === accountB.username) && (accountA.tenantId === accountB.tenantId) && (accountA.environment === accountB.environment) && claimsMatch
      };
      return AccountEntity
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthToken = (function() {
      function AuthToken(rawToken, crypto) {
        if (StringUtils.isEmpty(rawToken)) {
          throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
        }
        this.rawToken = rawToken;
        this.claims = AuthToken.extractTokenClaims(rawToken, crypto)
      }
      AuthToken.extractTokenClaims = function(encodedToken, crypto) {
        var decodedToken = StringUtils.decodeAuthToken(encodedToken);
        try {
          var base64TokenPayload = decodedToken.JWSPayload;
          var base64Decoded = crypto.base64Decode(base64TokenPayload);
          return JSON.parse(base64Decoded)
        }
        catch(err) {
          throw ClientAuthError.createTokenParsingError(err);
        }
      };
      return AuthToken
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var CacheManager = (function() {
      function CacheManager(clientId, cryptoImpl) {
        this.clientId = clientId;
        this.cryptoImpl = cryptoImpl
      }
      CacheManager.prototype.getAllAccounts = function() {
        var _this = this;
        var currentAccounts = this.getAccountsFilteredBy();
        var accountValues = Object.keys(currentAccounts).map(function(accountKey) {
            return currentAccounts[accountKey]
          });
        var numAccounts = accountValues.length;
        if (numAccounts < 1) {
          return []
        }
        else {
          var allAccounts = accountValues.map(function(value) {
              var accountEntity = CacheManager.toObject(new AccountEntity, value);
              var accountInfo = accountEntity.getAccountInfo();
              var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);
              if (idToken && !accountInfo.idTokenClaims) {
                accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims
              }
              return accountInfo
            });
          return allAccounts
        }
      };
      CacheManager.prototype.saveCacheRecord = function(cacheRecord) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!cacheRecord) {
                      throw ClientAuthError.createNullOrUndefinedCacheRecord();
                    }
                    if (!!cacheRecord.account) {
                      this.setAccount(cacheRecord.account)
                    }
                    if (!!cacheRecord.idToken) {
                      this.setIdTokenCredential(cacheRecord.idToken)
                    }
                    if (!!!cacheRecord.accessToken)
                      return [3, 2];
                    return [4, this.saveAccessToken(cacheRecord.accessToken)];
                  case 1:
                    _a.sent();
                    _a.label = 2;
                  case 2:
                    if (!!cacheRecord.refreshToken) {
                      this.setRefreshTokenCredential(cacheRecord.refreshToken)
                    }
                    if (!!cacheRecord.appMetadata) {
                      this.setAppMetadata(cacheRecord.appMetadata)
                    }
                    return [2]
                }
              })
          })
      };
      CacheManager.prototype.saveAccessToken = function(credential) {
        return __awaiter(this, void 0, void 0, function() {
            var currentTokenCache,
              currentScopes,
              currentAccessTokens,
              removedAccessTokens_1;
            var _this = this;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    currentTokenCache = this.getCredentialsFilteredBy({
                      clientId: credential.clientId, credentialType: credential.credentialType, environment: credential.environment, homeAccountId: credential.homeAccountId, realm: credential.realm, tokenType: credential.tokenType, requestedClaimsHash: credential.requestedClaimsHash
                    });
                    currentScopes = ScopeSet.fromString(credential.target);
                    currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function(key) {
                      return currentTokenCache.accessTokens[key]
                    });
                    if (!currentAccessTokens)
                      return [3, 2];
                    removedAccessTokens_1 = [];
                    currentAccessTokens.forEach(function(tokenEntity) {
                      var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
                      if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
                        removedAccessTokens_1.push(_this.removeCredential(tokenEntity))
                      }
                    });
                    return [4, Promise.all(removedAccessTokens_1)];
                  case 1:
                    _a.sent();
                    _a.label = 2;
                  case 2:
                    this.setAccessTokenCredential(credential);
                    return [2]
                }
              })
          })
      };
      CacheManager.prototype.getAccountsFilteredBy = function(accountFilter) {
        return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : "", accountFilter ? accountFilter.environment : "", accountFilter ? accountFilter.realm : "")
      };
      CacheManager.prototype.getAccountsFilteredByInternal = function(homeAccountId, environment, realm) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAccounts = {};
        allCacheKeys.forEach(function(cacheKey) {
          var entity = _this.getAccount(cacheKey);
          if (!entity) {
            return
          }
          if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
            return
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return
          }
          if (!!realm && !_this.matchRealm(entity, realm)) {
            return
          }
          matchingAccounts[cacheKey] = entity
        });
        return matchingAccounts
      };
      CacheManager.prototype.getCredentialsFilteredBy = function(filter) {
        return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.oboAssertion, filter.tokenType, filter.keyId, filter.requestedClaimsHash)
      };
      CacheManager.prototype.getCredentialsFilteredByInternal = function(homeAccountId, environment, credentialType, clientId, familyId, realm, target, oboAssertion, tokenType, keyId, requestedClaimsHash) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingCredentials = {
            idTokens: {}, accessTokens: {}, refreshTokens: {}
          };
        allCacheKeys.forEach(function(cacheKey) {
          var credType = CredentialEntity.getCredentialType(cacheKey);
          if (credType === Constants.NOT_DEFINED) {
            return
          }
          var entity = _this.getSpecificCredential(cacheKey, credType);
          if (!entity) {
            return
          }
          if (!!oboAssertion && !_this.matchOboAssertion(entity, oboAssertion)) {
            return
          }
          if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {
            return
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return
          }
          if (!!realm && !_this.matchRealm(entity, realm)) {
            return
          }
          if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {
            return
          }
          if (!!clientId && !_this.matchClientId(entity, clientId)) {
            return
          }
          if (!!familyId && !_this.matchFamilyId(entity, familyId)) {
            return
          }
          if (!!target && !_this.matchTarget(entity, target)) {
            return
          }
          if (requestedClaimsHash || entity.requestedClaimsHash) {
            if (entity.requestedClaimsHash !== requestedClaimsHash) {
              return
            }
          }
          if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
            if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {
              return
            }
            if (tokenType === exports.AuthenticationScheme.SSH) {
              if (keyId && !_this.matchKeyId(entity, keyId)) {
                return
              }
            }
          }
          var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);
          switch (credType) {
            case CredentialType.ID_TOKEN:
              matchingCredentials.idTokens[updatedCacheKey] = entity;
              break;
            case CredentialType.ACCESS_TOKEN:
            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
              matchingCredentials.accessTokens[updatedCacheKey] = entity;
              break;
            case CredentialType.REFRESH_TOKEN:
              matchingCredentials.refreshTokens[updatedCacheKey] = entity;
              break
          }
        });
        return matchingCredentials
      };
      CacheManager.prototype.getAppMetadataFilteredBy = function(filter) {
        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId)
      };
      CacheManager.prototype.getAppMetadataFilteredByInternal = function(environment, clientId) {
        var _this = this;
        var allCacheKeys = this.getKeys();
        var matchingAppMetadata = {};
        allCacheKeys.forEach(function(cacheKey) {
          if (!_this.isAppMetadata(cacheKey)) {
            return
          }
          var entity = _this.getAppMetadata(cacheKey);
          if (!entity) {
            return
          }
          if (!!environment && !_this.matchEnvironment(entity, environment)) {
            return
          }
          if (!!clientId && !_this.matchClientId(entity, clientId)) {
            return
          }
          matchingAppMetadata[cacheKey] = entity
        });
        return matchingAppMetadata
      };
      CacheManager.prototype.getAuthorityMetadataByAlias = function(host) {
        var _this = this;
        var allCacheKeys = this.getAuthorityMetadataKeys();
        var matchedEntity = null;
        allCacheKeys.forEach(function(cacheKey) {
          if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
            return
          }
          var entity = _this.getAuthorityMetadata(cacheKey);
          if (!entity) {
            return
          }
          if (entity.aliases.indexOf(host) === -1) {
            return
          }
          matchedEntity = entity
        });
        return matchedEntity
      };
      CacheManager.prototype.removeAllAccounts = function() {
        return __awaiter(this, void 0, void 0, function() {
            var allCacheKeys,
              removedAccounts;
            var _this = this;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    allCacheKeys = this.getKeys();
                    removedAccounts = [];
                    allCacheKeys.forEach(function(cacheKey) {
                      var entity = _this.getAccount(cacheKey);
                      if (!entity) {
                        return
                      }
                      removedAccounts.push(_this.removeAccount(cacheKey))
                    });
                    return [4, Promise.all(removedAccounts)];
                  case 1:
                    _a.sent();
                    return [2, true]
                }
              })
          })
      };
      CacheManager.prototype.removeAccount = function(accountKey) {
        return __awaiter(this, void 0, void 0, function() {
            var account;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    account = this.getAccount(accountKey);
                    if (!account) {
                      throw ClientAuthError.createNoAccountFoundError();
                    }
                    return [4, this.removeAccountContext(account)];
                  case 1:
                    return [2, ((_a.sent()) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT))]
                }
              })
          })
      };
      CacheManager.prototype.removeAccountContext = function(account) {
        return __awaiter(this, void 0, void 0, function() {
            var allCacheKeys,
              accountId,
              removedCredentials;
            var _this = this;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    allCacheKeys = this.getKeys();
                    accountId = account.generateAccountId();
                    removedCredentials = [];
                    allCacheKeys.forEach(function(cacheKey) {
                      var credType = CredentialEntity.getCredentialType(cacheKey);
                      if (credType === Constants.NOT_DEFINED) {
                        return
                      }
                      var cacheEntity = _this.getSpecificCredential(cacheKey, credType);
                      if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {
                        removedCredentials.push(_this.removeCredential(cacheEntity))
                      }
                    });
                    return [4, Promise.all(removedCredentials)];
                  case 1:
                    _a.sent();
                    return [2, true]
                }
              })
          })
      };
      CacheManager.prototype.removeCredential = function(credential) {
        return __awaiter(this, void 0, void 0, function() {
            var key,
              accessTokenWithAuthSchemeEntity,
              kid;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    key = credential.generateCredentialKey();
                    if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()))
                      return [3, 4];
                    if (!(credential.tokenType === exports.AuthenticationScheme.POP))
                      return [3, 4];
                    accessTokenWithAuthSchemeEntity = credential;
                    kid = accessTokenWithAuthSchemeEntity.keyId;
                    if (!kid)
                      return [3, 4];
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.cryptoImpl.removeTokenBindingKey(kid)];
                  case 2:
                    _a.sent();
                    return [3, 4];
                  case 3:
                    _a.sent();
                    throw ClientAuthError.createBindingKeyNotRemovedError();
                  case 4:
                    return [2, this.removeItem(key, CacheSchemaType.CREDENTIAL)]
                }
              })
          })
      };
      CacheManager.prototype.removeAppMetadata = function() {
        var _this = this;
        var allCacheKeys = this.getKeys();
        allCacheKeys.forEach(function(cacheKey) {
          if (_this.isAppMetadata(cacheKey)) {
            _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA)
          }
        });
        return true
      };
      CacheManager.prototype.readCacheRecord = function(account, clientId, request, environment) {
        var cachedAccount = this.readAccountFromCache(account);
        var cachedIdToken = this.readIdTokenFromCache(clientId, account);
        var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);
        var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);
        var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);
        if (cachedAccount && cachedIdToken) {
          cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims
        }
        return {
            account: cachedAccount, idToken: cachedIdToken, accessToken: cachedAccessToken, refreshToken: cachedRefreshToken, appMetadata: cachedAppMetadata
          }
      };
      CacheManager.prototype.readAccountFromCache = function(account) {
        var accountKey = AccountEntity.generateAccountCacheKey(account);
        return this.getAccount(accountKey)
      };
      CacheManager.prototype.readIdTokenFromCache = function(clientId, account) {
        var idTokenFilter = {
            homeAccountId: account.homeAccountId, environment: account.environment, credentialType: CredentialType.ID_TOKEN, clientId: clientId, realm: account.tenantId
          };
        var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);
        var idTokens = Object.keys(credentialCache.idTokens).map(function(key) {
            return credentialCache.idTokens[key]
          });
        var numIdTokens = idTokens.length;
        if (numIdTokens < 1) {
          return null
        }
        else if (numIdTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return idTokens[0]
      };
      CacheManager.prototype.readAccessTokenFromCache = function(clientId, account, request) {
        var scopes = new ScopeSet(request.scopes || []);
        var authScheme = request.authenticationScheme || exports.AuthenticationScheme.BEARER;
        var credentialType = (authScheme && authScheme.toLowerCase() !== exports.AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
        var accessTokenFilter = {
            homeAccountId: account.homeAccountId, environment: account.environment, credentialType: credentialType, clientId: clientId, realm: account.tenantId, target: scopes.printScopesLowerCase(), tokenType: authScheme, keyId: request.sshKid, requestedClaimsHash: request.requestedClaimsHash
          };
        var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);
        var accessTokens = Object.keys(credentialCache.accessTokens).map(function(key) {
            return credentialCache.accessTokens[key]
          });
        var numAccessTokens = accessTokens.length;
        if (numAccessTokens < 1) {
          return null
        }
        else if (numAccessTokens > 1) {
          throw ClientAuthError.createMultipleMatchingTokensInCacheError();
        }
        return accessTokens[0]
      };
      CacheManager.prototype.readRefreshTokenFromCache = function(clientId, account, familyRT) {
        var id = familyRT ? THE_FAMILY_ID : undefined;
        var refreshTokenFilter = {
            homeAccountId: account.homeAccountId, environment: account.environment, credentialType: CredentialType.REFRESH_TOKEN, clientId: clientId, familyId: id
          };
        var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);
        var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function(key) {
            return credentialCache.refreshTokens[key]
          });
        var numRefreshTokens = refreshTokens.length;
        if (numRefreshTokens < 1) {
          return null
        }
        return refreshTokens[0]
      };
      CacheManager.prototype.readAppMetadataFromCache = function(environment, clientId) {
        var appMetadataFilter = {
            environment: environment, clientId: clientId
          };
        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
        var appMetadataEntries = Object.keys(appMetadata).map(function(key) {
            return appMetadata[key]
          });
        var numAppMetadata = appMetadataEntries.length;
        if (numAppMetadata < 1) {
          return null
        }
        else if (numAppMetadata > 1) {
          throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
        }
        return appMetadataEntries[0]
      };
      CacheManager.prototype.isAppMetadataFOCI = function(environment, clientId) {
        var appMetadata = this.readAppMetadataFromCache(environment, clientId);
        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID)
      };
      CacheManager.prototype.matchHomeAccountId = function(entity, homeAccountId) {
        return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId)
      };
      CacheManager.prototype.matchOboAssertion = function(entity, oboAssertion) {
        return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion)
      };
      CacheManager.prototype.matchEnvironment = function(entity, environment) {
        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
          return true
        }
        return false
      };
      CacheManager.prototype.matchCredentialType = function(entity, credentialType) {
        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase())
      };
      CacheManager.prototype.matchClientId = function(entity, clientId) {
        return !!(entity.clientId && clientId === entity.clientId)
      };
      CacheManager.prototype.matchFamilyId = function(entity, familyId) {
        return !!(entity.familyId && familyId === entity.familyId)
      };
      CacheManager.prototype.matchRealm = function(entity, realm) {
        return !!(entity.realm && realm === entity.realm)
      };
      CacheManager.prototype.matchTarget = function(entity, target) {
        var isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
        if (isNotAccessTokenCredential || !entity.target) {
          return false
        }
        var entityScopeSet = ScopeSet.fromString(entity.target);
        var requestTargetScopeSet = ScopeSet.fromString(target);
        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {
          requestTargetScopeSet.removeOIDCScopes()
        }
        else {
          requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE)
        }
        return entityScopeSet.containsScopeSet(requestTargetScopeSet)
      };
      CacheManager.prototype.matchTokenType = function(entity, tokenType) {
        return !!(entity.tokenType && entity.tokenType === tokenType)
      };
      CacheManager.prototype.matchKeyId = function(entity, keyId) {
        return !!(entity.keyId && entity.keyId === keyId)
      };
      CacheManager.prototype.isAppMetadata = function(key) {
        return key.indexOf(APP_METADATA) !== -1
      };
      CacheManager.prototype.isAuthorityMetadata = function(key) {
        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1
      };
      CacheManager.prototype.generateAuthorityMetadataCacheKey = function(authority) {
        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority
      };
      CacheManager.prototype.getSpecificCredential = function(key, credType) {
        switch (credType) {
          case CredentialType.ID_TOKEN:
            {
              return this.getIdTokenCredential(key)
            }
          case CredentialType.ACCESS_TOKEN:
          case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
            {
              return this.getAccessTokenCredential(key)
            }
          case CredentialType.REFRESH_TOKEN:
            {
              return this.getRefreshTokenCredential(key)
            }
          default:
            return null
        }
      };
      CacheManager.toObject = function(obj, json) {
        for (var propertyName in json) {
          obj[propertyName] = json[propertyName]
        }
        return obj
      };
      return CacheManager
    }());
  var DefaultStorageClass = (function(_super) {
      __extends(DefaultStorageClass, _super);
      function DefaultStorageClass() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      DefaultStorageClass.prototype.setAccount = function() {
        var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getAccount = function() {
        var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setIdTokenCredential = function() {
        var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getIdTokenCredential = function() {
        var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setAccessTokenCredential = function() {
        var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getAccessTokenCredential = function() {
        var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setRefreshTokenCredential = function() {
        var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getRefreshTokenCredential = function() {
        var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setAppMetadata = function() {
        var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getAppMetadata = function() {
        var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setServerTelemetry = function() {
        var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getServerTelemetry = function() {
        var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setAuthorityMetadata = function() {
        var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getAuthorityMetadata = function() {
        var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getAuthorityMetadataKeys = function() {
        var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.setThrottlingCache = function() {
        var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getThrottlingCache = function() {
        var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.removeItem = function() {
        var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.containsKey = function() {
        var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.getKeys = function() {
        var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      DefaultStorageClass.prototype.clear = function() {
        return __awaiter(this, void 0, void 0, function() {
            var notImplErr;
            return __generator(this, function(_a) {
                notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
                throw AuthError.createUnexpectedError(notImplErr);
              })
          })
      };
      DefaultStorageClass.prototype.updateCredentialCacheKey = function() {
        var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
        throw AuthError.createUnexpectedError(notImplErr);
      };
      return DefaultStorageClass
    }(CacheManager));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
  var DEFAULT_SYSTEM_OPTIONS = {
      tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC, preventCorsPreflight: false, proxyUrl: ""
    };
  var DEFAULT_LOGGER_IMPLEMENTATION = {
      loggerCallback: function(){}, piiLoggingEnabled: false, logLevel: exports.LogLevel.Info, correlationId: ""
    };
  var DEFAULT_NETWORK_IMPLEMENTATION = {
      sendGetRequestAsync: function() {
        return __awaiter(this, void 0, void 0, function() {
            var notImplErr;
            return __generator(this, function(_a) {
                notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
                throw AuthError.createUnexpectedError(notImplErr);
              })
          })
      }, sendPostRequestAsync: function() {
          return __awaiter(this, void 0, void 0, function() {
              var notImplErr;
              return __generator(this, function(_a) {
                  notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
                  throw AuthError.createUnexpectedError(notImplErr);
                })
            })
        }
    };
  var DEFAULT_LIBRARY_INFO = {
      sku: Constants.SKU, version: version$1, cpu: "", os: ""
    };
  var DEFAULT_CLIENT_CREDENTIALS = {
      clientSecret: "", clientAssertion: undefined
    };
  var DEFAULT_AZURE_CLOUD_OPTIONS = {
      azureCloudInstance: exports.AzureCloudInstance.None, tenant: "" + Constants.DEFAULT_COMMON_TENANT
    };
  function buildClientConfiguration(_a) {
    var userAuthOptions = _a.authOptions,
      userSystemOptions = _a.systemOptions,
      userLoggerOption = _a.loggerOptions,
      storageImplementation = _a.storageInterface,
      networkImplementation = _a.networkInterface,
      cryptoImplementation = _a.cryptoInterface,
      clientCredentials = _a.clientCredentials,
      libraryInfo = _a.libraryInfo,
      serverTelemetryManager = _a.serverTelemetryManager,
      persistencePlugin = _a.persistencePlugin,
      serializableCache = _a.serializableCache;
    var loggerOptions = __assign(__assign({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
    return {
        authOptions: buildAuthOptions(userAuthOptions), systemOptions: __assign(__assign({}, DEFAULT_SYSTEM_OPTIONS), userSystemOptions), loggerOptions: loggerOptions, storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION), networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION, cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION, clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS, libraryInfo: __assign(__assign({}, DEFAULT_LIBRARY_INFO), libraryInfo), serverTelemetryManager: serverTelemetryManager || null, persistencePlugin: persistencePlugin || null, serializableCache: serializableCache || null
      }
  }
  function buildAuthOptions(authOptions) {
    return __assign({
        clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS
      }, authOptions)
  }
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ServerError = (function(_super) {
      __extends(ServerError, _super);
      function ServerError(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "ServerError";
        Object.setPrototypeOf(_this, ServerError.prototype);
        return _this
      }
      return ServerError
    }(AuthError));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ThrottlingUtils = (function() {
      function ThrottlingUtils(){}
      ThrottlingUtils.generateThrottlingStorageKey = function(thumbprint) {
        return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint)
      };
      ThrottlingUtils.preProcess = function(cacheManager, thumbprint) {
        var _a;
        var key = ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
        var value = cacheManager.getThrottlingCache(key);
        if (value) {
          if (value.throttleTime < Date.now()) {
            cacheManager.removeItem(key, CacheSchemaType.THROTTLING);
            return
          }
          throw new ServerError(((_a = value.errorCodes) === null || _a === void 0 ? void 0 : _a.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
        }
      };
      ThrottlingUtils.postProcess = function(cacheManager, thumbprint, response) {
        if (ThrottlingUtils.checkResponseStatus(response) || ThrottlingUtils.checkResponseForRetryAfter(response)) {
          var thumbprintValue = {
              throttleTime: ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])), error: response.body.error, errorCodes: response.body.error_codes, errorMessage: response.body.error_description, subError: response.body.suberror
            };
          cacheManager.setThrottlingCache(ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue)
        }
      };
      ThrottlingUtils.checkResponseStatus = function(response) {
        return response.status === 429 || response.status >= 500 && response.status < 600
      };
      ThrottlingUtils.checkResponseForRetryAfter = function(response) {
        if (response.headers) {
          return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300)
        }
        return false
      };
      ThrottlingUtils.calculateThrottleTime = function(throttleTime) {
        var time = throttleTime <= 0 ? 0 : throttleTime;
        var currentSeconds = Date.now() / 1000;
        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1000)
      };
      ThrottlingUtils.removeThrottle = function(cacheManager, clientId, request, homeAccountIdentifier) {
        var thumbprint = {
            clientId: clientId, authority: request.authority, scopes: request.scopes, homeAccountIdentifier: homeAccountIdentifier, claims: request.claims, authenticationScheme: request.authenticationScheme, resourceRequestMethod: request.resourceRequestMethod, resourceRequestUri: request.resourceRequestUri, shrClaims: request.shrClaims, sshKid: request.sshKid
          };
        var key = this.generateThrottlingStorageKey(thumbprint);
        return cacheManager.removeItem(key, CacheSchemaType.THROTTLING)
      };
      return ThrottlingUtils
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var NetworkManager = (function() {
      function NetworkManager(networkClient, cacheManager) {
        this.networkClient = networkClient;
        this.cacheManager = cacheManager
      }
      NetworkManager.prototype.sendPostRequest = function(thumbprint, tokenEndpoint, options) {
        return __awaiter(this, void 0, void 0, function() {
            var response,
              e_1;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
                  case 2:
                    response = _a.sent();
                    return [3, 4];
                  case 3:
                    e_1 = _a.sent();
                    if (e_1 instanceof AuthError) {
                      throw e_1;
                    }
                    else {
                      throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
                    }
                  case 4:
                    ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
                    return [2, response]
                }
              })
          })
      };
      return NetworkManager
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var CcsCredentialType;
  (function(CcsCredentialType) {
    CcsCredentialType["HOME_ACCOUNT_ID"] = "home_account_id";
    CcsCredentialType["UPN"] = "UPN"
  })(CcsCredentialType || (CcsCredentialType = {}));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var BaseClient = (function() {
      function BaseClient(configuration) {
        this.config = buildClientConfiguration(configuration);
        this.logger = new Logger(this.config.loggerOptions, name$1, version$1);
        this.cryptoUtils = this.config.cryptoInterface;
        this.cacheManager = this.config.storageInterface;
        this.networkClient = this.config.networkInterface;
        this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
        this.serverTelemetryManager = this.config.serverTelemetryManager;
        this.authority = this.config.authOptions.authority
      }
      BaseClient.prototype.createTokenRequestHeaders = function(ccsCred) {
        var headers = {};
        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
          switch (ccsCred.type) {
            case CcsCredentialType.HOME_ACCOUNT_ID:
              try {
                var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid
              }
              catch(e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e)
              }
              break;
            case CcsCredentialType.UPN:
              headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
              break
          }
        }
        return headers
      };
      BaseClient.prototype.executePostToTokenEndpoint = function(tokenEndpoint, queryString, headers, thumbprint) {
        return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, {
                          body: queryString, headers: headers, proxyUrl: this.config.systemOptions.proxyUrl
                        })];
                  case 1:
                    response = _a.sent();
                    if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
                      this.config.serverTelemetryManager.clearTelemetryCache()
                    }
                    return [2, response]
                }
              })
          })
      };
      BaseClient.prototype.updateAuthority = function(updatedAuthority) {
        if (!updatedAuthority.discoveryComplete()) {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
        }
        this.authority = updatedAuthority
      };
      return BaseClient
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var RequestValidator = (function() {
      function RequestValidator(){}
      RequestValidator.validateRedirectUri = function(redirectUri) {
        if (StringUtils.isEmpty(redirectUri)) {
          throw ClientConfigurationError.createRedirectUriEmptyError();
        }
      };
      RequestValidator.validatePrompt = function(prompt) {
        var promptValues = [];
        for (var value in PromptValue) {
          promptValues.push(PromptValue[value])
        }
        if (promptValues.indexOf(prompt) < 0) {
          throw ClientConfigurationError.createInvalidPromptError(prompt);
        }
      };
      RequestValidator.validateClaims = function(claims) {
        try {
          JSON.parse(claims)
        }
        catch(e) {
          throw ClientConfigurationError.createInvalidClaimsRequestError();
        }
      };
      RequestValidator.validateCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
        if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
          throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        }
        else {
          this.validateCodeChallengeMethod(codeChallengeMethod)
        }
      };
      RequestValidator.validateCodeChallengeMethod = function(codeChallengeMethod) {
        if ([CodeChallengeMethodValues.PLAIN, CodeChallengeMethodValues.S256].indexOf(codeChallengeMethod) < 0) {
          throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
        }
      };
      RequestValidator.sanitizeEQParams = function(eQParams, queryParams) {
        if (!eQParams) {
          return {}
        }
        queryParams.forEach(function(value, key) {
          if (eQParams[key]) {
            delete eQParams[key]
          }
        });
        return eQParams
      };
      return RequestValidator
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var RequestParameterBuilder = (function() {
      function RequestParameterBuilder() {
        this.parameters = new Map
      }
      RequestParameterBuilder.prototype.addResponseTypeCode = function() {
        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE))
      };
      RequestParameterBuilder.prototype.addResponseMode = function(responseMode) {
        this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent((responseMode) ? responseMode : ResponseMode.QUERY))
      };
      RequestParameterBuilder.prototype.addScopes = function(scopes, addOidcScopes) {
        if (addOidcScopes === void 0) {
          addOidcScopes = true
        }
        var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
        var scopeSet = new ScopeSet(requestScopes);
        this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()))
      };
      RequestParameterBuilder.prototype.addClientId = function(clientId) {
        this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId))
      };
      RequestParameterBuilder.prototype.addRedirectUri = function(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri))
      };
      RequestParameterBuilder.prototype.addPostLogoutRedirectUri = function(redirectUri) {
        RequestValidator.validateRedirectUri(redirectUri);
        this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri))
      };
      RequestParameterBuilder.prototype.addIdTokenHint = function(idTokenHint) {
        this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint))
      };
      RequestParameterBuilder.prototype.addDomainHint = function(domainHint) {
        this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint))
      };
      RequestParameterBuilder.prototype.addLoginHint = function(loginHint) {
        this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint))
      };
      RequestParameterBuilder.prototype.addCcsUpn = function(loginHint) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint))
      };
      RequestParameterBuilder.prototype.addCcsOid = function(clientInfo) {
        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid))
      };
      RequestParameterBuilder.prototype.addSid = function(sid) {
        this.parameters.set(SSOTypes.SID, encodeURIComponent(sid))
      };
      RequestParameterBuilder.prototype.addClaims = function(claims, clientCapabilities) {
        var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
        RequestValidator.validateClaims(mergedClaims);
        this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims))
      };
      RequestParameterBuilder.prototype.addCorrelationId = function(correlationId) {
        this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId))
      };
      RequestParameterBuilder.prototype.addLibraryInfo = function(libraryInfo) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
        this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
        this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
        this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu)
      };
      RequestParameterBuilder.prototype.addPrompt = function(prompt) {
        RequestValidator.validatePrompt(prompt);
        this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt))
      };
      RequestParameterBuilder.prototype.addState = function(state) {
        if (!StringUtils.isEmpty(state)) {
          this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state))
        }
      };
      RequestParameterBuilder.prototype.addNonce = function(nonce) {
        this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce))
      };
      RequestParameterBuilder.prototype.addCodeChallengeParams = function(codeChallenge, codeChallengeMethod) {
        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
        if (codeChallenge && codeChallengeMethod) {
          this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
          this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod))
        }
        else {
          throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
        }
      };
      RequestParameterBuilder.prototype.addAuthorizationCode = function(code) {
        this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code))
      };
      RequestParameterBuilder.prototype.addDeviceCode = function(code) {
        this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code))
      };
      RequestParameterBuilder.prototype.addRefreshToken = function(refreshToken) {
        this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken))
      };
      RequestParameterBuilder.prototype.addCodeVerifier = function(codeVerifier) {
        this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier))
      };
      RequestParameterBuilder.prototype.addClientSecret = function(clientSecret) {
        this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret))
      };
      RequestParameterBuilder.prototype.addClientAssertion = function(clientAssertion) {
        this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion))
      };
      RequestParameterBuilder.prototype.addClientAssertionType = function(clientAssertionType) {
        this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType))
      };
      RequestParameterBuilder.prototype.addOboAssertion = function(oboAssertion) {
        this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion))
      };
      RequestParameterBuilder.prototype.addRequestTokenUse = function(tokenUse) {
        this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse))
      };
      RequestParameterBuilder.prototype.addGrantType = function(grantType) {
        this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType))
      };
      RequestParameterBuilder.prototype.addClientInfo = function() {
        this.parameters.set(CLIENT_INFO, "1")
      };
      RequestParameterBuilder.prototype.addExtraQueryParameters = function(eQparams) {
        var _this = this;
        RequestValidator.sanitizeEQParams(eQparams, this.parameters);
        Object.keys(eQparams).forEach(function(key) {
          _this.parameters.set(key, eQparams[key])
        })
      };
      RequestParameterBuilder.prototype.addClientCapabilitiesToClaims = function(claims, clientCapabilities) {
        var mergedClaims;
        if (!claims) {
          mergedClaims = {}
        }
        else {
          try {
            mergedClaims = JSON.parse(claims)
          }
          catch(e) {
            throw ClientConfigurationError.createInvalidClaimsRequestError();
          }
        }
        if (clientCapabilities && clientCapabilities.length > 0) {
          if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {}
          }
          mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {values: clientCapabilities}
        }
        return JSON.stringify(mergedClaims)
      };
      RequestParameterBuilder.prototype.addUsername = function(username) {
        this.parameters.set(PasswordGrantConstants.username, username)
      };
      RequestParameterBuilder.prototype.addPassword = function(password) {
        this.parameters.set(PasswordGrantConstants.password, password)
      };
      RequestParameterBuilder.prototype.addPopToken = function(cnfString) {
        if (!StringUtils.isEmpty(cnfString)) {
          this.parameters.set(AADServerParamKeys.TOKEN_TYPE, exports.AuthenticationScheme.POP);
          this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString))
        }
      };
      RequestParameterBuilder.prototype.addSshJwk = function(sshJwkString) {
        if (!StringUtils.isEmpty(sshJwkString)) {
          this.parameters.set(AADServerParamKeys.TOKEN_TYPE, exports.AuthenticationScheme.SSH);
          this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString))
        }
      };
      RequestParameterBuilder.prototype.addServerTelemetry = function(serverTelemetryManager) {
        this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
        this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue())
      };
      RequestParameterBuilder.prototype.addThrottling = function() {
        this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE)
      };
      RequestParameterBuilder.prototype.addLogoutHint = function(logoutHint) {
        this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint))
      };
      RequestParameterBuilder.prototype.createQueryString = function() {
        var queryParameterArray = new Array;
        this.parameters.forEach(function(value, key) {
          queryParameterArray.push(key + "=" + value)
        });
        return queryParameterArray.join("&")
      };
      return RequestParameterBuilder
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var IdTokenEntity = (function(_super) {
      __extends(IdTokenEntity, _super);
      function IdTokenEntity() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      IdTokenEntity.createIdTokenEntity = function(homeAccountId, environment, idToken, clientId, tenantId, oboAssertion) {
        var idTokenEntity = new IdTokenEntity;
        idTokenEntity.credentialType = CredentialType.ID_TOKEN;
        idTokenEntity.homeAccountId = homeAccountId;
        idTokenEntity.environment = environment;
        idTokenEntity.clientId = clientId;
        idTokenEntity.secret = idToken;
        idTokenEntity.realm = tenantId;
        idTokenEntity.oboAssertion = oboAssertion;
        return idTokenEntity
      };
      IdTokenEntity.isIdTokenEntity = function(entity) {
        if (!entity) {
          return false
        }
        return (entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.ID_TOKEN)
      };
      return IdTokenEntity
    }(CredentialEntity));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var TimeUtils = (function() {
      function TimeUtils(){}
      TimeUtils.nowSeconds = function() {
        return Math.round((new Date).getTime() / 1000.0)
      };
      TimeUtils.isTokenExpired = function(expiresOn, offset) {
        var expirationSec = Number(expiresOn) || 0;
        var offsetCurrentTimeSec = TimeUtils.nowSeconds() + offset;
        return (offsetCurrentTimeSec > expirationSec)
      };
      TimeUtils.wasClockTurnedBack = function(cachedAt) {
        var cachedAtSec = Number(cachedAt);
        return cachedAtSec > TimeUtils.nowSeconds()
      };
      TimeUtils.delay = function(t, value) {
        return new Promise(function(resolve) {
            return setTimeout(function() {
                return resolve(value)
              }, t)
          })
      };
      return TimeUtils
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AccessTokenEntity = (function(_super) {
      __extends(AccessTokenEntity, _super);
      function AccessTokenEntity() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      AccessTokenEntity.createAccessTokenEntity = function(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, oboAssertion, keyId, requestedClaims, requestedClaimsHash) {
        var _a,
          _b;
        var atEntity = new AccessTokenEntity;
        atEntity.homeAccountId = homeAccountId;
        atEntity.credentialType = CredentialType.ACCESS_TOKEN;
        atEntity.secret = accessToken;
        var currentTime = TimeUtils.nowSeconds();
        atEntity.cachedAt = currentTime.toString();
        atEntity.expiresOn = expiresOn.toString();
        atEntity.extendedExpiresOn = extExpiresOn.toString();
        if (refreshOn) {
          atEntity.refreshOn = refreshOn.toString()
        }
        atEntity.environment = environment;
        atEntity.clientId = clientId;
        atEntity.realm = tenantId;
        atEntity.target = scopes;
        atEntity.oboAssertion = oboAssertion;
        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? exports.AuthenticationScheme.BEARER : tokenType;
        if (requestedClaims) {
          atEntity.requestedClaims = requestedClaims;
          atEntity.requestedClaimsHash = requestedClaimsHash
        }
        if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== exports.AuthenticationScheme.BEARER.toLowerCase()) {
          atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
          switch (atEntity.tokenType) {
            case exports.AuthenticationScheme.POP:
              var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
              if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {
                throw ClientAuthError.createTokenClaimsRequiredError();
              }
              atEntity.keyId = tokenClaims.cnf.kid;
              break;
            case exports.AuthenticationScheme.SSH:
              atEntity.keyId = keyId
          }
        }
        return atEntity
      };
      AccessTokenEntity.isAccessTokenEntity = function(entity) {
        if (!entity) {
          return false
        }
        return (entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("realm") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity.hasOwnProperty("target") && (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME))
      };
      return AccessTokenEntity
    }(CredentialEntity));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var RefreshTokenEntity = (function(_super) {
      __extends(RefreshTokenEntity, _super);
      function RefreshTokenEntity() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      RefreshTokenEntity.createRefreshTokenEntity = function(homeAccountId, environment, refreshToken, clientId, familyId, oboAssertion) {
        var rtEntity = new RefreshTokenEntity;
        rtEntity.clientId = clientId;
        rtEntity.credentialType = CredentialType.REFRESH_TOKEN;
        rtEntity.environment = environment;
        rtEntity.homeAccountId = homeAccountId;
        rtEntity.secret = refreshToken;
        rtEntity.oboAssertion = oboAssertion;
        if (familyId)
          rtEntity.familyId = familyId;
        return rtEntity
      };
      RefreshTokenEntity.isRefreshTokenEntity = function(entity) {
        if (!entity) {
          return false
        }
        return (entity.hasOwnProperty("homeAccountId") && entity.hasOwnProperty("environment") && entity.hasOwnProperty("credentialType") && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("secret") && entity["credentialType"] === CredentialType.REFRESH_TOKEN)
      };
      return RefreshTokenEntity
    }(CredentialEntity));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var InteractionRequiredServerErrorMessage = ["interaction_required", "consent_required", "login_required"];
  var InteractionRequiredAuthSubErrorMessage = ["message_only", "additional_action", "basic_action", "user_password_expired", "consent_required"];
  var InteractionRequiredAuthErrorMessage = {noTokensFoundError: {
        code: "no_tokens_found", desc: "No refresh token found in the cache. Please sign-in."
      }};
  var InteractionRequiredAuthError = (function(_super) {
      __extends(InteractionRequiredAuthError, _super);
      function InteractionRequiredAuthError(errorCode, errorMessage, subError) {
        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
        _this.name = "InteractionRequiredAuthError";
        Object.setPrototypeOf(_this, InteractionRequiredAuthError.prototype);
        return _this
      }
      InteractionRequiredAuthError.isInteractionRequiredError = function(errorCode, errorString, subError) {
        var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
        var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
        var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function(irErrorCode) {
            return errorString.indexOf(irErrorCode) > -1
          });
        return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError
      };
      InteractionRequiredAuthError.createNoTokensFoundError = function() {
        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc)
      };
      return InteractionRequiredAuthError
    }(AuthError));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var CacheRecord = (function() {
      function CacheRecord(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
        this.account = accountEntity || null;
        this.idToken = idTokenEntity || null;
        this.accessToken = accessTokenEntity || null;
        this.refreshToken = refreshTokenEntity || null;
        this.appMetadata = appMetadataEntity || null
      }
      return CacheRecord
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ProtocolUtils = (function() {
      function ProtocolUtils(){}
      ProtocolUtils.setRequestState = function(cryptoObj, userState, meta) {
        var libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);
        return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState
      };
      ProtocolUtils.generateLibraryState = function(cryptoObj, meta) {
        if (!cryptoObj) {
          throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
        }
        var stateObj = {id: cryptoObj.createNewGuid()};
        if (meta) {
          stateObj.meta = meta
        }
        var stateString = JSON.stringify(stateObj);
        return cryptoObj.base64Encode(stateString)
      };
      ProtocolUtils.parseRequestState = function(cryptoObj, state) {
        if (!cryptoObj) {
          throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
        }
        if (StringUtils.isEmpty(state)) {
          throw ClientAuthError.createInvalidStateError(state, "Null, undefined or empty state");
        }
        try {
          var splitState = state.split(Constants.RESOURCE_DELIM);
          var libraryState = splitState[0];
          var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : "";
          var libraryStateString = cryptoObj.base64Decode(libraryState);
          var libraryStateObj = JSON.parse(libraryStateString);
          return {
              userRequestState: !StringUtils.isEmpty(userState) ? userState : "", libraryState: libraryStateObj
            }
        }
        catch(e) {
          throw ClientAuthError.createInvalidStateError(state, e);
        }
      };
      return ProtocolUtils
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var UrlString = (function() {
      function UrlString(url) {
        this._urlString = url;
        if (StringUtils.isEmpty(this._urlString)) {
          throw ClientConfigurationError.createUrlEmptyError();
        }
        if (StringUtils.isEmpty(this.getHash())) {
          this._urlString = UrlString.canonicalizeUri(url)
        }
      }
      Object.defineProperty(UrlString.prototype, "urlString", {
        get: function() {
          return this._urlString
        }, enumerable: false, configurable: true
      });
      UrlString.canonicalizeUri = function(url) {
        if (url) {
          var lowerCaseUrl = url.toLowerCase();
          if (StringUtils.endsWith(lowerCaseUrl, "?")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -1)
          }
          else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
            lowerCaseUrl = lowerCaseUrl.slice(0, -2)
          }
          if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
            lowerCaseUrl += "/"
          }
          return lowerCaseUrl
        }
        return url
      };
      UrlString.prototype.validateAsUri = function() {
        var components;
        try {
          components = this.getUrlComponents()
        }
        catch(e) {
          throw ClientConfigurationError.createUrlParseError(e);
        }
        if (!components.HostNameAndPort || !components.PathSegments) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
          throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
        }
      };
      UrlString.appendQueryString = function(url, queryString) {
        if (StringUtils.isEmpty(queryString)) {
          return url
        }
        return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString
      };
      UrlString.removeHashFromUrl = function(url) {
        return UrlString.canonicalizeUri(url.split("#")[0])
      };
      UrlString.prototype.replaceTenantPath = function(tenantId) {
        var urlObject = this.getUrlComponents();
        var pathArray = urlObject.PathSegments;
        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
          pathArray[0] = tenantId
        }
        return UrlString.constructAuthorityUriFromObject(urlObject)
      };
      UrlString.prototype.getHash = function() {
        return UrlString.parseHash(this.urlString)
      };
      UrlString.prototype.getUrlComponents = function() {
        var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
        var match = this.urlString.match(regEx);
        if (!match) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
        }
        var urlComponents = {
            Protocol: match[1], HostNameAndPort: match[4], AbsolutePath: match[5], QueryString: match[7]
          };
        var pathSegments = urlComponents.AbsolutePath.split("/");
        pathSegments = pathSegments.filter(function(val) {
          return val && val.length > 0
        });
        urlComponents.PathSegments = pathSegments;
        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
          urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1)
        }
        return urlComponents
      };
      UrlString.getDomainFromUrl = function(url) {
        var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
        var match = url.match(regEx);
        if (!match) {
          throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
        }
        return match[2]
      };
      UrlString.getAbsoluteUrl = function(relativeUrl, baseUrl) {
        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
          var url = new UrlString(baseUrl);
          var baseComponents = url.getUrlComponents();
          return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl
        }
        return relativeUrl
      };
      UrlString.parseHash = function(hashString) {
        var hashIndex1 = hashString.indexOf("#");
        var hashIndex2 = hashString.indexOf("#/");
        if (hashIndex2 > -1) {
          return hashString.substring(hashIndex2 + 2)
        }
        else if (hashIndex1 > -1) {
          return hashString.substring(hashIndex1 + 1)
        }
        return ""
      };
      UrlString.constructAuthorityUriFromObject = function(urlObject) {
        return new UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"))
      };
      UrlString.getDeserializedHash = function(hash) {
        if (StringUtils.isEmpty(hash)) {
          return {}
        }
        var parsedHash = UrlString.parseHash(hash);
        var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
        if (!deserializedHash) {
          throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
        }
        return deserializedHash
      };
      UrlString.hashContainsKnownProperties = function(hash) {
        if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
          return false
        }
        var parameters = UrlString.getDeserializedHash(hash);
        return !!(parameters.code || parameters.error_description || parameters.error || parameters.state)
      };
      return UrlString
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var KeyLocation;
  (function(KeyLocation) {
    KeyLocation["SW"] = "sw";
    KeyLocation["UHW"] = "uhw"
  })(KeyLocation || (KeyLocation = {}));
  var PopTokenGenerator = (function() {
      function PopTokenGenerator(cryptoUtils) {
        this.cryptoUtils = cryptoUtils
      }
      PopTokenGenerator.prototype.generateCnf = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var reqCnf;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.generateKid(request)];
                  case 1:
                    reqCnf = _a.sent();
                    return [2, this.cryptoUtils.base64Encode(JSON.stringify(reqCnf))]
                }
              })
          })
      };
      PopTokenGenerator.prototype.generateKid = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var kidThumbprint;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.cryptoUtils.getPublicKeyThumbprint(request)];
                  case 1:
                    kidThumbprint = _a.sent();
                    return [2, {
                          kid: kidThumbprint, xms_ksl: KeyLocation.SW
                        }]
                }
              })
          })
      };
      PopTokenGenerator.prototype.signPopToken = function(accessToken, request) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
            var tokenClaims;
            return __generator(this, function(_b) {
                tokenClaims = AuthToken.extractTokenClaims(accessToken, this.cryptoUtils);
                if (!((_a = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _a === void 0 ? void 0 : _a.kid)) {
                  throw ClientAuthError.createTokenClaimsRequiredError();
                }
                return [2, this.signPayload(accessToken, tokenClaims.cnf.kid, request)]
              })
          })
      };
      PopTokenGenerator.prototype.signPayload = function(payload, kid, request, claims) {
        return __awaiter(this, void 0, void 0, function() {
            var resourceRequestMethod,
              resourceRequestUri,
              shrClaims,
              shrNonce,
              resourceUrlString,
              resourceUrlComponents;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    resourceRequestMethod = request.resourceRequestMethod,
                    resourceRequestUri = request.resourceRequestUri,
                    shrClaims = request.shrClaims,
                    shrNonce = request.shrNonce;
                    resourceUrlString = (resourceRequestUri) ? new UrlString(resourceRequestUri) : undefined;
                    resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
                    return [4, this.cryptoUtils.signJwt(__assign({
                          at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : undefined, client_claims: shrClaims || undefined
                        }, claims), kid)];
                  case 1:
                    return [2, _a.sent()]
                }
              })
          })
      };
      return PopTokenGenerator
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AppMetadataEntity = (function() {
      function AppMetadataEntity(){}
      AppMetadataEntity.prototype.generateAppMetadataKey = function() {
        return AppMetadataEntity.generateAppMetadataCacheKey(this.environment, this.clientId)
      };
      AppMetadataEntity.generateAppMetadataCacheKey = function(environment, clientId) {
        var appMetaDataKeyArray = [APP_METADATA, environment, clientId, ];
        return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase()
      };
      AppMetadataEntity.createAppMetadataEntity = function(clientId, environment, familyId) {
        var appMetadata = new AppMetadataEntity;
        appMetadata.clientId = clientId;
        appMetadata.environment = environment;
        if (familyId) {
          appMetadata.familyId = familyId
        }
        return appMetadata
      };
      AppMetadataEntity.isAppMetadataEntity = function(key, entity) {
        if (!entity) {
          return false
        }
        return (key.indexOf(APP_METADATA) === 0 && entity.hasOwnProperty("clientId") && entity.hasOwnProperty("environment"))
      };
      return AppMetadataEntity
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var TokenCacheContext = (function() {
      function TokenCacheContext(tokenCache, hasChanged) {
        this.cache = tokenCache;
        this.hasChanged = hasChanged
      }
      Object.defineProperty(TokenCacheContext.prototype, "cacheHasChanged", {
        get: function() {
          return this.hasChanged
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(TokenCacheContext.prototype, "tokenCache", {
        get: function() {
          return this.cache
        }, enumerable: false, configurable: true
      });
      return TokenCacheContext
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ResponseHandler = (function() {
      function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {
        this.clientId = clientId;
        this.cacheStorage = cacheStorage;
        this.cryptoObj = cryptoObj;
        this.logger = logger;
        this.serializableCache = serializableCache;
        this.persistencePlugin = persistencePlugin
      }
      ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function(serverResponseHash, cachedState, cryptoObj) {
        if (!serverResponseHash.state || !cachedState) {
          throw!serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
        }
        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
          throw ClientAuthError.createStateMismatchError();
        }
        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
          if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
            throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
          }
          throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
        }
        if (serverResponseHash.client_info) {
          buildClientInfo(serverResponseHash.client_info, cryptoObj)
        }
      };
      ResponseHandler.prototype.validateTokenResponse = function(serverResponse) {
        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
          if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
            throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);
          }
          var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
          throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
        }
      };
      ResponseHandler.prototype.handleServerTokenResponse = function(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, oboAssertion, handlingRefreshTokenResponse) {
        return __awaiter(this, void 0, void 0, function() {
            var idTokenObj,
              requestStateObj,
              cacheRecord,
              cacheContext,
              key,
              account;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (serverTokenResponse.id_token) {
                      idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);
                      if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
                        if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
                          throw ClientAuthError.createNonceMismatchError();
                        }
                      }
                    }
                    this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
                    if (!!authCodePayload && !!authCodePayload.state) {
                      requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state)
                    }
                    serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;
                    cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, oboAssertion, authCodePayload);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, , 5, 8]);
                    if (!(this.persistencePlugin && this.serializableCache))
                      return [3, 3];
                    this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
                    cacheContext = new TokenCacheContext(this.serializableCache, true);
                    return [4, this.persistencePlugin.beforeCacheAccess(cacheContext)];
                  case 2:
                    _a.sent();
                    _a.label = 3;
                  case 3:
                    if (handlingRefreshTokenResponse && cacheRecord.account) {
                      key = cacheRecord.account.generateAccountKey();
                      account = this.cacheStorage.getAccount(key);
                      if (!account) {
                        this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
                        return [2, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj)]
                      }
                    }
                    return [4, this.cacheStorage.saveCacheRecord(cacheRecord)];
                  case 4:
                    _a.sent();
                    return [3, 8];
                  case 5:
                    if (!(this.persistencePlugin && this.serializableCache && cacheContext))
                      return [3, 7];
                    this.logger.verbose("Persistence enabled, calling afterCacheAccess");
                    return [4, this.persistencePlugin.afterCacheAccess(cacheContext)];
                  case 6:
                    _a.sent();
                    _a.label = 7;
                  case 7:
                    return [7];
                  case 8:
                    return [2, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse.spa_code)]
                }
              })
          })
      };
      ResponseHandler.prototype.generateCacheRecord = function(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, oboAssertion, authCodePayload) {
        var env = authority.getPreferredCache();
        if (StringUtils.isEmpty(env)) {
          throw ClientAuthError.createInvalidCacheEnvironmentError();
        }
        var cachedIdToken;
        var cachedAccount;
        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
          cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING, oboAssertion);
          cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, oboAssertion, authCodePayload)
        }
        var cachedAccessToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
          var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
          var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
          var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
          var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;
          var tokenExpirationSeconds = reqTimestamp + expiresIn;
          var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
          var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;
          cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, oboAssertion, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash)
        }
        var cachedRefreshToken = null;
        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
          cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, oboAssertion)
        }
        var cachedAppMetadata = null;
        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
          cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci)
        }
        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata)
      };
      ResponseHandler.prototype.generateAccountEntity = function(serverTokenResponse, idToken, authority, oboAssertion, authCodePayload) {
        var authorityType = authority.authorityType;
        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : "";
        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : "";
        if (authorityType === AuthorityType.Adfs) {
          this.logger.verbose("Authority type is ADFS, creating ADFS account");
          return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, oboAssertion, cloudGraphHostName, msGraphhost)
        }
        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
          throw ClientAuthError.createClientInfoEmptyError();
        }
        return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, oboAssertion, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, oboAssertion, cloudGraphHostName, msGraphhost)
      };
      ResponseHandler.generateAuthenticationResult = function(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, code) {
        var _a,
          _b,
          _c;
        return __awaiter(this, void 0, void 0, function() {
            var accessToken,
              responseScopes,
              expiresOn,
              extExpiresOn,
              familyId,
              popTokenGenerator,
              uid,
              tid;
            return __generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    accessToken = "";
                    responseScopes = [];
                    expiresOn = null;
                    familyId = Constants.EMPTY_STRING;
                    if (!cacheRecord.accessToken)
                      return [3, 4];
                    if (!(cacheRecord.accessToken.tokenType === exports.AuthenticationScheme.POP))
                      return [3, 2];
                    popTokenGenerator = new PopTokenGenerator(cryptoObj);
                    return [4, popTokenGenerator.signPopToken(cacheRecord.accessToken.secret, request)];
                  case 1:
                    accessToken = _d.sent();
                    return [3, 3];
                  case 2:
                    accessToken = cacheRecord.accessToken.secret;
                    _d.label = 3;
                  case 3:
                    responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
                    expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);
                    extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);
                    _d.label = 4;
                  case 4:
                    if (cacheRecord.appMetadata) {
                      familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING
                    }
                    uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
                    tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
                    return [2, {
                          authority: authority.canonicalAuthority, uniqueId: uid, tenantId: tid, scopes: responseScopes, account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null, idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING, idTokenClaims: idTokenObj ? idTokenObj.claims : {}, accessToken: accessToken, fromCache: fromTokenCache, expiresOn: expiresOn, correlationId: request.correlationId, extExpiresOn: extExpiresOn, familyId: familyId, tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING, state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING, cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING, msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING, code: code
                        }]
                }
              })
          })
      };
      return ResponseHandler
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthorizationCodeClient = (function(_super) {
      __extends(AuthorizationCodeClient, _super);
      function AuthorizationCodeClient(configuration) {
        var _this = _super.call(this, configuration) || this;
        _this.includeRedirectUri = true;
        return _this
      }
      AuthorizationCodeClient.prototype.getAuthCodeUrl = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var queryString;
            return __generator(this, function(_a) {
                queryString = this.createAuthCodeUrlQueryString(request);
                return [2, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)]
              })
          })
      };
      AuthorizationCodeClient.prototype.acquireToken = function(request, authCodePayload) {
        return __awaiter(this, void 0, void 0, function() {
            var reqTimestamp,
              response,
              responseHandler;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.info("in acquireToken call");
                    if (!request || StringUtils.isEmpty(request.code)) {
                      throw ClientAuthError.createTokenRequestCannotBeMadeError();
                    }
                    reqTimestamp = TimeUtils.nowSeconds();
                    return [4, this.executeTokenRequest(this.authority, request)];
                  case 1:
                    response = _a.sent();
                    responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                    responseHandler.validateTokenResponse(response.body);
                    return [4, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload)];
                  case 2:
                    return [2, _a.sent()]
                }
              })
          })
      };
      AuthorizationCodeClient.prototype.handleFragmentResponse = function(hashFragment, cachedState) {
        var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
        var hashUrlString = new UrlString(hashFragment);
        var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
        if (!serverParams.code) {
          throw ClientAuthError.createNoAuthCodeInServerResponseError();
        }
        return __assign(__assign({}, serverParams), {code: serverParams.code})
      };
      AuthorizationCodeClient.prototype.getLogoutUri = function(logoutRequest) {
        if (!logoutRequest) {
          throw ClientConfigurationError.createEmptyLogoutRequestError();
        }
        var queryString = this.createLogoutUrlQueryString(logoutRequest);
        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString)
      };
      AuthorizationCodeClient.prototype.executeTokenRequest = function(authority, request) {
        return __awaiter(this, void 0, void 0, function() {
            var thumbprint,
              requestBody,
              queryParameters,
              ccsCredential,
              clientInfo,
              headers,
              endpoint;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    thumbprint = {
                      clientId: this.config.authOptions.clientId, authority: authority.canonicalAuthority, scopes: request.scopes, claims: request.claims, authenticationScheme: request.authenticationScheme, resourceRequestMethod: request.resourceRequestMethod, resourceRequestUri: request.resourceRequestUri, shrClaims: request.shrClaims, sshKid: request.sshKid
                    };
                    return [4, this.createTokenRequestBody(request)];
                  case 1:
                    requestBody = _a.sent();
                    queryParameters = this.createTokenQueryParameters(request);
                    ccsCredential = undefined;
                    if (request.clientInfo) {
                      try {
                        clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                        ccsCredential = {
                          credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid, type: CcsCredentialType.HOME_ACCOUNT_ID
                        }
                      }
                      catch(e) {
                        this.logger.verbose("Could not parse client info for CCS Header: " + e)
                      }
                    }
                    headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
                    endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + "?" + queryParameters;
                    return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)]
                }
              })
          })
      };
      AuthorizationCodeClient.prototype.createTokenQueryParameters = function(request) {
        var parameterBuilder = new RequestParameterBuilder;
        if (request.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters)
        }
        return parameterBuilder.createQueryString()
      };
      AuthorizationCodeClient.prototype.createTokenRequestBody = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var parameterBuilder,
              clientAssertion,
              popTokenGenerator,
              cnfString,
              correlationId,
              ccsCred,
              clientInfo;
            var _a;
            return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    parameterBuilder = new RequestParameterBuilder;
                    parameterBuilder.addClientId(this.config.authOptions.clientId);
                    if (!this.includeRedirectUri) {
                      RequestValidator.validateRedirectUri(request.redirectUri)
                    }
                    else {
                      parameterBuilder.addRedirectUri(request.redirectUri)
                    }
                    parameterBuilder.addScopes(request.scopes);
                    parameterBuilder.addAuthorizationCode(request.code);
                    parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                    parameterBuilder.addThrottling();
                    if (this.serverTelemetryManager) {
                      parameterBuilder.addServerTelemetry(this.serverTelemetryManager)
                    }
                    if (request.codeVerifier) {
                      parameterBuilder.addCodeVerifier(request.codeVerifier)
                    }
                    if (this.config.clientCredentials.clientSecret) {
                      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret)
                    }
                    if (this.config.clientCredentials.clientAssertion) {
                      clientAssertion = this.config.clientCredentials.clientAssertion;
                      parameterBuilder.addClientAssertion(clientAssertion.assertion);
                      parameterBuilder.addClientAssertionType(clientAssertion.assertionType)
                    }
                    parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
                    parameterBuilder.addClientInfo();
                    if (!(request.authenticationScheme === exports.AuthenticationScheme.POP))
                      return [3, 2];
                    popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                    return [4, popTokenGenerator.generateCnf(request)];
                  case 1:
                    cnfString = _b.sent();
                    parameterBuilder.addPopToken(cnfString);
                    return [3, 3];
                  case 2:
                    if (request.authenticationScheme === exports.AuthenticationScheme.SSH) {
                      if (request.sshJwk) {
                        parameterBuilder.addSshJwk(request.sshJwk)
                      }
                      else {
                        throw ClientConfigurationError.createMissingSshJwkError();
                      }
                    }
                    _b.label = 3;
                  case 3:
                    correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
                    parameterBuilder.addCorrelationId(correlationId);
                    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities)
                    }
                    ccsCred = undefined;
                    if (request.clientInfo) {
                      try {
                        clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
                        ccsCred = {
                          credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid, type: CcsCredentialType.HOME_ACCOUNT_ID
                        }
                      }
                      catch(e) {
                        this.logger.verbose("Could not parse client info for CCS Header: " + e)
                      }
                    }
                    else {
                      ccsCred = request.ccsCredential
                    }
                    if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
                      switch (ccsCred.type) {
                        case CcsCredentialType.HOME_ACCOUNT_ID:
                          try {
                            clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
                            parameterBuilder.addCcsOid(clientInfo)
                          }
                          catch(e) {
                            this.logger.verbose("Could not parse home account ID for CCS Header: " + e)
                          }
                          break;
                        case CcsCredentialType.UPN:
                          parameterBuilder.addCcsUpn(ccsCred.credential);
                          break
                      }
                    }
                    if (request.tokenBodyParameters) {
                      parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters)
                    }
                    if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
                      parameterBuilder.addExtraQueryParameters((_a = {}, _a[AADServerParamKeys.RETURN_SPA_CODE] = "1", _a))
                    }
                    return [2, parameterBuilder.createQueryString()]
                }
              })
          })
      };
      AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function(request) {
        var parameterBuilder = new RequestParameterBuilder;
        parameterBuilder.addClientId(this.config.authOptions.clientId);
        var requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);
        parameterBuilder.addScopes(requestScopes);
        parameterBuilder.addRedirectUri(request.redirectUri);
        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
        parameterBuilder.addCorrelationId(correlationId);
        parameterBuilder.addResponseMode(request.responseMode);
        parameterBuilder.addResponseTypeCode();
        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
        parameterBuilder.addClientInfo();
        if (request.codeChallenge && request.codeChallengeMethod) {
          parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod)
        }
        if (request.prompt) {
          parameterBuilder.addPrompt(request.prompt)
        }
        if (request.domainHint) {
          parameterBuilder.addDomainHint(request.domainHint)
        }
        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
          if (request.sid && request.prompt === PromptValue.NONE) {
            this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
            parameterBuilder.addSid(request.sid)
          }
          else if (request.account) {
            var accountSid = this.extractAccountSid(request.account);
            if (accountSid && request.prompt === PromptValue.NONE) {
              this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
              parameterBuilder.addSid(accountSid);
              try {
                var clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                parameterBuilder.addCcsOid(clientInfo)
              }
              catch(e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e)
              }
            }
            else if (request.loginHint) {
              this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
              parameterBuilder.addLoginHint(request.loginHint);
              parameterBuilder.addCcsUpn(request.loginHint)
            }
            else if (request.account.username) {
              this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
              parameterBuilder.addLoginHint(request.account.username);
              try {
                var clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
                parameterBuilder.addCcsOid(clientInfo)
              }
              catch(e) {
                this.logger.verbose("Could not parse home account ID for CCS Header: " + e)
              }
            }
          }
          else if (request.loginHint) {
            this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
            parameterBuilder.addLoginHint(request.loginHint);
            parameterBuilder.addCcsUpn(request.loginHint)
          }
        }
        else {
          this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints")
        }
        if (request.nonce) {
          parameterBuilder.addNonce(request.nonce)
        }
        if (request.state) {
          parameterBuilder.addState(request.state)
        }
        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
          parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities)
        }
        if (request.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.extraQueryParameters)
        }
        return parameterBuilder.createQueryString()
      };
      AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function(request) {
        var parameterBuilder = new RequestParameterBuilder;
        if (request.postLogoutRedirectUri) {
          parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri)
        }
        if (request.correlationId) {
          parameterBuilder.addCorrelationId(request.correlationId)
        }
        if (request.idTokenHint) {
          parameterBuilder.addIdTokenHint(request.idTokenHint)
        }
        if (request.state) {
          parameterBuilder.addState(request.state)
        }
        if (request.logoutHint) {
          parameterBuilder.addLogoutHint(request.logoutHint)
        }
        if (request.extraQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.extraQueryParameters)
        }
        return parameterBuilder.createQueryString()
      };
      AuthorizationCodeClient.prototype.extractAccountSid = function(account) {
        if (account.idTokenClaims) {
          var tokenClaims = account.idTokenClaims;
          return tokenClaims.sid || null
        }
        return null
      };
      return AuthorizationCodeClient
    }(BaseClient));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var RefreshTokenClient = (function(_super) {
      __extends(RefreshTokenClient, _super);
      function RefreshTokenClient(configuration) {
        return _super.call(this, configuration) || this
      }
      RefreshTokenClient.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var reqTimestamp,
              response,
              responseHandler;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    reqTimestamp = TimeUtils.nowSeconds();
                    return [4, this.executeTokenRequest(request, this.authority)];
                  case 1:
                    response = _a.sent();
                    responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
                    responseHandler.validateTokenResponse(response.body);
                    return [2, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, undefined, true)]
                }
              })
          })
      };
      RefreshTokenClient.prototype.acquireTokenByRefreshToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var isFOCI,
              noFamilyRTInCache,
              clientMismatchErrorWithFamilyRT;
            return __generator(this, function(_a) {
                if (!request) {
                  throw ClientConfigurationError.createEmptyTokenRequestError();
                }
                if (!request.account) {
                  throw ClientAuthError.createNoAccountInSilentRequestError();
                }
                isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment, this.config.authOptions.clientId);
                if (isFOCI) {
                  try {
                    return [2, this.acquireTokenWithCachedRefreshToken(request, true)]
                  }
                  catch(e) {
                    noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
                    clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
                    if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
                      return [2, this.acquireTokenWithCachedRefreshToken(request, false)]
                    }
                    else {
                      throw e;
                    }
                  }
                }
                return [2, this.acquireTokenWithCachedRefreshToken(request, false)]
              })
          })
      };
      RefreshTokenClient.prototype.acquireTokenWithCachedRefreshToken = function(request, foci) {
        return __awaiter(this, void 0, void 0, function() {
            var refreshToken,
              refreshTokenRequest;
            return __generator(this, function(_a) {
                refreshToken = this.cacheManager.readRefreshTokenFromCache(this.config.authOptions.clientId, request.account, foci);
                if (!refreshToken) {
                  throw InteractionRequiredAuthError.createNoTokensFoundError();
                }
                refreshTokenRequest = __assign(__assign({}, request), {
                  refreshToken: refreshToken.secret, authenticationScheme: request.authenticationScheme || exports.AuthenticationScheme.BEARER, ccsCredential: {
                      credential: request.account.homeAccountId, type: CcsCredentialType.HOME_ACCOUNT_ID
                    }
                });
                return [2, this.acquireToken(refreshTokenRequest)]
              })
          })
      };
      RefreshTokenClient.prototype.executeTokenRequest = function(request, authority) {
        return __awaiter(this, void 0, void 0, function() {
            var requestBody,
              queryParameters,
              headers,
              thumbprint,
              endpoint;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.createTokenRequestBody(request)];
                  case 1:
                    requestBody = _a.sent();
                    queryParameters = this.createTokenQueryParameters(request);
                    headers = this.createTokenRequestHeaders(request.ccsCredential);
                    thumbprint = {
                      clientId: this.config.authOptions.clientId, authority: authority.canonicalAuthority, scopes: request.scopes, claims: request.claims, authenticationScheme: request.authenticationScheme, resourceRequestMethod: request.resourceRequestMethod, resourceRequestUri: request.resourceRequestUri, shrClaims: request.shrClaims, sshKid: request.sshKid
                    };
                    endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParameters);
                    return [2, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)]
                }
              })
          })
      };
      RefreshTokenClient.prototype.createTokenQueryParameters = function(request) {
        var parameterBuilder = new RequestParameterBuilder;
        if (request.tokenQueryParameters) {
          parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters)
        }
        return parameterBuilder.createQueryString()
      };
      RefreshTokenClient.prototype.createTokenRequestBody = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var parameterBuilder,
              correlationId,
              clientAssertion,
              popTokenGenerator,
              cnfString,
              clientInfo;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    parameterBuilder = new RequestParameterBuilder;
                    parameterBuilder.addClientId(this.config.authOptions.clientId);
                    parameterBuilder.addScopes(request.scopes);
                    parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
                    parameterBuilder.addClientInfo();
                    parameterBuilder.addLibraryInfo(this.config.libraryInfo);
                    parameterBuilder.addThrottling();
                    if (this.serverTelemetryManager) {
                      parameterBuilder.addServerTelemetry(this.serverTelemetryManager)
                    }
                    correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
                    parameterBuilder.addCorrelationId(correlationId);
                    parameterBuilder.addRefreshToken(request.refreshToken);
                    if (this.config.clientCredentials.clientSecret) {
                      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret)
                    }
                    if (this.config.clientCredentials.clientAssertion) {
                      clientAssertion = this.config.clientCredentials.clientAssertion;
                      parameterBuilder.addClientAssertion(clientAssertion.assertion);
                      parameterBuilder.addClientAssertionType(clientAssertion.assertionType)
                    }
                    if (!(request.authenticationScheme === exports.AuthenticationScheme.POP))
                      return [3, 2];
                    popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
                    return [4, popTokenGenerator.generateCnf(request)];
                  case 1:
                    cnfString = _a.sent();
                    parameterBuilder.addPopToken(cnfString);
                    return [3, 3];
                  case 2:
                    if (request.authenticationScheme === exports.AuthenticationScheme.SSH) {
                      if (request.sshJwk) {
                        parameterBuilder.addSshJwk(request.sshJwk)
                      }
                      else {
                        throw ClientConfigurationError.createMissingSshJwkError();
                      }
                    }
                    _a.label = 3;
                  case 3:
                    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
                      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities)
                    }
                    if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
                      switch (request.ccsCredential.type) {
                        case CcsCredentialType.HOME_ACCOUNT_ID:
                          try {
                            clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
                            parameterBuilder.addCcsOid(clientInfo)
                          }
                          catch(e) {
                            this.logger.verbose("Could not parse home account ID for CCS Header: " + e)
                          }
                          break;
                        case CcsCredentialType.UPN:
                          parameterBuilder.addCcsUpn(request.ccsCredential.credential);
                          break
                      }
                    }
                    return [2, parameterBuilder.createQueryString()]
                }
              })
          })
      };
      return RefreshTokenClient
    }(BaseClient));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var SilentFlowClient = (function(_super) {
      __extends(SilentFlowClient, _super);
      function SilentFlowClient(configuration) {
        return _super.call(this, configuration) || this
      }
      SilentFlowClient.prototype.acquireToken = function(request) {
        return __awaiter(this, void 0, void 0, function() {
            var e_1,
              refreshTokenClient;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4, this.acquireCachedToken(request)];
                  case 1:
                    return [2, _a.sent()];
                  case 2:
                    e_1 = _a.sent();
                    if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
                      refreshTokenClient = new RefreshTokenClient(this.config);
                      return [2, refreshTokenClient.acquireTokenByRefreshToken(request)]
                    }
                    else {
                      throw e_1;
                    }
                  case 3:
                    return [2]
                }
              })
          })
      };
      SilentFlowClient.prototype.acquireCachedToken = function(request) {
        var _a,
          _b,
          _c,
          _d;
        return __awaiter(this, void 0, void 0, function() {
            var environment,
              cacheRecord;
            return __generator(this, function(_e) {
                switch (_e.label) {
                  case 0:
                    if (!request) {
                      throw ClientConfigurationError.createEmptyTokenRequestError();
                    }
                    if (request.forceRefresh) {
                      (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
                      this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
                      throw ClientAuthError.createRefreshRequiredError();
                    }
                    if (!request.account) {
                      throw ClientAuthError.createNoAccountInSilentRequestError();
                    }
                    environment = request.authority || this.authority.getPreferredCache();
                    cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);
                    if (!cacheRecord.accessToken) {
                      (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
                      this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
                      throw ClientAuthError.createRefreshRequiredError();
                    }
                    else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
                      (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
                      this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
                      throw ClientAuthError.createRefreshRequiredError();
                    }
                    else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
                      (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
                      this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
                      throw ClientAuthError.createRefreshRequiredError();
                    }
                    if (this.config.serverTelemetryManager) {
                      this.config.serverTelemetryManager.incrementCacheHits()
                    }
                    return [4, this.generateResultFromCacheRecord(cacheRecord, request)];
                  case 1:
                    return [2, _e.sent()]
                }
              })
          })
      };
      SilentFlowClient.prototype.generateResultFromCacheRecord = function(cacheRecord, request) {
        return __awaiter(this, void 0, void 0, function() {
            var idTokenObj;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (cacheRecord.idToken) {
                      idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface)
                    }
                    return [4, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];
                  case 1:
                    return [2, _a.sent()]
                }
              })
          })
      };
      return SilentFlowClient
    }(BaseClient));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  function isOpenIdConfigResponse(response) {
    return (response.hasOwnProperty("authorization_endpoint") && response.hasOwnProperty("token_endpoint") && response.hasOwnProperty("issuer"))
  }
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  exports.ProtocolMode = void 0;
  (function(ProtocolMode) {
    ProtocolMode["AAD"] = "AAD";
    ProtocolMode["OIDC"] = "OIDC"
  })(exports.ProtocolMode || (exports.ProtocolMode = {}));
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthorityMetadataEntity = (function() {
      function AuthorityMetadataEntity() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS
      }
      AuthorityMetadataEntity.prototype.updateCloudDiscoveryMetadata = function(metadata, fromNetwork) {
        this.aliases = metadata.aliases;
        this.preferred_cache = metadata.preferred_cache;
        this.preferred_network = metadata.preferred_network;
        this.aliasesFromNetwork = fromNetwork
      };
      AuthorityMetadataEntity.prototype.updateEndpointMetadata = function(metadata, fromNetwork) {
        this.authorization_endpoint = metadata.authorization_endpoint;
        this.token_endpoint = metadata.token_endpoint;
        this.end_session_endpoint = metadata.end_session_endpoint;
        this.issuer = metadata.issuer;
        this.endpointsFromNetwork = fromNetwork
      };
      AuthorityMetadataEntity.prototype.updateCanonicalAuthority = function(authority) {
        this.canonical_authority = authority
      };
      AuthorityMetadataEntity.prototype.resetExpiresAt = function() {
        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS
      };
      AuthorityMetadataEntity.prototype.isExpired = function() {
        return this.expiresAt <= TimeUtils.nowSeconds()
      };
      AuthorityMetadataEntity.isAuthorityMetadataEntity = function(key, entity) {
        if (!entity) {
          return false
        }
        return (key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 && entity.hasOwnProperty("aliases") && entity.hasOwnProperty("preferred_cache") && entity.hasOwnProperty("preferred_network") && entity.hasOwnProperty("canonical_authority") && entity.hasOwnProperty("authorization_endpoint") && entity.hasOwnProperty("token_endpoint") && entity.hasOwnProperty("issuer") && entity.hasOwnProperty("aliasesFromNetwork") && entity.hasOwnProperty("endpointsFromNetwork") && entity.hasOwnProperty("expiresAt"))
      };
      return AuthorityMetadataEntity
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  function isCloudInstanceDiscoveryResponse(response) {
    return (response.hasOwnProperty("tenant_discovery_endpoint") && response.hasOwnProperty("metadata"))
  }
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var RegionDiscovery = (function() {
      function RegionDiscovery(networkInterface) {
        this.networkInterface = networkInterface
      }
      RegionDiscovery.prototype.detectRegion = function(environmentRegion, regionDiscoveryMetadata, proxyUrl) {
        return __awaiter(this, void 0, void 0, function() {
            var autodetectedRegionName,
              options,
              localIMDSVersionResponse,
              currentIMDSVersion,
              currentIMDSVersionResponse;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    autodetectedRegionName = environmentRegion;
                    if (!!autodetectedRegionName)
                      return [3, 8];
                    options = RegionDiscovery.IMDS_OPTIONS;
                    if (proxyUrl) {
                      options.proxyUrl = proxyUrl
                    }
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 6, , 7]);
                    return [4, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];
                  case 2:
                    localIMDSVersionResponse = _a.sent();
                    if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                      autodetectedRegionName = localIMDSVersionResponse.body;
                      regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS
                    }
                    if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest))
                      return [3, 5];
                    return [4, this.getCurrentVersion(options)];
                  case 3:
                    currentIMDSVersion = _a.sent();
                    if (!currentIMDSVersion) {
                      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                      return [2, null]
                    }
                    return [4, this.getRegionFromIMDS(currentIMDSVersion, options)];
                  case 4:
                    currentIMDSVersionResponse = _a.sent();
                    if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
                      autodetectedRegionName = currentIMDSVersionResponse.body;
                      regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS
                    }
                    _a.label = 5;
                  case 5:
                    return [3, 7];
                  case 6:
                    _a.sent();
                    regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
                    return [2, null];
                  case 7:
                    return [3, 9];
                  case 8:
                    regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
                    _a.label = 9;
                  case 9:
                    if (!autodetectedRegionName) {
                      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION
                    }
                    return [2, autodetectedRegionName || null]
                }
              })
          })
      };
      RegionDiscovery.prototype.getRegionFromIMDS = function(version, options) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
                return [2, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + version + "&format=text", options, Constants.IMDS_TIMEOUT)]
              })
          })
      };
      RegionDiscovery.prototype.getCurrentVersion = function(options) {
        return __awaiter(this, void 0, void 0, function() {
            var response;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", options)];
                  case 1:
                    response = _a.sent();
                    if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
                      return [2, response.body["newest-versions"][0]]
                    }
                    return [2, null];
                  case 2:
                    _a.sent();
                    return [2, null];
                  case 3:
                    return [2]
                }
              })
          })
      };
      RegionDiscovery.IMDS_OPTIONS = {headers: {Metadata: "true"}};
      return RegionDiscovery
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var Authority = (function() {
      function Authority(authority, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        this.canonicalAuthority = authority;
        this._canonicalAuthority.validateAsUri();
        this.networkInterface = networkInterface;
        this.cacheManager = cacheManager;
        this.authorityOptions = authorityOptions;
        this.regionDiscovery = new RegionDiscovery(networkInterface);
        this.regionDiscoveryMetadata = {
          region_used: undefined, region_source: undefined, region_outcome: undefined
        };
        this.proxyUrl = proxyUrl || Constants.EMPTY_STRING
      }
      Object.defineProperty(Authority.prototype, "authorityType", {
        get: function() {
          var pathSegments = this.canonicalAuthorityUrlComponents.PathSegments;
          if (pathSegments.length && pathSegments[0].toLowerCase() === Constants.ADFS) {
            return AuthorityType.Adfs
          }
          return AuthorityType.Default
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "protocolMode", {
        get: function() {
          return this.authorityOptions.protocolMode
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "options", {
        get: function() {
          return this.authorityOptions
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "canonicalAuthority", {
        get: function() {
          return this._canonicalAuthority.urlString
        }, set: function(url) {
            this._canonicalAuthority = new UrlString(url);
            this._canonicalAuthority.validateAsUri();
            this._canonicalAuthorityUrlComponents = null
          }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "canonicalAuthorityUrlComponents", {
        get: function() {
          if (!this._canonicalAuthorityUrlComponents) {
            this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents()
          }
          return this._canonicalAuthorityUrlComponents
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "hostnameAndPort", {
        get: function() {
          return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase()
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "tenant", {
        get: function() {
          return this.canonicalAuthorityUrlComponents.PathSegments[0]
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "authorizationEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.authorization_endpoint);
            return this.replaceTenant(endpoint)
          }
          else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "tokenEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.token_endpoint);
            return this.replaceTenant(endpoint)
          }
          else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "deviceCodeEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
            return this.replaceTenant(endpoint)
          }
          else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "endSessionEndpoint", {
        get: function() {
          if (this.discoveryComplete()) {
            if (!this.metadata.end_session_endpoint) {
              throw ClientAuthError.createLogoutNotSupportedError();
            }
            var endpoint = this.replacePath(this.metadata.end_session_endpoint);
            return this.replaceTenant(endpoint)
          }
          else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        }, enumerable: false, configurable: true
      });
      Object.defineProperty(Authority.prototype, "selfSignedJwtAudience", {
        get: function() {
          if (this.discoveryComplete()) {
            var endpoint = this.replacePath(this.metadata.issuer);
            return this.replaceTenant(endpoint)
          }
          else {
            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
          }
        }, enumerable: false, configurable: true
      });
      Authority.prototype.replaceTenant = function(urlString) {
        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant)
      };
      Authority.prototype.replacePath = function(urlString) {
        var endpoint = urlString;
        var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
        var cachedAuthorityParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
        currentAuthorityParts.forEach(function(currentPart, index) {
          var cachedPart = cachedAuthorityParts[index];
          if (currentPart !== cachedPart) {
            endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/")
          }
        });
        return endpoint
      };
      Object.defineProperty(Authority.prototype, "defaultOpenIdConfigurationEndpoint", {
        get: function() {
          if (this.authorityType === AuthorityType.Adfs || this.protocolMode === exports.ProtocolMode.OIDC) {
            return this.canonicalAuthority + ".well-known/openid-configuration"
          }
          return this.canonicalAuthority + "v2.0/.well-known/openid-configuration"
        }, enumerable: false, configurable: true
      });
      Authority.prototype.discoveryComplete = function() {
        return !!this.metadata
      };
      Authority.prototype.resolveEndpointsAsync = function() {
        return __awaiter(this, void 0, void 0, function() {
            var metadataEntity,
              cloudDiscoverySource,
              endpointSource,
              cacheKey;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
                    if (!metadataEntity) {
                      metadataEntity = new AuthorityMetadataEntity;
                      metadataEntity.updateCanonicalAuthority(this.canonicalAuthority)
                    }
                    return [4, this.updateCloudDiscoveryMetadata(metadataEntity)];
                  case 1:
                    cloudDiscoverySource = _a.sent();
                    this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
                    return [4, this.updateEndpointMetadata(metadataEntity)];
                  case 2:
                    endpointSource = _a.sent();
                    if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
                      metadataEntity.resetExpiresAt();
                      metadataEntity.updateCanonicalAuthority(this.canonicalAuthority)
                    }
                    cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
                    this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
                    this.metadata = metadataEntity;
                    return [2]
                }
              })
          })
      };
      Authority.prototype.updateEndpointMetadata = function(metadataEntity) {
        var _a;
        return __awaiter(this, void 0, void 0, function() {
            var metadata,
              autodetectedRegionName,
              azureRegion;
            return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    metadata = this.getEndpointMetadataFromConfig();
                    if (metadata) {
                      metadataEntity.updateEndpointMetadata(metadata, false);
                      return [2, AuthorityMetadataSource.CONFIG]
                    }
                    if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
                      return [2, AuthorityMetadataSource.CACHE]
                    }
                    return [4, this.getEndpointMetadataFromNetwork()];
                  case 1:
                    metadata = _b.sent();
                    if (!metadata)
                      return [3, 4];
                    if (!((_a = this.authorityOptions.azureRegionConfiguration) === null || _a === void 0 ? void 0 : _a.azureRegion))
                      return [3, 3];
                    return [4, this.regionDiscovery.detectRegion(this.authorityOptions.azureRegionConfiguration.environmentRegion, this.regionDiscoveryMetadata, this.proxyUrl)];
                  case 2:
                    autodetectedRegionName = _b.sent();
                    azureRegion = this.authorityOptions.azureRegionConfiguration.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG ? autodetectedRegionName : this.authorityOptions.azureRegionConfiguration.azureRegion;
                    if (this.authorityOptions.azureRegionConfiguration.azureRegion === Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
                      this.regionDiscoveryMetadata.region_outcome = autodetectedRegionName ? RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL : RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED
                    }
                    else {
                      if (autodetectedRegionName) {
                        this.regionDiscoveryMetadata.region_outcome = (this.authorityOptions.azureRegionConfiguration.azureRegion === autodetectedRegionName) ? RegionDiscoveryOutcomes.CONFIGURED_MATCHES_DETECTED : RegionDiscoveryOutcomes.CONFIGURED_NOT_DETECTED
                      }
                      else {
                        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION
                      }
                    }
                    if (azureRegion) {
                      this.regionDiscoveryMetadata.region_used = azureRegion;
                      metadata = Authority.replaceWithRegionalInformation(metadata, azureRegion)
                    }
                    _b.label = 3;
                  case 3:
                    metadataEntity.updateEndpointMetadata(metadata, true);
                    return [2, AuthorityMetadataSource.NETWORK];
                  case 4:
                    throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
                }
              })
          })
      };
      Authority.prototype.isAuthoritySameType = function(metadataEntity) {
        var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
        var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length
      };
      Authority.prototype.getEndpointMetadataFromConfig = function() {
        if (this.authorityOptions.authorityMetadata) {
          try {
            return JSON.parse(this.authorityOptions.authorityMetadata)
          }
          catch(e) {
            throw ClientConfigurationError.createInvalidAuthorityMetadataError();
          }
        }
        return null
      };
      Authority.prototype.getEndpointMetadataFromNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
            var options,
              response;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    options = {};
                    if (this.proxyUrl) {
                      options.proxyUrl = this.proxyUrl
                    }
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.networkInterface.sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
                  case 2:
                    response = _a.sent();
                    return [2, isOpenIdConfigResponse(response.body) ? response.body : null];
                  case 3:
                    _a.sent();
                    return [2, null];
                  case 4:
                    return [2]
                }
              })
          })
      };
      Authority.prototype.updateCloudDiscoveryMetadata = function(metadataEntity) {
        return __awaiter(this, void 0, void 0, function() {
            var metadata;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    metadata = this.getCloudDiscoveryMetadataFromConfig();
                    if (metadata) {
                      metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
                      return [2, AuthorityMetadataSource.CONFIG]
                    }
                    if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntity.isExpired()) {
                      return [2, AuthorityMetadataSource.CACHE]
                    }
                    return [4, this.getCloudDiscoveryMetadataFromNetwork()];
                  case 1:
                    metadata = _a.sent();
                    if (metadata) {
                      metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
                      return [2, AuthorityMetadataSource.NETWORK]
                    }
                    else {
                      throw ClientConfigurationError.createUntrustedAuthorityError();
                    }
                }
              })
          })
      };
      Authority.prototype.getCloudDiscoveryMetadataFromConfig = function() {
        if (this.authorityOptions.cloudDiscoveryMetadata) {
          try {
            var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
            var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
            if (metadata) {
              return metadata
            }
          }
          catch(e) {
            throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
          }
        }
        if (this.isInKnownAuthorities()) {
          return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort)
        }
        return null
      };
      Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function() {
        return __awaiter(this, void 0, void 0, function() {
            var instanceDiscoveryEndpoint,
              options,
              match,
              response,
              metadata;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    instanceDiscoveryEndpoint = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
                    options = {};
                    if (this.proxyUrl) {
                      options.proxyUrl = this.proxyUrl
                    }
                    match = null;
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
                  case 2:
                    response = _a.sent();
                    metadata = isCloudInstanceDiscoveryResponse(response.body) ? response.body.metadata : [];
                    if (metadata.length === 0) {
                      return [2, null]
                    }
                    match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
                    return [3, 4];
                  case 3:
                    _a.sent();
                    return [2, null];
                  case 4:
                    if (!match) {
                      match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort)
                    }
                    return [2, match]
                }
              })
          })
      };
      Authority.prototype.isInKnownAuthorities = function() {
        var _this = this;
        var matches = this.authorityOptions.knownAuthorities.filter(function(authority) {
            return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort
          });
        return matches.length > 0
      };
      Authority.generateAuthority = function(authorityString, azureCloudOptions) {
        var authorityAzureCloudInstance;
        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== exports.AzureCloudInstance.None) {
          var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
          authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/"
        }
        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString
      };
      Authority.createCloudDiscoveryMetadataFromHost = function(host) {
        return {
            preferred_network: host, preferred_cache: host, aliases: [host]
          }
      };
      Authority.getCloudDiscoveryMetadataFromNetworkResponse = function(response, authority) {
        for (var i = 0; i < response.length; i++) {
          var metadata = response[i];
          if (metadata.aliases.indexOf(authority) > -1) {
            return metadata
          }
        }
        return null
      };
      Authority.prototype.getPreferredCache = function() {
        if (this.discoveryComplete()) {
          return this.metadata.preferred_cache
        }
        else {
          throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
        }
      };
      Authority.prototype.isAlias = function(host) {
        return this.metadata.aliases.indexOf(host) > -1
      };
      Authority.isPublicCloudAuthority = function(host) {
        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0
      };
      Authority.buildRegionalAuthorityString = function(host, region, queryString) {
        var authorityUrlInstance = new UrlString(host);
        authorityUrlInstance.validateAsUri();
        var authorityUrlParts = authorityUrlInstance.getUrlComponents();
        var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
          hostNameAndPort = region + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX
        }
        var url = UrlString.constructAuthorityUriFromObject(__assign(__assign({}, authorityUrlInstance.getUrlComponents()), {HostNameAndPort: hostNameAndPort})).urlString;
        if (queryString)
          return url + "?" + queryString;
        return url
      };
      Authority.replaceWithRegionalInformation = function(metadata, azureRegion) {
        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
        metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, "allowestsrnonmsi=true");
        if (metadata.end_session_endpoint) {
          metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion)
        }
        return metadata
      };
      return Authority
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthorityFactory = (function() {
      function AuthorityFactory(){}
      AuthorityFactory.createDiscoveredInstance = function(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl) {
        return __awaiter(this, void 0, void 0, function() {
            var acquireTokenAuthority,
              e_1;
            return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    acquireTokenAuthority = AuthorityFactory.createInstance(authorityUri, networkClient, cacheManager, authorityOptions, proxyUrl);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, acquireTokenAuthority.resolveEndpointsAsync()];
                  case 2:
                    _a.sent();
                    return [2, acquireTokenAuthority];
                  case 3:
                    e_1 = _a.sent();
                    throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
                  case 4:
                    return [2]
                }
              })
          })
      };
      AuthorityFactory.createInstance = function(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl) {
        if (StringUtils.isEmpty(authorityUrl)) {
          throw ClientConfigurationError.createUrlEmptyError();
        }
        return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, proxyUrl)
      };
      return AuthorityFactory
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ServerTelemetryEntity = (function() {
      function ServerTelemetryEntity() {
        this.failedRequests = [];
        this.errors = [];
        this.cacheHits = 0
      }
      ServerTelemetryEntity.isServerTelemetryEntity = function(key, entity) {
        var validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
        var validateEntity = true;
        if (entity) {
          validateEntity = entity.hasOwnProperty("failedRequests") && entity.hasOwnProperty("errors") && entity.hasOwnProperty("cacheHits")
        }
        return validateKey && validateEntity
      };
      return ServerTelemetryEntity
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ThrottlingEntity = (function() {
      function ThrottlingEntity(){}
      ThrottlingEntity.isThrottlingEntity = function(key, entity) {
        var validateKey = false;
        if (key) {
          validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0
        }
        var validateEntity = true;
        if (entity) {
          validateEntity = entity.hasOwnProperty("throttleTime")
        }
        return validateKey && validateEntity
      };
      return ThrottlingEntity
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var StubbedNetworkModule = {
      sendGetRequestAsync: function() {
        var notImplErr = "Network interface - sendGetRequestAsync() has not been implemented for the Network interface.";
        return Promise.reject(AuthError.createUnexpectedError(notImplErr))
      }, sendPostRequestAsync: function() {
          var notImplErr = "Network interface - sendPostRequestAsync() has not been implemented for the Network interface.";
          return Promise.reject(AuthError.createUnexpectedError(notImplErr))
        }
    };
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var AuthenticationHeaderParser = (function() {
      function AuthenticationHeaderParser(headers) {
        this.headers = headers
      }
      AuthenticationHeaderParser.prototype.getShrNonce = function() {
        var authenticationInfo = this.headers[HeaderNames.AuthenticationInfo];
        if (authenticationInfo) {
          var authenticationInfoChallenges = this.parseChallenges(authenticationInfo);
          if (authenticationInfoChallenges.nextnonce) {
            return authenticationInfoChallenges.nextnonce
          }
          throw ClientConfigurationError.createInvalidAuthenticationHeaderError(HeaderNames.AuthenticationInfo, "nextnonce challenge is missing.");
        }
        var wwwAuthenticate = this.headers[HeaderNames.WWWAuthenticate];
        if (wwwAuthenticate) {
          var wwwAuthenticateChallenges = this.parseChallenges(wwwAuthenticate);
          if (wwwAuthenticateChallenges.nonce) {
            return wwwAuthenticateChallenges.nonce
          }
          throw ClientConfigurationError.createInvalidAuthenticationHeaderError(HeaderNames.WWWAuthenticate, "nonce challenge is missing.");
        }
        throw ClientConfigurationError.createMissingNonceAuthenticationHeadersError();
      };
      AuthenticationHeaderParser.prototype.parseChallenges = function(header) {
        var schemeSeparator = header.indexOf(" ");
        var challenges = header.substr(schemeSeparator + 1).split(",");
        var challengeMap = {};
        challenges.forEach(function(challenge) {
          var _a = challenge.split("="),
            key = _a[0],
            value = _a[1];
          challengeMap[key] = unescape(value.replace(/['"]+/g, ""))
        });
        return challengeMap
      };
      return AuthenticationHeaderParser
    }());
  /*! @azure/msal-common v6.1.0 2022-03-07 */
  var ServerTelemetryManager = (function() {
      function ServerTelemetryManager(telemetryRequest, cacheManager) {
        this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
        this.cacheManager = cacheManager;
        this.apiId = telemetryRequest.apiId;
        this.correlationId = telemetryRequest.correlationId;
        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId
      }
      ServerTelemetryManager.prototype.generateCurrentRequestHeaderValue = function() {
        var request = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
        var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var regionDiscoveryFields = this.getRegionDiscoveryFields();
        var requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR)
      };
      ServerTelemetryManager.prototype.generateLastRequestHeaderValue = function() {
        var lastRequests = this.getLastRequests();
        var maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);
        var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        var errorCount = lastRequests.errors.length;
        var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
        var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR)
      };
      ServerTelemetryManager.prototype.cacheFailedRequest = function(error) {
        var lastRequests = this.getLastRequests();
        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
          lastRequests.failedRequests.shift();
          lastRequests.failedRequests.shift();
          lastRequests.errors.shift()
        }
        lastRequests.failedRequests.push(this.apiId, this.correlationId);
        if (!StringUtils.isEmpty(error.subError)) {
          lastRequests.errors.push(error.subError)
        }
        else if (!StringUtils.isEmpty(error.errorCode)) {
          lastRequests.errors.push(error.errorCode)
        }
        else if (!!error && error.toString()) {
          lastRequests.errors.push(error.toString())
        }
        else {
          lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR)
        }
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return
      };
      ServerTelemetryManager.prototype.incrementCacheHits = function() {
        var lastRequests = this.getLastRequests();
        lastRequests.cacheHits += 1;
        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
        return lastRequests.cacheHits
      };
      ServerTelemetryManager.prototype.getLastRequests = function() {
        var initialValue = new ServerTelemetryEntity;
        var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
        return lastRequests || initialValue
      };
      ServerTelemetryManager.prototype.clearTelemetryCache = function() {
        var lastRequests = this.getLastRequests();
        var numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);
        var errorCount = lastRequests.errors.length;
        if (numErrorsFlushed === errorCount) {
          this.cacheManager.removeItem(this.telemetryCacheKey)
        }
        else {
          var serverTelemEntity = new ServerTelemetryEntity;
          serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2);
          serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
          this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity)
        }
      };
      ServerTelemetryManager.maxErrorsToSend = function(serverTelemetryEntity) {
        var i;
        var maxErrors = 0;
        var dataSize = 0;
        var errorCount = serverTelemetryEntity.errors.length;
        for (i = 0; i < errorCount; i++) {
          var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
          var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
          var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
          dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
          if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
            maxErrors += 1
          }
          else {
            break
          }
        }
        return maxErrors
      };
      ServerTelemetryManager.prototype.getRegionDiscoveryFields = function() {
        var regionDiscoveryFields = [];
        regionDiscoveryFields.push(this.regionUsed || "");
        regionDiscoveryFields.push(this.regionSource || "");
        regionDiscoveryFields.push(this.regionOutcome || "");
        return regionDiscoveryFields.join(",")
      };
      ServerTelemetryManager.prototype.updateRegionDiscoveryMetadata = function(regionDiscoveryMetadata) {
        this.regionUsed = regionDiscoveryMetadata.region_used;
        this.regionSource = regionDiscoveryMetadata.region_source;
        this.regionOutcome = regionDiscoveryMetadata.region_outcome
      };
      ServerTelemetryManager.prototype.setCacheOutcome = function(cacheOutcome) {
        this.cacheOutcome = cacheOutcome
      };
      return ServerTelemetryManager
    }());
  var BrowserConstants = {
      INTERACTION_IN_PROGRESS_VALUE: "interaction_in_progress", INVALID_GRANT_ERROR: "invalid_grant", POPUP_WIDTH: 483, POPUP_HEIGHT: 600, POPUP_NAME_PREFIX: "msal", POLL_INTERVAL_MS: 50, MSAL_SKU: "msal.js.browser"
    };
  exports.BrowserCacheLocation = void 0;
  (function(BrowserCacheLocation) {
    BrowserCacheLocation["LocalStorage"] = "localStorage";
    BrowserCacheLocation["SessionStorage"] = "sessionStorage";
    BrowserCacheLocation["MemoryStorage"] = "memoryStorage"
  })(exports.BrowserCacheLocation || (exports.BrowserCacheLocation = {}));
  var HTTP_REQUEST_TYPE;
  (function(HTTP_REQUEST_TYPE) {
    HTTP_REQUEST_TYPE["GET"] = "GET";
    HTTP_REQUEST_TYPE["POST"] = "POST"
  })(HTTP_REQUEST_TYPE || (HTTP_REQUEST_TYPE = {}));
  exports.TemporaryCacheKeys = void 0;
  (function(TemporaryCacheKeys) {
    TemporaryCacheKeys["AUTHORITY"] = "authority";
    TemporaryCacheKeys["ACQUIRE_TOKEN_ACCOUNT"] = "acquireToken.account";
    TemporaryCacheKeys["SESSION_STATE"] = "session.state";
    TemporaryCacheKeys["REQUEST_STATE"] = "request.state";
    TemporaryCacheKeys["NONCE_IDTOKEN"] = "nonce.id_token";
    TemporaryCacheKeys["ORIGIN_URI"] = "request.origin";
    TemporaryCacheKeys["RENEW_STATUS"] = "token.renew.status";
    TemporaryCacheKeys["URL_HASH"] = "urlHash";
    TemporaryCacheKeys["REQUEST_PARAMS"] = "request.params";
    TemporaryCacheKeys["SCOPES"] = "scopes";
    TemporaryCacheKeys["INTERACTION_STATUS_KEY"] = "interaction.status";
    TemporaryCacheKeys["CCS_CREDENTIAL"] = "ccs.credential";
    TemporaryCacheKeys["CORRELATION_ID"] = "request.correlationId"
  })(exports.TemporaryCacheKeys || (exports.TemporaryCacheKeys = {}));
  var InMemoryCacheKeys;
  (function(InMemoryCacheKeys) {
    InMemoryCacheKeys["WRAPPER_SKU"] = "wrapper.sku";
    InMemoryCacheKeys["WRAPPER_VER"] = "wrapper.version"
  })(InMemoryCacheKeys || (InMemoryCacheKeys = {}));
  exports.ApiId = void 0;
  (function(ApiId) {
    ApiId[ApiId["acquireTokenRedirect"] = 861] = "acquireTokenRedirect";
    ApiId[ApiId["acquireTokenPopup"] = 862] = "acquireTokenPopup";
    ApiId[ApiId["ssoSilent"] = 863] = "ssoSilent";
    ApiId[ApiId["acquireTokenSilent_authCode"] = 864] = "acquireTokenSilent_authCode";
    ApiId[ApiId["handleRedirectPromise"] = 865] = "handleRedirectPromise";
    ApiId[ApiId["acquireTokenByCode"] = 866] = "acquireTokenByCode";
    ApiId[ApiId["acquireTokenSilent_silentFlow"] = 61] = "acquireTokenSilent_silentFlow";
    ApiId[ApiId["logout"] = 961] = "logout";
    ApiId[ApiId["logoutPopup"] = 962] = "logoutPopup"
  })(exports.ApiId || (exports.ApiId = {}));
  exports.InteractionType = void 0;
  (function(InteractionType) {
    InteractionType["Redirect"] = "redirect";
    InteractionType["Popup"] = "popup";
    InteractionType["Silent"] = "silent";
    InteractionType["None"] = "none"
  })(exports.InteractionType || (exports.InteractionType = {}));
  exports.InteractionStatus = void 0;
  (function(InteractionStatus) {
    InteractionStatus["Startup"] = "startup";
    InteractionStatus["Login"] = "login";
    InteractionStatus["Logout"] = "logout";
    InteractionStatus["AcquireToken"] = "acquireToken";
    InteractionStatus["SsoSilent"] = "ssoSilent";
    InteractionStatus["HandleRedirect"] = "handleRedirect";
    InteractionStatus["None"] = "none"
  })(exports.InteractionStatus || (exports.InteractionStatus = {}));
  var DEFAULT_REQUEST = {scopes: OIDC_DEFAULT_SCOPES};
  var KEY_FORMAT_JWK = "jwk";
  exports.WrapperSKU = void 0;
  (function(WrapperSKU) {
    WrapperSKU["React"] = "@azure/msal-react";
    WrapperSKU["Angular"] = "@azure/msal-angular"
  })(exports.WrapperSKU || (exports.WrapperSKU = {}));
  var DB_NAME = "msal.db";
  var DB_VERSION = 1;
  var DB_TABLE_NAME = DB_NAME + ".keys";
  var MathUtils = (function() {
      function MathUtils(){}
      MathUtils.decimalToHex = function(num) {
        var hex = num.toString(16);
        while (hex.length < 2) {
          hex = "0" + hex
        }
        return hex
      };
      return MathUtils
    }());
  var GuidGenerator = (function() {
      function GuidGenerator(cryptoObj) {
        this.cryptoObj = cryptoObj
      }
      GuidGenerator.prototype.generateGuid = function() {
        try {
          var buffer = new Uint8Array(16);
          this.cryptoObj.getRandomValues(buffer);
          buffer[6] |= 0x40;
          buffer[6] &= 0x4f;
          buffer[8] |= 0x80;
          buffer[8] &= 0xbf;
          return MathUtils.decimalToHex(buffer[0]) + MathUtils.decimalToHex(buffer[1]) + MathUtils.decimalToHex(buffer[2]) + MathUtils.decimalToHex(buffer[3]) + "-" + MathUtils.decimalToHex(buffer[4]) + MathUtils.decimalToHex(buffer[5]) + "-" + MathUtils.decimalToHex(buffer[6]) + MathUtils.decimalToHex(buffer[7]) + "-" + MathUtils.decimalToHex(buffer[8]) + MathUtils.decimalToHex(buffer[9]) + "-" + MathUtils.decimalToHex(buffer[10]) + MathUtils.decimalToHex(buffer[11]) + MathUtils.decimalToHex(buffer[12]) + MathUtils.decimalToHex(buffer[13]) + MathUtils.decimalToHex(buffer[14]) + MathUtils.decimalToHex(buffer[15])
        }
        catch(err) {
          var guidHolder = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
          var hex = "0123456789abcdef";
          var r = 0;
          var guidResponse = "";
          for (var i = 0; i < 36; i++) {
            if (guidHolder[i] !== "-" && guidHolder[i] !== "4") {
              r = Math.random() * 16 | 0
            }
            if (guidHolder[i] === "x") {
              guidResponse += hex[r]
            }
            else if (guidHolder[i] === "y") {
              r &= 0x3;
              r |= 0x8;
              guidResponse += hex[r]
            }
            else {
              guidResponse += guidHolder[i]
            }
          }
          return guidResponse
        }
      };
      GuidGenerator.isGuid = function(guid) {
        var regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return regexGuid.test(guid)
      };
      return GuidGenerator
    }());
  var BrowserStringUtils = (function() {
      function BrowserStringUtils(){}
      BrowserStringUtils.stringToUtf8Arr = function(sDOMStr) {
        var nChr;
        var nArrLen = 0;
        var nStrLen = sDOMStr.length;
        for (var nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {
          nChr = sDOMStr.charCodeAt(nMapIdx);
          nArrLen += nChr < 0x80 ? 1 : nChr < 0x800 ? 2 : nChr < 0x10000 ? 3 : nChr < 0x200000 ? 4 : nChr < 0x4000000 ? 5 : 6
        }
        var aBytes = new Uint8Array(nArrLen);
        for (var nIdx = 0, nChrIdx = 0; nIdx < nArrLen; nChrIdx++) {
          nChr = sDOMStr.charCodeAt(nChrIdx);
          if (nChr < 128) {
            aBytes[nIdx++] = nChr
          }
          else if (nChr < 0x800) {
            aBytes[nIdx++] = 192 + (nChr >>> 6);
            aBytes[nIdx++] = 128 + (nChr & 63)
          }
          else if (nChr < 0x10000) {
            aBytes[nIdx++] = 224 + (nChr >>> 12);
            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
            aBytes[nIdx++] = 128 + (nChr & 63)
          }
          else if (nChr < 0x200000) {
            aBytes[nIdx++] = 240 + (nChr >>> 18);
            aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
            aBytes[nIdx++] = 128 + (nChr & 63)
          }
          else if (nChr < 0x4000000) {
            aBytes[nIdx++] = 248 + (nChr >>> 24);
            aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
            aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
            aBytes[nIdx++] = 128 + (nChr & 63)
          }
          else {
            aBytes[nIdx++] = 252 + (nChr >>> 30);
            aBytes[nIdx++] = 128 + (nChr >>> 24 & 63);
            aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
            aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
            aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
            aBytes[nIdx++] = 128 + (nChr & 63)
          }
        }
        return aBytes
      };
      BrowserStringUtils.stringToArrayBuffer = function(dataString) {
        var data = new ArrayBuffer(dataString.length);
        var dataView = new Uint8Array(data);
        for (var i = 0; i < dataString.length; i++) {
          dataView[i] = dataString.charCodeAt(i)
        }
        return data
      };
      BrowserStringUtils.utf8ArrToString = function(aBytes) {
        var sView = "";
        for (var nPart = void 0, nLen = aBytes.length, nIdx = 0; nIdx < nLen; nIdx++) {
          nPart = aBytes[nIdx];
          sView += String.fromCharCode(nPart > 251 && nPart < 254 && nIdx + 5 < nLen ? (nPart - 252) * 1073741824 + (aBytes[++nIdx] - 128 << 24) + (aBytes[++nIdx] - 128 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128 : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ? (nPart - 248 << 24) + (aBytes[++nIdx] - 128 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128 : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ? (nPart - 240 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128 : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ? (nPart - 224 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128 : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ? (nPart - 192 << 6) + aBytes[++nIdx] - 128 : nPart)
        }
        return sView
      };
      return BrowserStringUtils
    }());
  var Base64Encode = (function() {
      function Base64Encode(){}
      Base64Encode.prototype.urlEncode = function(input) {
        return encodeURIComponent(this.encode(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"))
      };
      Base64Encode.prototype.urlEncodeArr = function(inputArr) {
        return this.base64EncArr(inputArr).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
      };
      Base64Encode.prototype.encode = function(input) {
        var inputUtf8Arr = BrowserStringUtils.stringToUtf8Arr(input);
        return this.base64EncArr(inputUtf8Arr)
      };
      Base64Encode.prototype.base64EncArr = function(aBytes) {
        var eqLen = (3 - (aBytes.length % 3)) % 3;
        var sB64Enc = "";
        for (var nMod3 = void 0, nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
          nMod3 = nIdx % 3;
          nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
          if (nMod3 === 2 || aBytes.length - nIdx === 1) {
            sB64Enc += String.fromCharCode(this.uint6ToB64(nUint24 >>> 18 & 63), this.uint6ToB64(nUint24 >>> 12 & 63), this.uint6ToB64(nUint24 >>> 6 & 63), this.uint6ToB64(nUint24 & 63));
            nUint24 = 0
          }
        }
        return eqLen === 0 ? sB64Enc : sB64Enc.substring(0, sB64Enc.length - eqLen) + (eqLen === 1 ? "=" : "==")
      };
      Base64Encode.prototype.uint6ToB64 = function(nUint6) {
        return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65
      };
      return Base64Encode
    }());
  var Base64Decode = (function() {
      function Base64Decode(){}
      Base64Decode.prototype.decode = function(input) {
        var encodedString = input.replace(/-/g, "+").replace(/_/g, "/");
        switch (encodedString.length % 4) {
          case 0:
            break;
          case 2:
            encodedString += "==";
            break;
          case 3:
            encodedString += "=";
            break;
          default:
            throw new Error("Invalid base64 string");
        }
        var inputUtf8Arr = this.base64DecToArr(encodedString);
        return BrowserStringUtils.utf8ArrToString(inputUtf8Arr)
      };
      Base64Decode.prototype.base64DecToArr = function(base64String, nBlockSize) {
        var sB64Enc = base64String.replace(/[^A-Za-z0-9\+\/]/g, "");
        var nInLen = sB64Enc.length;
        var nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2;
        var aBytes = new Uint8Array(nOutLen);
        for (var nMod3 = void 0, nMod4 = void 0, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
          nMod4 = nInIdx & 3;
          nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
          if (nMod4 === 3 || nInLen - nInIdx === 1) {
            for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
              aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255
            }
            nUint24 = 0
          }
        }
        return aBytes
      };
      Base64Decode.prototype.b64ToUint6 = function(charNum) {
        return charNum > 64 && charNum < 91 ? charNum - 65 : charNum > 96 && charNum < 123 ? charNum - 71 : charNum > 47 && charNum < 58 ? charNum + 4 : charNum === 43 ? 62 : charNum === 47 ? 63 : 0
      };
      return Base64Decode
    }());
  var BrowserAuthErrorMessage = {
      pkceNotGenerated: {
        code: "pkce_not_created", desc: "The PKCE code challenge and verifier could not be generated."
      }, cryptoDoesNotExist: {
          code: "crypto_nonexistent", desc: "The crypto object or function is not available."
        }, httpMethodNotImplementedError: {
          code: "http_method_not_implemented", desc: "The HTTP method given has not been implemented in this library."
        }, emptyNavigateUriError: {
          code: "empty_navigate_uri", desc: "Navigation URI is empty. Please check stack trace for more info."
        }, hashEmptyError: {
          code: "hash_empty_error", desc: "Hash value cannot be processed because it is empty. Please verify that your redirectUri is not clearing the hash."
        }, hashDoesNotContainStateError: {
          code: "no_state_in_hash", desc: "Hash does not contain state. Please verify that the request originated from msal."
        }, hashDoesNotContainKnownPropertiesError: {
          code: "hash_does_not_contain_known_properties", desc: "Hash does not contain known properites. Please verify that your redirectUri is not changing the hash."
        }, unableToParseStateError: {
          code: "unable_to_parse_state", desc: "Unable to parse state. Please verify that the request originated from msal."
        }, stateInteractionTypeMismatchError: {
          code: "state_interaction_type_mismatch", desc: "Hash contains state but the interaction type does not match the caller."
        }, interactionInProgress: {
          code: "interaction_in_progress", desc: "Interaction is currently in progress. Please ensure that this interaction has been completed before calling an interactive API.  For more visit: aka.ms/msaljs/browser-errors."
        }, popupWindowError: {
          code: "popup_window_error", desc: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser."
        }, emptyWindowError: {
          code: "empty_window_error", desc: "window.open returned null or undefined window object."
        }, userCancelledError: {
          code: "user_cancelled", desc: "User cancelled the flow."
        }, monitorPopupTimeoutError: {
          code: "monitor_window_timeout", desc: "Token acquisition in popup failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
        }, monitorIframeTimeoutError: {
          code: "monitor_window_timeout", desc: "Token acquisition in iframe failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
        }, redirectInIframeError: {
          code: "redirect_in_iframe", desc: "Code flow is not supported inside an iframe. Please ensure you are using MSAL.js in a top frame of the window if using the redirect APIs, or use the popup APIs."
        }, blockTokenRequestsInHiddenIframeError: {
          code: "block_iframe_reload", desc: "Request was blocked inside an iframe because MSAL detected an authentication response. For more visit: aka.ms/msaljs/browser-errors"
        }, blockAcquireTokenInPopupsError: {
          code: "block_nested_popups", desc: "Request was blocked inside a popup because MSAL detected it was running in a popup."
        }, iframeClosedPrematurelyError: {
          code: "iframe_closed_prematurely", desc: "The iframe being monitored was closed prematurely."
        }, silentLogoutUnsupportedError: {
          code: "silent_logout_unsupported", desc: "Silent logout not supported. Please call logoutRedirect or logoutPopup instead."
        }, noAccountError: {
          code: "no_account_error", desc: "No account object provided to acquireTokenSilent and no active account has been set. Please call setActiveAccount or provide an account on the request."
        }, silentPromptValueError: {
          code: "silent_prompt_value_error", desc: "The value given for the prompt value is not valid for silent requests - must be set to 'none'."
        }, noTokenRequestCacheError: {
          code: "no_token_request_cache_error", desc: "No token request found in cache."
        }, unableToParseTokenRequestCacheError: {
          code: "unable_to_parse_token_request_cache_error", desc: "The cached token request could not be parsed."
        }, noCachedAuthorityError: {
          code: "no_cached_authority_error", desc: "No cached authority found."
        }, authRequestNotSet: {
          code: "auth_request_not_set_error", desc: "Auth Request not set. Please ensure initiateAuthRequest was called from the InteractionHandler"
        }, invalidCacheType: {
          code: "invalid_cache_type", desc: "Invalid cache type"
        }, notInBrowserEnvironment: {
          code: "non_browser_environment", desc: "Login and token requests are not supported in non-browser environments."
        }, databaseNotOpen: {
          code: "database_not_open", desc: "Database is not open!"
        }, noNetworkConnectivity: {
          code: "no_network_connectivity", desc: "No network connectivity. Check your internet connection."
        }, postRequestFailed: {
          code: "post_request_failed", desc: "Network request failed: If the browser threw a CORS error, check that the redirectUri is registered in the Azure App Portal as type 'SPA'"
        }, getRequestFailed: {
          code: "get_request_failed", desc: "Network request failed. Please check the network trace to determine root cause."
        }, failedToParseNetworkResponse: {
          code: "failed_to_parse_response", desc: "Failed to parse network response. Check network trace."
        }, unableToLoadTokenError: {
          code: "unable_to_load_token", desc: "Error loading token to cache."
        }, signingKeyNotFoundInStorage: {
          code: "crypto_key_not_found", desc: "Cryptographic Key or Keypair not found in browser storage."
        }, authCodeRequired: {
          code: "auth_code_required", desc: "An authorization code must be provided (as the `code` property on the request) to this flow."
        }, databaseUnavailable: {
          code: "database_unavailable", desc: "IndexedDB, which is required for persistent cryptographic key storage, is unavailable. This may be caused by browser privacy features which block persistent storage in third-party contexts."
        }
    };
  var BrowserAuthError = (function(_super) {
      __extends$1(BrowserAuthError, _super);
      function BrowserAuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        Object.setPrototypeOf(_this, BrowserAuthError.prototype);
        _this.name = "BrowserAuthError";
        return _this
      }
      BrowserAuthError.createPkceNotGeneratedError = function(errDetail) {
        return new BrowserAuthError(BrowserAuthErrorMessage.pkceNotGenerated.code, BrowserAuthErrorMessage.pkceNotGenerated.desc + " Detail:" + errDetail)
      };
      BrowserAuthError.createCryptoNotAvailableError = function(errDetail) {
        return new BrowserAuthError(BrowserAuthErrorMessage.cryptoDoesNotExist.code, BrowserAuthErrorMessage.cryptoDoesNotExist.desc + " Detail:" + errDetail)
      };
      BrowserAuthError.createHttpMethodNotImplementedError = function(method) {
        return new BrowserAuthError(BrowserAuthErrorMessage.httpMethodNotImplementedError.code, BrowserAuthErrorMessage.httpMethodNotImplementedError.desc + " Given Method: " + method)
      };
      BrowserAuthError.createEmptyNavigationUriError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.emptyNavigateUriError.code, BrowserAuthErrorMessage.emptyNavigateUriError.desc)
      };
      BrowserAuthError.createEmptyHashError = function(hashValue) {
        return new BrowserAuthError(BrowserAuthErrorMessage.hashEmptyError.code, BrowserAuthErrorMessage.hashEmptyError.desc + " Given Url: " + hashValue)
      };
      BrowserAuthError.createHashDoesNotContainStateError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.hashDoesNotContainStateError.code, BrowserAuthErrorMessage.hashDoesNotContainStateError.desc)
      };
      BrowserAuthError.createHashDoesNotContainKnownPropertiesError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.hashDoesNotContainKnownPropertiesError.code, BrowserAuthErrorMessage.hashDoesNotContainKnownPropertiesError.desc)
      };
      BrowserAuthError.createUnableToParseStateError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.unableToParseStateError.code, BrowserAuthErrorMessage.unableToParseStateError.desc)
      };
      BrowserAuthError.createStateInteractionTypeMismatchError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.stateInteractionTypeMismatchError.code, BrowserAuthErrorMessage.stateInteractionTypeMismatchError.desc)
      };
      BrowserAuthError.createInteractionInProgressError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.interactionInProgress.code, BrowserAuthErrorMessage.interactionInProgress.desc)
      };
      BrowserAuthError.createPopupWindowError = function(errDetail) {
        var errorMessage = BrowserAuthErrorMessage.popupWindowError.desc;
        errorMessage = !StringUtils.isEmpty(errDetail) ? errorMessage + " Details: " + errDetail : errorMessage;
        return new BrowserAuthError(BrowserAuthErrorMessage.popupWindowError.code, errorMessage)
      };
      BrowserAuthError.createEmptyWindowCreatedError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.emptyWindowError.code, BrowserAuthErrorMessage.emptyWindowError.desc)
      };
      BrowserAuthError.createUserCancelledError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.userCancelledError.code, BrowserAuthErrorMessage.userCancelledError.desc)
      };
      BrowserAuthError.createMonitorPopupTimeoutError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.monitorPopupTimeoutError.code, BrowserAuthErrorMessage.monitorPopupTimeoutError.desc)
      };
      BrowserAuthError.createMonitorIframeTimeoutError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.monitorIframeTimeoutError.code, BrowserAuthErrorMessage.monitorIframeTimeoutError.desc)
      };
      BrowserAuthError.createRedirectInIframeError = function(windowParentCheck) {
        return new BrowserAuthError(BrowserAuthErrorMessage.redirectInIframeError.code, BrowserAuthErrorMessage.redirectInIframeError.desc + " (window.parent !== window) => " + windowParentCheck)
      };
      BrowserAuthError.createBlockReloadInHiddenIframeError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.blockTokenRequestsInHiddenIframeError.code, BrowserAuthErrorMessage.blockTokenRequestsInHiddenIframeError.desc)
      };
      BrowserAuthError.createBlockAcquireTokenInPopupsError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.blockAcquireTokenInPopupsError.code, BrowserAuthErrorMessage.blockAcquireTokenInPopupsError.desc)
      };
      BrowserAuthError.createIframeClosedPrematurelyError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.iframeClosedPrematurelyError.code, BrowserAuthErrorMessage.iframeClosedPrematurelyError.desc)
      };
      BrowserAuthError.createSilentLogoutUnsupportedError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.silentLogoutUnsupportedError.code, BrowserAuthErrorMessage.silentLogoutUnsupportedError.desc)
      };
      BrowserAuthError.createNoAccountError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.noAccountError.code, BrowserAuthErrorMessage.noAccountError.desc)
      };
      BrowserAuthError.createSilentPromptValueError = function(givenPrompt) {
        return new BrowserAuthError(BrowserAuthErrorMessage.silentPromptValueError.code, BrowserAuthErrorMessage.silentPromptValueError.desc + " Given value: " + givenPrompt)
      };
      BrowserAuthError.createUnableToParseTokenRequestCacheError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.unableToParseTokenRequestCacheError.code, BrowserAuthErrorMessage.unableToParseTokenRequestCacheError.desc)
      };
      BrowserAuthError.createNoTokenRequestCacheError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.noTokenRequestCacheError.code, BrowserAuthErrorMessage.noTokenRequestCacheError.desc)
      };
      BrowserAuthError.createAuthRequestNotSetError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.authRequestNotSet.code, BrowserAuthErrorMessage.authRequestNotSet.desc)
      };
      BrowserAuthError.createNoCachedAuthorityError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.noCachedAuthorityError.code, BrowserAuthErrorMessage.noCachedAuthorityError.desc)
      };
      BrowserAuthError.createInvalidCacheTypeError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.invalidCacheType.code, "" + BrowserAuthErrorMessage.invalidCacheType.desc)
      };
      BrowserAuthError.createNonBrowserEnvironmentError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.notInBrowserEnvironment.code, BrowserAuthErrorMessage.notInBrowserEnvironment.desc)
      };
      BrowserAuthError.createDatabaseNotOpenError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.databaseNotOpen.code, BrowserAuthErrorMessage.databaseNotOpen.desc)
      };
      BrowserAuthError.createNoNetworkConnectivityError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.noNetworkConnectivity.code, BrowserAuthErrorMessage.noNetworkConnectivity.desc)
      };
      BrowserAuthError.createPostRequestFailedError = function(errorDesc, endpoint) {
        return new BrowserAuthError(BrowserAuthErrorMessage.postRequestFailed.code, BrowserAuthErrorMessage.postRequestFailed.desc + " | Network client threw: " + errorDesc + " | Attempted to reach: " + endpoint.split("?")[0])
      };
      BrowserAuthError.createGetRequestFailedError = function(errorDesc, endpoint) {
        return new BrowserAuthError(BrowserAuthErrorMessage.getRequestFailed.code, BrowserAuthErrorMessage.getRequestFailed.desc + " | Network client threw: " + errorDesc + " | Attempted to reach: " + endpoint.split("?")[0])
      };
      BrowserAuthError.createFailedToParseNetworkResponseError = function(endpoint) {
        return new BrowserAuthError(BrowserAuthErrorMessage.failedToParseNetworkResponse.code, BrowserAuthErrorMessage.failedToParseNetworkResponse.desc + " | Attempted to reach: " + endpoint.split("?")[0])
      };
      BrowserAuthError.createUnableToLoadTokenError = function(errorDetail) {
        return new BrowserAuthError(BrowserAuthErrorMessage.unableToLoadTokenError.code, BrowserAuthErrorMessage.unableToLoadTokenError.desc + " | " + errorDetail)
      };
      BrowserAuthError.createSigningKeyNotFoundInStorageError = function(keyId) {
        return new BrowserAuthError(BrowserAuthErrorMessage.signingKeyNotFoundInStorage.code, BrowserAuthErrorMessage.signingKeyNotFoundInStorage.desc + " | No match found for KeyId: " + keyId)
      };
      BrowserAuthError.createAuthCodeRequiredError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.authCodeRequired.code, BrowserAuthErrorMessage.authCodeRequired.desc)
      };
      BrowserAuthError.createDatabaseUnavailableError = function() {
        return new BrowserAuthError(BrowserAuthErrorMessage.databaseUnavailable.code, BrowserAuthErrorMessage.databaseUnavailable.desc)
      };
      return BrowserAuthError
    }(AuthError));
  var RANDOM_BYTE_ARR_LENGTH = 32;
  var PkceGenerator = (function() {
      function PkceGenerator(cryptoObj) {
        this.base64Encode = new Base64Encode;
        this.cryptoObj = cryptoObj
      }
      PkceGenerator.prototype.generateCodes = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var codeVerifier,
              codeChallenge;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    codeVerifier = this.generateCodeVerifier();
                    return [4, this.generateCodeChallengeFromVerifier(codeVerifier)];
                  case 1:
                    codeChallenge = _a.sent();
                    return [2, {
                          verifier: codeVerifier, challenge: codeChallenge
                        }]
                }
              })
          })
      };
      PkceGenerator.prototype.generateCodeVerifier = function() {
        try {
          var buffer = new Uint8Array(RANDOM_BYTE_ARR_LENGTH);
          this.cryptoObj.getRandomValues(buffer);
          var pkceCodeVerifierB64 = this.base64Encode.urlEncodeArr(buffer);
          return pkceCodeVerifierB64
        }
        catch(e) {
          throw BrowserAuthError.createPkceNotGeneratedError(e);
        }
      };
      PkceGenerator.prototype.generateCodeChallengeFromVerifier = function(pkceCodeVerifier) {
        return __awaiter$1(this, void 0, void 0, function() {
            var pkceHashedCodeVerifier,
              e_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4, this.cryptoObj.sha256Digest(pkceCodeVerifier)];
                  case 1:
                    pkceHashedCodeVerifier = _a.sent();
                    return [2, this.base64Encode.urlEncodeArr(new Uint8Array(pkceHashedCodeVerifier))];
                  case 2:
                    e_1 = _a.sent();
                    throw BrowserAuthError.createPkceNotGeneratedError(e_1);
                  case 3:
                    return [2]
                }
              })
          })
      };
      return PkceGenerator
    }());
  var PKCS1_V15_KEYGEN_ALG = "RSASSA-PKCS1-v1_5";
  var S256_HASH_ALG = "SHA-256";
  var MODULUS_LENGTH = 2048;
  var PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);
  var BrowserCrypto = (function() {
      function BrowserCrypto(logger) {
        this.logger = logger;
        if (!(this.hasCryptoAPI())) {
          throw BrowserAuthError.createCryptoNotAvailableError("Browser crypto or msCrypto object not available.");
        }
        this._keygenAlgorithmOptions = {
          name: PKCS1_V15_KEYGEN_ALG, hash: S256_HASH_ALG, modulusLength: MODULUS_LENGTH, publicExponent: PUBLIC_EXPONENT
        }
      }
      BrowserCrypto.prototype.sha256Digest = function(dataString) {
        return __awaiter$1(this, void 0, void 0, function() {
            var data;
            return __generator$1(this, function(_a) {
                data = BrowserStringUtils.stringToUtf8Arr(dataString);
                return [2, this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data)]
              })
          })
      };
      BrowserCrypto.prototype.getRandomValues = function(dataBuffer) {
        var cryptoObj = window["msCrypto"] || window.crypto;
        if (!cryptoObj.getRandomValues) {
          throw BrowserAuthError.createCryptoNotAvailableError("getRandomValues does not exist.");
        }
        cryptoObj.getRandomValues(dataBuffer)
      };
      BrowserCrypto.prototype.generateKeyPair = function(extractable, usages) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, (this.hasIECrypto() ? this.msCryptoGenerateKey(extractable, usages) : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages))]
              })
          })
      };
      BrowserCrypto.prototype.exportJwk = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key)]
              })
          })
      };
      BrowserCrypto.prototype.importJwk = function(key, extractable, usages) {
        return __awaiter$1(this, void 0, void 0, function() {
            var keyString,
              keyBuffer;
            return __generator$1(this, function(_a) {
                keyString = BrowserCrypto.getJwkString(key);
                keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);
                return [2, this.hasIECrypto() ? this.msCryptoImportKey(keyBuffer, extractable, usages) : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages)]
              })
          })
      };
      BrowserCrypto.prototype.sign = function(key, data) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, this.hasIECrypto() ? this.msCryptoSign(key, data) : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data)]
              })
          })
      };
      BrowserCrypto.prototype.hasCryptoAPI = function() {
        return this.hasIECrypto() || this.hasBrowserCrypto()
      };
      BrowserCrypto.prototype.hasIECrypto = function() {
        return "msCrypto" in window
      };
      BrowserCrypto.prototype.hasBrowserCrypto = function() {
        return "crypto" in window
      };
      BrowserCrypto.prototype.getSubtleCryptoDigest = function(algorithm, data) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, window.crypto.subtle.digest(algorithm, data)]
              })
          })
      };
      BrowserCrypto.prototype.getMSCryptoDigest = function(algorithm, data) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var digestOperation = window["msCrypto"].subtle.digest(algorithm, data.buffer);
                      digestOperation.addEventListener("complete", function(e) {
                        resolve(e.target.result)
                      });
                      digestOperation.addEventListener("error", function(error) {
                        reject(error)
                      })
                    })]
              })
          })
      };
      BrowserCrypto.prototype.msCryptoGenerateKey = function(extractable, usages) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var msGenerateKey = window["msCrypto"].subtle.generateKey(_this._keygenAlgorithmOptions, extractable, usages);
                      msGenerateKey.addEventListener("complete", function(e) {
                        resolve(e.target.result)
                      });
                      msGenerateKey.addEventListener("error", function(error) {
                        reject(error)
                      })
                    })]
              })
          })
      };
      BrowserCrypto.prototype.msCryptoExportJwk = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var msExportKey = window["msCrypto"].subtle.exportKey(KEY_FORMAT_JWK, key);
                      msExportKey.addEventListener("complete", function(e) {
                        var resultBuffer = e.target.result;
                        var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\r/g, "").replace(/\n/g, "").replace(/\t/g, "").split(" ").join("").replace("\u0000", "");
                        try {
                          resolve(JSON.parse(resultString))
                        }
                        catch(e) {
                          reject(e)
                        }
                      });
                      msExportKey.addEventListener("error", function(error) {
                        reject(error)
                      })
                    })]
              })
          })
      };
      BrowserCrypto.prototype.msCryptoImportKey = function(keyBuffer, extractable, usages) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var msImportKey = window["msCrypto"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, _this._keygenAlgorithmOptions, extractable, usages);
                      msImportKey.addEventListener("complete", function(e) {
                        resolve(e.target.result)
                      });
                      msImportKey.addEventListener("error", function(error) {
                        reject(error)
                      })
                    })]
              })
          })
      };
      BrowserCrypto.prototype.msCryptoSign = function(key, data) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var msSign = window["msCrypto"].subtle.sign(_this._keygenAlgorithmOptions, key, data);
                      msSign.addEventListener("complete", function(e) {
                        resolve(e.target.result)
                      });
                      msSign.addEventListener("error", function(error) {
                        reject(error)
                      })
                    })]
              })
          })
      };
      BrowserCrypto.getJwkString = function(jwk) {
        return JSON.stringify(jwk, Object.keys(jwk).sort())
      };
      return BrowserCrypto
    }());
  var DatabaseStorage = (function() {
      function DatabaseStorage() {
        this.dbName = DB_NAME;
        this.version = DB_VERSION;
        this.tableName = DB_TABLE_NAME;
        this.dbOpen = false
      }
      DatabaseStorage.prototype.open = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var openDB = window.indexedDB.open(_this.dbName, _this.version);
                      openDB.addEventListener("upgradeneeded", function(e) {
                        var event = e;
                        event.target.result.createObjectStore(_this.tableName)
                      });
                      openDB.addEventListener("success", function(e) {
                        var event = e;
                        _this.db = event.target.result;
                        _this.dbOpen = true;
                        resolve()
                      });
                      openDB.addEventListener("error", function() {
                        return reject(BrowserAuthError.createDatabaseUnavailableError())
                      })
                    })]
              })
          })
      };
      DatabaseStorage.prototype.validateDbIsOpen = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!!this.dbOpen)
                      return [3, 2];
                    return [4, this.open()];
                  case 1:
                    return [2, _a.sent()];
                  case 2:
                    return [2]
                }
              })
          })
      };
      DatabaseStorage.prototype.getItem = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.validateDbIsOpen()];
                  case 1:
                    _a.sent();
                    return [2, new Promise(function(resolve, reject) {
                          if (!_this.db) {
                            return reject(BrowserAuthError.createDatabaseNotOpenError())
                          }
                          var transaction = _this.db.transaction([_this.tableName], "readonly");
                          var objectStore = transaction.objectStore(_this.tableName);
                          var dbGet = objectStore.get(key);
                          dbGet.addEventListener("success", function(e) {
                            var event = e;
                            resolve(event.target.result)
                          });
                          dbGet.addEventListener("error", function(e) {
                            return reject(e)
                          })
                        })]
                }
              })
          })
      };
      DatabaseStorage.prototype.setItem = function(key, payload) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.validateDbIsOpen()];
                  case 1:
                    _a.sent();
                    return [2, new Promise(function(resolve, reject) {
                          if (!_this.db) {
                            return reject(BrowserAuthError.createDatabaseNotOpenError())
                          }
                          var transaction = _this.db.transaction([_this.tableName], "readwrite");
                          var objectStore = transaction.objectStore(_this.tableName);
                          var dbPut = objectStore.put(payload, key);
                          dbPut.addEventListener("success", function() {
                            return resolve()
                          });
                          dbPut.addEventListener("error", function(e) {
                            return reject(e)
                          })
                        })]
                }
              })
          })
      };
      DatabaseStorage.prototype.removeItem = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.validateDbIsOpen()];
                  case 1:
                    _a.sent();
                    return [2, new Promise(function(resolve, reject) {
                          if (!_this.db) {
                            return reject(BrowserAuthError.createDatabaseNotOpenError())
                          }
                          var transaction = _this.db.transaction([_this.tableName], "readwrite");
                          var objectStore = transaction.objectStore(_this.tableName);
                          var dbDelete = objectStore.delete(key);
                          dbDelete.addEventListener("success", function() {
                            return resolve()
                          });
                          dbDelete.addEventListener("error", function(e) {
                            return reject(e)
                          })
                        })]
                }
              })
          })
      };
      DatabaseStorage.prototype.getKeys = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.validateDbIsOpen()];
                  case 1:
                    _a.sent();
                    return [2, new Promise(function(resolve, reject) {
                          if (!_this.db) {
                            return reject(BrowserAuthError.createDatabaseNotOpenError())
                          }
                          var transaction = _this.db.transaction([_this.tableName], "readonly");
                          var objectStore = transaction.objectStore(_this.tableName);
                          var dbGetKeys = objectStore.getAllKeys();
                          dbGetKeys.addEventListener("success", function(e) {
                            var event = e;
                            resolve(event.target.result)
                          });
                          dbGetKeys.addEventListener("error", function(e) {
                            return reject(e)
                          })
                        })]
                }
              })
          })
      };
      DatabaseStorage.prototype.containsKey = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.validateDbIsOpen()];
                  case 1:
                    _a.sent();
                    return [2, new Promise(function(resolve, reject) {
                          if (!_this.db) {
                            return reject(BrowserAuthError.createDatabaseNotOpenError())
                          }
                          var transaction = _this.db.transaction([_this.tableName], "readonly");
                          var objectStore = transaction.objectStore(_this.tableName);
                          var dbContainsKey = objectStore.count(key);
                          dbContainsKey.addEventListener("success", function(e) {
                            var event = e;
                            resolve(event.target.result === 1)
                          });
                          dbContainsKey.addEventListener("error", function(e) {
                            return reject(e)
                          })
                        })]
                }
              })
          })
      };
      DatabaseStorage.prototype.deleteDatabase = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, new Promise(function(resolve, reject) {
                      var deleteDbRequest = window.indexedDB.deleteDatabase(DB_NAME);
                      deleteDbRequest.addEventListener("success", function() {
                        return resolve(true)
                      });
                      deleteDbRequest.addEventListener("error", function() {
                        return reject(false)
                      })
                    })]
              })
          })
      };
      return DatabaseStorage
    }());
  var MemoryStorage = (function() {
      function MemoryStorage() {
        this.cache = new Map
      }
      MemoryStorage.prototype.getItem = function(key) {
        return this.cache.get(key) || null
      };
      MemoryStorage.prototype.setItem = function(key, value) {
        this.cache.set(key, value)
      };
      MemoryStorage.prototype.removeItem = function(key) {
        this.cache.delete(key)
      };
      MemoryStorage.prototype.getKeys = function() {
        var cacheKeys = [];
        this.cache.forEach(function(value, key) {
          cacheKeys.push(key)
        });
        return cacheKeys
      };
      MemoryStorage.prototype.containsKey = function(key) {
        return this.cache.has(key)
      };
      MemoryStorage.prototype.clear = function() {
        this.cache.clear()
      };
      return MemoryStorage
    }());
  var AsyncMemoryStorage = (function() {
      function AsyncMemoryStorage(logger) {
        this.inMemoryCache = new MemoryStorage;
        this.indexedDBCache = new DatabaseStorage;
        this.logger = logger
      }
      AsyncMemoryStorage.prototype.handleDatabaseAccessError = function(error) {
        if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {
          this.logger.error("Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.")
        }
      };
      AsyncMemoryStorage.prototype.getItem = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            var item,
              e_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    item = this.inMemoryCache.getItem(key);
                    if (!!item)
                      return [3, 4];
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    this.logger.verbose("Queried item not found in in-memory cache, now querying persistent storage.");
                    return [4, this.indexedDBCache.getItem(key)];
                  case 2:
                    return [2, _a.sent()];
                  case 3:
                    e_1 = _a.sent();
                    this.handleDatabaseAccessError(e_1);
                    return [3, 4];
                  case 4:
                    return [2, item]
                }
              })
          })
      };
      AsyncMemoryStorage.prototype.setItem = function(key, value) {
        return __awaiter$1(this, void 0, void 0, function() {
            var e_2;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.inMemoryCache.setItem(key, value);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.indexedDBCache.setItem(key, value)];
                  case 2:
                    _a.sent();
                    return [3, 4];
                  case 3:
                    e_2 = _a.sent();
                    this.handleDatabaseAccessError(e_2);
                    return [3, 4];
                  case 4:
                    return [2]
                }
              })
          })
      };
      AsyncMemoryStorage.prototype.removeItem = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            var e_3;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.inMemoryCache.removeItem(key);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.indexedDBCache.removeItem(key)];
                  case 2:
                    _a.sent();
                    return [3, 4];
                  case 3:
                    e_3 = _a.sent();
                    this.handleDatabaseAccessError(e_3);
                    return [3, 4];
                  case 4:
                    return [2]
                }
              })
          })
      };
      AsyncMemoryStorage.prototype.getKeys = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var cacheKeys,
              e_4;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    cacheKeys = this.inMemoryCache.getKeys();
                    if (!(cacheKeys.length === 0))
                      return [3, 4];
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    this.logger.verbose("In-memory cache is empty, now querying persistent storage.");
                    return [4, this.indexedDBCache.getKeys()];
                  case 2:
                    return [2, _a.sent()];
                  case 3:
                    e_4 = _a.sent();
                    this.handleDatabaseAccessError(e_4);
                    return [3, 4];
                  case 4:
                    return [2, cacheKeys]
                }
              })
          })
      };
      AsyncMemoryStorage.prototype.containsKey = function(key) {
        return __awaiter$1(this, void 0, void 0, function() {
            var containsKey,
              e_5;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    containsKey = this.inMemoryCache.containsKey(key);
                    if (!!containsKey)
                      return [3, 4];
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    this.logger.verbose("Key not found in in-memory cache, now querying persistent storage.");
                    return [4, this.indexedDBCache.containsKey(key)];
                  case 2:
                    return [2, _a.sent()];
                  case 3:
                    e_5 = _a.sent();
                    this.handleDatabaseAccessError(e_5);
                    return [3, 4];
                  case 4:
                    return [2, containsKey]
                }
              })
          })
      };
      AsyncMemoryStorage.prototype.clear = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var e_6;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.inMemoryCache.clear();
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.indexedDBCache.deleteDatabase()];
                  case 2:
                    _a.sent();
                    return [3, 4];
                  case 3:
                    e_6 = _a.sent();
                    this.handleDatabaseAccessError(e_6);
                    return [3, 4];
                  case 4:
                    return [2]
                }
              })
          })
      };
      return AsyncMemoryStorage
    }());
  var CryptoOps = (function() {
      function CryptoOps(logger) {
        this.logger = logger;
        this.browserCrypto = new BrowserCrypto(this.logger);
        this.b64Encode = new Base64Encode;
        this.b64Decode = new Base64Decode;
        this.guidGenerator = new GuidGenerator(this.browserCrypto);
        this.pkceGenerator = new PkceGenerator(this.browserCrypto);
        this.cache = {
          asymmetricKeys: new AsyncMemoryStorage(this.logger), symmetricKeys: new AsyncMemoryStorage(this.logger)
        }
      }
      CryptoOps.prototype.createNewGuid = function() {
        return this.guidGenerator.generateGuid()
      };
      CryptoOps.prototype.base64Encode = function(input) {
        return this.b64Encode.encode(input)
      };
      CryptoOps.prototype.base64Decode = function(input) {
        return this.b64Decode.decode(input)
      };
      CryptoOps.prototype.generatePkceCodes = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, this.pkceGenerator.generateCodes()]
              })
          })
      };
      CryptoOps.prototype.getPublicKeyThumbprint = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var keyPair,
              publicKeyJwk,
              pubKeyThumprintObj,
              publicJwkString,
              publicJwkHash,
              privateKeyJwk,
              unextractablePrivateKey;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.browserCrypto.generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES)];
                  case 1:
                    keyPair = _a.sent();
                    return [4, this.browserCrypto.exportJwk(keyPair.publicKey)];
                  case 2:
                    publicKeyJwk = _a.sent();
                    pubKeyThumprintObj = {
                      e: publicKeyJwk.e, kty: publicKeyJwk.kty, n: publicKeyJwk.n
                    };
                    publicJwkString = BrowserCrypto.getJwkString(pubKeyThumprintObj);
                    return [4, this.hashString(publicJwkString)];
                  case 3:
                    publicJwkHash = _a.sent();
                    return [4, this.browserCrypto.exportJwk(keyPair.privateKey)];
                  case 4:
                    privateKeyJwk = _a.sent();
                    return [4, this.browserCrypto.importJwk(privateKeyJwk, false, ["sign"])];
                  case 5:
                    unextractablePrivateKey = _a.sent();
                    return [4, this.cache.asymmetricKeys.setItem(publicJwkHash, {
                          privateKey: unextractablePrivateKey, publicKey: keyPair.publicKey, requestMethod: request.resourceRequestMethod, requestUri: request.resourceRequestUri
                        })];
                  case 6:
                    _a.sent();
                    return [2, publicJwkHash]
                }
              })
          })
      };
      CryptoOps.prototype.removeTokenBindingKey = function(kid) {
        return __awaiter$1(this, void 0, void 0, function() {
            var keyFound;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.cache.asymmetricKeys.removeItem(kid)];
                  case 1:
                    _a.sent();
                    return [4, this.cache.asymmetricKeys.containsKey(kid)];
                  case 2:
                    keyFound = _a.sent();
                    return [2, !keyFound]
                }
              })
          })
      };
      CryptoOps.prototype.clearKeystore = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var dataStoreNames,
              databaseStorage,
              _a;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    dataStoreNames = Object.keys(this.cache);
                    databaseStorage = this.cache[dataStoreNames[0]];
                    if (!databaseStorage)
                      return [3, 2];
                    return [4, databaseStorage.deleteDatabase()];
                  case 1:
                    _a = _b.sent();
                    return [3, 3];
                  case 2:
                    _a = false;
                    _b.label = 3;
                  case 3:
                    return [2, _a]
                }
              })
          })
      };
      CryptoOps.prototype.signJwt = function(payload, kid) {
        return __awaiter$1(this, void 0, void 0, function() {
            var cachedKeyPair,
              publicKeyJwk,
              publicKeyJwkString,
              header,
              encodedHeader,
              encodedPayload,
              tokenString,
              tokenBuffer,
              signatureBuffer,
              encodedSignature;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.cache.asymmetricKeys.getItem(kid)];
                  case 1:
                    cachedKeyPair = _a.sent();
                    if (!cachedKeyPair) {
                      throw BrowserAuthError.createSigningKeyNotFoundInStorageError(kid);
                    }
                    return [4, this.browserCrypto.exportJwk(cachedKeyPair.publicKey)];
                  case 2:
                    publicKeyJwk = _a.sent();
                    publicKeyJwkString = BrowserCrypto.getJwkString(publicKeyJwk);
                    header = {
                      alg: publicKeyJwk.alg, type: KEY_FORMAT_JWK
                    };
                    encodedHeader = this.b64Encode.urlEncode(JSON.stringify(header));
                    payload.cnf = {jwk: JSON.parse(publicKeyJwkString)};
                    encodedPayload = this.b64Encode.urlEncode(JSON.stringify(payload));
                    tokenString = encodedHeader + "." + encodedPayload;
                    tokenBuffer = BrowserStringUtils.stringToArrayBuffer(tokenString);
                    return [4, this.browserCrypto.sign(cachedKeyPair.privateKey, tokenBuffer)];
                  case 3:
                    signatureBuffer = _a.sent();
                    encodedSignature = this.b64Encode.urlEncodeArr(new Uint8Array(signatureBuffer));
                    return [2, tokenString + "." + encodedSignature]
                }
              })
          })
      };
      CryptoOps.prototype.hashString = function(plainText) {
        return __awaiter$1(this, void 0, void 0, function() {
            var hashBuffer,
              hashBytes;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.browserCrypto.sha256Digest(plainText)];
                  case 1:
                    hashBuffer = _a.sent();
                    hashBytes = new Uint8Array(hashBuffer);
                    return [2, this.b64Encode.urlEncodeArr(hashBytes)]
                }
              })
          })
      };
      CryptoOps.POP_KEY_USAGES = ["sign", "verify"];
      CryptoOps.EXTRACTABLE = true;
      return CryptoOps
    }());
  var BrowserConfigurationAuthErrorMessage = {
      redirectUriNotSet: {
        code: "redirect_uri_empty", desc: "A redirect URI is required for all calls, and none has been set."
      }, postLogoutUriNotSet: {
          code: "post_logout_uri_empty", desc: "A post logout redirect has not been set."
        }, storageNotSupportedError: {
          code: "storage_not_supported", desc: "Given storage configuration option was not supported."
        }, noRedirectCallbacksSet: {
          code: "no_redirect_callbacks", desc: "No redirect callbacks have been set. Please call setRedirectCallbacks() with the appropriate function arguments before continuing. " + "More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
        }, invalidCallbackObject: {
          code: "invalid_callback_object", desc: "The object passed for the callback was invalid. " + "More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
        }, stubPcaInstanceCalled: {
          code: "stubbed_public_client_application_called", desc: "Stub instance of Public Client Application was called. If using msal-react, please ensure context is not used without a provider. For more visit: aka.ms/msaljs/browser-errors"
        }, inMemRedirectUnavailable: {
          code: "in_mem_redirect_unavailable", desc: "Redirect cannot be supported. In-memory storage was selected and storeAuthStateInCookie=false, which would cause the library to be unable to handle the incoming hash. If you would like to use the redirect API, please use session/localStorage or set storeAuthStateInCookie=true."
        }
    };
  var BrowserConfigurationAuthError = (function(_super) {
      __extends$1(BrowserConfigurationAuthError, _super);
      function BrowserConfigurationAuthError(errorCode, errorMessage) {
        var _this = _super.call(this, errorCode, errorMessage) || this;
        _this.name = "BrowserConfigurationAuthError";
        Object.setPrototypeOf(_this, BrowserConfigurationAuthError.prototype);
        return _this
      }
      BrowserConfigurationAuthError.createRedirectUriEmptyError = function() {
        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.redirectUriNotSet.code, BrowserConfigurationAuthErrorMessage.redirectUriNotSet.desc)
      };
      BrowserConfigurationAuthError.createPostLogoutRedirectUriEmptyError = function() {
        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.postLogoutUriNotSet.code, BrowserConfigurationAuthErrorMessage.postLogoutUriNotSet.desc)
      };
      BrowserConfigurationAuthError.createStorageNotSupportedError = function(givenStorageLocation) {
        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.storageNotSupportedError.code, BrowserConfigurationAuthErrorMessage.storageNotSupportedError.desc + " Given Location: " + givenStorageLocation)
      };
      BrowserConfigurationAuthError.createRedirectCallbacksNotSetError = function() {
        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.noRedirectCallbacksSet.code, BrowserConfigurationAuthErrorMessage.noRedirectCallbacksSet.desc)
      };
      BrowserConfigurationAuthError.createStubPcaInstanceCalledError = function() {
        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.stubPcaInstanceCalled.code, BrowserConfigurationAuthErrorMessage.stubPcaInstanceCalled.desc)
      };
      BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError = function() {
        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.inMemRedirectUnavailable.code, BrowserConfigurationAuthErrorMessage.inMemRedirectUnavailable.desc)
      };
      return BrowserConfigurationAuthError
    }(AuthError));
  var BrowserStorage = (function() {
      function BrowserStorage(cacheLocation) {
        this.validateWindowStorage(cacheLocation);
        this.windowStorage = window[cacheLocation]
      }
      BrowserStorage.prototype.validateWindowStorage = function(cacheLocation) {
        if (cacheLocation !== exports.BrowserCacheLocation.LocalStorage && cacheLocation !== exports.BrowserCacheLocation.SessionStorage) {
          throw BrowserConfigurationAuthError.createStorageNotSupportedError(cacheLocation);
        }
        var storageSupported = !!window[cacheLocation];
        if (!storageSupported) {
          throw BrowserConfigurationAuthError.createStorageNotSupportedError(cacheLocation);
        }
      };
      BrowserStorage.prototype.getItem = function(key) {
        return this.windowStorage.getItem(key)
      };
      BrowserStorage.prototype.setItem = function(key, value) {
        this.windowStorage.setItem(key, value)
      };
      BrowserStorage.prototype.removeItem = function(key) {
        this.windowStorage.removeItem(key)
      };
      BrowserStorage.prototype.getKeys = function() {
        return Object.keys(this.windowStorage)
      };
      BrowserStorage.prototype.containsKey = function(key) {
        return this.windowStorage.hasOwnProperty(key)
      };
      return BrowserStorage
    }());
  var BrowserProtocolUtils = (function() {
      function BrowserProtocolUtils(){}
      BrowserProtocolUtils.extractBrowserRequestState = function(browserCrypto, state) {
        if (StringUtils.isEmpty(state)) {
          return null
        }
        try {
          var requestStateObj = ProtocolUtils.parseRequestState(browserCrypto, state);
          return requestStateObj.libraryState.meta
        }
        catch(e) {
          throw ClientAuthError.createInvalidStateError(state, e);
        }
      };
      BrowserProtocolUtils.parseServerResponseFromHash = function(locationHash) {
        if (!locationHash) {
          return {}
        }
        var hashUrlString = new UrlString(locationHash);
        return UrlString.getDeserializedHash(hashUrlString.getHash())
      };
      return BrowserProtocolUtils
    }());
  var BrowserCacheManager = (function(_super) {
      __extends$1(BrowserCacheManager, _super);
      function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {
        var _this = _super.call(this, clientId, cryptoImpl) || this;
        _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;
        _this.cacheConfig = cacheConfig;
        _this.logger = logger;
        _this.internalStorage = new MemoryStorage;
        _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);
        _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.cacheLocation);
        _this.migrateCacheEntries();
        return _this
      }
      BrowserCacheManager.prototype.setupBrowserStorage = function(cacheLocation) {
        switch (cacheLocation) {
          case exports.BrowserCacheLocation.LocalStorage:
          case exports.BrowserCacheLocation.SessionStorage:
            try {
              return new BrowserStorage(cacheLocation)
            }
            catch(e) {
              this.logger.verbose(e);
              break
            }
          case exports.BrowserCacheLocation.MemoryStorage:
        }
        this.cacheConfig.cacheLocation = exports.BrowserCacheLocation.MemoryStorage;
        return new MemoryStorage
      };
      BrowserCacheManager.prototype.setupTemporaryCacheStorage = function(cacheLocation) {
        switch (cacheLocation) {
          case exports.BrowserCacheLocation.LocalStorage:
          case exports.BrowserCacheLocation.SessionStorage:
            try {
              return new BrowserStorage(exports.BrowserCacheLocation.SessionStorage)
            }
            catch(e) {
              this.logger.verbose(e);
              return this.internalStorage
            }
          case exports.BrowserCacheLocation.MemoryStorage:
          default:
            return this.internalStorage
        }
      };
      BrowserCacheManager.prototype.migrateCacheEntries = function() {
        var _this = this;
        var idTokenKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ID_TOKEN;
        var clientInfoKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.CLIENT_INFO;
        var errorKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ERROR;
        var errorDescKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ERROR_DESC;
        var idTokenValue = this.browserStorage.getItem(idTokenKey);
        var clientInfoValue = this.browserStorage.getItem(clientInfoKey);
        var errorValue = this.browserStorage.getItem(errorKey);
        var errorDescValue = this.browserStorage.getItem(errorDescKey);
        var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];
        var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];
        keysToMigrate.forEach(function(cacheKey, index) {
          return _this.migrateCacheEntry(cacheKey, values[index])
        })
      };
      BrowserCacheManager.prototype.migrateCacheEntry = function(newKey, value) {
        if (value) {
          this.setTemporaryCache(newKey, value, true)
        }
      };
      BrowserCacheManager.prototype.validateAndParseJson = function(jsonValue) {
        try {
          var parsedJson = JSON.parse(jsonValue);
          return (parsedJson && typeof parsedJson === "object") ? parsedJson : null
        }
        catch(error) {
          return null
        }
      };
      BrowserCacheManager.prototype.getItem = function(key) {
        return this.browserStorage.getItem(key)
      };
      BrowserCacheManager.prototype.setItem = function(key, value) {
        this.browserStorage.setItem(key, value)
      };
      BrowserCacheManager.prototype.getAccount = function(accountKey) {
        var account = this.getItem(accountKey);
        if (!account) {
          return null
        }
        var parsedAccount = this.validateAndParseJson(account);
        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {
          return null
        }
        return CacheManager.toObject(new AccountEntity, parsedAccount)
      };
      BrowserCacheManager.prototype.setAccount = function(account) {
        this.logger.trace("BrowserCacheManager.setAccount called");
        var key = account.generateAccountKey();
        this.setItem(key, JSON.stringify(account))
      };
      BrowserCacheManager.prototype.getIdTokenCredential = function(idTokenKey) {
        var value = this.getItem(idTokenKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
          return null
        }
        var parsedIdToken = this.validateAndParseJson(value);
        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {
          this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
          return null
        }
        this.logger.trace("BrowserCacheManager.getIdTokenCredential: cache hit");
        return CacheManager.toObject(new IdTokenEntity, parsedIdToken)
      };
      BrowserCacheManager.prototype.setIdTokenCredential = function(idToken) {
        this.logger.trace("BrowserCacheManager.setIdTokenCredential called");
        var idTokenKey = idToken.generateCredentialKey();
        this.setItem(idTokenKey, JSON.stringify(idToken))
      };
      BrowserCacheManager.prototype.getAccessTokenCredential = function(accessTokenKey) {
        var value = this.getItem(accessTokenKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
          return null
        }
        var parsedAccessToken = this.validateAndParseJson(value);
        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {
          this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
          return null
        }
        this.logger.trace("BrowserCacheManager.getAccessTokenCredential: cache hit");
        return CacheManager.toObject(new AccessTokenEntity, parsedAccessToken)
      };
      BrowserCacheManager.prototype.setAccessTokenCredential = function(accessToken) {
        this.logger.trace("BrowserCacheManager.setAccessTokenCredential called");
        var accessTokenKey = accessToken.generateCredentialKey();
        this.setItem(accessTokenKey, JSON.stringify(accessToken))
      };
      BrowserCacheManager.prototype.getRefreshTokenCredential = function(refreshTokenKey) {
        var value = this.getItem(refreshTokenKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
          return null
        }
        var parsedRefreshToken = this.validateAndParseJson(value);
        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {
          this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
          return null
        }
        this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: cache hit");
        return CacheManager.toObject(new RefreshTokenEntity, parsedRefreshToken)
      };
      BrowserCacheManager.prototype.setRefreshTokenCredential = function(refreshToken) {
        this.logger.trace("BrowserCacheManager.setRefreshTokenCredential called");
        var refreshTokenKey = refreshToken.generateCredentialKey();
        this.setItem(refreshTokenKey, JSON.stringify(refreshToken))
      };
      BrowserCacheManager.prototype.getAppMetadata = function(appMetadataKey) {
        var value = this.getItem(appMetadataKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
          return null
        }
        var parsedMetadata = this.validateAndParseJson(value);
        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {
          this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
          return null
        }
        this.logger.trace("BrowserCacheManager.getAppMetadata: cache hit");
        return CacheManager.toObject(new AppMetadataEntity, parsedMetadata)
      };
      BrowserCacheManager.prototype.setAppMetadata = function(appMetadata) {
        this.logger.trace("BrowserCacheManager.setAppMetadata called");
        var appMetadataKey = appMetadata.generateAppMetadataKey();
        this.setItem(appMetadataKey, JSON.stringify(appMetadata))
      };
      BrowserCacheManager.prototype.getServerTelemetry = function(serverTelemetryKey) {
        var value = this.getItem(serverTelemetryKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
          return null
        }
        var parsedMetadata = this.validateAndParseJson(value);
        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {
          this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
          return null
        }
        this.logger.trace("BrowserCacheManager.getServerTelemetry: cache hit");
        return CacheManager.toObject(new ServerTelemetryEntity, parsedMetadata)
      };
      BrowserCacheManager.prototype.setServerTelemetry = function(serverTelemetryKey, serverTelemetry) {
        this.logger.trace("BrowserCacheManager.setServerTelemetry called");
        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry))
      };
      BrowserCacheManager.prototype.getAuthorityMetadata = function(key) {
        var value = this.internalStorage.getItem(key);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getAuthorityMetadata: called, no cache hit");
          return null
        }
        var parsedMetadata = this.validateAndParseJson(value);
        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {
          this.logger.trace("BrowserCacheManager.getAuthorityMetadata: cache hit");
          return CacheManager.toObject(new AuthorityMetadataEntity, parsedMetadata)
        }
        return null
      };
      BrowserCacheManager.prototype.getAuthorityMetadataKeys = function() {
        var _this = this;
        var allKeys = this.internalStorage.getKeys();
        return allKeys.filter(function(key) {
            return _this.isAuthorityMetadata(key)
          })
      };
      BrowserCacheManager.prototype.setWrapperMetadata = function(wrapperSKU, wrapperVersion) {
        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);
        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion)
      };
      BrowserCacheManager.prototype.getWrapperMetadata = function() {
        var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || "";
        var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || "";
        return [sku, version]
      };
      BrowserCacheManager.prototype.setAuthorityMetadata = function(key, entity) {
        this.logger.trace("BrowserCacheManager.setAuthorityMetadata called");
        this.internalStorage.setItem(key, JSON.stringify(entity))
      };
      BrowserCacheManager.prototype.getActiveAccount = function() {
        var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);
        var activeAccountId = this.browserStorage.getItem(activeAccountIdKey);
        if (!activeAccountId) {
          return null
        }
        return this.getAccountInfoByFilter({localAccountId: activeAccountId})[0] || null
      };
      BrowserCacheManager.prototype.setActiveAccount = function(account) {
        var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);
        if (account) {
          this.logger.verbose("setActiveAccount: Active account set");
          this.browserStorage.setItem(activeAccountIdKey, account.localAccountId)
        }
        else {
          this.logger.verbose("setActiveAccount: No account passed, active account not set");
          this.browserStorage.removeItem(activeAccountIdKey)
        }
      };
      BrowserCacheManager.prototype.getAccountInfoByFilter = function(accountFilter) {
        var allAccounts = this.getAllAccounts();
        return allAccounts.filter(function(accountObj) {
            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {
              return false
            }
            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {
              return false
            }
            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {
              return false
            }
            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {
              return false
            }
            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {
              return false
            }
            return true
          })
      };
      BrowserCacheManager.prototype.getThrottlingCache = function(throttlingCacheKey) {
        var value = this.getItem(throttlingCacheKey);
        if (!value) {
          this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
          return null
        }
        var parsedThrottlingCache = this.validateAndParseJson(value);
        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {
          this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
          return null
        }
        this.logger.trace("BrowserCacheManager.getThrottlingCache: cache hit");
        return CacheManager.toObject(new ThrottlingEntity, parsedThrottlingCache)
      };
      BrowserCacheManager.prototype.setThrottlingCache = function(throttlingCacheKey, throttlingCache) {
        this.logger.trace("BrowserCacheManager.setThrottlingCache called");
        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache))
      };
      BrowserCacheManager.prototype.getTemporaryCache = function(cacheKey, generateKey) {
        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
        if (this.cacheConfig.storeAuthStateInCookie) {
          var itemCookie = this.getItemCookie(key);
          if (itemCookie) {
            this.logger.trace("BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies");
            return itemCookie
          }
        }
        var value = this.temporaryCacheStorage.getItem(key);
        if (!value) {
          if (this.cacheConfig.cacheLocation === exports.BrowserCacheLocation.LocalStorage) {
            var item = this.browserStorage.getItem(key);
            if (item) {
              this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage");
              return item
            }
          }
          this.logger.trace("BrowserCacheManager.getTemporaryCache: No cache item found in local storage");
          return null
        }
        this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item returned");
        return value
      };
      BrowserCacheManager.prototype.setTemporaryCache = function(cacheKey, value, generateKey) {
        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
        this.temporaryCacheStorage.setItem(key, value);
        if (this.cacheConfig.storeAuthStateInCookie) {
          this.logger.trace("BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie");
          this.setItemCookie(key, value)
        }
      };
      BrowserCacheManager.prototype.removeItem = function(key) {
        this.browserStorage.removeItem(key);
        this.temporaryCacheStorage.removeItem(key);
        if (this.cacheConfig.storeAuthStateInCookie) {
          this.logger.trace("BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie");
          this.clearItemCookie(key)
        }
        return true
      };
      BrowserCacheManager.prototype.containsKey = function(key) {
        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key)
      };
      BrowserCacheManager.prototype.getKeys = function() {
        return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys())
      };
      BrowserCacheManager.prototype.clear = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.removeAllAccounts()];
                  case 1:
                    _a.sent();
                    this.removeAppMetadata();
                    this.getKeys().forEach(function(cacheKey) {
                      if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(_this.clientId) !== -1))) {
                        _this.removeItem(cacheKey)
                      }
                    });
                    this.internalStorage.clear();
                    return [2]
                }
              })
          })
      };
      BrowserCacheManager.prototype.setItemCookie = function(cookieName, cookieValue, expires) {
        var cookieStr = encodeURIComponent(cookieName) + "=" + encodeURIComponent(cookieValue) + ";path=/;";
        if (expires) {
          var expireTime = this.getCookieExpirationTime(expires);
          cookieStr += "expires=" + expireTime + ";"
        }
        if (this.cacheConfig.secureCookies) {
          cookieStr += "Secure;"
        }
        document.cookie = cookieStr
      };
      BrowserCacheManager.prototype.getItemCookie = function(cookieName) {
        var name = encodeURIComponent(cookieName) + "=";
        var cookieList = document.cookie.split(";");
        for (var i = 0; i < cookieList.length; i++) {
          var cookie = cookieList[i];
          while (cookie.charAt(0) === " ") {
            cookie = cookie.substring(1)
          }
          if (cookie.indexOf(name) === 0) {
            return decodeURIComponent(cookie.substring(name.length, cookie.length))
          }
        }
        return ""
      };
      BrowserCacheManager.prototype.clearMsalCookies = function() {
        var _this = this;
        var cookiePrefix = Constants.CACHE_PREFIX + "." + this.clientId;
        var cookieList = document.cookie.split(";");
        cookieList.forEach(function(cookie) {
          while (cookie.charAt(0) === " ") {
            cookie = cookie.substring(1)
          }
          if (cookie.indexOf(cookiePrefix) === 0) {
            var cookieKey = cookie.split("=")[0];
            _this.clearItemCookie(cookieKey)
          }
        })
      };
      BrowserCacheManager.prototype.clearItemCookie = function(cookieName) {
        this.setItemCookie(cookieName, "", -1)
      };
      BrowserCacheManager.prototype.getCookieExpirationTime = function(cookieLifeDays) {
        var today = new Date;
        var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);
        return expr.toUTCString()
      };
      BrowserCacheManager.prototype.getCache = function() {
        return this.browserStorage
      };
      BrowserCacheManager.prototype.setCache = function(){};
      BrowserCacheManager.prototype.generateCacheKey = function(key) {
        var generatedKey = this.validateAndParseJson(key);
        if (!generatedKey) {
          if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {
            return key
          }
          return Constants.CACHE_PREFIX + "." + this.clientId + "." + key
        }
        return JSON.stringify(key)
      };
      BrowserCacheManager.prototype.generateAuthorityKey = function(stateString) {
        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;
        return this.generateCacheKey(exports.TemporaryCacheKeys.AUTHORITY + "." + stateId)
      };
      BrowserCacheManager.prototype.generateNonceKey = function(stateString) {
        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;
        return this.generateCacheKey(exports.TemporaryCacheKeys.NONCE_IDTOKEN + "." + stateId)
      };
      BrowserCacheManager.prototype.generateStateKey = function(stateString) {
        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;
        return this.generateCacheKey(exports.TemporaryCacheKeys.REQUEST_STATE + "." + stateId)
      };
      BrowserCacheManager.prototype.getCachedAuthority = function(cachedState) {
        var stateCacheKey = this.generateStateKey(cachedState);
        var state = this.getTemporaryCache(stateCacheKey);
        if (!state) {
          return null
        }
        var authorityCacheKey = this.generateAuthorityKey(state);
        return this.getTemporaryCache(authorityCacheKey)
      };
      BrowserCacheManager.prototype.updateCacheEntries = function(state, nonce, authorityInstance, loginHint, account) {
        this.logger.trace("BrowserCacheManager.updateCacheEntries called");
        var stateCacheKey = this.generateStateKey(state);
        this.setTemporaryCache(stateCacheKey, state, false);
        var nonceCacheKey = this.generateNonceKey(state);
        this.setTemporaryCache(nonceCacheKey, nonce, false);
        var authorityCacheKey = this.generateAuthorityKey(state);
        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);
        if (account) {
          var ccsCredential = {
              credential: account.homeAccountId, type: CcsCredentialType.HOME_ACCOUNT_ID
            };
          this.setTemporaryCache(exports.TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true)
        }
        else if (!StringUtils.isEmpty(loginHint)) {
          var ccsCredential = {
              credential: loginHint, type: CcsCredentialType.UPN
            };
          this.setTemporaryCache(exports.TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true)
        }
      };
      BrowserCacheManager.prototype.resetRequestCache = function(state) {
        var _this = this;
        this.logger.trace("BrowserCacheManager.resetRequestCache called");
        if (!StringUtils.isEmpty(state)) {
          this.getKeys().forEach(function(key) {
            if (key.indexOf(state) !== -1) {
              _this.removeItem(key)
            }
          })
        }
        if (state) {
          this.removeItem(this.generateStateKey(state));
          this.removeItem(this.generateNonceKey(state));
          this.removeItem(this.generateAuthorityKey(state))
        }
        this.removeItem(this.generateCacheKey(exports.TemporaryCacheKeys.REQUEST_PARAMS));
        this.removeItem(this.generateCacheKey(exports.TemporaryCacheKeys.ORIGIN_URI));
        this.removeItem(this.generateCacheKey(exports.TemporaryCacheKeys.URL_HASH));
        this.removeItem(this.generateCacheKey(exports.TemporaryCacheKeys.CORRELATION_ID));
        this.removeItem(this.generateCacheKey(exports.TemporaryCacheKeys.CCS_CREDENTIAL));
        this.setInteractionInProgress(false)
      };
      BrowserCacheManager.prototype.cleanRequestByState = function(stateString) {
        this.logger.trace("BrowserCacheManager.cleanRequestByState called");
        if (stateString) {
          var stateKey = this.generateStateKey(stateString);
          var cachedState = this.temporaryCacheStorage.getItem(stateKey);
          this.logger.infoPii("BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: " + cachedState);
          this.resetRequestCache(cachedState || "")
        }
        this.clearMsalCookies()
      };
      BrowserCacheManager.prototype.cleanRequestByInteractionType = function(interactionType) {
        var _this = this;
        this.logger.trace("BrowserCacheManager.cleanRequestByInteractionType called");
        this.getKeys().forEach(function(key) {
          if (key.indexOf(exports.TemporaryCacheKeys.REQUEST_STATE) === -1) {
            return
          }
          var stateValue = _this.temporaryCacheStorage.getItem(key);
          if (!stateValue) {
            return
          }
          var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);
          if (parsedState && parsedState.interactionType === interactionType) {
            _this.logger.infoPii("BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: " + stateValue);
            _this.resetRequestCache(stateValue)
          }
        });
        this.clearMsalCookies();
        this.setInteractionInProgress(false)
      };
      BrowserCacheManager.prototype.cacheCodeRequest = function(authCodeRequest, browserCrypto) {
        this.logger.trace("BrowserCacheManager.cacheCodeRequest called");
        var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));
        this.setTemporaryCache(exports.TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true)
      };
      BrowserCacheManager.prototype.getCachedRequest = function(state, browserCrypto) {
        this.logger.trace("BrowserCacheManager.getCachedRequest called");
        var encodedTokenRequest = this.getTemporaryCache(exports.TemporaryCacheKeys.REQUEST_PARAMS, true);
        if (!encodedTokenRequest) {
          throw BrowserAuthError.createNoTokenRequestCacheError();
        }
        var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));
        if (!parsedRequest) {
          throw BrowserAuthError.createUnableToParseTokenRequestCacheError();
        }
        this.removeItem(this.generateCacheKey(exports.TemporaryCacheKeys.REQUEST_PARAMS));
        if (StringUtils.isEmpty(parsedRequest.authority)) {
          var authorityCacheKey = this.generateAuthorityKey(state);
          var cachedAuthority = this.getTemporaryCache(authorityCacheKey);
          if (!cachedAuthority) {
            throw BrowserAuthError.createNoCachedAuthorityError();
          }
          parsedRequest.authority = cachedAuthority
        }
        return parsedRequest
      };
      BrowserCacheManager.prototype.isInteractionInProgress = function(matchClientId) {
        var clientId = this.getInteractionInProgress();
        if (matchClientId) {
          return clientId === this.clientId
        }
        else {
          return !!clientId
        }
      };
      BrowserCacheManager.prototype.getInteractionInProgress = function() {
        var key = Constants.CACHE_PREFIX + "." + exports.TemporaryCacheKeys.INTERACTION_STATUS_KEY;
        return this.getTemporaryCache(key, false)
      };
      BrowserCacheManager.prototype.setInteractionInProgress = function(inProgress) {
        var key = Constants.CACHE_PREFIX + "." + exports.TemporaryCacheKeys.INTERACTION_STATUS_KEY;
        if (inProgress) {
          if (this.getInteractionInProgress()) {
            throw BrowserAuthError.createInteractionInProgressError();
          }
          else {
            this.setTemporaryCache(key, this.clientId, false)
          }
        }
        else if (!inProgress && this.getInteractionInProgress() === this.clientId) {
          this.removeItem(key)
        }
      };
      BrowserCacheManager.prototype.getLegacyLoginHint = function() {
        var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);
        if (adalIdTokenString) {
          this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);
          this.logger.verbose("Cached ADAL id token retrieved.")
        }
        var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);
        if (msalIdTokenString) {
          this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));
          this.logger.verbose("Cached MSAL.js v1 id token retrieved")
        }
        var cachedIdTokenString = msalIdTokenString || adalIdTokenString;
        if (cachedIdTokenString) {
          var cachedIdToken = new AuthToken(cachedIdTokenString, this.cryptoImpl);
          if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {
            this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint");
            return cachedIdToken.claims.preferred_username
          }
          else if (cachedIdToken.claims && cachedIdToken.claims.upn) {
            this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint");
            return cachedIdToken.claims.upn
          }
          else {
            this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.")
          }
        }
        return null
      };
      BrowserCacheManager.prototype.updateCredentialCacheKey = function(currentCacheKey, credential) {
        var updatedCacheKey = credential.generateCredentialKey();
        if (currentCacheKey !== updatedCacheKey) {
          var cacheItem = this.getItem(currentCacheKey);
          if (cacheItem) {
            this.removeItem(currentCacheKey);
            this.setItem(updatedCacheKey, cacheItem);
            this.logger.verbose("Updated an outdated " + credential.credentialType + " cache key");
            return updatedCacheKey
          }
          else {
            this.logger.error("Attempted to update an outdated " + credential.credentialType + " cache key but no item matching the outdated key was found in storage")
          }
        }
        return currentCacheKey
      };
      return BrowserCacheManager
    }(CacheManager));
  var DEFAULT_BROWSER_CACHE_MANAGER = function(clientId, logger) {
      var cacheOptions = {
          cacheLocation: exports.BrowserCacheLocation.MemoryStorage, storeAuthStateInCookie: false, secureCookies: false
        };
      return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger)
    };
  var FetchClient = (function() {
      function FetchClient(){}
      FetchClient.prototype.sendGetRequestAsync = function(url, options) {
        return __awaiter$1(this, void 0, void 0, function() {
            var response,
              e_1,
              _a;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _b.trys.push([0, 2, , 3]);
                    return [4, fetch(url, {
                          method: HTTP_REQUEST_TYPE.GET, headers: this.getFetchHeaders(options)
                        })];
                  case 1:
                    response = _b.sent();
                    return [3, 3];
                  case 2:
                    e_1 = _b.sent();
                    if (window.navigator.onLine) {
                      throw BrowserAuthError.createGetRequestFailedError(e_1, url);
                    }
                    else {
                      throw BrowserAuthError.createNoNetworkConnectivityError();
                    }
                  case 3:
                    _b.trys.push([3, 5, , 6]);
                    _a = {headers: this.getHeaderDict(response.headers)};
                    return [4, response.json()];
                  case 4:
                    return [2, (_a.body = (_b.sent()), _a.status = response.status, _a)];
                  case 5:
                    _b.sent();
                    throw BrowserAuthError.createFailedToParseNetworkResponseError(url);
                  case 6:
                    return [2]
                }
              })
          })
      };
      FetchClient.prototype.sendPostRequestAsync = function(url, options) {
        return __awaiter$1(this, void 0, void 0, function() {
            var reqBody,
              response,
              e_3,
              _a;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    reqBody = (options && options.body) || "";
                    _b.label = 1;
                  case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4, fetch(url, {
                          method: HTTP_REQUEST_TYPE.POST, headers: this.getFetchHeaders(options), body: reqBody
                        })];
                  case 2:
                    response = _b.sent();
                    return [3, 4];
                  case 3:
                    e_3 = _b.sent();
                    if (window.navigator.onLine) {
                      throw BrowserAuthError.createPostRequestFailedError(e_3, url);
                    }
                    else {
                      throw BrowserAuthError.createNoNetworkConnectivityError();
                    }
                  case 4:
                    _b.trys.push([4, 6, , 7]);
                    _a = {headers: this.getHeaderDict(response.headers)};
                    return [4, response.json()];
                  case 5:
                    return [2, (_a.body = (_b.sent()), _a.status = response.status, _a)];
                  case 6:
                    _b.sent();
                    throw BrowserAuthError.createFailedToParseNetworkResponseError(url);
                  case 7:
                    return [2]
                }
              })
          })
      };
      FetchClient.prototype.getFetchHeaders = function(options) {
        var headers = new Headers;
        if (!(options && options.headers)) {
          return headers
        }
        var optionsHeaders = options.headers;
        Object.keys(optionsHeaders).forEach(function(key) {
          headers.append(key, optionsHeaders[key])
        });
        return headers
      };
      FetchClient.prototype.getHeaderDict = function(headers) {
        var headerDict = {};
        headers.forEach(function(value, key) {
          headerDict[key] = value
        });
        return headerDict
      };
      return FetchClient
    }());
  var XhrClient = (function() {
      function XhrClient(){}
      XhrClient.prototype.sendGetRequestAsync = function(url, options) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, this.sendRequestAsync(url, HTTP_REQUEST_TYPE.GET, options)]
              })
          })
      };
      XhrClient.prototype.sendPostRequestAsync = function(url, options) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, this.sendRequestAsync(url, HTTP_REQUEST_TYPE.POST, options)]
              })
          })
      };
      XhrClient.prototype.sendRequestAsync = function(url, method, options) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest;
            xhr.open(method, url, true);
            _this.setXhrHeaders(xhr, options);
            xhr.onload = function() {
              if (xhr.status < 200 || xhr.status >= 300) {
                if (method === HTTP_REQUEST_TYPE.POST) {
                  reject(BrowserAuthError.createPostRequestFailedError("Failed with status " + xhr.status, url))
                }
                else {
                  reject(BrowserAuthError.createGetRequestFailedError("Failed with status " + xhr.status, url))
                }
              }
              try {
                var jsonResponse = JSON.parse(xhr.responseText);
                var networkResponse = {
                    headers: _this.getHeaderDict(xhr), body: jsonResponse, status: xhr.status
                  };
                resolve(networkResponse)
              }
              catch(e) {
                reject(BrowserAuthError.createFailedToParseNetworkResponseError(url))
              }
            };
            xhr.onerror = function() {
              if (window.navigator.onLine) {
                if (method === HTTP_REQUEST_TYPE.POST) {
                  reject(BrowserAuthError.createPostRequestFailedError("Failed with status " + xhr.status, url))
                }
                else {
                  reject(BrowserAuthError.createGetRequestFailedError("Failed with status " + xhr.status, url))
                }
              }
              else {
                reject(BrowserAuthError.createNoNetworkConnectivityError())
              }
            };
            if (method === HTTP_REQUEST_TYPE.POST && options && options.body) {
              xhr.send(options.body)
            }
            else if (method === HTTP_REQUEST_TYPE.GET) {
              xhr.send()
            }
            else {
              throw BrowserAuthError.createHttpMethodNotImplementedError(method);
            }
          })
      };
      XhrClient.prototype.setXhrHeaders = function(xhr, options) {
        if (options && options.headers) {
          var headers_1 = options.headers;
          Object.keys(headers_1).forEach(function(key) {
            xhr.setRequestHeader(key, headers_1[key])
          })
        }
      };
      XhrClient.prototype.getHeaderDict = function(xhr) {
        var headerString = xhr.getAllResponseHeaders();
        var headerArr = headerString.trim().split(/[\r\n]+/);
        var headerDict = {};
        headerArr.forEach(function(value) {
          var parts = value.split(": ");
          var headerName = parts.shift();
          var headerVal = parts.join(": ");
          if (headerName && headerVal) {
            headerDict[headerName] = headerVal
          }
        });
        return headerDict
      };
      return XhrClient
    }());
  var BrowserUtils = (function() {
      function BrowserUtils(){}
      BrowserUtils.clearHash = function(contentWindow) {
        contentWindow.location.hash = Constants.EMPTY_STRING;
        if (typeof contentWindow.history.replaceState === "function") {
          contentWindow.history.replaceState(null, Constants.EMPTY_STRING, "" + contentWindow.location.origin + contentWindow.location.pathname + contentWindow.location.search)
        }
      };
      BrowserUtils.replaceHash = function(url) {
        var urlParts = url.split("#");
        urlParts.shift();
        window.location.hash = urlParts.length > 0 ? urlParts.join("#") : ""
      };
      BrowserUtils.isInIframe = function() {
        return window.parent !== window
      };
      BrowserUtils.isInPopup = function() {
        return typeof window !== "undefined" && !!window.opener && window.opener !== window && typeof window.name === "string" && window.name.indexOf(BrowserConstants.POPUP_NAME_PREFIX + ".") === 0
      };
      BrowserUtils.getCurrentUri = function() {
        return window.location.href.split("?")[0].split("#")[0]
      };
      BrowserUtils.getHomepage = function() {
        var currentUrl = new UrlString(window.location.href);
        var urlComponents = currentUrl.getUrlComponents();
        return urlComponents.Protocol + "//" + urlComponents.HostNameAndPort + "/"
      };
      BrowserUtils.getBrowserNetworkClient = function() {
        if (window.fetch && window.Headers) {
          return new FetchClient
        }
        else {
          return new XhrClient
        }
      };
      BrowserUtils.blockReloadInHiddenIframes = function() {
        var isResponseHash = UrlString.hashContainsKnownProperties(window.location.hash);
        if (isResponseHash && BrowserUtils.isInIframe()) {
          throw BrowserAuthError.createBlockReloadInHiddenIframeError();
        }
      };
      BrowserUtils.blockRedirectInIframe = function(interactionType, allowRedirectInIframe) {
        var isIframedApp = BrowserUtils.isInIframe();
        if (interactionType === exports.InteractionType.Redirect && isIframedApp && !allowRedirectInIframe) {
          throw BrowserAuthError.createRedirectInIframeError(isIframedApp);
        }
      };
      BrowserUtils.blockAcquireTokenInPopups = function() {
        if (BrowserUtils.isInPopup()) {
          throw BrowserAuthError.createBlockAcquireTokenInPopupsError();
        }
      };
      BrowserUtils.blockNonBrowserEnvironment = function(isBrowserEnvironment) {
        if (!isBrowserEnvironment) {
          throw BrowserAuthError.createNonBrowserEnvironmentError();
        }
      };
      BrowserUtils.detectIEOrEdge = function() {
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf("MSIE ");
        var msie11 = ua.indexOf("Trident/");
        var msedge = ua.indexOf("Edge/");
        var isIE = msie > 0 || msie11 > 0;
        var isEdge = msedge > 0;
        return isIE || isEdge
      };
      return BrowserUtils
    }());
  var NavigationClient = (function() {
      function NavigationClient(){}
      NavigationClient.prototype.navigateInternal = function(url, options) {
        return NavigationClient.defaultNavigateWindow(url, options)
      };
      NavigationClient.prototype.navigateExternal = function(url, options) {
        return NavigationClient.defaultNavigateWindow(url, options)
      };
      NavigationClient.defaultNavigateWindow = function(url, options) {
        if (options.noHistory) {
          window.location.replace(url)
        }
        else {
          window.location.assign(url)
        }
        return new Promise(function(resolve) {
            setTimeout(function() {
              resolve(true)
            }, options.timeout)
          })
      };
      return NavigationClient
    }());
  var DEFAULT_POPUP_TIMEOUT_MS = 60000;
  var DEFAULT_IFRAME_TIMEOUT_MS = 6000;
  var DEFAULT_REDIRECT_TIMEOUT_MS = 30000;
  function buildConfiguration(_a, isBrowserEnvironment) {
    var userInputAuth = _a.auth,
      userInputCache = _a.cache,
      userInputSystem = _a.system;
    var DEFAULT_AUTH_OPTIONS = {
        clientId: "", authority: "" + Constants.DEFAULT_AUTHORITY, knownAuthorities: [], cloudDiscoveryMetadata: "", authorityMetadata: "", redirectUri: "", postLogoutRedirectUri: "", navigateToLoginRequestUrl: true, clientCapabilities: [], protocolMode: exports.ProtocolMode.AAD, azureCloudOptions: {
            azureCloudInstance: exports.AzureCloudInstance.None, tenant: ""
          }
      };
    var DEFAULT_CACHE_OPTIONS = {
        cacheLocation: exports.BrowserCacheLocation.SessionStorage, storeAuthStateInCookie: false, secureCookies: false
      };
    var DEFAULT_LOGGER_OPTIONS = {
        loggerCallback: function(){}, logLevel: exports.LogLevel.Info, piiLoggingEnabled: false
      };
    var DEFAULT_BROWSER_SYSTEM_OPTIONS = __assign$1(__assign$1({}, DEFAULT_SYSTEM_OPTIONS), {
        loggerOptions: DEFAULT_LOGGER_OPTIONS, networkClient: isBrowserEnvironment ? BrowserUtils.getBrowserNetworkClient() : StubbedNetworkModule, navigationClient: new NavigationClient, loadFrameTimeout: 0, windowHashTimeout: (userInputSystem && userInputSystem.loadFrameTimeout) || DEFAULT_POPUP_TIMEOUT_MS, iframeHashTimeout: (userInputSystem && userInputSystem.loadFrameTimeout) || DEFAULT_IFRAME_TIMEOUT_MS, navigateFrameWait: isBrowserEnvironment && BrowserUtils.detectIEOrEdge() ? 500 : 0, redirectNavigationTimeout: DEFAULT_REDIRECT_TIMEOUT_MS, asyncPopups: false, allowRedirectInIframe: false
      });
    var overlayedConfig = {
        auth: __assign$1(__assign$1({}, DEFAULT_AUTH_OPTIONS), userInputAuth), cache: __assign$1(__assign$1({}, DEFAULT_CACHE_OPTIONS), userInputCache), system: __assign$1(__assign$1({}, DEFAULT_BROWSER_SYSTEM_OPTIONS), userInputSystem)
      };
    return overlayedConfig
  }
  var name = "@azure/msal-browser";
  var version = "2.22.1";
  exports.EventType = void 0;
  (function(EventType) {
    EventType["ACCOUNT_ADDED"] = "msal:accountAdded";
    EventType["ACCOUNT_REMOVED"] = "msal:accountRemoved";
    EventType["LOGIN_START"] = "msal:loginStart";
    EventType["LOGIN_SUCCESS"] = "msal:loginSuccess";
    EventType["LOGIN_FAILURE"] = "msal:loginFailure";
    EventType["ACQUIRE_TOKEN_START"] = "msal:acquireTokenStart";
    EventType["ACQUIRE_TOKEN_SUCCESS"] = "msal:acquireTokenSuccess";
    EventType["ACQUIRE_TOKEN_FAILURE"] = "msal:acquireTokenFailure";
    EventType["ACQUIRE_TOKEN_NETWORK_START"] = "msal:acquireTokenFromNetworkStart";
    EventType["SSO_SILENT_START"] = "msal:ssoSilentStart";
    EventType["SSO_SILENT_SUCCESS"] = "msal:ssoSilentSuccess";
    EventType["SSO_SILENT_FAILURE"] = "msal:ssoSilentFailure";
    EventType["ACQUIRE_TOKEN_BY_CODE_START"] = "msal:acquireTokenByCodeStart";
    EventType["ACQUIRE_TOKEN_BY_CODE_SUCCESS"] = "msal:acquireTokenByCodeSuccess";
    EventType["ACQUIRE_TOKEN_BY_CODE_FAILURE"] = "msal:acquireTokenByCodeFailure";
    EventType["HANDLE_REDIRECT_START"] = "msal:handleRedirectStart";
    EventType["HANDLE_REDIRECT_END"] = "msal:handleRedirectEnd";
    EventType["POPUP_OPENED"] = "msal:popupOpened";
    EventType["LOGOUT_START"] = "msal:logoutStart";
    EventType["LOGOUT_SUCCESS"] = "msal:logoutSuccess";
    EventType["LOGOUT_FAILURE"] = "msal:logoutFailure";
    EventType["LOGOUT_END"] = "msal:logoutEnd"
  })(exports.EventType || (exports.EventType = {}));
  var EventHandler = (function() {
      function EventHandler(logger, browserCrypto) {
        this.eventCallbacks = new Map;
        this.logger = logger;
        this.browserCrypto = browserCrypto;
        this.listeningToStorageEvents = false;
        this.handleAccountCacheChange = this.handleAccountCacheChange.bind(this)
      }
      EventHandler.prototype.addEventCallback = function(callback) {
        if (typeof window !== "undefined") {
          var callbackId = this.browserCrypto.createNewGuid();
          this.eventCallbacks.set(callbackId, callback);
          this.logger.verbose("Event callback registered with id: " + callbackId);
          return callbackId
        }
        return null
      };
      EventHandler.prototype.removeEventCallback = function(callbackId) {
        this.eventCallbacks.delete(callbackId);
        this.logger.verbose("Event callback " + callbackId + " removed.")
      };
      EventHandler.prototype.enableAccountStorageEvents = function() {
        if (typeof window === "undefined") {
          return
        }
        if (!this.listeningToStorageEvents) {
          this.logger.verbose("Adding account storage listener.");
          this.listeningToStorageEvents = true;
          window.addEventListener("storage", this.handleAccountCacheChange)
        }
        else {
          this.logger.verbose("Account storage listener already registered.")
        }
      };
      EventHandler.prototype.disableAccountStorageEvents = function() {
        if (typeof window === "undefined") {
          return
        }
        if (this.listeningToStorageEvents) {
          this.logger.verbose("Removing account storage listener.");
          window.removeEventListener("storage", this.handleAccountCacheChange);
          this.listeningToStorageEvents = false
        }
        else {
          this.logger.verbose("No account storage listener registered.")
        }
      };
      EventHandler.prototype.emitEvent = function(eventType, interactionType, payload, error) {
        var _this = this;
        if (typeof window !== "undefined") {
          var message_1 = {
              eventType: eventType, interactionType: interactionType || null, payload: payload || null, error: error || null, timestamp: Date.now()
            };
          this.logger.info("Emitting event: " + eventType);
          this.eventCallbacks.forEach(function(callback, callbackId) {
            _this.logger.verbose("Emitting event to callback " + callbackId + ": " + eventType);
            callback.apply(null, [message_1])
          })
        }
      };
      EventHandler.prototype.handleAccountCacheChange = function(e) {
        try {
          var cacheValue = e.newValue || e.oldValue;
          if (!cacheValue) {
            return
          }
          var parsedValue = JSON.parse(cacheValue);
          if (typeof parsedValue !== "object" || !AccountEntity.isAccountEntity(parsedValue)) {
            return
          }
          var accountEntity = CacheManager.toObject(new AccountEntity, parsedValue);
          var accountInfo = accountEntity.getAccountInfo();
          if (!e.oldValue && e.newValue) {
            this.logger.info("Account was added to cache in a different window");
            this.emitEvent(exports.EventType.ACCOUNT_ADDED, undefined, accountInfo)
          }
          else if (!e.newValue && e.oldValue) {
            this.logger.info("Account was removed from cache in a different window");
            this.emitEvent(exports.EventType.ACCOUNT_REMOVED, undefined, accountInfo)
          }
        }
        catch(e) {
          return
        }
      };
      return EventHandler
    }());
  var BaseInteractionClient = (function() {
      function BaseInteractionClient(config, storageImpl, browserCrypto, logger, eventHandler, correlationId) {
        this.config = config;
        this.browserStorage = storageImpl;
        this.browserCrypto = browserCrypto;
        this.networkClient = this.config.system.networkClient;
        this.eventHandler = eventHandler;
        this.correlationId = correlationId || this.browserCrypto.createNewGuid();
        this.logger = logger.clone(BrowserConstants.MSAL_SKU, version, this.correlationId)
      }
      BaseInteractionClient.prototype.clearCacheOnLogout = function(account) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (!account)
                      return [3, 5];
                    if (AccountEntity.accountInfoIsEqual(account, this.browserStorage.getActiveAccount(), false)) {
                      this.logger.verbose("Setting active account to null");
                      this.browserStorage.setActiveAccount(null)
                    }
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4, this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(account))];
                  case 2:
                    _a.sent();
                    this.logger.verbose("Cleared cache items belonging to the account provided in the logout request.");
                    return [3, 4];
                  case 3:
                    _a.sent();
                    this.logger.error("Account provided in logout request was not found. Local cache unchanged.");
                    return [3, 4];
                  case 4:
                    return [3, 9];
                  case 5:
                    _a.trys.push([5, 8, , 9]);
                    return [4, this.browserStorage.clear()];
                  case 6:
                    _a.sent();
                    return [4, this.browserCrypto.clearKeystore()];
                  case 7:
                    _a.sent();
                    this.logger.verbose("No account provided in logout request, clearing all cache items.");
                    return [3, 9];
                  case 8:
                    _a.sent();
                    this.logger.error("Attempted to clear all MSAL cache items and failed. Local cache unchanged.");
                    return [3, 9];
                  case 9:
                    return [2]
                }
              })
          })
      };
      BaseInteractionClient.prototype.initializeBaseRequest = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var authority,
              scopes,
              validatedRequest,
              _a;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    this.logger.verbose("Initializing BaseAuthRequest");
                    authority = request.authority || this.config.auth.authority;
                    scopes = __spread(((request && request.scopes) || []));
                    validatedRequest = __assign$1(__assign$1({}, request), {
                      correlationId: this.correlationId, authority: authority, scopes: scopes
                    });
                    if (!validatedRequest.authenticationScheme) {
                      validatedRequest.authenticationScheme = exports.AuthenticationScheme.BEARER;
                      this.logger.verbose("Authentication Scheme wasn't explicitly set in request, defaulting to \"Bearer\" request")
                    }
                    else {
                      if (validatedRequest.authenticationScheme === exports.AuthenticationScheme.SSH) {
                        if (!request.sshJwk) {
                          throw ClientConfigurationError.createMissingSshJwkError();
                        }
                        if (!request.sshKid) {
                          throw ClientConfigurationError.createMissingSshKidError();
                        }
                      }
                      this.logger.verbose("Authentication Scheme set to \"" + validatedRequest.authenticationScheme + "\" as configured in Auth request")
                    }
                    if (!(request.claims && !StringUtils.isEmpty(request.claims)))
                      return [3, 2];
                    _a = validatedRequest;
                    return [4, this.browserCrypto.hashString(request.claims)];
                  case 1:
                    _a.requestedClaimsHash = _b.sent();
                    _b.label = 2;
                  case 2:
                    return [2, validatedRequest]
                }
              })
          })
      };
      BaseInteractionClient.prototype.getRedirectUri = function(requestRedirectUri) {
        this.logger.verbose("getRedirectUri called");
        var redirectUri = requestRedirectUri || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();
        return UrlString.getAbsoluteUrl(redirectUri, BrowserUtils.getCurrentUri())
      };
      BaseInteractionClient.prototype.initializeServerTelemetryManager = function(apiId, forceRefresh) {
        this.logger.verbose("initializeServerTelemetryManager called");
        var telemetryPayload = {
            clientId: this.config.auth.clientId, correlationId: this.correlationId, apiId: apiId, forceRefresh: forceRefresh || false, wrapperSKU: this.browserStorage.getWrapperMetadata()[0], wrapperVer: this.browserStorage.getWrapperMetadata()[1]
          };
        return new ServerTelemetryManager(telemetryPayload, this.browserStorage)
      };
      return BaseInteractionClient
    }());
  var StandardInteractionClient = (function(_super) {
      __extends$1(StandardInteractionClient, _super);
      function StandardInteractionClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, correlationId) {
        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, correlationId) || this;
        _this.navigationClient = navigationClient;
        return _this
      }
      StandardInteractionClient.prototype.initializeAuthorizationCodeRequest = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var generatedPkceParams,
              authCodeRequest;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("initializeAuthorizationRequest called", request.correlationId);
                    return [4, this.browserCrypto.generatePkceCodes()];
                  case 1:
                    generatedPkceParams = _a.sent();
                    authCodeRequest = __assign$1(__assign$1({}, request), {
                      redirectUri: request.redirectUri, code: "", codeVerifier: generatedPkceParams.verifier
                    });
                    request.codeChallenge = generatedPkceParams.challenge;
                    request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;
                    return [2, authCodeRequest]
                }
              })
          })
      };
      StandardInteractionClient.prototype.initializeLogoutRequest = function(logoutRequest) {
        this.logger.verbose("initializeLogoutRequest called", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);
        var validLogoutRequest = __assign$1({correlationId: this.browserCrypto.createNewGuid()}, logoutRequest);
        if (logoutRequest) {
          if (!logoutRequest.logoutHint) {
            if (logoutRequest.account) {
              var logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);
              if (logoutHint) {
                this.logger.verbose("Setting logoutHint to login_hint ID Token Claim value for the account provided");
                validLogoutRequest.logoutHint = logoutHint
              }
            }
            else {
              this.logger.verbose("logoutHint was not set and account was not passed into logout request, logoutHint will not be set")
            }
          }
          else {
            this.logger.verbose("logoutHint has already been set in logoutRequest")
          }
        }
        else {
          this.logger.verbose("logoutHint will not be set since no logout request was configured")
        }
        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {
          if (logoutRequest && logoutRequest.postLogoutRedirectUri) {
            this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", validLogoutRequest.correlationId);
            validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri())
          }
          else if (this.config.auth.postLogoutRedirectUri === null) {
            this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", validLogoutRequest.correlationId)
          }
          else if (this.config.auth.postLogoutRedirectUri) {
            this.logger.verbose("Setting postLogoutRedirectUri to configured uri", validLogoutRequest.correlationId);
            validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri())
          }
          else {
            this.logger.verbose("Setting postLogoutRedirectUri to current page", validLogoutRequest.correlationId);
            validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri())
          }
        }
        else {
          this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", validLogoutRequest.correlationId)
        }
        return validLogoutRequest
      };
      StandardInteractionClient.prototype.getLogoutHintFromIdTokenClaims = function(account) {
        var idTokenClaims = account.idTokenClaims;
        if (idTokenClaims) {
          if (idTokenClaims.login_hint) {
            return idTokenClaims.login_hint
          }
          else {
            this.logger.verbose("The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request")
          }
        }
        else {
          this.logger.verbose("The provided account does not contain ID Token Claims, logoutHint will not be added to logout request")
        }
        return null
      };
      StandardInteractionClient.prototype.createAuthCodeClient = function(serverTelemetryManager, authorityUrl, requestAzureCloudOptions) {
        return __awaiter$1(this, void 0, void 0, function() {
            var clientConfig;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions)];
                  case 1:
                    clientConfig = _a.sent();
                    return [2, new AuthorizationCodeClient(clientConfig)]
                }
              })
          })
      };
      StandardInteractionClient.prototype.getClientConfiguration = function(serverTelemetryManager, requestAuthority, requestAzureCloudOptions) {
        return __awaiter$1(this, void 0, void 0, function() {
            var discoveredAuthority;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("getClientConfiguration called");
                    return [4, this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions)];
                  case 1:
                    discoveredAuthority = _a.sent();
                    return [2, {
                          authOptions: {
                            clientId: this.config.auth.clientId, authority: discoveredAuthority, clientCapabilities: this.config.auth.clientCapabilities
                          }, systemOptions: {
                              tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds, preventCorsPreflight: true
                            }, loggerOptions: {
                              loggerCallback: this.config.system.loggerOptions.loggerCallback, piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled, logLevel: this.config.system.loggerOptions.logLevel, correlationId: this.correlationId
                            }, cryptoInterface: this.browserCrypto, networkInterface: this.networkClient, storageInterface: this.browserStorage, serverTelemetryManager: serverTelemetryManager, libraryInfo: {
                              sku: BrowserConstants.MSAL_SKU, version: version, cpu: "", os: ""
                            }
                        }]
                }
              })
          })
      };
      StandardInteractionClient.prototype.validateAndExtractStateFromHash = function(hash, interactionType, requestCorrelationId) {
        this.logger.verbose("validateAndExtractStateFromHash called", requestCorrelationId);
        var serverParams = UrlString.getDeserializedHash(hash);
        if (!serverParams.state) {
          throw BrowserAuthError.createHashDoesNotContainStateError();
        }
        var platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);
        if (!platformStateObj) {
          throw BrowserAuthError.createUnableToParseStateError();
        }
        if (platformStateObj.interactionType !== interactionType) {
          throw BrowserAuthError.createStateInteractionTypeMismatchError();
        }
        this.logger.verbose("Returning state from hash", requestCorrelationId);
        return serverParams.state
      };
      StandardInteractionClient.prototype.getDiscoveredAuthority = function(requestAuthority, requestAzureCloudOptions) {
        return __awaiter$1(this, void 0, void 0, function() {
            var authorityOptions,
              userAuthority,
              builtAuthority;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("getDiscoveredAuthority called");
                    authorityOptions = {
                      protocolMode: this.config.auth.protocolMode, knownAuthorities: this.config.auth.knownAuthorities, cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata, authorityMetadata: this.config.auth.authorityMetadata
                    };
                    userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;
                    builtAuthority = Authority.generateAuthority(userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);
                    this.logger.verbose("Creating discovered authority with configured authority");
                    return [4, AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions)];
                  case 1:
                    return [2, _a.sent()]
                }
              })
          })
      };
      StandardInteractionClient.prototype.initializeAuthorizationRequest = function(request, interactionType) {
        return __awaiter$1(this, void 0, void 0, function() {
            var redirectUri,
              browserState,
              state,
              validatedRequest,
              _a,
              account,
              legacyLoginHint;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    this.logger.verbose("initializeAuthorizationRequest called");
                    redirectUri = this.getRedirectUri(request.redirectUri);
                    browserState = {interactionType: interactionType};
                    state = ProtocolUtils.setRequestState(this.browserCrypto, (request && request.state) || Constants.EMPTY_STRING, browserState);
                    _a = [{}];
                    return [4, this.initializeBaseRequest(request)];
                  case 1:
                    validatedRequest = __assign$1.apply(void 0, [__assign$1.apply(void 0, _a.concat([_b.sent()])), {
                        redirectUri: redirectUri, state: state, nonce: request.nonce || this.browserCrypto.createNewGuid(), responseMode: ResponseMode.FRAGMENT
                      }]);
                    account = request.account || this.browserStorage.getActiveAccount();
                    if (account) {
                      this.logger.verbose("Setting validated request account");
                      this.logger.verbosePii("Setting validated request account: " + account);
                      validatedRequest.account = account
                    }
                    if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {
                      legacyLoginHint = this.browserStorage.getLegacyLoginHint();
                      if (legacyLoginHint) {
                        validatedRequest.loginHint = legacyLoginHint
                      }
                    }
                    return [2, validatedRequest]
                }
              })
          })
      };
      return StandardInteractionClient
    }(BaseInteractionClient));
  var PopupUtils = (function() {
      function PopupUtils(storageImpl, logger) {
        this.browserStorage = storageImpl;
        this.logger = logger;
        this.unloadWindow = this.unloadWindow.bind(this)
      }
      PopupUtils.prototype.openPopup = function(urlNavigate, popupParams) {
        try {
          var popupWindow = void 0;
          if (popupParams.popup) {
            popupWindow = popupParams.popup;
            this.logger.verbosePii("Navigating popup window to: " + urlNavigate);
            popupWindow.location.assign(urlNavigate)
          }
          else if (typeof popupParams.popup === "undefined") {
            this.logger.verbosePii("Opening popup window to: " + urlNavigate);
            popupWindow = PopupUtils.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes, this.logger)
          }
          if (!popupWindow) {
            throw BrowserAuthError.createEmptyWindowCreatedError();
          }
          if (popupWindow.focus) {
            popupWindow.focus()
          }
          this.currentWindow = popupWindow;
          window.addEventListener("beforeunload", this.unloadWindow);
          return popupWindow
        }
        catch(e) {
          this.logger.error("error opening popup " + e.message);
          this.browserStorage.setInteractionInProgress(false);
          throw BrowserAuthError.createPopupWindowError(e.toString());
        }
      };
      PopupUtils.openSizedPopup = function(urlNavigate, popupName, popupWindowAttributes, logger) {
        var _a,
          _b,
          _c,
          _d;
        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;
        var winTop = window.screenTop ? window.screenTop : window.screenY;
        var winWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        var winHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        var width = (_a = popupWindowAttributes.popupSize) === null || _a === void 0 ? void 0 : _a.width;
        var height = (_b = popupWindowAttributes.popupSize) === null || _b === void 0 ? void 0 : _b.height;
        var top = (_c = popupWindowAttributes.popupPosition) === null || _c === void 0 ? void 0 : _c.top;
        var left = (_d = popupWindowAttributes.popupPosition) === null || _d === void 0 ? void 0 : _d.left;
        if (!width || width < 0 || width > winWidth) {
          logger.verbose("Default popup window width used. Window width not configured or invalid.");
          width = BrowserConstants.POPUP_WIDTH
        }
        if (!height || height < 0 || height > winHeight) {
          logger.verbose("Default popup window height used. Window height not configured or invalid.");
          height = BrowserConstants.POPUP_HEIGHT
        }
        if (!top || top < 0 || top > winHeight) {
          logger.verbose("Default popup window top position used. Window top not configured or invalid.");
          top = Math.max(0, ((winHeight / 2) - (BrowserConstants.POPUP_HEIGHT / 2)) + winTop)
        }
        if (!left || left < 0 || left > winWidth) {
          logger.verbose("Default popup window left position used. Window left not configured or invalid.");
          left = Math.max(0, ((winWidth / 2) - (BrowserConstants.POPUP_WIDTH / 2)) + winLeft)
        }
        return window.open(urlNavigate, popupName, "width=" + width + ", height=" + height + ", top=" + top + ", left=" + left + ", scrollbars=yes")
      };
      PopupUtils.prototype.unloadWindow = function(e) {
        this.browserStorage.cleanRequestByInteractionType(exports.InteractionType.Popup);
        if (this.currentWindow) {
          this.currentWindow.close()
        }
        e.preventDefault()
      };
      PopupUtils.prototype.cleanPopup = function(popupWindow) {
        if (popupWindow) {
          popupWindow.close()
        }
        window.removeEventListener("beforeunload", this.unloadWindow);
        this.browserStorage.setInteractionInProgress(false)
      };
      PopupUtils.prototype.monitorPopupForSameOrigin = function(popupWindow) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var intervalId = setInterval(function() {
                if (popupWindow.closed) {
                  _this.cleanPopup();
                  clearInterval(intervalId);
                  reject(BrowserAuthError.createUserCancelledError());
                  return
                }
                var href = Constants.EMPTY_STRING;
                try {
                  href = popupWindow.location.href
                }
                catch(e) {}
                if (StringUtils.isEmpty(href) || href === "about:blank") {
                  return
                }
                clearInterval(intervalId);
                resolve()
              }, BrowserConstants.POLL_INTERVAL_MS)
          })
      };
      PopupUtils.generatePopupName = function(clientId, scopes, authority, correlationId) {
        return BrowserConstants.POPUP_NAME_PREFIX + "." + clientId + "." + scopes.join("-") + "." + authority + "." + correlationId
      };
      PopupUtils.generateLogoutPopupName = function(clientId, request) {
        var homeAccountId = request.account && request.account.homeAccountId;
        return BrowserConstants.POPUP_NAME_PREFIX + "." + clientId + "." + homeAccountId + "." + request.correlationId
      };
      return PopupUtils
    }());
  var InteractionHandler = (function() {
      function InteractionHandler(authCodeModule, storageImpl, authCodeRequest, browserRequestLogger) {
        this.authModule = authCodeModule;
        this.browserStorage = storageImpl;
        this.authCodeRequest = authCodeRequest;
        this.browserRequestLogger = browserRequestLogger
      }
      InteractionHandler.prototype.handleCodeResponseFromHash = function(locationHash, state, authority, networkModule) {
        return __awaiter$1(this, void 0, void 0, function() {
            var stateKey,
              requestState,
              authCodeResponse;
            return __generator$1(this, function(_a) {
                this.browserRequestLogger.verbose("InteractionHandler.handleCodeResponse called");
                if (StringUtils.isEmpty(locationHash)) {
                  throw BrowserAuthError.createEmptyHashError(locationHash);
                }
                stateKey = this.browserStorage.generateStateKey(state);
                requestState = this.browserStorage.getTemporaryCache(stateKey);
                if (!requestState) {
                  throw ClientAuthError.createStateNotFoundError("Cached State");
                }
                authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);
                return [2, this.handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule)]
              })
          })
      };
      InteractionHandler.prototype.handleCodeResponseFromServer = function(authCodeResponse, state, authority, networkModule, validateNonce) {
        if (validateNonce === void 0) {
          validateNonce = true
        }
        return __awaiter$1(this, void 0, void 0, function() {
            var stateKey,
              requestState,
              nonceKey,
              cachedNonce,
              cachedCcsCred,
              tokenResponse;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.browserRequestLogger.trace("InteractionHandler.handleCodeResponseFromServer called");
                    stateKey = this.browserStorage.generateStateKey(state);
                    requestState = this.browserStorage.getTemporaryCache(stateKey);
                    if (!requestState) {
                      throw ClientAuthError.createStateNotFoundError("Cached State");
                    }
                    nonceKey = this.browserStorage.generateNonceKey(requestState);
                    cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);
                    this.authCodeRequest.code = authCodeResponse.code;
                    if (!authCodeResponse.cloud_instance_host_name)
                      return [3, 2];
                    return [4, this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule)];
                  case 1:
                    _a.sent();
                    _a.label = 2;
                  case 2:
                    if (validateNonce) {
                      authCodeResponse.nonce = cachedNonce || undefined
                    }
                    authCodeResponse.state = requestState;
                    if (authCodeResponse.client_info) {
                      this.authCodeRequest.clientInfo = authCodeResponse.client_info
                    }
                    else {
                      cachedCcsCred = this.checkCcsCredentials();
                      if (cachedCcsCred) {
                        this.authCodeRequest.ccsCredential = cachedCcsCred
                      }
                    }
                    return [4, this.authModule.acquireToken(this.authCodeRequest, authCodeResponse)];
                  case 3:
                    tokenResponse = _a.sent();
                    this.browserStorage.cleanRequestByState(state);
                    return [2, tokenResponse]
                }
              })
          })
      };
      InteractionHandler.prototype.updateTokenEndpointAuthority = function(cloudInstanceHostname, authority, networkModule) {
        return __awaiter$1(this, void 0, void 0, function() {
            var cloudInstanceAuthorityUri,
              cloudInstanceAuthority;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    cloudInstanceAuthorityUri = "https://" + cloudInstanceHostname + "/" + authority.tenant + "/";
                    return [4, AuthorityFactory.createDiscoveredInstance(cloudInstanceAuthorityUri, networkModule, this.browserStorage, authority.options)];
                  case 1:
                    cloudInstanceAuthority = _a.sent();
                    this.authModule.updateAuthority(cloudInstanceAuthority);
                    return [2]
                }
              })
          })
      };
      InteractionHandler.prototype.checkCcsCredentials = function() {
        var cachedCcsCred = this.browserStorage.getTemporaryCache(exports.TemporaryCacheKeys.CCS_CREDENTIAL, true);
        if (cachedCcsCred) {
          try {
            return JSON.parse(cachedCcsCred)
          }
          catch(e) {
            this.authModule.logger.error("Cache credential could not be parsed");
            this.authModule.logger.errorPii("Cache credential could not be parsed: " + cachedCcsCred)
          }
        }
        return null
      };
      return InteractionHandler
    }());
  var PopupHandler = (function(_super) {
      __extends$1(PopupHandler, _super);
      function PopupHandler(authCodeModule, storageImpl, authCodeRequest, browserRequestLogger) {
        var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, browserRequestLogger) || this;
        _this.popupUtils = new PopupUtils(storageImpl, browserRequestLogger);
        return _this
      }
      PopupHandler.prototype.initiateAuthRequest = function(requestUrl, params) {
        if (!StringUtils.isEmpty(requestUrl)) {
          this.browserRequestLogger.infoPii("Navigate to: " + requestUrl);
          return this.popupUtils.openPopup(requestUrl, params)
        }
        else {
          this.browserRequestLogger.error("Navigate url is empty");
          throw BrowserAuthError.createEmptyNavigationUriError();
        }
      };
      PopupHandler.prototype.monitorPopupForHash = function(popupWindow) {
        var _this = this;
        return this.popupUtils.monitorPopupForSameOrigin(popupWindow).then(function() {
            var contentHash = popupWindow.location.hash;
            BrowserUtils.clearHash(popupWindow);
            _this.popupUtils.cleanPopup(popupWindow);
            if (!contentHash) {
              throw BrowserAuthError.createEmptyHashError(popupWindow.location.href);
            }
            if (UrlString.hashContainsKnownProperties(contentHash)) {
              return contentHash
            }
            else {
              throw BrowserAuthError.createHashDoesNotContainKnownPropertiesError();
            }
          })
      };
      return PopupHandler
    }(InteractionHandler));
  var PopupClient = (function(_super) {
      __extends$1(PopupClient, _super);
      function PopupClient() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      PopupClient.prototype.acquireToken = function(request) {
        try {
          var popupName = PopupUtils.generatePopupName(this.config.auth.clientId, request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority, this.correlationId);
          var popupWindowAttributes = request.popupWindowAttributes || {};
          if (this.config.system.asyncPopups) {
            this.logger.verbose("asyncPopups set to true, acquiring token");
            return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes)
          }
          else {
            this.logger.verbose("asyncPopup set to false, opening popup before acquiring token");
            var popup = PopupUtils.openSizedPopup("about:blank", popupName, popupWindowAttributes, this.logger);
            return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup)
          }
        }
        catch(e) {
          return Promise.reject(e)
        }
      };
      PopupClient.prototype.logout = function(logoutRequest) {
        try {
          this.logger.verbose("logoutPopup called");
          var validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
          var popupName = PopupUtils.generateLogoutPopupName(this.config.auth.clientId, validLogoutRequest);
          var authority = logoutRequest && logoutRequest.authority;
          var mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;
          var popupWindowAttributes = (logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.popupWindowAttributes) || {};
          if (this.config.system.asyncPopups) {
            this.logger.verbose("asyncPopups set to true");
            return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri)
          }
          else {
            this.logger.verbose("asyncPopup set to false, opening popup");
            var popup = PopupUtils.openSizedPopup("about:blank", popupName, popupWindowAttributes, this.logger);
            return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri)
          }
        }
        catch(e) {
          return Promise.reject(e)
        }
      };
      PopupClient.prototype.acquireTokenPopupAsync = function(request, popupName, popupWindowAttributes, popup) {
        return __awaiter$1(this, void 0, void 0, function() {
            var serverTelemetryManager,
              validRequest,
              authCodeRequest,
              authClient,
              navigateUrl,
              interactionHandler,
              popupParameters,
              popupWindow,
              hash,
              state,
              result,
              e_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("acquireTokenPopupAsync called");
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.acquireTokenPopup);
                    return [4, this.initializeAuthorizationRequest(request, exports.InteractionType.Popup)];
                  case 1:
                    validRequest = _a.sent();
                    this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || "", validRequest.account || null);
                    _a.label = 2;
                  case 2:
                    _a.trys.push([2, 8, , 9]);
                    return [4, this.initializeAuthorizationCodeRequest(validRequest)];
                  case 3:
                    authCodeRequest = _a.sent();
                    return [4, this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];
                  case 4:
                    authClient = _a.sent();
                    this.logger.verbose("Auth code client created");
                    return [4, authClient.getAuthCodeUrl(validRequest)];
                  case 5:
                    navigateUrl = _a.sent();
                    interactionHandler = new PopupHandler(authClient, this.browserStorage, authCodeRequest, this.logger);
                    popupParameters = {
                      popup: popup, popupName: popupName, popupWindowAttributes: popupWindowAttributes
                    };
                    popupWindow = interactionHandler.initiateAuthRequest(navigateUrl, popupParameters);
                    this.eventHandler.emitEvent(exports.EventType.POPUP_OPENED, exports.InteractionType.Popup, {popupWindow: popupWindow}, null);
                    return [4, interactionHandler.monitorPopupForHash(popupWindow)];
                  case 6:
                    hash = _a.sent();
                    state = this.validateAndExtractStateFromHash(hash, exports.InteractionType.Popup, validRequest.correlationId);
                    ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);
                    return [4, interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient)];
                  case 7:
                    result = _a.sent();
                    return [2, result];
                  case 8:
                    e_1 = _a.sent();
                    if (popup) {
                      popup.close()
                    }
                    if (e_1 instanceof AuthError) {
                      e_1.setCorrelationId(this.correlationId)
                    }
                    serverTelemetryManager.cacheFailedRequest(e_1);
                    this.browserStorage.cleanRequestByState(validRequest.state);
                    throw e_1;
                  case 9:
                    return [2]
                }
              })
          })
      };
      PopupClient.prototype.logoutPopupAsync = function(validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {
        return __awaiter$1(this, void 0, void 0, function() {
            var serverTelemetryManager,
              authClient,
              logoutUri,
              popupUtils,
              popupWindow,
              e_2,
              navigationOptions,
              absoluteUrl,
              e_3;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("logoutPopupAsync called");
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_START, exports.InteractionType.Popup, validRequest);
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.logoutPopup);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 8, , 9]);
                    return [4, this.clearCacheOnLogout(validRequest.account)];
                  case 2:
                    _a.sent();
                    return [4, this.createAuthCodeClient(serverTelemetryManager, requestAuthority)];
                  case 3:
                    authClient = _a.sent();
                    this.logger.verbose("Auth code client created");
                    logoutUri = authClient.getLogoutUri(validRequest);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_SUCCESS, exports.InteractionType.Popup, validRequest);
                    popupUtils = new PopupUtils(this.browserStorage, this.logger);
                    popupWindow = popupUtils.openPopup(logoutUri, {
                      popupName: popupName, popupWindowAttributes: popupWindowAttributes, popup: popup
                    });
                    this.eventHandler.emitEvent(exports.EventType.POPUP_OPENED, exports.InteractionType.Popup, {popupWindow: popupWindow}, null);
                    _a.label = 4;
                  case 4:
                    _a.trys.push([4, 6, , 7]);
                    return [4, popupUtils.monitorPopupForSameOrigin(popupWindow)];
                  case 5:
                    _a.sent();
                    this.logger.verbose("Popup successfully redirected to postLogoutRedirectUri");
                    return [3, 7];
                  case 6:
                    e_2 = _a.sent();
                    this.logger.verbose("Error occurred while monitoring popup for same origin. Session on server may remain active. Error: " + e_2);
                    return [3, 7];
                  case 7:
                    popupUtils.cleanPopup(popupWindow);
                    if (mainWindowRedirectUri) {
                      navigationOptions = {
                        apiId: exports.ApiId.logoutPopup, timeout: this.config.system.redirectNavigationTimeout, noHistory: false
                      };
                      absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());
                      this.logger.verbose("Redirecting main window to url specified in the request");
                      this.logger.verbosePii("Redirecting main window to: " + absoluteUrl);
                      this.navigationClient.navigateInternal(absoluteUrl, navigationOptions)
                    }
                    else {
                      this.logger.verbose("No main window navigation requested")
                    }
                    return [3, 9];
                  case 8:
                    e_3 = _a.sent();
                    if (popup) {
                      popup.close()
                    }
                    if (e_3 instanceof AuthError) {
                      e_3.setCorrelationId(this.correlationId)
                    }
                    this.browserStorage.setInteractionInProgress(false);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_FAILURE, exports.InteractionType.Popup, null, e_3);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_END, exports.InteractionType.Popup);
                    serverTelemetryManager.cacheFailedRequest(e_3);
                    throw e_3;
                  case 9:
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_END, exports.InteractionType.Popup);
                    return [2]
                }
              })
          })
      };
      return PopupClient
    }(StandardInteractionClient));
  var RedirectHandler = (function(_super) {
      __extends$1(RedirectHandler, _super);
      function RedirectHandler(authCodeModule, storageImpl, authCodeRequest, browserRequestLogger, browserCrypto) {
        var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, browserRequestLogger) || this;
        _this.browserCrypto = browserCrypto;
        return _this
      }
      RedirectHandler.prototype.initiateAuthRequest = function(requestUrl, params) {
        return __awaiter$1(this, void 0, void 0, function() {
            var navigationOptions,
              navigate;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.browserRequestLogger.verbose("RedirectHandler.initiateAuthRequest called");
                    if (!!StringUtils.isEmpty(requestUrl))
                      return [3, 7];
                    if (params.redirectStartPage) {
                      this.browserRequestLogger.verbose("RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page");
                      this.browserStorage.setTemporaryCache(exports.TemporaryCacheKeys.ORIGIN_URI, params.redirectStartPage, true)
                    }
                    this.browserStorage.setTemporaryCache(exports.TemporaryCacheKeys.CORRELATION_ID, this.authCodeRequest.correlationId, true);
                    this.browserStorage.cacheCodeRequest(this.authCodeRequest, this.browserCrypto);
                    this.browserRequestLogger.infoPii("RedirectHandler.initiateAuthRequest: Navigate to: " + requestUrl);
                    navigationOptions = {
                      apiId: exports.ApiId.acquireTokenRedirect, timeout: params.redirectTimeout, noHistory: false
                    };
                    if (!(typeof params.onRedirectNavigate === "function"))
                      return [3, 4];
                    this.browserRequestLogger.verbose("RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback");
                    navigate = params.onRedirectNavigate(requestUrl);
                    if (!(navigate !== false))
                      return [3, 2];
                    this.browserRequestLogger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating");
                    return [4, params.navigationClient.navigateExternal(requestUrl, navigationOptions)];
                  case 1:
                    _a.sent();
                    return [2];
                  case 2:
                    this.browserRequestLogger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation");
                    return [2];
                  case 3:
                    return [3, 6];
                  case 4:
                    this.browserRequestLogger.verbose("RedirectHandler.initiateAuthRequest: Navigating window to navigate url");
                    return [4, params.navigationClient.navigateExternal(requestUrl, navigationOptions)];
                  case 5:
                    _a.sent();
                    return [2];
                  case 6:
                    return [3, 8];
                  case 7:
                    this.browserRequestLogger.info("RedirectHandler.initiateAuthRequest: Navigate url is empty");
                    throw BrowserAuthError.createEmptyNavigationUriError();
                  case 8:
                    return [2]
                }
              })
          })
      };
      RedirectHandler.prototype.handleCodeResponseFromHash = function(locationHash, state, authority, networkModule, clientId) {
        return __awaiter$1(this, void 0, void 0, function() {
            var stateKey,
              requestState,
              authCodeResponse,
              nonceKey,
              cachedNonce,
              cachedCcsCred,
              tokenResponse;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.browserRequestLogger.verbose("RedirectHandler.handleCodeResponse called");
                    if (StringUtils.isEmpty(locationHash)) {
                      throw BrowserAuthError.createEmptyHashError(locationHash);
                    }
                    this.browserStorage.setInteractionInProgress(false);
                    stateKey = this.browserStorage.generateStateKey(state);
                    requestState = this.browserStorage.getTemporaryCache(stateKey);
                    if (!requestState) {
                      throw ClientAuthError.createStateNotFoundError("Cached State");
                    }
                    authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);
                    nonceKey = this.browserStorage.generateNonceKey(requestState);
                    cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);
                    this.authCodeRequest.code = authCodeResponse.code;
                    if (!authCodeResponse.cloud_instance_host_name)
                      return [3, 2];
                    return [4, this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule)];
                  case 1:
                    _a.sent();
                    _a.label = 2;
                  case 2:
                    authCodeResponse.nonce = cachedNonce || undefined;
                    authCodeResponse.state = requestState;
                    if (authCodeResponse.client_info) {
                      this.authCodeRequest.clientInfo = authCodeResponse.client_info
                    }
                    else {
                      cachedCcsCred = this.checkCcsCredentials();
                      if (cachedCcsCred) {
                        this.authCodeRequest.ccsCredential = cachedCcsCred
                      }
                    }
                    if (clientId) {
                      ThrottlingUtils.removeThrottle(this.browserStorage, clientId, this.authCodeRequest)
                    }
                    return [4, this.authModule.acquireToken(this.authCodeRequest, authCodeResponse)];
                  case 3:
                    tokenResponse = _a.sent();
                    this.browserStorage.cleanRequestByState(state);
                    return [2, tokenResponse]
                }
              })
          })
      };
      return RedirectHandler
    }(InteractionHandler));
  var RedirectClient = (function(_super) {
      __extends$1(RedirectClient, _super);
      function RedirectClient() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      RedirectClient.prototype.acquireToken = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var validRequest,
              serverTelemetryManager,
              handleBackButton,
              authCodeRequest,
              authClient,
              interactionHandler,
              navigateUrl,
              redirectStartPage,
              e_1;
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.initializeAuthorizationRequest(request, exports.InteractionType.Redirect)];
                  case 1:
                    validRequest = _a.sent();
                    this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || "", validRequest.account || null);
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.acquireTokenRedirect);
                    handleBackButton = function(event) {
                      if (event.persisted) {
                        _this.logger.verbose("Page was restored from back/forward cache. Clearing temporary cache.");
                        _this.browserStorage.cleanRequestByState(validRequest.state)
                      }
                    };
                    _a.label = 2;
                  case 2:
                    _a.trys.push([2, 7, , 8]);
                    return [4, this.initializeAuthorizationCodeRequest(validRequest)];
                  case 3:
                    authCodeRequest = _a.sent();
                    return [4, this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];
                  case 4:
                    authClient = _a.sent();
                    this.logger.verbose("Auth code client created");
                    interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.browserCrypto);
                    return [4, authClient.getAuthCodeUrl(validRequest)];
                  case 5:
                    navigateUrl = _a.sent();
                    redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);
                    this.logger.verbosePii("Redirect start page: " + redirectStartPage);
                    window.addEventListener("pageshow", handleBackButton);
                    return [4, interactionHandler.initiateAuthRequest(navigateUrl, {
                          navigationClient: this.navigationClient, redirectTimeout: this.config.system.redirectNavigationTimeout, redirectStartPage: redirectStartPage, onRedirectNavigate: request.onRedirectNavigate
                        })];
                  case 6:
                    return [2, _a.sent()];
                  case 7:
                    e_1 = _a.sent();
                    if (e_1 instanceof AuthError) {
                      e_1.setCorrelationId(this.correlationId)
                    }
                    window.removeEventListener("pageshow", handleBackButton);
                    serverTelemetryManager.cacheFailedRequest(e_1);
                    this.browserStorage.cleanRequestByState(validRequest.state);
                    throw e_1;
                  case 8:
                    return [2]
                }
              })
          })
      };
      RedirectClient.prototype.handleRedirectPromise = function(hash) {
        return __awaiter$1(this, void 0, void 0, function() {
            var serverTelemetryManager,
              responseHash,
              state,
              loginRequestUrl,
              loginRequestUrlNormalized,
              currentUrlNormalized,
              handleHashResult,
              navigationOptions,
              processHashOnRedirect,
              homepage,
              e_2;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.handleRedirectPromise);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 10, , 11]);
                    if (!this.browserStorage.isInteractionInProgress(true)) {
                      this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
                      return [2, null]
                    }
                    responseHash = this.getRedirectResponseHash(hash || window.location.hash);
                    if (!responseHash) {
                      this.logger.info("handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.");
                      this.browserStorage.cleanRequestByInteractionType(exports.InteractionType.Redirect);
                      return [2, null]
                    }
                    state = void 0;
                    try {
                      state = this.validateAndExtractStateFromHash(responseHash, exports.InteractionType.Redirect);
                      this.logger.verbose("State extracted from hash")
                    }
                    catch(e) {
                      this.logger.info("handleRedirectPromise was unable to extract state due to: " + e);
                      this.browserStorage.cleanRequestByInteractionType(exports.InteractionType.Redirect);
                      return [2, null]
                    }
                    loginRequestUrl = this.browserStorage.getTemporaryCache(exports.TemporaryCacheKeys.ORIGIN_URI, true) || "";
                    loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);
                    currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);
                    if (!(loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl))
                      return [3, 3];
                    this.logger.verbose("Current page is loginRequestUrl, handling hash");
                    return [4, this.handleHash(responseHash, state, serverTelemetryManager)];
                  case 2:
                    handleHashResult = _a.sent();
                    if (loginRequestUrl.indexOf("#") > -1) {
                      BrowserUtils.replaceHash(loginRequestUrl)
                    }
                    return [2, handleHashResult];
                  case 3:
                    if (!!this.config.auth.navigateToLoginRequestUrl)
                      return [3, 4];
                    this.logger.verbose("NavigateToLoginRequestUrl set to false, handling hash");
                    return [2, this.handleHash(responseHash, state, serverTelemetryManager)];
                  case 4:
                    if (!(!BrowserUtils.isInIframe() || this.config.system.allowRedirectInIframe))
                      return [3, 9];
                    this.browserStorage.setTemporaryCache(exports.TemporaryCacheKeys.URL_HASH, responseHash, true);
                    navigationOptions = {
                      apiId: exports.ApiId.handleRedirectPromise, timeout: this.config.system.redirectNavigationTimeout, noHistory: true
                    };
                    processHashOnRedirect = true;
                    if (!(!loginRequestUrl || loginRequestUrl === "null"))
                      return [3, 6];
                    homepage = BrowserUtils.getHomepage();
                    this.browserStorage.setTemporaryCache(exports.TemporaryCacheKeys.ORIGIN_URI, homepage, true);
                    this.logger.warning("Unable to get valid login request url from cache, redirecting to home page");
                    return [4, this.navigationClient.navigateInternal(homepage, navigationOptions)];
                  case 5:
                    processHashOnRedirect = _a.sent();
                    return [3, 8];
                  case 6:
                    this.logger.verbose("Navigating to loginRequestUrl: " + loginRequestUrl);
                    return [4, this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions)];
                  case 7:
                    processHashOnRedirect = _a.sent();
                    _a.label = 8;
                  case 8:
                    if (!processHashOnRedirect) {
                      return [2, this.handleHash(responseHash, state, serverTelemetryManager)]
                    }
                    _a.label = 9;
                  case 9:
                    return [2, null];
                  case 10:
                    e_2 = _a.sent();
                    if (e_2 instanceof AuthError) {
                      e_2.setCorrelationId(this.correlationId)
                    }
                    serverTelemetryManager.cacheFailedRequest(e_2);
                    this.browserStorage.cleanRequestByInteractionType(exports.InteractionType.Redirect);
                    throw e_2;
                  case 11:
                    return [2]
                }
              })
          })
      };
      RedirectClient.prototype.getRedirectResponseHash = function(hash) {
        this.logger.verbose("getRedirectResponseHash called");
        var isResponseHash = UrlString.hashContainsKnownProperties(hash);
        if (isResponseHash) {
          BrowserUtils.clearHash(window);
          this.logger.verbose("Hash contains known properties, returning response hash");
          return hash
        }
        var cachedHash = this.browserStorage.getTemporaryCache(exports.TemporaryCacheKeys.URL_HASH, true);
        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(exports.TemporaryCacheKeys.URL_HASH));
        this.logger.verbose("Hash does not contain known properties, returning cached hash");
        return cachedHash
      };
      RedirectClient.prototype.handleHash = function(hash, state, serverTelemetryManager) {
        return __awaiter$1(this, void 0, void 0, function() {
            var cachedRequest,
              currentAuthority,
              authClient,
              interactionHandler;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    cachedRequest = this.browserStorage.getCachedRequest(state, this.browserCrypto);
                    this.logger.verbose("handleHash called, retrieved cached request");
                    currentAuthority = this.browserStorage.getCachedAuthority(state);
                    if (!currentAuthority) {
                      throw BrowserAuthError.createNoCachedAuthorityError();
                    }
                    return [4, this.createAuthCodeClient(serverTelemetryManager, currentAuthority)];
                  case 1:
                    authClient = _a.sent();
                    this.logger.verbose("Auth code client created");
                    interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, this.logger, this.browserCrypto);
                    return [4, interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient, this.config.auth.clientId)];
                  case 2:
                    return [2, _a.sent()]
                }
              })
          })
      };
      RedirectClient.prototype.logout = function(logoutRequest) {
        return __awaiter$1(this, void 0, void 0, function() {
            var validLogoutRequest,
              serverTelemetryManager,
              navigationOptions,
              authClient,
              logoutUri,
              navigate,
              e_3;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("logoutRedirect called");
                    validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.logout);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 10, , 11]);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_START, exports.InteractionType.Redirect, logoutRequest);
                    return [4, this.clearCacheOnLogout(validLogoutRequest.account)];
                  case 2:
                    _a.sent();
                    navigationOptions = {
                      apiId: exports.ApiId.logout, timeout: this.config.system.redirectNavigationTimeout, noHistory: false
                    };
                    return [4, this.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority)];
                  case 3:
                    authClient = _a.sent();
                    this.logger.verbose("Auth code client created");
                    logoutUri = authClient.getLogoutUri(validLogoutRequest);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_SUCCESS, exports.InteractionType.Redirect, validLogoutRequest);
                    if (!(logoutRequest && typeof logoutRequest.onRedirectNavigate === "function"))
                      return [3, 7];
                    navigate = logoutRequest.onRedirectNavigate(logoutUri);
                    if (!(navigate !== false))
                      return [3, 5];
                    this.logger.verbose("Logout onRedirectNavigate did not return false, navigating");
                    return [4, this.navigationClient.navigateExternal(logoutUri, navigationOptions)];
                  case 4:
                    _a.sent();
                    return [2];
                  case 5:
                    this.logger.verbose("Logout onRedirectNavigate returned false, stopping navigation");
                    _a.label = 6;
                  case 6:
                    return [3, 9];
                  case 7:
                    return [4, this.navigationClient.navigateExternal(logoutUri, navigationOptions)];
                  case 8:
                    _a.sent();
                    return [2];
                  case 9:
                    return [3, 11];
                  case 10:
                    e_3 = _a.sent();
                    if (e_3 instanceof AuthError) {
                      e_3.setCorrelationId(this.correlationId)
                    }
                    serverTelemetryManager.cacheFailedRequest(e_3);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_FAILURE, exports.InteractionType.Redirect, null, e_3);
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_END, exports.InteractionType.Redirect);
                    throw e_3;
                  case 11:
                    this.eventHandler.emitEvent(exports.EventType.LOGOUT_END, exports.InteractionType.Redirect);
                    return [2]
                }
              })
          })
      };
      RedirectClient.prototype.getRedirectStartPage = function(requestStartPage) {
        var redirectStartPage = requestStartPage || window.location.href;
        return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri())
      };
      return RedirectClient
    }(StandardInteractionClient));
  var SilentHandler = (function(_super) {
      __extends$1(SilentHandler, _super);
      function SilentHandler(authCodeModule, storageImpl, authCodeRequest, browserRequestLogger, navigateFrameWait) {
        var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, browserRequestLogger) || this;
        _this.navigateFrameWait = navigateFrameWait;
        return _this
      }
      SilentHandler.prototype.initiateAuthRequest = function(requestUrl) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _a;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    if (StringUtils.isEmpty(requestUrl)) {
                      this.browserRequestLogger.info("Navigate url is empty");
                      throw BrowserAuthError.createEmptyNavigationUriError();
                    }
                    if (!this.navigateFrameWait)
                      return [3, 2];
                    return [4, this.loadFrame(requestUrl)];
                  case 1:
                    _a = _b.sent();
                    return [3, 3];
                  case 2:
                    _a = this.loadFrameSync(requestUrl);
                    _b.label = 3;
                  case 3:
                    return [2, _a]
                }
              })
          })
      };
      SilentHandler.prototype.monitorIframeForHash = function(iframe, timeout) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {
              _this.browserRequestLogger.warning("system.loadFrameTimeout or system.iframeHashTimeout set to lower (" + timeout + "ms) than the default (" + DEFAULT_IFRAME_TIMEOUT_MS + "ms). This may result in timeouts.")
            }
            var nowMark = window.performance.now();
            var timeoutMark = nowMark + timeout;
            var intervalId = setInterval(function() {
                if (window.performance.now() > timeoutMark) {
                  _this.removeHiddenIframe(iframe);
                  clearInterval(intervalId);
                  reject(BrowserAuthError.createMonitorIframeTimeoutError());
                  return
                }
                var href = Constants.EMPTY_STRING;
                var contentWindow = iframe.contentWindow;
                try {
                  href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING
                }
                catch(e) {}
                if (StringUtils.isEmpty(href)) {
                  return
                }
                var contentHash = contentWindow ? contentWindow.location.hash : Constants.EMPTY_STRING;
                if (UrlString.hashContainsKnownProperties(contentHash)) {
                  _this.removeHiddenIframe(iframe);
                  clearInterval(intervalId);
                  resolve(contentHash);
                  return
                }
              }, BrowserConstants.POLL_INTERVAL_MS)
          })
      };
      SilentHandler.prototype.loadFrame = function(urlNavigate) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var frameHandle = _this.createHiddenIframe();
            setTimeout(function() {
              if (!frameHandle) {
                reject("Unable to load iframe");
                return
              }
              frameHandle.src = urlNavigate;
              resolve(frameHandle)
            }, _this.navigateFrameWait)
          })
      };
      SilentHandler.prototype.loadFrameSync = function(urlNavigate) {
        var frameHandle = this.createHiddenIframe();
        frameHandle.src = urlNavigate;
        return frameHandle
      };
      SilentHandler.prototype.createHiddenIframe = function() {
        var authFrame = document.createElement("iframe");
        authFrame.style.visibility = "hidden";
        authFrame.style.position = "absolute";
        authFrame.style.width = authFrame.style.height = "0";
        authFrame.style.border = "0";
        authFrame.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
        document.getElementsByTagName("body")[0].appendChild(authFrame);
        return authFrame
      };
      SilentHandler.prototype.removeHiddenIframe = function(iframe) {
        if (document.body === iframe.parentNode) {
          document.body.removeChild(iframe)
        }
      };
      return SilentHandler
    }(InteractionHandler));
  var SilentIframeClient = (function(_super) {
      __extends$1(SilentIframeClient, _super);
      function SilentIframeClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, correlationId) {
        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, correlationId) || this;
        _this.apiId = apiId;
        return _this
      }
      SilentIframeClient.prototype.acquireToken = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentRequest,
              serverTelemetryManager,
              authCodeRequest,
              authClient,
              navigateUrl,
              e_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.verbose("acquireTokenByIframe called");
                    if (StringUtils.isEmpty(request.loginHint) && StringUtils.isEmpty(request.sid) && (!request.account || StringUtils.isEmpty(request.account.username))) {
                      this.logger.warning("No user hint provided. The authorization server may need more information to complete this request.")
                    }
                    if (request.prompt && request.prompt !== PromptValue.NONE) {
                      throw BrowserAuthError.createSilentPromptValueError(request.prompt);
                    }
                    return [4, this.initializeAuthorizationRequest(__assign$1(__assign$1({}, request), {prompt: PromptValue.NONE}), exports.InteractionType.Silent)];
                  case 1:
                    silentRequest = _a.sent();
                    this.browserStorage.updateCacheEntries(silentRequest.state, silentRequest.nonce, silentRequest.authority, silentRequest.loginHint || "", silentRequest.account || null);
                    serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
                    _a.label = 2;
                  case 2:
                    _a.trys.push([2, 7, , 8]);
                    return [4, this.initializeAuthorizationCodeRequest(silentRequest)];
                  case 3:
                    authCodeRequest = _a.sent();
                    return [4, this.createAuthCodeClient(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions)];
                  case 4:
                    authClient = _a.sent();
                    this.logger.verbose("Auth code client created");
                    return [4, authClient.getAuthCodeUrl(silentRequest)];
                  case 5:
                    navigateUrl = _a.sent();
                    return [4, this.silentTokenHelper(navigateUrl, authCodeRequest, authClient, this.logger)];
                  case 6:
                    return [2, _a.sent()];
                  case 7:
                    e_1 = _a.sent();
                    if (e_1 instanceof AuthError) {
                      e_1.setCorrelationId(this.correlationId)
                    }
                    serverTelemetryManager.cacheFailedRequest(e_1);
                    this.browserStorage.cleanRequestByState(silentRequest.state);
                    throw e_1;
                  case 8:
                    return [2]
                }
              })
          })
      };
      SilentIframeClient.prototype.logout = function() {
        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError())
      };
      SilentIframeClient.prototype.silentTokenHelper = function(navigateUrl, authCodeRequest, authClient, browserRequestLogger) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentHandler,
              msalFrame,
              hash,
              state;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    silentHandler = new SilentHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger, this.config.system.navigateFrameWait);
                    return [4, silentHandler.initiateAuthRequest(navigateUrl)];
                  case 1:
                    msalFrame = _a.sent();
                    return [4, silentHandler.monitorIframeForHash(msalFrame, this.config.system.iframeHashTimeout)];
                  case 2:
                    hash = _a.sent();
                    state = this.validateAndExtractStateFromHash(hash, exports.InteractionType.Silent, authCodeRequest.correlationId);
                    return [2, silentHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient)]
                }
              })
          })
      };
      return SilentIframeClient
    }(StandardInteractionClient));
  var SilentRefreshClient = (function(_super) {
      __extends$1(SilentRefreshClient, _super);
      function SilentRefreshClient() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      SilentRefreshClient.prototype.acquireToken = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentRequest,
              _a,
              serverTelemetryManager,
              refreshTokenClient;
            var _this = this;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _a = [__assign$1({}, request)];
                    return [4, this.initializeBaseRequest(request)];
                  case 1:
                    silentRequest = __assign$1.apply(void 0, _a.concat([_b.sent()]));
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.acquireTokenSilent_silentFlow);
                    return [4, this.createRefreshTokenClient(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions)];
                  case 2:
                    refreshTokenClient = _b.sent();
                    this.logger.verbose("Refresh token client created");
                    return [2, refreshTokenClient.acquireTokenByRefreshToken(silentRequest).catch(function(e) {
                          if (e instanceof AuthError) {
                            e.setCorrelationId(_this.correlationId)
                          }
                          serverTelemetryManager.cacheFailedRequest(e);
                          throw e;
                        })]
                }
              })
          })
      };
      SilentRefreshClient.prototype.logout = function() {
        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError())
      };
      SilentRefreshClient.prototype.createRefreshTokenClient = function(serverTelemetryManager, authorityUrl, azureCloudOptions) {
        return __awaiter$1(this, void 0, void 0, function() {
            var clientConfig;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.getClientConfiguration(serverTelemetryManager, authorityUrl, azureCloudOptions)];
                  case 1:
                    clientConfig = _a.sent();
                    return [2, new RefreshTokenClient(clientConfig)]
                }
              })
          })
      };
      return SilentRefreshClient
    }(StandardInteractionClient));
  var TokenCache = (function() {
      function TokenCache(configuration, storage, logger, cryptoObj) {
        this.isBrowserEnvironment = typeof window !== "undefined";
        this.config = configuration;
        this.storage = storage;
        this.logger = logger;
        this.cryptoObj = cryptoObj
      }
      TokenCache.prototype.loadExternalTokens = function(request, response, options) {
        this.logger.info("TokenCache - loadExternalTokens called");
        if (!response.id_token) {
          throw BrowserAuthError.createUnableToLoadTokenError("Please ensure server response includes id token.");
        }
        if (request.account) {
          this.loadIdToken(response.id_token, request.account.homeAccountId, request.account.environment, request.account.tenantId, options);
          this.loadAccessToken(request, response, request.account.homeAccountId, request.account.environment, request.account.tenantId, options)
        }
        else if (request.authority) {
          var authorityUrl = Authority.generateAuthority(request.authority, request.azureCloudOptions);
          var authorityOptions = {
              protocolMode: this.config.auth.protocolMode, knownAuthorities: this.config.auth.knownAuthorities, cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata, authorityMetadata: this.config.auth.authorityMetadata
            };
          var authority = new Authority(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions);
          if (options.clientInfo) {
            this.logger.trace("TokenCache - homeAccountId from options");
            this.loadIdToken(response.id_token, options.clientInfo, authority.hostnameAndPort, authority.tenant, options);
            this.loadAccessToken(request, response, options.clientInfo, authority.hostnameAndPort, authority.tenant, options)
          }
          else if (response.client_info) {
            this.logger.trace("TokenCache - homeAccountId from response");
            this.loadIdToken(response.id_token, response.client_info, authority.hostnameAndPort, authority.tenant, options);
            this.loadAccessToken(request, response, response.client_info, authority.hostnameAndPort, authority.tenant, options)
          }
          else {
            throw BrowserAuthError.createUnableToLoadTokenError("Please provide clientInfo in the response or options.");
          }
        }
        else {
          throw BrowserAuthError.createUnableToLoadTokenError("Please provide a request with an account or a request with authority.");
        }
      };
      TokenCache.prototype.loadIdToken = function(idToken, homeAccountId, environment, tenantId, options) {
        var idTokenEntity = IdTokenEntity.createIdTokenEntity(homeAccountId, environment, idToken, this.config.auth.clientId, tenantId);
        var idAuthToken = new AuthToken(idToken, this.cryptoObj);
        var accountEntity = options.clientInfo ? AccountEntity.createAccount(options.clientInfo, homeAccountId, idAuthToken, undefined, undefined, undefined, undefined, environment) : AccountEntity.createGenericAccount(homeAccountId, idAuthToken, undefined, undefined, undefined, undefined, environment);
        if (this.isBrowserEnvironment) {
          this.logger.verbose("TokenCache - loading id token");
          this.storage.setAccount(accountEntity);
          this.storage.setIdTokenCredential(idTokenEntity)
        }
        else {
          throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
        }
      };
      TokenCache.prototype.loadAccessToken = function(request, response, homeAccountId, environment, tenantId, options) {
        if (!response.access_token) {
          this.logger.verbose("TokenCache - No access token provided for caching");
          return
        }
        if (!response.expires_in) {
          throw BrowserAuthError.createUnableToLoadTokenError("Please ensure server response includes expires_in value.");
        }
        if (!options.extendedExpiresOn) {
          throw BrowserAuthError.createUnableToLoadTokenError("Please provide an extendedExpiresOn value in the options.");
        }
        var scopes = new ScopeSet(request.scopes).printScopes();
        var expiresOn = response.expires_in;
        var extendedExpiresOn = options.extendedExpiresOn;
        var accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes, expiresOn, extendedExpiresOn, this.cryptoObj);
        if (this.isBrowserEnvironment) {
          this.logger.verbose("TokenCache - loading access token");
          this.storage.setAccessTokenCredential(accessTokenEntity)
        }
        else {
          throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
        }
      };
      return TokenCache
    }());
  var HybridSpaAuthorizationCodeClient = (function(_super) {
      __extends$1(HybridSpaAuthorizationCodeClient, _super);
      function HybridSpaAuthorizationCodeClient(config) {
        var _this = _super.call(this, config) || this;
        _this.includeRedirectUri = false;
        return _this
      }
      return HybridSpaAuthorizationCodeClient
    }(AuthorizationCodeClient));
  var SilentAuthCodeClient = (function(_super) {
      __extends$1(SilentAuthCodeClient, _super);
      function SilentAuthCodeClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, correlationId) {
        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, correlationId) || this;
        _this.apiId = apiId;
        return _this
      }
      SilentAuthCodeClient.prototype.acquireToken = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentRequest,
              serverTelemetryManager,
              authCodeRequest,
              clientConfig,
              authClient,
              silentHandler,
              e_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.trace("SilentAuthCodeClient.acquireToken called");
                    if (!request.code) {
                      throw BrowserAuthError.createAuthCodeRequiredError();
                    }
                    return [4, this.initializeAuthorizationRequest(request, exports.InteractionType.Silent)];
                  case 1:
                    silentRequest = _a.sent();
                    this.browserStorage.updateCacheEntries(silentRequest.state, silentRequest.nonce, silentRequest.authority, silentRequest.loginHint || "", silentRequest.account || null);
                    serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
                    _a.label = 2;
                  case 2:
                    _a.trys.push([2, 4, , 5]);
                    authCodeRequest = __assign$1(__assign$1({}, silentRequest), {code: request.code});
                    return [4, this.getClientConfiguration(serverTelemetryManager, silentRequest.authority)];
                  case 3:
                    clientConfig = _a.sent();
                    authClient = new HybridSpaAuthorizationCodeClient(clientConfig);
                    this.logger.verbose("Auth code client created");
                    silentHandler = new SilentHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.config.system.navigateFrameWait);
                    return [2, silentHandler.handleCodeResponseFromServer({
                          code: request.code, msgraph_host: request.msGraphHost, cloud_graph_host_name: request.cloudGraphHostName, cloud_instance_host_name: request.cloudInstanceHostName
                        }, silentRequest.state, authClient.authority, this.networkClient, false)];
                  case 4:
                    e_1 = _a.sent();
                    if (e_1 instanceof AuthError) {
                      e_1.setCorrelationId(this.correlationId)
                    }
                    serverTelemetryManager.cacheFailedRequest(e_1);
                    this.browserStorage.cleanRequestByState(silentRequest.state);
                    throw e_1;
                  case 5:
                    return [2]
                }
              })
          })
      };
      SilentAuthCodeClient.prototype.logout = function() {
        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError())
      };
      return SilentAuthCodeClient
    }(StandardInteractionClient));
  var ClientApplication = (function() {
      function ClientApplication(configuration) {
        this.isBrowserEnvironment = typeof window !== "undefined";
        this.config = buildConfiguration(configuration, this.isBrowserEnvironment);
        this.logger = new Logger(this.config.system.loggerOptions, name, version);
        this.networkClient = this.config.system.networkClient;
        this.navigationClient = this.config.system.navigationClient;
        this.redirectResponse = new Map;
        this.hybridAuthCodeResponses = new Map;
        this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger) : DEFAULT_CRYPTO_IMPLEMENTATION;
        this.eventHandler = new EventHandler(this.logger, this.browserCrypto);
        this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);
        this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto)
      }
      ClientApplication.prototype.handleRedirectPromise = function(hash) {
        return __awaiter$1(this, void 0, void 0, function() {
            var loggedInAccounts,
              redirectResponseKey,
              response,
              correlationId,
              redirectClient;
            var _this = this;
            return __generator$1(this, function(_a) {
                this.logger.verbose("handleRedirectPromise called");
                loggedInAccounts = this.getAllAccounts();
                if (this.isBrowserEnvironment) {
                  redirectResponseKey = hash || Constants.EMPTY_STRING;
                  response = this.redirectResponse.get(redirectResponseKey);
                  if (typeof response === "undefined") {
                    this.eventHandler.emitEvent(exports.EventType.HANDLE_REDIRECT_START, exports.InteractionType.Redirect);
                    this.logger.verbose("handleRedirectPromise has been called for the first time, storing the promise");
                    correlationId = this.browserStorage.getTemporaryCache(exports.TemporaryCacheKeys.CORRELATION_ID, true) || "";
                    redirectClient = new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, correlationId);
                    response = redirectClient.handleRedirectPromise(hash).then(function(result) {
                      if (result) {
                        var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;
                        if (isLoggingIn) {
                          _this.eventHandler.emitEvent(exports.EventType.LOGIN_SUCCESS, exports.InteractionType.Redirect, result);
                          _this.logger.verbose("handleRedirectResponse returned result, login success")
                        }
                        else {
                          _this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_SUCCESS, exports.InteractionType.Redirect, result);
                          _this.logger.verbose("handleRedirectResponse returned result, acquire token success")
                        }
                      }
                      _this.eventHandler.emitEvent(exports.EventType.HANDLE_REDIRECT_END, exports.InteractionType.Redirect);
                      return result
                    }).catch(function(e) {
                      if (loggedInAccounts.length > 0) {
                        _this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_FAILURE, exports.InteractionType.Redirect, null, e)
                      }
                      else {
                        _this.eventHandler.emitEvent(exports.EventType.LOGIN_FAILURE, exports.InteractionType.Redirect, null, e)
                      }
                      _this.eventHandler.emitEvent(exports.EventType.HANDLE_REDIRECT_END, exports.InteractionType.Redirect);
                      throw e;
                    });
                    this.redirectResponse.set(redirectResponseKey, response)
                  }
                  else {
                    this.logger.verbose("handleRedirectPromise has been called previously, returning the result from the first call")
                  }
                  return [2, response]
                }
                this.logger.verbose("handleRedirectPromise returns null, not browser environment");
                return [2, null]
              })
          })
      };
      ClientApplication.prototype.acquireTokenRedirect = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var isLoggedIn,
              redirectClient;
            var _this = this;
            return __generator$1(this, function(_a) {
                this.logger.verbose("acquireTokenRedirect called");
                this.preflightBrowserEnvironmentCheck(exports.InteractionType.Redirect);
                isLoggedIn = this.getAllAccounts().length > 0;
                if (isLoggedIn) {
                  this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_START, exports.InteractionType.Redirect, request)
                }
                else {
                  this.eventHandler.emitEvent(exports.EventType.LOGIN_START, exports.InteractionType.Redirect, request)
                }
                redirectClient = new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, request.correlationId);
                return [2, redirectClient.acquireToken(request).catch(function(e) {
                      if (isLoggedIn) {
                        _this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_FAILURE, exports.InteractionType.Redirect, null, e)
                      }
                      else {
                        _this.eventHandler.emitEvent(exports.EventType.LOGIN_FAILURE, exports.InteractionType.Redirect, null, e)
                      }
                      throw e;
                    })]
              })
          })
      };
      ClientApplication.prototype.acquireTokenPopup = function(request) {
        var _this = this;
        try {
          this.logger.verbose("acquireTokenPopup called", request.correlationId);
          this.preflightBrowserEnvironmentCheck(exports.InteractionType.Popup)
        }
        catch(e) {
          return Promise.reject(e)
        }
        var loggedInAccounts = this.getAllAccounts();
        if (loggedInAccounts.length > 0) {
          this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_START, exports.InteractionType.Popup, request)
        }
        else {
          this.eventHandler.emitEvent(exports.EventType.LOGIN_START, exports.InteractionType.Popup, request)
        }
        var popupClient = new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, request.correlationId);
        return popupClient.acquireToken(request).then(function(result) {
            var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;
            if (isLoggingIn) {
              _this.eventHandler.emitEvent(exports.EventType.LOGIN_SUCCESS, exports.InteractionType.Popup, result)
            }
            else {
              _this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_SUCCESS, exports.InteractionType.Popup, result)
            }
            return result
          }).catch(function(e) {
            if (loggedInAccounts.length > 0) {
              _this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_FAILURE, exports.InteractionType.Popup, null, e)
            }
            else {
              _this.eventHandler.emitEvent(exports.EventType.LOGIN_FAILURE, exports.InteractionType.Popup, null, e)
            }
            return Promise.reject(e)
          })
      };
      ClientApplication.prototype.ssoSilent = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentIframeClient,
              silentTokenResult,
              e_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.preflightBrowserEnvironmentCheck(exports.InteractionType.Silent);
                    this.logger.verbose("ssoSilent called", request.correlationId);
                    this.eventHandler.emitEvent(exports.EventType.SSO_SILENT_START, exports.InteractionType.Silent, request);
                    _a.label = 1;
                  case 1:
                    _a.trys.push([1, 3, , 4]);
                    silentIframeClient = new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, exports.ApiId.ssoSilent, request.correlationId);
                    return [4, silentIframeClient.acquireToken(request)];
                  case 2:
                    silentTokenResult = _a.sent();
                    this.eventHandler.emitEvent(exports.EventType.SSO_SILENT_SUCCESS, exports.InteractionType.Silent, silentTokenResult);
                    return [2, silentTokenResult];
                  case 3:
                    e_1 = _a.sent();
                    this.eventHandler.emitEvent(exports.EventType.SSO_SILENT_FAILURE, exports.InteractionType.Silent, null, e_1);
                    throw e_1;
                  case 4:
                    return [2]
                }
              })
          })
      };
      ClientApplication.prototype.acquireTokenByCode = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var response;
            var _this = this;
            return __generator$1(this, function(_a) {
                this.preflightBrowserEnvironmentCheck(exports.InteractionType.Silent);
                this.logger.trace("acquireTokenByCode called", request.correlationId);
                this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_BY_CODE_START, exports.InteractionType.Silent, request);
                try {
                  if (!request.code) {
                    throw BrowserAuthError.createAuthCodeRequiredError();
                  }
                  response = this.hybridAuthCodeResponses.get(request.code);
                  if (!response) {
                    this.logger.verbose("Initiating new acquireTokenByCode request", request.correlationId);
                    response = this.acquireTokenByCodeAsync(request).then(function(result) {
                      _this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, exports.InteractionType.Silent, result);
                      _this.hybridAuthCodeResponses.delete(request.code);
                      return result
                    }).catch(function(error) {
                      _this.hybridAuthCodeResponses.delete(request.code);
                      throw error;
                    });
                    this.hybridAuthCodeResponses.set(request.code, response)
                  }
                  else {
                    this.logger.verbose("Existing acquireTokenByCode request found", request.correlationId)
                  }
                  return [2, response]
                }
                catch(e) {
                  this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, exports.InteractionType.Silent, null, e);
                  throw e;
                }
                return [2]
              })
          })
      };
      ClientApplication.prototype.acquireTokenByCodeAsync = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentAuthCodeClient,
              silentTokenResult;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    this.logger.trace("acquireTokenByCodeAsync called", request.correlationId);
                    silentAuthCodeClient = new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, exports.ApiId.acquireTokenByCode, request.correlationId);
                    return [4, silentAuthCodeClient.acquireToken(request)];
                  case 1:
                    silentTokenResult = _a.sent();
                    return [2, silentTokenResult]
                }
              })
          })
      };
      ClientApplication.prototype.acquireTokenByRefreshToken = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentRefreshClient;
            var _this = this;
            return __generator$1(this, function(_a) {
                this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_NETWORK_START, exports.InteractionType.Silent, request);
                BrowserUtils.blockReloadInHiddenIframes();
                silentRefreshClient = new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, request.correlationId);
                return [2, silentRefreshClient.acquireToken(request).catch(function(e) {
                      var isServerError = e instanceof ServerError;
                      var isInteractionRequiredError = e instanceof InteractionRequiredAuthError;
                      var isInvalidGrantError = (e.errorCode === BrowserConstants.INVALID_GRANT_ERROR);
                      if (isServerError && isInvalidGrantError && !isInteractionRequiredError) {
                        _this.logger.verbose("Refresh token expired or invalid, attempting acquire token by iframe", request.correlationId);
                        var silentIframeClient = new SilentIframeClient(_this.config, _this.browserStorage, _this.browserCrypto, _this.logger, _this.eventHandler, _this.navigationClient, exports.ApiId.acquireTokenSilent_authCode, request.correlationId);
                        return silentIframeClient.acquireToken(request)
                      }
                      throw e;
                    })]
              })
          })
      };
      ClientApplication.prototype.logout = function(logoutRequest) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                this.logger.warning("logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.");
                return [2, this.logoutRedirect(logoutRequest)]
              })
          })
      };
      ClientApplication.prototype.logoutRedirect = function(logoutRequest) {
        return __awaiter$1(this, void 0, void 0, function() {
            var redirectClient;
            return __generator$1(this, function(_a) {
                this.preflightBrowserEnvironmentCheck(exports.InteractionType.Redirect);
                redirectClient = new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);
                return [2, redirectClient.logout(logoutRequest)]
              })
          })
      };
      ClientApplication.prototype.logoutPopup = function(logoutRequest) {
        try {
          this.preflightBrowserEnvironmentCheck(exports.InteractionType.Popup);
          var popupClient = new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);
          return popupClient.logout(logoutRequest)
        }
        catch(e) {
          return Promise.reject(e)
        }
      };
      ClientApplication.prototype.getAllAccounts = function() {
        this.logger.verbose("getAllAccounts called");
        return this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : []
      };
      ClientApplication.prototype.getAccountByUsername = function(userName) {
        var allAccounts = this.getAllAccounts();
        if (!StringUtils.isEmpty(userName) && allAccounts && allAccounts.length) {
          this.logger.verbose("Account matching username found, returning");
          this.logger.verbosePii("Returning signed-in accounts matching username: " + userName);
          return allAccounts.filter(function(accountObj) {
              return accountObj.username.toLowerCase() === userName.toLowerCase()
            })[0] || null
        }
        else {
          this.logger.verbose("getAccountByUsername: No matching account found, returning null");
          return null
        }
      };
      ClientApplication.prototype.getAccountByHomeId = function(homeAccountId) {
        var allAccounts = this.getAllAccounts();
        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {
          this.logger.verbose("Account matching homeAccountId found, returning");
          this.logger.verbosePii("Returning signed-in accounts matching homeAccountId: " + homeAccountId);
          return allAccounts.filter(function(accountObj) {
              return accountObj.homeAccountId === homeAccountId
            })[0] || null
        }
        else {
          this.logger.verbose("getAccountByHomeId: No matching account found, returning null");
          return null
        }
      };
      ClientApplication.prototype.getAccountByLocalId = function(localAccountId) {
        var allAccounts = this.getAllAccounts();
        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {
          this.logger.verbose("Account matching localAccountId found, returning");
          this.logger.verbosePii("Returning signed-in accounts matching localAccountId: " + localAccountId);
          return allAccounts.filter(function(accountObj) {
              return accountObj.localAccountId === localAccountId
            })[0] || null
        }
        else {
          this.logger.verbose("getAccountByLocalId: No matching account found, returning null");
          return null
        }
      };
      ClientApplication.prototype.setActiveAccount = function(account) {
        this.browserStorage.setActiveAccount(account)
      };
      ClientApplication.prototype.getActiveAccount = function() {
        return this.browserStorage.getActiveAccount()
      };
      ClientApplication.prototype.preflightBrowserEnvironmentCheck = function(interactionType) {
        this.logger.verbose("preflightBrowserEnvironmentCheck started");
        BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment);
        BrowserUtils.blockRedirectInIframe(interactionType, this.config.system.allowRedirectInIframe);
        BrowserUtils.blockReloadInHiddenIframes();
        BrowserUtils.blockAcquireTokenInPopups();
        if (interactionType === exports.InteractionType.Redirect && this.config.cache.cacheLocation === exports.BrowserCacheLocation.MemoryStorage && !this.config.cache.storeAuthStateInCookie) {
          throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();
        }
        if (interactionType === exports.InteractionType.Redirect || interactionType === exports.InteractionType.Popup) {
          this.preflightInteractiveRequest()
        }
      };
      ClientApplication.prototype.preflightInteractiveRequest = function() {
        this.logger.verbose("preflightInteractiveRequest called, validating app environment");
        BrowserUtils.blockReloadInHiddenIframes();
        this.browserStorage.setInteractionInProgress(true)
      };
      ClientApplication.prototype.addEventCallback = function(callback) {
        return this.eventHandler.addEventCallback(callback)
      };
      ClientApplication.prototype.removeEventCallback = function(callbackId) {
        this.eventHandler.removeEventCallback(callbackId)
      };
      ClientApplication.prototype.enableAccountStorageEvents = function() {
        this.eventHandler.enableAccountStorageEvents()
      };
      ClientApplication.prototype.disableAccountStorageEvents = function() {
        this.eventHandler.disableAccountStorageEvents()
      };
      ClientApplication.prototype.getTokenCache = function() {
        return this.tokenCache
      };
      ClientApplication.prototype.getLogger = function() {
        return this.logger
      };
      ClientApplication.prototype.setLogger = function(logger) {
        this.logger = logger
      };
      ClientApplication.prototype.initializeWrapperLibrary = function(sku, version) {
        this.browserStorage.setWrapperMetadata(sku, version)
      };
      ClientApplication.prototype.setNavigationClient = function(navigationClient) {
        this.navigationClient = navigationClient
      };
      ClientApplication.prototype.getConfiguration = function() {
        return this.config
      };
      return ClientApplication
    }());
  var SilentCacheClient = (function(_super) {
      __extends$1(SilentCacheClient, _super);
      function SilentCacheClient() {
        return _super !== null && _super.apply(this, arguments) || this
      }
      SilentCacheClient.prototype.acquireToken = function(silentRequest) {
        return __awaiter$1(this, void 0, void 0, function() {
            var serverTelemetryManager,
              silentAuthClient,
              cachedToken,
              error_1;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    serverTelemetryManager = this.initializeServerTelemetryManager(exports.ApiId.acquireTokenSilent_silentFlow);
                    return [4, this.createSilentFlowClient(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions)];
                  case 1:
                    silentAuthClient = _a.sent();
                    this.logger.verbose("Silent auth client created");
                    _a.label = 2;
                  case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4, silentAuthClient.acquireCachedToken(silentRequest)];
                  case 3:
                    cachedToken = _a.sent();
                    this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_SUCCESS, exports.InteractionType.Silent, cachedToken);
                    return [2, cachedToken];
                  case 4:
                    error_1 = _a.sent();
                    if (error_1 instanceof BrowserAuthError && error_1.errorCode === BrowserAuthErrorMessage.signingKeyNotFoundInStorage.code) {
                      this.logger.verbose("Signing keypair for bound access token not found. Refreshing bound access token and generating a new crypto keypair.")
                    }
                    throw error_1;
                  case 5:
                    return [2]
                }
              })
          })
      };
      SilentCacheClient.prototype.logout = function() {
        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError())
      };
      SilentCacheClient.prototype.createSilentFlowClient = function(serverTelemetryManager, authorityUrl, azureCloudOptions) {
        return __awaiter$1(this, void 0, void 0, function() {
            var clientConfig;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.getClientConfiguration(serverTelemetryManager, authorityUrl, azureCloudOptions)];
                  case 1:
                    clientConfig = _a.sent();
                    return [2, new SilentFlowClient(clientConfig)]
                }
              })
          })
      };
      SilentCacheClient.prototype.initializeSilentRequest = function(request, account) {
        return __awaiter$1(this, void 0, void 0, function() {
            var _a;
            return __generator$1(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _a = [__assign$1({}, request)];
                    return [4, this.initializeBaseRequest(request)];
                  case 1:
                    return [2, __assign$1.apply(void 0, [__assign$1.apply(void 0, _a.concat([_b.sent()])), {
                            account: account, forceRefresh: request.forceRefresh || false
                          }])]
                }
              })
          })
      };
      return SilentCacheClient
    }(StandardInteractionClient));
  var PublicClientApplication = (function(_super) {
      __extends$1(PublicClientApplication, _super);
      function PublicClientApplication(configuration) {
        var _this = _super.call(this, configuration) || this;
        _this.activeSilentTokenRequests = new Map;
        return _this
      }
      PublicClientApplication.prototype.loginRedirect = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                this.logger.verbose("loginRedirect called");
                return [2, this.acquireTokenRedirect(request || DEFAULT_REQUEST)]
              })
          })
      };
      PublicClientApplication.prototype.loginPopup = function(request) {
        this.logger.verbose("loginPopup called");
        return this.acquireTokenPopup(request || DEFAULT_REQUEST)
      };
      PublicClientApplication.prototype.acquireTokenSilent = function(request) {
        return __awaiter$1(this, void 0, void 0, function() {
            var account,
              thumbprint,
              silentRequestKey,
              cachedResponse,
              response;
            var _this = this;
            return __generator$1(this, function(_a) {
                this.preflightBrowserEnvironmentCheck(exports.InteractionType.Silent);
                this.logger.verbose("acquireTokenSilent called", request.correlationId);
                account = request.account || this.getActiveAccount();
                if (!account) {
                  throw BrowserAuthError.createNoAccountError();
                }
                thumbprint = {
                  clientId: this.config.auth.clientId, authority: request.authority || "", scopes: request.scopes, homeAccountIdentifier: account.homeAccountId, claims: request.claims, authenticationScheme: request.authenticationScheme, resourceRequestMethod: request.resourceRequestMethod, resourceRequestUri: request.resourceRequestUri, shrClaims: request.shrClaims, sshKid: request.sshKid
                };
                silentRequestKey = JSON.stringify(thumbprint);
                cachedResponse = this.activeSilentTokenRequests.get(silentRequestKey);
                if (typeof cachedResponse === "undefined") {
                  this.logger.verbose("acquireTokenSilent called for the first time, storing active request", request.correlationId);
                  response = this.acquireTokenSilentAsync(request, account).then(function(result) {
                    _this.activeSilentTokenRequests.delete(silentRequestKey);
                    return result
                  }).catch(function(error) {
                    _this.activeSilentTokenRequests.delete(silentRequestKey);
                    throw error;
                  });
                  this.activeSilentTokenRequests.set(silentRequestKey, response);
                  return [2, response]
                }
                else {
                  this.logger.verbose("acquireTokenSilent has been called previously, returning the result from the first call", request.correlationId);
                  return [2, cachedResponse]
                }
              })
          })
      };
      PublicClientApplication.prototype.acquireTokenSilentAsync = function(request, account) {
        return __awaiter$1(this, void 0, void 0, function() {
            var silentCacheClient,
              silentRequest;
            var _this = this;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    silentCacheClient = new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, request.correlationId);
                    return [4, silentCacheClient.initializeSilentRequest(request, account)];
                  case 1:
                    silentRequest = _a.sent();
                    this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_START, exports.InteractionType.Silent, request);
                    return [2, silentCacheClient.acquireToken(silentRequest).catch(function() {
                          return __awaiter$1(_this, void 0, void 0, function() {
                              var tokenRenewalResult,
                                tokenRenewalError_1;
                              return __generator$1(this, function(_a) {
                                  switch (_a.label) {
                                    case 0:
                                      _a.trys.push([0, 2, , 3]);
                                      return [4, this.acquireTokenByRefreshToken(silentRequest)];
                                    case 1:
                                      tokenRenewalResult = _a.sent();
                                      this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_SUCCESS, exports.InteractionType.Silent, tokenRenewalResult);
                                      return [2, tokenRenewalResult];
                                    case 2:
                                      tokenRenewalError_1 = _a.sent();
                                      this.eventHandler.emitEvent(exports.EventType.ACQUIRE_TOKEN_FAILURE, exports.InteractionType.Silent, null, tokenRenewalError_1);
                                      throw tokenRenewalError_1;
                                    case 3:
                                      return [2]
                                  }
                                })
                            })
                        })]
                }
              })
          })
      };
      return PublicClientApplication
    }(ClientApplication));
  var stubbedPublicClientApplication = {
      acquireTokenPopup: function() {
        return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
      }, acquireTokenRedirect: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, acquireTokenSilent: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, acquireTokenByCode: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, getAllAccounts: function() {
          return []
        }, getAccountByHomeId: function() {
          return null
        }, getAccountByUsername: function() {
          return null
        }, getAccountByLocalId: function() {
          return null
        }, handleRedirectPromise: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, loginPopup: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, loginRedirect: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, logout: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, logoutRedirect: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, logoutPopup: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, ssoSilent: function() {
          return Promise.reject(BrowserConfigurationAuthError.createStubPcaInstanceCalledError())
        }, addEventCallback: function() {
          return null
        }, removeEventCallback: function() {
          return
        }, enableAccountStorageEvents: function() {
          return
        }, disableAccountStorageEvents: function() {
          return
        }, getTokenCache: function() {
          throw BrowserConfigurationAuthError.createStubPcaInstanceCalledError();
        }, getLogger: function() {
          throw BrowserConfigurationAuthError.createStubPcaInstanceCalledError();
        }, setLogger: function() {
          return
        }, setActiveAccount: function() {
          return
        }, getActiveAccount: function() {
          return null
        }, initializeWrapperLibrary: function() {
          return
        }, setNavigationClient: function() {
          return
        }, getConfiguration: function() {
          throw BrowserConfigurationAuthError.createStubPcaInstanceCalledError();
        }
    };
  var EventMessageUtils = (function() {
      function EventMessageUtils(){}
      EventMessageUtils.getInteractionStatusFromEvent = function(message, currentStatus) {
        switch (message.eventType) {
          case exports.EventType.LOGIN_START:
            return exports.InteractionStatus.Login;
          case exports.EventType.SSO_SILENT_START:
            return exports.InteractionStatus.SsoSilent;
          case exports.EventType.ACQUIRE_TOKEN_START:
            if (message.interactionType === exports.InteractionType.Redirect || message.interactionType === exports.InteractionType.Popup) {
              return exports.InteractionStatus.AcquireToken
            }
            break;
          case exports.EventType.HANDLE_REDIRECT_START:
            return exports.InteractionStatus.HandleRedirect;
          case exports.EventType.LOGOUT_START:
            return exports.InteractionStatus.Logout;
          case exports.EventType.SSO_SILENT_SUCCESS:
          case exports.EventType.SSO_SILENT_FAILURE:
            if (currentStatus && currentStatus !== exports.InteractionStatus.SsoSilent) {
              break
            }
            return exports.InteractionStatus.None;
          case exports.EventType.LOGOUT_END:
            if (currentStatus && currentStatus !== exports.InteractionStatus.Logout) {
              break
            }
            return exports.InteractionStatus.None;
          case exports.EventType.HANDLE_REDIRECT_END:
            if (currentStatus && currentStatus !== exports.InteractionStatus.HandleRedirect) {
              break
            }
            return exports.InteractionStatus.None;
          case exports.EventType.LOGIN_SUCCESS:
          case exports.EventType.LOGIN_FAILURE:
          case exports.EventType.ACQUIRE_TOKEN_SUCCESS:
          case exports.EventType.ACQUIRE_TOKEN_FAILURE:
            if (message.interactionType === exports.InteractionType.Redirect || message.interactionType === exports.InteractionType.Popup) {
              if (currentStatus && currentStatus !== exports.InteractionStatus.Login && currentStatus !== exports.InteractionStatus.AcquireToken) {
                break
              }
              return exports.InteractionStatus.None
            }
            break
        }
        return null
      };
      return EventMessageUtils
    }());
  var SignedHttpRequest = (function() {
      function SignedHttpRequest(shrParameters, shrOptions) {
        var loggerOptions = (shrOptions && shrOptions.loggerOptions) || {};
        this.logger = new Logger(loggerOptions, name, version);
        this.cryptoOps = new CryptoOps(this.logger);
        this.popTokenGenerator = new PopTokenGenerator(this.cryptoOps);
        this.shrParameters = shrParameters
      }
      SignedHttpRequest.prototype.generatePublicKeyThumbprint = function() {
        return __awaiter$1(this, void 0, void 0, function() {
            var kid;
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.popTokenGenerator.generateKid(this.shrParameters)];
                  case 1:
                    kid = (_a.sent()).kid;
                    return [2, kid]
                }
              })
          })
      };
      SignedHttpRequest.prototype.signRequest = function(payload, publicKeyThumbprint, claims) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                return [2, this.popTokenGenerator.signPayload(payload, publicKeyThumbprint, this.shrParameters, claims)]
              })
          })
      };
      SignedHttpRequest.prototype.removeKeys = function(publicKeyThumbprint) {
        return __awaiter$1(this, void 0, void 0, function() {
            return __generator$1(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    return [4, this.cryptoOps.removeTokenBindingKey(publicKeyThumbprint)];
                  case 1:
                    return [2, _a.sent()]
                }
              })
          })
      };
      return SignedHttpRequest
    }());
  exports.AccountEntity = AccountEntity;
  exports.AuthError = AuthError;
  exports.AuthErrorMessage = AuthErrorMessage;
  exports.AuthenticationHeaderParser = AuthenticationHeaderParser;
  exports.BrowserAuthError = BrowserAuthError;
  exports.BrowserAuthErrorMessage = BrowserAuthErrorMessage;
  exports.BrowserCacheManager = BrowserCacheManager;
  exports.BrowserConfigurationAuthError = BrowserConfigurationAuthError;
  exports.BrowserConfigurationAuthErrorMessage = BrowserConfigurationAuthErrorMessage;
  exports.BrowserConstants = BrowserConstants;
  exports.BrowserUtils = BrowserUtils;
  exports.ClientAuthError = ClientAuthError;
  exports.ClientAuthErrorMessage = ClientAuthErrorMessage;
  exports.ClientConfigurationError = ClientConfigurationError;
  exports.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
  exports.DEFAULT_IFRAME_TIMEOUT_MS = DEFAULT_IFRAME_TIMEOUT_MS;
  exports.EventHandler = EventHandler;
  exports.EventMessageUtils = EventMessageUtils;
  exports.InteractionRequiredAuthError = InteractionRequiredAuthError;
  exports.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
  exports.Logger = Logger;
  exports.NavigationClient = NavigationClient;
  exports.OIDC_DEFAULT_SCOPES = OIDC_DEFAULT_SCOPES;
  exports.PopupClient = PopupClient;
  exports.PopupUtils = PopupUtils;
  exports.PublicClientApplication = PublicClientApplication;
  exports.RedirectClient = RedirectClient;
  exports.RedirectHandler = RedirectHandler;
  exports.ServerError = ServerError;
  exports.SignedHttpRequest = SignedHttpRequest;
  exports.SilentCacheClient = SilentCacheClient;
  exports.SilentIframeClient = SilentIframeClient;
  exports.SilentRefreshClient = SilentRefreshClient;
  exports.StandardInteractionClient = StandardInteractionClient;
  exports.StringUtils = StringUtils;
  exports.UrlString = UrlString;
  exports.stubbedPublicClientApplication = stubbedPublicClientApplication;
  exports.version = version;
  Object.defineProperty(exports, '__esModule', {value: true})
})));
;
(function() {
  const version = '1.0.7-4668';
  window.winId = window.winId || getWindowId();
  function getToken(oauth2Config, username) {
    currentOAuth2Config = oauth2Config;
    currentOAuth2Config.defaultUPN = username;
    logInfo(`getToken: WinID = ${window.winId} - Search = ${window.location.search}`);
    authMSALInit();
    logDebug(`getToken: Before call handleRedirectPromise() - WinID = ${window.winId}`);
    return MSALClientApp.handleRedirectPromise().catch(error =>  {
          logError(`getToken (catch): Error = ${error} - WinID = ${window.winId}`);
          throw new Error('redirect-error');
        }).then(authResult =>  {
          if (authResult) {
            logInfo(`getToken (then): Redirect login for ${authResult.account.username} completed`);
            authSetLoggedAccount(authResult);
            return authResult
          }
          else {
            logInfo(`getToken (then): No redirect login, Trying SSO or login - WinID = ${window.winId}`);
            const account = authSelectLastAccount(currentOAuth2Config);
            return authDoSSOOrLogin(account)
          }
        }).catch(error =>  {
          if (error === 'redirect') {
            return error
          }
          logError(`getToken (catch): error = ${error}`);
          throw error;
        }).then(result =>  {
          if (result === 'redirect') {
            const goingAuthInfo = {
                token: null, isRedirecting: true
              };
            tokenChange(goingAuthInfo);
            return goingAuthInfo
          }
          return authGetTokenInfo()
        })
  }
  function addLogCallback(fn) {
    if (typeof fn === 'function') {
      logCallbacks.push(fn)
    }
  }
  function addTokenChangeCallback(fn) {
    if (typeof fn === 'function') {
      tokenChangeCallbacks.push(fn)
    }
  }
  function isOAuth2Redirect() {
    return location.hash.indexOf('code') > -1
  }
  function isLogoutRedirect(clear) {
    var result = location.hash.indexOf('logout') > -1;
    if (result && clear !== false) {
      location.href = location.href.replace('logout&', '').replace('logout', '')
    }
    return result
  }
  function logout() {
    if (MSALClientApp) {
      if (!currentOAuth2Config.usePopup) {
        logDebug('logout: Before call logout (redirect)');
        MSALClientApp.logout({idTokenHint: idToken})
      }
      else {
        logDebug('logout: Before call logoutPopup())');
        MSALClientApp.logoutPopup({idTokenHint: idToken})
      }
    }
  }
  function removeLogCallback(fn) {
    var len = logCallbacks.length;
    while (len--) {
      if (logCallbacks[len] === fn) {
        logCallbacks.splice(len, 1)
      }
    }
  }
  function removeTokenChangeCallback(fn) {
    var len = tokenChangeCallbacks.length;
    while (len--) {
      if (tokenChangeCallbacks[len] === fn) {
        tokenChangeCallbacks.splice(len, 1)
      }
    }
  }
  function authMSALLoggerCallback(level, message, containsPii) {
    if (!currentOAuth2Config.debug && containsPii) {
      return
    }
    let decoMessage = 'MSAL:' + message;
    switch (level) {
      case msal.LogLevel.Verbose:
        logDebug(decoMessage);
        break;
      case msal.LogLevel.Info:
        logInfo(decoMessage);
        break;
      case msal.LogLevel.Warning:
        logWarn(decoMessage);
        break;
      case msal.LogLevel.Error:
        logError(decoMessage);
        break;
      default:
        logError('authMSALLoggerCallback: invalid log error!');
        break
    }
  }
  function authRawTokenToObject(rawToken) {
    const decodedToken = msal.StringUtils.decodeAuthToken(rawToken);
    if (!decodedToken) {
      logError('authRawTokenToObject: Cannot read token!!!');
      return undefined
    }
    try {
      const tokenPayload = decodedToken.JWSPayload;
      const decoder = MSALClientApp.browserCrypto.b64Decode;
      const tokenDecoded = decoder.decode(tokenPayload);
      return JSON.parse(tokenDecoded)
    }
    catch(error) {
      logError(`authRawTokenToObject: Failed - Error = ${error}`)
    }
    return undefined
  }
  function authGetMSALInitOptions(authServerConfig) {
    var newHRef = location.origin + location.pathname + location.search + '#logout';
    const options = {
        auth: {
          clientId: authServerConfig.clientId, authority: authServerConfig.authorityUrl, postLogoutRedirectUri: authServerConfig.postLogoutRedirectUri || newHRef
        }, cache: {cacheLocation: 'localStorage'}
      };
    if (authServerConfig.authorityIsAdfs) {
      const url = new URL(authServerConfig.authorityUrl);
      const knownAuthority = url.hostname;
      options.auth.knownAuthorities = [knownAuthority];
      options.system = {
        loggerOptions: {
          loggerCallback: authMSALLoggerCallback, piiLoggingEnabled: true, logLevel: msal.LogLevel.Verbose
        }, windowHashTimeout: 60000, iframeHashTimeout: 6000, loadFrameTimeout: 0
      }
    }
    return options
  }
  function authGetMSALRequestOptions(account) {
    const authOptions = {};
    if (currentAccount) {
      logDebug(`authGetMSALRequestOptions: Account with username = ${currentAccount.username} inserted`);
      authOptions.account = currentAccount
    }
    let scopes = currentOAuth2Config.scopes;
    if (!scopes) {
      throw new Error('authGetMSALRequestOptions: missing scopes');
    }
    logDebug(`authGetMSALRequestOptions: using these scopes ${currentOAuth2Config.scopes}`);
    authOptions.scopes = [...DefaultScopes, ...scopes];
    if (account) {
      authOptions.loginHint = account.username;
      if (account.isHint && account.username && currentAccount && account.username !== authOptions.account) {
        authOptions.prompt = 'login'
      }
    }
    return authOptions
  }
  function authSelectLastAccount(cfg) {
    const url = new URL(cfg.authorityUrl);
    const hostname = url.hostname;
    const matchEnvironment = hostname === 'login.microsoftonline.com' ? 'login.windows.net' : hostname;
    const hint = cfg.defaultUPN || '';
    try {
      const accounts = MSALClientApp.getAllAccounts();
      let found;
      if (hint) {
        found = accounts.find(el => el.username.toLowerCase() === hint.toLowerCase());
        if (!found) {
          logInfo(`authSelectLastAccount: No account in cache, using default username (hint) = ${hint}`);
          return {
              username: hint, isHint: true
            }
        }
      }
      else {
        found = accounts.find(el => el.environment.toLowerCase() === matchEnvironment.toLowerCase());
        if (!found) {
          logInfo(`authSelectLastAccount: No account in cache`);
          return {
              username: '', isHint: true
            }
        }
      }
      logInfo(`authSelectLastAccount: Account in cache, username = ${found.username}`);
      currentAccount = found;
      return {username: found.username}
    }
    catch(ex) {
      logError(`authSelectLastAccount: Error = ${ex}`);
      return null
    }
  }
  function authMSALInit() {
    logDebug('authMSALInit: Init MSAL Client Application');
    const oauth2Options = authGetMSALInitOptions(currentOAuth2Config);
    MSALClientApp = new msal.PublicClientApplication(oauth2Options);
    const postLogoutURI = MSALClientApp.config.auth.postLogoutRedirectUri;
    logDebug(`authMSALInit: Logout Redirect URI = ${postLogoutURI}`);
    renewalOffset = MSALClientApp.config.system.tokenRenewalOffsetSeconds;
    logDebug(`authMSALInit: renewalOffset = ${renewalOffset} seconds`)
  }
  function authSetLoggedAccount(authResult) {
    if (!authResult) {
      logError('authSetLoggedAccount: Login Failed - No authorization result!!!')
    }
    else if (authResult.account) {
      idToken = authResult.idToken;
      if (authResult.idTokenClaims.iss) {
        const url = new URL(authResult.idTokenClaims.iss);
        const tmp = url.hostname.split('.', 2);
        logDebug(`authSetLoggedAccount: token claims iss = ${tmp.join('-')}`)
      }
      logDebug(`authSetLoggedAccount: token claims proxy = ${authResult.idTokenClaims.proxy}`);
      currentAccount = authResult.account;
      logInfo(`authSetLoggedAccount: Account for Username/UPN = ${currentAccount.username}`);
      if (authResult.accessToken) {
        const acToken = authResult.accessToken;
        logDebug(`authSetLoggedAccount: ID Token audience = ${authResult.idTokenClaims.aud}`);
        logDebug(`authSetLoggedAccount: Login authResult contains Access Token - Len = ${acToken.length}`);
        try {
          const tokenAsObject = authRawTokenToObject(acToken);
          logDebug(`authSetLoggedAccount: Access Token audience = ${tokenAsObject.aud} - Scopes = ${tokenAsObject.scp}`)
        }
        catch(error) {
          logError(`authSetLoggedAccount: Failed parsing Access Token - Error = ${error}`)
        }
      }
      else {
        logError(`authSetLoggedAccount: Login authResult doesn't contains access Token`)
      }
    }
    else {
      logError('authSetLoggedAccount: Login Failed - No user account!!!')
    }
  }
  function authDoSSOOrLogin(account) {
    logDebug(`authDoSSOOrLogin: Before call ssoSilent() - Login Hint = ${account.username} - WinID = ${window.winId}`);
    const authOptions = authGetMSALRequestOptions(account);
    return MSALClientApp.ssoSilent(authOptions).then(authResult =>  {
          logInfo(`authDoSSOOrLogin (then): ssoSilent() completed`);
          authSetLoggedAccount(authResult)
        }).catch(error =>  {
          logInfo(`authDoSSOOrLogin (catch): ssoSilent() error`);
          if (error instanceof msal.InteractionRequiredAuthError || error instanceof msal.BrowserAuthError) {
            logError(`authDoSSOOrLogin: ssoSilent() Failed : MSAL Error code = ${error.errorCode} - Message = 
	${error.errorMessage}`);
            if ((error.errorCode === 'login_required' || error.toString().indexOf('AADSTS50058') > -1) && (!currentAccount || !currentAccount.username)) {
              logDebug(`authDoSSOOrLogin: attempting to force login prompt`);
              authOptions.prompt = 'login'
            }
            return authDoLogin(authOptions)
          }
          else if (error instanceof msal.AuthError) {
            logError(`authDoSSOOrLogin: ssoSilent() Failed : Generic MSAL error = ${error.errorCode} - Message = 
	${error.errorMessage}`)
          }
          else if (error instanceof Error) {
            logError(`authDoSSOOrLogin: ssoSilent() Failed : Generic Error message = ${error.message}`)
          }
          else {
            logError(`authDoSSOOrLogin: Failed : Unexpected Error!`)
          }
          throw new Error('ssosilent-error');
        })
  }
  function authDoLogin(authOptions) {
    if (!currentOAuth2Config.usePopup) {
      logDebug('authDoLogin: Before call loginRedirect()');
      MSALClientApp.loginRedirect(authOptions);
      throw'redirect';
    }
    else {
      logDebug('authDoLogin: Before call loginPopup()');
      return MSALClientApp.loginPopup(authOptions).then(authResult =>  {
            authSetLoggedAccount(authResult)
          }).catch(error =>  {
            logError(`authDoLogin: Login failed - Error Code = ${error.errorCode} - Message = 
	${error.errorMessage}`)
          })
    }
  }
  function authAcquireToken() {
    const tokenRequestOptions = authGetMSALRequestOptions();
    logDebug('authAcquireToken: before call acquireTokenSilent()');
    return MSALClientApp.acquireTokenSilent(tokenRequestOptions).then(authResult =>  {
          if (authResult) {
            logInfo('authAcquireToken (then): acquireTokenSilent() Succeeded');
            authUpdateTokenInfo(authResult.accessToken, authResult.expiresOn, authResult.idTokenClaims);
            if (!authResult.idTokenClaims.upn) {
              logDebug('authAcquireToken (then): upn missing in ID Token Claims')
            }
            logDebug(`authAcquireToken (then): ID Token Claims: audience = ${authResult.idTokenClaims.aud}` + ` upn = ${authResult.idTokenClaims.upn || 'none'}`)
          }
          else {
            logError('authAcquireToken (then): acquireTokenSilent() returned an invalid Auth result!!!');
            throw new Error('acquireTokenSilent() invalid Auth result');
          }
        }).catch(error =>  {
          logError(`authAcquireToken (catch): acquireTokenSilent() Failed - Error Code = ${error.errorCode} - Message = 
	${error.errorMessage}`);
          let retryTokenAcquisition = error instanceof msal.InteractionRequiredAuthError;
          if (retryTokenAcquisition) {
            return MSALClientApp.acquireTokenPopup(tokenRequestOptions).then(authResult =>  {
                  logInfo('authAcquireToken (then): acquireTokenPopup() Succeeded');
                  authUpdateTokenInfo(authResult.accessToken, authResult.expiresOn, authResult.idTokenClaims)
                }).catch(error =>  {
                  logError(`authAcquireToken (catch): acquireTokenPopup() Failed - Error Code = ${error.errorCode} - Message = 
	${error.errorMessage}`)
                })
          }
        })
  }
  function authUpdateTokenInfo(acToken, expireTime, claims) {
    accessToken = acToken;
    try {
      accessTokenAsObject = authRawTokenToObject(acToken)
    }
    catch(error) {
      logError(`authUpdateTokenInfo: Error in authRawTokenToObject() - Error = ${error}`)
    }
    const now = new Date;
    const minutes = now.getMinutes();
    const hour = now.getHours();
    const timeToExpire_ms = expireTime.getTime() - now.getTime();
    const renewalToExpireOffset_ms = (renewalOffset * 1000.0) / 2;
    const timeToRenew_ms = timeToExpire_ms - renewalToExpireOffset_ms;
    const timeToExpire_sec = timeToExpire_ms / 1000.0;
    const timeToRenew_sec = timeToRenew_ms / 1000.0;
    const optzero = minutes < 10 ? '0' : '';
    logInfo(`authUpdateTokenInfo: @ ${hour}:${optzero}${minutes} - Expire in ${timeToExpire_sec} seconds - Renewal in ${timeToRenew_sec} seconds
` + `\tToken audience = ${accessTokenAsObject.aud}`);
    setTimeout(authGetTokenInfo, timeToRenew_ms)
  }
  function authGetTokenInfo() {
    return authAcquireToken().then(() =>  {
          const newAuthInfo = {
              token: accessToken, username: currentAccount && currentAccount.username || ''
            };
          if (accessTokenAsObject) {
            logInfo('authGetTokenInfo: Raw Access Token and additional info returned');
            newAuthInfo.audience = accessTokenAsObject.aud;
            newAuthInfo.iss = accessTokenAsObject.iss
          }
          else {
            logWarn('authGetTokenInfo: Only Raw Access Token returned')
          }
          tokenChange(newAuthInfo);
          return newAuthInfo
        }).catch(error =>  {
          logError(`authGetTokenInfo: Failed to acquire Access Token - Error = ${error}`);
          const noAuthInfo = {token: null};
          tokenChange(noAuthInfo);
          return noAuthInfo
        })
  }
  function getWindowId() {
    const f = (performance.timeOrigin * 10000) % 9000;
    const r = 1000 + Math.floor(f);
    return r.toString()
  }
  function log(context, severity, message) {
    var len = logCallbacks.length;
    while (len--) {
      logCallbacks[len](context, severity, message)
    }
  }
  function tokenChange(newAuthInfo) {
    var len = tokenChangeCallbacks.length;
    while (len--) {
      tokenChangeCallbacks[len](newAuthInfo)
    }
  }
  if (typeof namespace !== 'function') {
    var namespace = function(globalNamespace) {
        var ns = window,
          parts = globalNamespace.split('.');
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          ns[part] = ns[part] || {};
          ns = ns[part]
        }
        return ns
      }
  }
  let MSALClientApp,
    currentOAuth2Config,
    renewalOffset;
  let currentAccount;
  let accessToken,
    accessTokenAsObject,
    idToken;
  const DefaultScopes = ['profile', 'email', 'openid', 'offline_access'];
  const THIS = 'Iam.OAuth2',
    DEBUG = 'Debug',
    INFO = 'Info',
    WARN = 'Warn',
    ERROR = 'Error';
  const logDebug = log.bind(this, THIS, DEBUG),
    logInfo = log.bind(this, THIS, INFO),
    logWarn = log.bind(this, THIS, WARN),
    logError = log.bind(this, THIS, ERROR);
  const logCallbacks = [],
    tokenChangeCallbacks = [];
  const ns = namespace("Ifm.Iam.OAuth2");
  ns.addLogCallback = addLogCallback;
  ns.addTokenChangeCallback = addTokenChangeCallback;
  ns.getToken = getToken;
  ns.isOAuth2Redirect = isOAuth2Redirect;
  ns.isLogoutRedirect = isLogoutRedirect;
  ns.logout = logout;
  ns.removeLogCallback = removeLogCallback;
  ns.removeTokenChangeCallback = removeTokenChangeCallback;
  ns.version = version
})()
