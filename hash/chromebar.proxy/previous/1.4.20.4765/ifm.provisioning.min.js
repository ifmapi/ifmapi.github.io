
/*!============================================================================

 * Ifm.Provisioning/1.2.4-4669
 * Copyright (c) Base Digitale Platform. All rights reserved.

 ============================================================================*/

"use strict";
(function() {
  const version = "1.2.4-4669";
  const DefaultProduct = "phonebar";
  const DefaultTopic = "ifm.provisioning.chromebar";
  const DefaultSubject = "ifm.provisioning.chromebar.#Chromebar";
  function addLogCallback(fn) {
    if (typeof fn === 'function') {
      logCallbacks.push(fn)
    }
  }
  function removeLogCallback(fn) {
    var len = logCallbacks.length;
    while (len--) {
      if (logCallbacks[len] === fn) {
        logCallbacks.splice(len, 1)
      }
    }
  }
  function getAuthConfig(username, product, topic, subject) {
    var endPoint = WebAPIMethod.replace('{product}', 'oauth2').replace('{section}', 'authority');
    return provisioningGetConfigurationSection(endPoint, undefined, username, topic, subject).then(remoteAuthInfo =>  {
          if (remoteAuthInfo) {
            logInfo("getAuthConfig (then): Auth Information succesfully received");
            return {data: {
                  authorityUrl: remoteAuthInfo.authority.authorityurl, authorityIsAdfs: remoteAuthInfo.authority.isadfs, clientId: remoteAuthInfo.authority.clientid, scopes: remoteAuthInfo.authority.scopes
                }}
          }
          else {
            return {error: "AuthInfo not received!"}
          }
        }).catch(error =>  {
          logError(`getAuthConfig (catch): request failed - err = ${error}!!!`);
          return {error: error}
        })
  }
  function getSiteList(username, token, product, topic, subject) {
    var endPoint = WebAPIMethod.replace('{product}', product || DefaultProduct).replace('{section}', 'validScopesFor');
    return provisioningGetConfigurationSection(endPoint, token, username, topic || DefaultTopic, subject || DefaultSubject).then(remoteInfo =>  {
          logInfo("getSiteList (then): site list succesfully received");
          if (remoteInfo.data) {
            for (var idx = 0; idx < remoteInfo.data.length; idx++) {
              if (remoteInfo.data[idx].name === "Site") {
                return {data: remoteInfo.data[idx].values}
              }
            }
            return {data: []}
          }
          else if (remoteInfo.error) {
            return {error: remoteInfo.error}
          }
          else {
            return {data: []}
          }
        }).catch(error =>  {
          logError(`getSiteList (catch): request failed - err = ${error}!!!`);
          return {error: error}
        })
  }
  function getConfig(username, token, site, product, topic, subject) {
    var endPoint = WebAPIMethodEx.replace('{product}', product || DefaultProduct).replace('{section}', "config");
    return provisioningGetConfigurationSection(endPoint, token, username, topic || DefaultTopic, subject || DefaultSubject, site).then(remoteInfo =>  {
          if (remoteInfo.data) {
            logInfo("getConfigForSite (then): configuration parameters from remote succesfully received");
            if (remoteInfo.data.hasOwnProperty("config")) {
              if (remoteInfo.data.config.hasOwnProperty("softphoneconfig")) {
                remoteInfo.data.softphoneconfig = remoteInfo.data.config.softphoneconfig;
                delete remoteInfo.data.config["softphoneconfig"]
              }
              if (remoteInfo.data.config.hasOwnProperty("webrtcconfig")) {
                remoteInfo.data.webrtcconfig = remoteInfo.data.config.webrtcconfig;
                delete remoteInfo.data.config["webrtcconfig"]
              }
              if (remoteInfo.data.config.hasOwnProperty("xmppconfig")) {
                remoteInfo.data.xmppconfig = remoteInfo.data.config.xmppconfig;
                delete remoteInfo.data.config["xmppconfig"]
              }
            }
            return {data: remoteInfo.data}
          }
          else {
            return {error: "Configuration not received!"}
          }
        }).catch(error =>  {
          logError(`getConfigSite (catch): request failed - err = ${error}!!!`);
          return {error: error}
        })
  }
  function log(context, severity, message) {
    var len = logCallbacks.length;
    while (len--) {
      logCallbacks[len](context, severity, message)
    }
  }
  function provisioningGetConfigurationSection(endpoint, token, username, topic, subject, site) {
    if (!Boolean(endpoint)) {
      logError(`provisioningGetConfigurationSection: Wrong request!!! section = ${section}`);
      return
    }
    logDebug(`provisioningGetConfigurationSection: section endpoint = ${endpoint} - username = ${username} - topic = ${topic} - section = ${subject}`);
    var url = DefaultProvisioningServer + endpoint;
    var delimiter = '?';
    if (Boolean(topic)) {
      url += delimiter + 'topic=' + encodeURIComponent(topic);
      delimiter = "&"
    }
    if (Boolean(subject)) {
      url += delimiter + 'subject=' + encodeURIComponent(subject);
      delimiter = "&"
    }
    if (Boolean(site)) {
      url += delimiter + 'site=' + encodeURIComponent(site);
      delimiter = "&"
    }
    if (Boolean(username)) {
      url += delimiter + 'userName=' + encodeURIComponent(username);
      delimiter = "&"
    }
    let xhr;
    return new Promise(function(resolve, reject) {
        xhr = new XMLHttpRequest;
        xhr.open('GET', url, true);
        xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
        xhr.onload = function() {
          if (this.status >= 200 && this.status < 300) {
            resolve(xhr.response)
          }
          else {
            reject({
              status: this.status, statusText: this.statusText
            })
          }
        };
        xhr.onerror = function() {
          reject({
            status: this.status, statusText: this.statusText
          })
        };
        if (Boolean(token)) {
          xhr.setRequestHeader('Authorization', 'bearer ' + token)
        }
        xhr.send()
      }).then(response =>  {
          let responseAsJSON = JSON.parse(xhr.responseText);
          if (Boolean(responseAsJSON.error)) {
            logError(`provisioningGetPhoneBarUserData: No Data received - Server Error = ${responseAsJSON.error}`);
            throw responseAsJSON.error;
          }
          else {
            logDebug(`provisioningGetPhoneBarUserData: Configuration data received`);
            return responseAsJSON
          }
        })
  }
  if (typeof namespace !== 'function') {
    var namespace = function(globalNamespace) {
        var ns = window,
          parts = globalNamespace.split('.');
        for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          ns[part] = ns[part] || {};
          ns = ns[part]
        }
        return ns
      }
  }
  const WebAPIMethod = '/api/users/{product}/{section}';
  const WebAPIMethodEx = '/api/users/{product}/{section}ForTopic';
  const DefaultProvisioningServer = "https://provisioning.ifmcommunications.it:443";
  const THIS = 'Ifm.Config.Provisioning',
    DEBUG = 'Debug',
    INFO = 'Info',
    WARN = 'Warn',
    ERROR = 'Error';
  const logDebug = log.bind(this, THIS, DEBUG),
    logInfo = log.bind(this, THIS, INFO),
    logWarn = log.bind(this, THIS, WARN),
    logError = log.bind(this, THIS, ERROR);
  const logCallbacks = [];
  const ns = namespace("Ifm.Config.Provisioning");
  ns.addLogCallback = addLogCallback;
  ns.getAuthConfig = getAuthConfig;
  ns.getSiteList = getSiteList;
  ns.getConfig = getConfig;
  ns.removeLogCallback = removeLogCallback;
  ns.version = version
})()
