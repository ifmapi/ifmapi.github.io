
//============================================================================

// Copyright (c) IFM Infomaster. All rights reserved.

//============================================================================

//============================================================================

// Copyright (c) IFM Infomaster. All rights reserved.

//============================================================================

"use strict";

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

(function () {

  // Constants
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  const version = "1.2.3-4087"

  const defProduct = "phonebar";
  const defTopic = "ifm.provisioning.chromebar";
  const defSubject = "ifm.provisioning.chromebar.#Chromebar";

  // Exported functions
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  function addLogCallback(fn) {
    if (typeof fn === 'function') {
      logCallbacks.push(fn);
    }
  }

  function removeLogCallback(fn) {
    var len = logCallbacks.length;
    while (len--) {
      if (logCallbacks[len] === fn) {
        logCallbacks.splice(len, 1);
      }
    }
  }

  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  // Returns the parameters to be used to perform SSO and get the access token
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  function getAuthConfig(username, /*[opt]*/ product, /*[opt]*/topic, /*[opt]*/subject) {
    var endPoint = WebAPIMethod.replace('{product}', 'oauth2').replace('{section}', 'authority');

    return provisioningGetConfigurationSection(endPoint, undefined, username, topic, subject)
      .then(remoteAuthInfo => {
        if (remoteAuthInfo) {
          logInfo("getAuthConfig (then): Auth Information succesfully received");
          return {
            data: {
              authorityUrl: remoteAuthInfo.authority.authorityurl,
              authorityIsAdfs: remoteAuthInfo.authority.isadfs,
              clientId: remoteAuthInfo.authority.clientid,
              scopes: remoteAuthInfo.authority.scopes
            }
          };
        }
        else {
          return { error: "AuthInfo not received!" }
        }
      })
      .catch(error => {
        logError(`getAuthConfig (catch): request failed - err = ${error}!!!`);
        return { error: error }
      });
  }

  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  // Returns the list of possible sites to which the agent can connect
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  function getSiteList(username, token, /*[opt]*/ product, /*[opt]*/topic, /*[opt]*/subject) {
    var endPoint = WebAPIMethod.replace('{product}', product || defProduct).replace('{section}', 'validScopesFor');

    return provisioningGetConfigurationSection(endPoint, token, username, topic || defTopic, subject || defSubject)
      .then(remoteInfo => {
        logInfo("getSiteList (then): site list succesfully received");

        if (remoteInfo.data) {
          for (var idx = 0; idx < remoteInfo.data.length; idx++) {
            if (remoteInfo.data[idx].name === "Site") {
              return { data: remoteInfo.data[idx].values };
            }
          }

          return { data: [] };
        }
        else if (remoteInfo.error) {
          return { error: remoteInfo.error };
        }
        else {
          return { data: [] };
        }
      })
      .catch(error => {
        logError(`getSiteList (catch): request failed - err = ${error}!!!`);
        return { error: error };
      });
  }


  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  // Returns the configuration parameters, for a particular site, for the sections indicated 
  // in the second parameter
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  function getConfig(username, token, /*[opt]*/ site, /*[opt]*/ product, /*[opt]*/ topic, /*[opt]*/ subject) {
    var endPoint = WebAPIMethodEx.replace('{product}', product || defProduct).replace('{section}', "config");

    return provisioningGetConfigurationSection(endPoint, token, username, topic || defTopic, subject || defSubject, site)
      .then(remoteInfo => {
        if (remoteInfo.data) {
          logInfo("getConfigForSite (then): configuration parameters from remote succesfully received");

          if (remoteInfo.data.hasOwnProperty("config")) {
            if (remoteInfo.data.config.hasOwnProperty("softphoneconfig")) {
              remoteInfo.data.softphoneconfig = remoteInfo.data.config.softphoneconfig;
              delete remoteInfo.data.config["softphoneconfig"];
            }
            if (remoteInfo.data.config.hasOwnProperty("webrtcconfig")) {
              remoteInfo.data.webrtcconfig = remoteInfo.data.config.webrtcconfig;
              delete remoteInfo.data.config["webrtcconfig"];
            }
            if (remoteInfo.data.config.hasOwnProperty("xmppconfig")) {
              remoteInfo.data.xmppconfig = remoteInfo.data.config.xmppconfig;
              delete remoteInfo.data.config["xmppconfig"];
            }
          }

          return { data: remoteInfo.data };
        }
        else {
          return { error: "Configuration not received!" }
        }
      })
      .catch(error => {
        logError(`getConfigSite (catch): request failed - err = ${error}!!!`);
        return { error: error }
      });
  }

  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  // Private utility functions
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  function log(context, severity, message) {
    var len = logCallbacks.length;
    while (len--) {
      logCallbacks[len](context, severity, message);
    }
  }

  function provisioningGetConfigurationSection(endpoint, /*[opt]*/ token, /*[opt]*/ username, /*[opt]*/ topic, /*[opt]*/ subject, /*[opt]*/ site ) {
    if (!Boolean(endpoint)) {
      logError(`provisioningGetConfigurationSection: Wrong request!!! section = ${section}`);
      return;
    }

    logDebug(`provisioningGetConfigurationSection: section endpoint = ${endpoint} - username = ${username} - topic = ${ topic } - section = ${ subject }`);

    var url = DefaultProvisioningServer + endpoint;
    var delimiter = '?';

    if (Boolean(topic)) {
      url += delimiter + 'topic=' + encodeURIComponent(topic);
      delimiter = "&";
    }
    if (Boolean(subject)) {
      url += delimiter + 'subject=' + encodeURIComponent(subject);
      delimiter = "&";
    }
    if (Boolean(site)) {
      url += delimiter + 'site=' + encodeURIComponent(site);
      delimiter = "&";
    }
    if (Boolean(username)) {
      url += delimiter + 'userName=' + encodeURIComponent(username);
      delimiter = "&";
    }

    let xhr;

    return new Promise(function (resolve, reject) {
      xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

      xhr.onload = function () {
        if (this.status >= 200 && this.status < 300) {
          resolve(xhr.response);
        } else {
          reject({
            status: this.status,
            statusText: this.statusText
          });
        }
      };
      xhr.onerror = function () {
        reject({
          status: this.status,
          statusText: this.statusText
        });
      };

      if (Boolean(token)) {
        xhr.setRequestHeader('Authorization', 'bearer ' + token);
      }

      // Send request
      xhr.send();
    })
      .then(response => {
        let responseAsJSON = JSON.parse(xhr.responseText);
        if (Boolean(responseAsJSON.error)) {
          logError(`provisioningGetPhoneBarUserData: No Data received - Server Error = ${responseAsJSON.error}`);
          throw responseAsJSON.error;
        } else {
          logDebug(`provisioningGetPhoneBarUserData: Configuration data received`);
          return responseAsJSON;
        }
      });
}

  // Polyfills
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  if (typeof namespace !== 'function') {

    // defined in ifm.js:
    var namespace = function(globalNamespace) {
      var ns = window, parts = globalNamespace.split('.');
      for (var i = 0; i < parts.length; i++) {
          var part = parts[i];
          ns[part] = ns[part] || { };
          ns = ns[part];
      }
      return ns;
    };
  }

  // Static Members
  //::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  const WebAPIMethod = '/api/users/{product}/{section}';
  const WebAPIMethodEx = '/api/users/{product}/{section}ForTopic';

  // Via nginx su Caldera 103.10
  const DefaultProvisioningServer = "https://provisioning.ifmcommunications.it:443";

  // Logging constants:
  const
    THIS = 'Ifm.Config.Provisioning', // Logging context (filter)
    DEBUG = 'Debug', INFO = 'Info', WARN = 'Warn', ERROR = 'Error';

  const
    logDebug = log.bind(this, THIS, DEBUG),
    logInfo = log.bind(this, THIS, INFO),
    logWarn = log.bind(this, THIS, WARN),
    logError = log.bind(this, THIS, ERROR);

  const logCallbacks = [];

  // Exports:
  const ns = namespace("Ifm.Config.Provisioning");

  ns.addLogCallback = addLogCallback;
  ns.getAuthConfig = getAuthConfig;
  ns.getSiteList = getSiteList;
  ns.getConfig = getConfig;
  ns.removeLogCallback = removeLogCallback;
  ns.version = version;

})();

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
