
//============================================================================

// Copyright (c) Base Digitale Platform. All rights reserved.

//============================================================================

"use strict";
var global = global || window;
if (Object.defineProperty) {
  Object.defineProperty(global, "T0", {value: +new Date})
}
else {
  var T0 = +new Date
}
var dT = function() {
    return new Date - T0
  };
function defineEvents(names) {
  var eventbox = {};
  for (var i = 0; i < arguments.length; i++) {
    var name = arguments[i];
    if (!Ifm.Type.isString(name)) {
      throw Ifm.Diagnostics.Errors.arg("name");
    }
    createEventAccessors(eventbox, name)
  }
  return eventbox
}
function createEventAccessors(owner, name) {
  var evt = new Ifm.Event;
  Object.defineProperty(owner, name, {
    get: function() {
      return evt
    }, set: function(handler) {
        evt.addHandler(handler)
      }
  })
}
function inherits(ctorClass, ctorBase) {
  if (!Ifm.Type.isFunction(ctorClass))
    throw Ifm.Diagnostics.Errors.func("ctorClass");
  if (!Ifm.Type.isFunction(ctorBase))
    throw Ifm.Diagnostics.Errors.func("ctorBase");
  ctorClass.prototype = Object.create(ctorBase.prototype);
  ctorClass.prototype.constructor = ctorClass;
  return ctorBase.prototype
}
;
function namespace(globalNamespace, factory) {
  var ns = window,
    parts = globalNamespace.split('.');
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    ns[part] = ns[part] || {};
    ns = ns[part]
  }
  if (typeof factory === typeof namespace) {
    factory.call(ns)
  }
  else {
    for (var e in factory) {
      ns[e] = factory[e]
    }
  }
  return ns
}
function query(url) {
  var query = url || window.location.search,
    pairs = {};
  query.replace(/[?&#]([^=]+)=([^&]*)?/g, function(match, key, val) {
    if (key)
      pairs[key] = val || "";
    return ""
  });
  return pairs
}
Function.getName = function(func) {
  if (!Ifm.Type.isFunction(func))
    throw Ifm.Diagnostics.Errors.func("func");
  var res = /function\s+(\w+)/.exec(func);
  if (res && res.length === 2)
    return res[1];
  res = /(\w+)\s*=\s*function/.exec(func);
  if (res && res.length === 2)
    return res[1];
  return 'anonymous function'
};
Function.prototype.toShortString = function() {
  var body = this.toString().replace(/[\r|\n]/g, '').replace(/[\s]+/g, ' ');
  return body.substr(0, body.indexOf('{')).trim()
};
Array.pushArray = function(array1, array2) {
  if (!Ifm.Type.isArray(array1))
    throw Ifm.Diagnostics.Errors.arg("array1");
  if (!Ifm.Type.isArray(array2))
    throw Ifm.Diagnostics.Errors.arg("array2");
  return Array.prototype.push.apply(array1, array2)
};
if (!Array.prototype.find) {
  try {
    Object.defineProperty(Array.prototype, "find", {
      enumerable: false, value: function(func, thisArg) {
          if (!Ifm.Type.isFunction(func))
            throw Ifm.Diagnostics.Errors.func("func");
          for (var i = 0, len = this.length; i < len; i++) {
            if (i in this && func.call(thisArg, this[i], i, this)) {
              return this[i]
            }
          }
          return undefined
        }
    })
  }
  catch(e) {}
}
if (window.ArrayBuffer) {
  ArrayBuffer.fromBytes = function(bytes) {
    var len = bytes.length;
    var buffer = new ArrayBuffer(len);
    var bufView = new Uint8Array(buffer);
    for (var i = 0; i < len; i++) {
      bufView[i] = bytes[i]
    }
    return buffer
  };
  ArrayBuffer.prototype.getBytes = function() {
    var bufView = new Uint8Array(this);
    var bytes = [];
    for (var i = 0, l = bufView.length; i < l; i++) {
      bytes.push(bufView[i])
    }
    return bytes
  }
}
if (!Object.entries) {
  Object.entries = function(obj) {
    var e = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        e.push([i, obj[i]]);
    return e
  }
}
if (!Object.keys) {
  Object.keys = function(obj) {
    var k = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        k.push(i);
    return k
  }
}
if (!Object.values) {
  Object.values = function(obj) {
    var v = [];
    for (var i in obj)
      if (obj.hasOwnProperty(i))
        v.push(obj[i]);
    return v
  }
}
String.format = function(str, formatargs) {
  if (!str || !Ifm.Type.isString(str))
    return str;
  var args = Array.prototype.slice.call(arguments, 1);
  return str.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] !== 'undefined' ? args[number] : ''
    })
};
String.prototype.format = function(formatargs) {
  var args = [this];
  Array.prototype.push.apply(args, arguments);
  return String.format.apply(null, args)
};
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(str, position) {
    position = position || 0;
    return this.substr(position, str.length) === str
  }
}
if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(str, position) {
    position = position || this.length;
    var start = Math.max(position - str.length, 0);
    return this.slice(start, position) === str
  }
}
if (!String.prototype.trim) {
  String.prototype.trim = function() {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
  }
}
String.prototype.indexAfter = function(str) {
  var p = this.indexOf(str);
  return p + (p < 0 ? 0 : str.length)
};
String.prototype.lastIndexAfter = function(str) {
  var p = this.lastIndexOf(str);
  return p + (p < 0 ? 0 : str.length)
};
if (!Date.now) {
  Date.now = function() {
    return +new Date
  }
}
if (!Date.prototype.toISOString) {
  (function() {
    function pad(number) {
      var r = String(number);
      if (r.length === 1) {
        r = '0' + r
      }
      return r
    }
    Date.prototype.toISOString = function() {
      return this.getUTCFullYear() + '-' + pad(this.getUTCMonth() + 1) + '-' + pad(this.getUTCDate()) + 'T' + pad(this.getUTCHours()) + ':' + pad(this.getUTCMinutes()) + ':' + pad(this.getUTCSeconds()) + '.' + String((this.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5) + 'Z'
    }
  })()
}
if (!Date.prototype.toISOLocaleDateString) {
  Date.prototype.toISOLocaleDateString = function() {
    var yyyy = '' + this.getFullYear(),
      mm = '' + (this.getMonth() + 1),
      dd = '' + this.getDate();
    if (mm.length < 2)
      mm = '0' + mm;
    if (dd.length < 2)
      dd = '0' + dd;
    return yyyy + '-' + mm + '-' + dd
  }
}
namespace("Ifm", function() {
  Ifm.version = "Ifm.js/1.0.94-5278";
  this.Objects = {deepMerge: function recursive(o1, o2, skipNullOrUndefined) {
      for (var i in o2) {
        if (typeof o2[i] === typeof{}) {
          if (o2[i] === null) {
            if (skipNullOrUndefined !== true) {
              o1[i] = null
            }
          }
          else if (typeof o1[i] !== typeof{} || o1[i] === null) {
            o1[i] = {}
          }
          recursive(o1[i], o2[i], skipNullOrUndefined)
        }
        else {
          if (o2[i] !== undefined || skipNullOrUndefined !== true) {
            o1[i] = o2[i]
          }
        }
      }
      return o1
    }};
  this.Enum = {};
  this.Enum.getName = function(enumObject, value) {
    var names = Object.getOwnPropertyNames(enumObject);
    for (var i = 0, l = names.length; i < l; i++) {
      var name = names[i];
      if (enumObject[name] === value) {
        return name
      }
    }
    return ''
  };
  this.Enum.getLength = function(enumObject) {
    return Object.getOwnPropertyNames(enumObject).length
  };
  this.Type = {};
  this.Type.getTypeName = function(o) {
    var ecmaname = Object.prototype.toString.call(o).slice(8, -1);
    if (ecmaname === 'Object') {
      var ctorname = o && o.constructor && o.constructor.toString().match(/function\s+([^\s]{1,})\s*\(/);
      if (ctorname)
        return ctorname[1]
    }
    return ecmaname
  };
  this.Type.isArray = function(o) {
    return Object.prototype.toString.call(o) === "[object Array]"
  };
  this.Type.isLikeArray = function(o) {
    return typeof o === 'object' && !Ifm.Type.isString(o) && typeof o.length === 'number' && !o.propertyIsEnumerable('length')
  };
  this.Type.isFunction = function(o) {
    return typeof o === 'function'
  };
  this.Type.isNumber = function(o) {
    return typeof o === 'number'
  };
  this.Type.isString = function(o) {
    return typeof o === 'string' || o instanceof String
  };
  this.Event = function() {
    if (!(this instanceof Ifm.Event))
      throw Ifm.Diagnostics.Errors.ctor();
    const _handlers = [];
    function raiseHandler(index, args) {
      return new Promise(function(resolve) {
          if (index >= 0) {
            const h = _handlers[index];
            let result;
            try {
              result = h.func.apply(h.owner, args)
            }
            catch(err) {
              console.error(err)
            }
            ;
            if (h.options.once) {
              _handlers.splice(index, 1)
            }
            if (result instanceof Promise) {
              result.finally(function() {
                raiseHandler(index - 1, args).finally(function() {
                  resolve()
                })
              })
            }
            else {
              raiseHandler(index - 1, args);
              resolve()
            }
          }
          else {
            resolve()
          }
        })
    }
    return {
        constructor: Ifm.Event, addHandler: function(func, owner = null, options = {once: false}) {
            if (!Ifm.Type.isFunction(func))
              return;
            if (!options || typeof options !== typeof{}) {
              const once = typeof options === typeof true ? options : false;
              options = {once}
            }
            _handlers.push({
              func, owner, options
            })
          }, hasHandlers: function() {
            return _handlers.length > 0
          }, removeAllHandlers: function() {
            _handlers.length = 0
          }, removeHandler: function(func) {
            var len = _handlers.length;
            while (len--) {
              if (_handlers[len].func === func) {
                _handlers.splice(len, 1)
              }
            }
          }, raise: function(args) {
            return raiseHandler(_handlers.length - 1, arguments)
          }
      }
  }
});
namespace("Ifm.Diagnostics", function() {
  this.Debug = {};
  this.Debug.onprint = new Ifm.Event;
  this.Debug.enabled = false;
  this.Debug.popupAssertions = false;
  this.Debug.assert = function __assert(condition, message) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    if (Ifm.Type.isString(condition)) {
      try {
        var tester = new Function("return " + condition);
        Ifm.Diagnostics.Debug.assert(tester(), condition + ' ' + message)
      }
      catch(e) {
        Ifm.Diagnostics.Debug.fail("Invalid assert condition '" + condition + "' : " + e.message)
      }
      return
    }
    if (!condition)
      Ifm.Diagnostics.Debug.fail(message)
  };
  this.Debug.fail = function __fail(message) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    var st = arguments[1];
    var fn = arguments[2] || __fail;
    if (!st) {
      try {
        throw new Error("Assertion failed");
      }
      catch(e) {
        st = e.stack || "[Callstack not available]"
      }
    }
    window.console && console.error && console.error(message, st);
    Ifm.Diagnostics.Debug.popupAssertions && alert(message + "\n\n----Stack----\n\n" + st)
  };
  this.Debug.clear = function() {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    window.console && console.clear && console.clear();
    var conview = document.getElementById("consoleview");
    if (conview) {
      conview.innerHTML = ''
    }
  };
  this.Debug.print = function(str) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    var line = arguments.length > 1 ? Array.prototype.slice.call(arguments).join(' ') : str && str.toString() || null;
    if (line === null) {
      return
    }
    window.console && console.log && console.log(line);
    Ifm.Diagnostics.Debug.onprint.raise(line);
    var conview = document.getElementById("consoleview");
    if (conview) {
      conview.innerHTML += line + "<br>";
      conview.scrollTop = conview.scrollHeight
    }
  };
  this.Debug.printf = function(format, args) {
    if (!Ifm.Diagnostics.Debug.enabled)
      return;
    Ifm.Diagnostics.Debug.print(String.format.apply(null, arguments))
  };
  this.Errors = (function() {
    var instance = {};
    instance.arg = function(name) {
      return _error("Invalid function argument", name)
    };
    instance.argsno = function(num) {
      return _error("Invalid number of function arguments", num)
    };
    instance.browser = function() {
      return _error("Browser not supported")
    };
    instance.ctor = function(name) {
      return _error("Invalid constructor call", name)
    };
    instance.func = function(name) {
      return _error("Function argument expected", name)
    };
    instance.miss = function(name) {
      return _error("Missing type or module", name)
    };
    instance.notimpl = function(name) {
      return _error("Feature not implemented", name)
    };
    instance.notsup = function(name) {
      return _error("Feature not supported", name)
    };
    instance.op = function(state) {
      return _error("Invalid operation", state)
    };
    function _error(error, name) {
      return new Error(error + (name ? ": '" + name + "'" : ""))
    }
    return instance
  })()
});
;
namespace("Ifm");
Ifm.Cookies = {
  get: function(name) {
    try {
      return document.cookie.replace(new RegExp("(?:(?:^|.*;\\s*)" + name + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")
    }
    catch(err) {
      return ""
    }
  }, delete: function(name) {
      try {
        document.cookie = name + "=;expires=Thu, 01-Jan-70 00:00:01 GMT;path=/"
      }
      catch(err) {}
    }, set: function(name, value) {
      try {
        document.cookie = name + "=" + value + ";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/"
      }
      catch(err) {}
    }
};
;
namespace("Ifm.Messaging");
(function() {
  this.FMessage = {
    HeaderLength: 18, LengthPosition: 16, ExtLenPosition: 12, DataPosition: 20, MessageHeaderId: 0x55555555
  };
  this.FMessageReader = function(messageBuffer) {
    if (!messageBuffer) {
      throw new Error("FMessageReader() -> Invalid message buffer");
    }
    this._bytes = [];
    this._readingpos = 0;
    if (messageBuffer instanceof ArrayBuffer) {
      this._bytes = messageBuffer.getBytes()
    }
    else if (messageBuffer instanceof Array) {
      this._bytes = messageBuffer
    }
    else {
      throw new Error("FMessageReader() -> Unsupported message data format: " + typeof messageBuffer);
    }
    if (this._bytes.length < Ifm.Messaging.FMessage.DataPosition) {
      throw new Error("FMessageReader() -> Invalid message length: " + this._bytes.length);
    }
    var headerId = this.nextInt32();
    if (headerId !== Ifm.Messaging.FMessage.MessageHeaderId) {
      throw new Error("FMessageReader() -> Invalid FMessage signature: " + headerId.toString(16));
    }
    this._readingpos = Ifm.Messaging.FMessage.LengthPosition;
    this.length = this.nextInt16();
    if (this.length === 0) {
      this._readingpos = Ifm.Messaging.FMessage.ExtLenPosition;
      this.length = this.nextInt32();
      if (this.length === 0) {
        throw new Error("FMessageReader() -> Invalid FMessage length");
      }
    }
    this._readingpos = Ifm.Messaging.FMessage.HeaderLength;
    this.code = this.nextInt16()
  };
  this.FMessageReader.prototype.remainingBytes = function() {
    return this.length + Ifm.Messaging.FMessage.HeaderLength - this._readingpos
  };
  this.FMessageReader.prototype.nextByte = function() {
    if (this._readingpos < this._bytes.length) {
      return this._bytes[this._readingpos++]
    }
    throw new Error("FMessageReader.nextByte() -> No more bytes to read: " + this._readingpos);
  };
  this.FMessageReader.prototype.nextBool = function() {
    return this.nextByte() === 0 ? false : true
  };
  this.FMessageReader.prototype.nextBool32 = function() {
    return this.nextInt32() === 0 ? false : true
  };
  this.FMessageReader.prototype.nextInt16 = function() {
    return (this.nextByte() << 8) + this.nextByte()
  };
  this.FMessageReader.prototype.nextInt32 = function() {
    return (this.nextInt16() << 16) + this.nextInt16()
  };
  this.FMessageReader.prototype.nextString = function() {
    var strlen = this.nextInt16();
    var bytes = [];
    for (var i = 0; i < strlen; i++) {
      bytes.push(this.nextByte())
    }
    return String.fromCharCode.apply(null, bytes)
  };
  this.FMessageReader.prototype.nextUniString = function() {
    var strlen = this.nextInt16();
    var bytes = [];
    for (var i = 0; i < strlen; i++) {
      bytes.push(this.nextByte());
      bytes.push(this.nextByte() << 8)
    }
    return String.fromCharCode.apply(null, bytes)
  };
  this.FMessageWriter = function(code) {
    this._bytes = [];
    this._len = 0;
    this.addInt32(Ifm.Messaging.FMessage.MessageHeaderId);
    this.addInt32(0);
    this.addInt32(0);
    this.addInt32(0);
    this.addInt16(0);
    this._len = 0;
    this.addInt16(code);
    this.code = code
  };
  this.FMessageWriter.prototype.addByte = function(byte) {
    this._bytes.push(byte);
    this._len++;
    return this
  };
  this.FMessageWriter.prototype.addBool = function(bool) {
    this.addByte(bool ? 1 : 0);
    return this
  };
  this.FMessageWriter.prototype.addBool32 = function(bool) {
    this.addInt32(bool ? 1 : 0);
    return this
  };
  this.FMessageWriter.prototype.addInt16 = function(short) {
    this.addByte((0xFF00 & short) >> 8);
    this.addByte(0x00FF & short);
    return this
  };
  this.FMessageWriter.prototype.addInt32 = function(int) {
    this.addInt16((0xFFFF0000 & int) >> 16);
    this.addInt16(0x0000FFFF & int);
    return this
  };
  this.FMessageWriter.prototype.addString = function(str) {
    var strlen = (str && str.length) || 0;
    this.addInt16(strlen);
    for (var i = 0; i < strlen; i++) {
      this.addByte(str.charCodeAt(i))
    }
    return this
  };
  this.FMessageWriter.prototype.addUniString = function(str) {
    var strlen = (str && str.length) || 0;
    this.addInt16(strlen);
    for (var i = 0; i < strlen; i++) {
      this.addByte(0x00FF & str.charCodeAt(i));
      this.addByte((0xFF00 & str.charCodeAt(i)) >> 8)
    }
    return this
  };
  this.FMessageWriter.prototype.end = function() {
    this._bytes[Ifm.Messaging.FMessage.LengthPosition] = (0xFF00 & this._len) >> 8;
    this._bytes[Ifm.Messaging.FMessage.LengthPosition + 1] = 0x00FF & this._len
  };
  this.FMessageWriter.prototype.toArrayBuffer = function() {
    return ArrayBuffer.fromBytes(this._bytes)
  }
}).call(Ifm.Messaging);
;
namespace("Ifm.Messaging");
(function(ns) {
  ns.FStringMessage = {
    MessageHeaderV1: "*begin*", MessageTypeDelV1: "%%%", MessageFieldDelV1: "###", MessageFooterV1: "\xA7end\xA7", MessageHeaderV2: "\x7Cbegin\x7C", MessageTypeDelV2: "\x7C%\x7C", MessageFieldDelV2: "\x7C#\x7C", MessageFooterV2: "\x7Cend\x7C", MinValidLength: 16, ProtocolVersion: "V1"
  };
  ns.FStringMessageReader = function(messageBuffer) {
    if (!(this instanceof Ifm.Messaging.FStringMessageReader)) {
      throw Ifm.Diagnostics.Errors.ctor("Ifm.Messaging.FStringMessageReader");
    }
    if (!messageBuffer) {
      throw Ifm.Diagnostics.Errors.arg("messageBuffer");
    }
    this._message = '';
    this._readingpos = 0;
    if (Ifm.Type.isString(messageBuffer)) {
      this._message = messageBuffer
    }
    else {
      throw new Error("FStringMessageReader() -> Unsupported message data format: " + typeof messageBuffer);
    }
    if (this._message.length < ns.FStringMessage.MinValidLength) {
      throw new Error("FStringMessageReader() -> Invalid message length: " + this._message.length);
    }
    if (this._message.startsWith(ns.FStringMessage.MessageHeaderV1)) {
      var matches = this._message.match(/^\*begin\*([A-z0-9]*)%{3}/);
      if (matches && matches.length == 2) {
        this.type = matches[1]
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage type format");
      }
      matches = this._message.match(/%{3}(.*)[\xA7|$]end[\xA7|$]/);
      if (matches && matches.length == 2) {
        this.data = matches[1].split(ns.FStringMessage.MessageFieldDelV1)
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage data format");
      }
    }
    else if (this._message.startsWith(ns.FStringMessage.MessageHeaderV2)) {
      var matches = this._message.match(/^\x7Cbegin\x7C([A-z0-9]*)\x7C%\x7C/);
      if (matches && matches.length == 2) {
        this.type = matches[1]
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage type format");
      }
      matches = this._message.match(/\x7C%\x7C(.*)[\x7C]end[\x7C]/);
      if (matches && matches.length == 2) {
        this.data = matches[1].split(ns.FStringMessage.MessageFieldDelV2)
      }
      else {
        throw new Error("FStringMessageReader() -> Invalid FStringMessage data format");
      }
    }
    else {
      throw new Error("FStringMessageReader() -> Invalid FStringMessage signature");
    }
  };
  ns.FStringMessageWriter = function FStringMessageWriter(type, protocolVersion) {
    if (!(this instanceof Ifm.Messaging.FStringMessageWriter)) {
      throw Ifm.Diagnostics.Errors.ctor("Ifm.Messaging.FStringMessageWriter");
    }
    if (!Ifm.Type.isString(type)) {
      throw Ifm.Diagnostics.Errors.arg("type");
    }
    this._dataAdded = false;
    this.type = type;
    if (protocolVersion === "V2") {
      ns.FStringMessage.protocolVersion = protocolVersion;
      this._message = ns.FStringMessage.MessageHeaderV2 + type + ns.FStringMessage.MessageTypeDelV2
    }
    else {
      ns.FStringMessage.protocolVersion = "V1";
      this._message = ns.FStringMessage.MessageHeaderV1 + type + ns.FStringMessage.MessageTypeDelV1
    }
  };
  ns.FStringMessageWriter.prototype.add = function(str) {
    if (str === undefined || str === null) {
      throw Ifm.Diagnostics.Errors.arg("str");
    }
    if (ns.FStringMessage.protocolVersion === 'V1') {
      if (this._dataAdded) {
        this._message += ns.FStringMessage.MessageFieldDelV1
      }
      this._message += str;
      this._dataAdded = true
    }
    else {
      if (this._dataAdded) {
        this._message += ns.FStringMessage.MessageFieldDelV2
      }
      this._message += str;
      this._dataAdded = true
    }
    return this
  };
  ns.FStringMessageWriter.prototype.end = function() {
    if (ns.FStringMessage.protocolVersion === 'V1') {
      this._message += ns.FStringMessage.MessageFooterV1
    }
    else {
      this._message += ns.FStringMessage.MessageFooterV2
    }
    return this
  };
  ns.FStringMessageWriter.prototype.toString = function() {
    return this._message
  }
})(Ifm.Messaging);
namespace("Ifm.Messaging");
(function() {
  this.FMessageBuilder = function() {
    if (!window.ArrayBuffer) {
      throw new Error("FMessageBuilder() -> ArrayBuffer not supported");
    }
    this.message = new Ifm.Event;
    this._buffer = [];
    this.toString = function() {
      return "[object FMessageBuilder]"
    }
  };
  this.FMessageBuilder.isSupported = function() {
    return (window.ArrayBuffer) ? true : false
  };
  this.FMessageBuilder.prototype.append = function(buffer) {
    if (!buffer) {
      throw new Error("FMessageBuilder.append() -> Invalid message buffer");
    }
    else if (buffer instanceof ArrayBuffer) {
      Array.pushArray(this._buffer, buffer.getBytes())
    }
    else if (buffer instanceof Array) {
      Array.pushArray(this._buffer, buffer)
    }
    else {
      throw new Error("FMessageBuilder.append() -> Unsupported message data format: " + typeof buffer);
    }
    while (this._buffer.length > Ifm.Messaging.FMessage.HeaderLength) {
      var message = new Ifm.Messaging.FMessageReader(this._buffer);
      if ((Ifm.Messaging.FMessage.HeaderLength + message.length) <= this._buffer.length) {
        try {
          this.message.raise(this, {message: message})
        }
        catch(e) {
          console.error(e);
          Ifm.Diagnostics.Debug.print(this, "Error dispatching or processing message:", e.message);
          Ifm.Diagnostics.Debug.print(e.stack)
        }
        this._buffer.splice(0, Ifm.Messaging.FMessage.HeaderLength + message.length)
      }
    }
  }
}).call(Ifm.Messaging);
;
namespace("Ifm.Messaging").FPropertyList = function(pliststr) {
  if (!(this instanceof Ifm.Messaging.FPropertyList)) {
    throw Ifm.Diagnostics.Errors.ctor();
  }
  if (!pliststr || !Ifm.Type.isString(pliststr)) {
    throw Ifm.Diagnostics.Errors.arg("pliststr");
  }
  pliststr = pliststr.trim();
  var list = {},
    sort = [],
    match;
  var re = /{\s*([^\s{]*)\s*=\s*([^}]*)}/g;
  while (match = re.exec(pliststr)) {
    list[match[1]] = match[2];
    sort.push(match[1])
  }
  this.events = defineEvents("changed");
  this.originalString = pliststr;
  this.get = function(key) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    return list[key]
  };
  this.keys = function() {
    var properties = [];
    for (var p in list) {
      properties.push(p)
    }
    return properties
  };
  this.remove = function(key) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    if (list.hasOwnProperty(key)) {
      delete list[key];
      var len = sort.length;
      while (len--) {
        if (sort[len] === key) {
          sort.splice(len, 1);
          this.events.changed.raise(this, {
            key: key, value: undefined
          })
        }
      }
    }
  };
  this.set = function(key, value) {
    if (!key || !Ifm.Type.isString(key)) {
      throw Ifm.Diagnostics.Errors.arg("key");
    }
    if (value !== undefined) {
      if (!list.hasOwnProperty(key)) {
        sort.push(key)
      }
      if (list[key] !== value) {
        list[key] = value;
        this.events.changed.raise(this, {
          key: key, value: value
        })
      }
    }
  };
  this.toString = function() {
    var pliststr = "{";
    for (var i = 0; i < sort.length; i++) {
      pliststr += "{" + sort[i] + " = " + list[sort[i]] + "}"
    }
    return pliststr + "}"
  }
};
;
(function() {
  var ns = namespace("Ifm.Messaging");
  var This = ns.FPort = function FPort() {
      if (!(this instanceof FPort))
        throw Ifm.Diagnostics.Errors.ctor();
      this.opened = new Ifm.Event;
      this.closed = new Ifm.Event;
      this.message = new Ifm.Event
    };
  This.isSupported = function() {
    return global.WebSocket && global.ArrayBuffer ? true : false
  };
  var proto = This.prototype;
  proto.isClosed = function() {
    return this._websocket ? this._websocket.readyState === WebSocket.CLOSED : true
  };
  proto.isOpen = function() {
    return this._websocket ? this._websocket.readyState === WebSocket.OPEN : false
  };
  proto.open = function(address, opt_protocol) {
    if (!This.isSupported())
      throw Ifm.Diagnostics.Errors.notsup("FPort");
    if (!address)
      throw Ifm.Diagnostics.Errors.arg("address");
    if (this.isOpen())
      throw Ifm.Diagnostics.Errors.op("port open");
    var port = this;
    var msgBuilder = new Ifm.Messaging.FMessageBuilder;
    msgBuilder.message.addHandler(function(sender, e) {
      this.message.raise(port, {reader: e.message})
    }, this);
    this._closedhere = false;
    this._wasconnected = false;
    this._gateway = false;
    this._localPort = null;
    Ifm.Diagnostics.Debug.print("[FPort] connecting to " + address);
    try {
      if (opt_protocol) {
        this._websocket = new WebSocket(address, opt_protocol)
      }
      else {
        this._websocket = new WebSocket(address)
      }
      this._websocket.binaryType = 'arraybuffer';
      this._address = address
    }
    catch(err) {
      Ifm.Diagnostics.Debug.print("[FPort] connection failed: " + err.message);
      port.closed.raise(port, {
        clean: false, failed: true, lost: false, reason: err.message
      });
      return
    }
    this._websocket.onmessage = function(e) {
      if (Ifm.Type.isString(e.data)) {
        var parts = e.data.split("|");
        switch (parts[0]) {
          case"#ready":
            Ifm.Diagnostics.Debug.print("[FPort] ready");
            port._websocket.send("#qlp");
            port._wasconnected = true;
            port.opened.raise(port, {
              address: address, gateway: port._gateway
            });
            return;
          case"#qlp":
            port._localPort = Number(parts[1]);
            return;
          case"#close":
            var code = parts.length > 1 ? parts[1] : "0";
            var reason = code + getCloseReason(code);
            Ifm.Diagnostics.Debug.printf("[FPort] closed ({0})", reason);
            return;
          default:
            if (parts[0].startsWith('#')) {
              return
            }
            break
        }
        var reader;
        try {
          reader = new Ifm.Messaging.FStringMessageReader(e.data)
        }
        catch(err) {
          Ifm.Diagnostics.Debug.printf("[FPort] invalid message {0}", e.data);
          Ifm.Diagnostics.Debug.print(err);
          return
        }
        port.message.raise(port, {reader: reader})
      }
      else if (e.data instanceof ArrayBuffer) {
        msgBuilder.append(e.data)
      }
      else {
        Ifm.Diagnostics.Debug.printf("[FPort] unknown message {0}", e.data)
      }
    };
    this._websocket.onclose = function(e) {
      Ifm.Diagnostics.Debug.print("[FPort] closed");
      cleanup(port, e.reason)
    }
  };
  proto.close = function() {
    if (!this.isClosed()) {
      this._closedhere = true;
      this._websocket.close();
      const port = this;
      setTimeout(function() {
        if (!port.isClosed()) {
          Ifm.Diagnostics.Debug.print("[FPort] Timeout closing connection");
          cleanup(port)
        }
      }, 3000)
    }
  };
  proto.send = function(message) {
    if (!message || !this.isOpen())
      return;
    if (message instanceof Ifm.Messaging.FMessageWriter) {
      this._websocket.send(message.toArrayBuffer())
    }
    else if (message instanceof Ifm.Messaging.FStringMessageWriter) {
      this._websocket.send(message.toString())
    }
    else {
      throw Error("Unsupported message format: " + message + " (" + Ifm.Type.getTypeName(message) + ")");
    }
  };
  function cleanup(port, closeEventReason) {
    port._websocket.onclose = null;
    port._websocket.onmessage = null;
    const clean = port._closedhere;
    const failed = !port._wasconnected;
    const lost = !failed && !clean;
    const closeReason = closeEventReason ? 'terminated for "' + closeEventReason + '"' : (failed ? 'failed' : 'lost');
    const closeDescription = "Connection to " + port._address + " " + closeReason;
    if (!clean) {
      Ifm.Diagnostics.Debug.print("[FPort] " + "Connection to " + port._address + " " + closeReason)
    }
    port.closed.raise(port, {
      clean, failed, lost, reason: clean ? "" : "Connection " + closeReason
    });
    delete port._localPort;
    delete port._address;
    delete port._websocket
  }
  function getCloseReason(code) {
    switch (code) {
      case"403":
        return ": no destination for protocol";
      case"500":
        return ": client-gateway protocol error";
      case"502":
        return ": gateway-server protocol error";
      case"503":
        return ": no destination reachable";
      default:
        return ""
    }
  }
})();
(function() {
  var ns = namespace("Ifm.Messaging");
  ns.FConnection = function() {
    if (!(this instanceof Ifm.Messaging.FConnection))
      throw Ifm.Diagnostics.Errors.ctor();
    var port = null;
    var disconnectionCause = null;
    return {
        constructor: ns.FConnection, events: defineEvents("connecting", "connected", "disconnecting", "disconnected", "binarymessage", "stringmessage"), isSupported: function() {
            return !!(port && port.isSupported())
          }, isClosed: function() {
            return !!(port && port.isClosed())
          }, isConnected: function() {
            return !!(port && port.isOpen())
          }, getAddress: function() {
            return port && port._remoteAddress || ""
          }, getLocalPort: function() {
            return port && port._localPort || null
          }, connect: function(address, protocol, onconnected) {
            if (this.isConnected()) {
              if (Ifm.Type.isFunction(onconnected))
                onconnected();
              return true
            }
            if (!address || Ifm.Type.isArray(address) && address.length === 0)
              throw Ifm.Diagnostics.Errors.arg("address");
            port = new Ifm.Messaging.FPort;
            port.opened.addHandler(function(sender, e) {
              this.events.connected.raise(this);
              if (Ifm.Type.isFunction(onconnected))
                onconnected()
            }, this);
            port.closed.addHandler(function(sender, e) {
              if (e.failed && Ifm.Type.isArray(address) && address.length > 1) {
                this.connect(address.slice().splice(1), protocol, onconnected);
                return
              }
              this.events.disconnected.raise(this, disconnectionCause || e);
              disconnectionCause = null
            }, this);
            port.message.addHandler(function(sender, e) {
              if (e.reader instanceof Ifm.Messaging.FStringMessageReader) {
                this.events.stringmessage.raise(this, e)
              }
              else if (e.reader instanceof Ifm.Messaging.FMessageReader) {
                this.events.binarymessage.raise(this, e)
              }
              else {
                Ifm.Diagnostics.Debug.fail("Invalid messageReader");
                return
              }
            }, this);
            this.events.connecting.raise(this, {address: address});
            if (Ifm.Type.isArray(address)) {
              port.open(address[0], protocol)
            }
            else {
              port.open(address, protocol)
            }
          }, disconnect: function(opt_cause) {
            if (!this.isConnected())
              return true;
            disconnectionCause = opt_cause || null;
            this.events.disconnecting.raise(this);
            port.close()
          }, send: function(message) {
            if (!message)
              throw Ifm.Diagnostics.Errors.arg("message");
            if (!this.isConnected()) {
              console.warn("[Ifm.Messaging.FConnection] Can't send, not connected");
              return
            }
            port.send(message)
          }
      }
  }
})();
;
(function() {
  var ns = namespace("Ifm.PhoneBar");
  ns.AgentListCampaigns = {
    AnyCampaign: 0, SpecificCampaign: 0x100, OmitSynthetics: 0x200, OmitHumans: 0x400
  };
  ns.AgentListStates = {
    NotAvailable: 0x1, Available: 0x2, Assigned: 0x4, Booked: 0x8, Talking: 0x10, Paused: 0x20, Postcall: 0x40, Othercall: 0x80, AnyAvailable: 0xFE
  };
  ns.CampaignInfoFlags = {
    Inactive: 0x1, Active: 0x2, Suspended: 0x4, AnyStatus: 0x7, Inbound: 0x8, Outbound: 0x10, AnyBoundness: 0x18, NotAssigned: 0x20, Assigned: 0x40, AnyAssignment: 0x60, PostCallWork: 0x80, HideTransferNotAllowed: 0x100, ExcludeSyntheticCampaigns: 0x200, ExcludeHumanCampaigns: 0x400
  };
  ns.LoginReplyFailureCauses = {
    Unspecified: 0, AccountLockout: 1, ExpiredPassword: 2, WrongUsernameOrPassword: 3, InvalidNewPassword: 4, PasswordChangeNotAllowed: 5, WrongState: 6, InvalidExtension: 7, ExtensionAlreadyInUse: 8, TokenBasedLoginNotAvailable: 9, InvalidToken: 10, ProvisioningError: 11, ExtensionTranslationError: 0x80
  };
  ns.Mediatypes = {
    Voice: 1, NearRealTime: 8, StoreAndForward: 16
  };
  ns.States = {
    Initialization: "[Initialization]", NotLoggedIn: "[Not Logged In]", Connecting: "[Connecting]", LoggedIn: "[Logged In]", Paused: "[Paused]", Ready: "[Ready]", Alerting: "[Alerting]", Talking: "[Talking]", PostCall: "[Post Call]", OtherCall: "[Other Call]", Assigned: "[Assigned]", WaitingOutbound: "[Waiting Outbound]", WaitingTransfer: "[Waiting Transfer]"
  };
  ns.TransferCallModes = {
    Blind: 0, Default: 1, Consultative: 2
  }
})();
namespace("Ifm.PhoneBar");
(function(PhoneBar) {
  PhoneBar.about = {
    product: "#phones", title: "#phonebar", version: "1.0.89-5278"
  };
  PhoneBar.events = defineEvents("initialized", "languagechanged", "displayStateChanged", "booked", "assignment", "alerting", "answered", "callfailure", "newcall", "abortcall", "othercall", "pausebooked", "pause", "ready", "readyfordetach", "transferinitiated", "readyfortransfer", "terminated", "recordingstarted", "recordingmutechanged", "recordingstopped", "maskeddigitreceived", "maskedpayloadreceived", "statechanged", "statetimechanged", "supervisormessage");
  PhoneBar.version = PhoneBar.about.title + '/' + PhoneBar.about.version;
  PhoneBar.canRun = function() {
    return !!(global && global.WebSocket && global.ArrayBuffer && global.jQuery)
  };
  PhoneBar.run = function(settings, options) {
    this.run = function() {
      self.log("PhoneBar", "Debug", "Already running")
    };
    this.instance.initialize(settings, options)
  };
  PhoneBar.instance = (function(PhoneBar) {
    var instance = {};
    var self,
      events,
      _settings,
      _config,
      states,
      strings,
      el;
    var isExtension = !!(window.chrome && chrome.runtime && chrome.runtime.id);
    var isBooked = false,
      currentState = PhoneBar.States.Initialization,
      lastDisplayState = "",
      isTemporaryDisplayState = false,
      currentStateReasonId = 0,
      currentStateReason = "",
      currentStateTime = 0,
      stateTimeTimer,
      _lastKeepAliveTime,
      _keepAliveTimerId;
    var _inputNumbers = {};
    var data = {
        accessToken: "", language: "it", localOAuth2: false, loginRedirect: false, logoutRedirect: false
      };
    var connection = new Ifm.Messaging.FConnection,
      activeCalls,
      callbacks,
      newCallRequest;
    var AgentStates = {
        0x1: "[Not Available]", 0x2: "[Available]", 0x4: "[Assigned]", 0x8: "[Booked]", 0x10: "[Talking]", 0x20: "[Paused]", 0x40: "[Post-Call]", 0x80: "[Manual Call]"
      };
    var CallFailureCauses = {
        1: "[No Dial Tone]", 2: "[No Ringback]", 3: "[Line Busy]", 4: "[No Answer]", 5: "[Fax Tone]", 6: "[Remote Hangup]", 7: "[Agent: No Dial Tone]", 8: "[Agent: No Ringback]", 9: "[Agent: Line Busy]", 10: "[Agent: No Answer]", 255: "[Unknown]"
      };
    var CallFailureCauseResources = {
        1: "CallFailureNoDialTone", 2: "CallFailureNoRingback", 3: "CallFailureLineBusy", 4: "CallFailureNoAnswer", 5: "CallFailureFaxTone", 6: "CallFailureRemoteHangUp", 7: "CallFailureAgentNoDialTone", 8: "CallFailureAgentNoRingback", 9: "CallFailureAgentBusy", 10: "CallFailureAgentNoAnswer", 255: "CallFailureUnknown"
      };
    var RecordingStates = {
        RecordingInactive: 0, RecordingActive: 1, TxChannelMuted: 2, RxChannelMuted: 4
      };
    var cookies = {
        _root: "phonebar!", _agent: "agent!"
      };
    cookies.agent = {
      firstName: cookies._root + cookies._agent + "firstName", lastName: cookies._root + cookies._agent + "lastName", password: cookies._root + cookies._agent + "password", extension: cookies._root + cookies._agent + "extension", username: cookies._root + cookies._agent + "username"
    };
    var DefaultPhonesFlags = 0;
    var DefaultPhonesProtocol = 'ipb';
    var DefaultROPFlags = 3;
    var DefaultROPProtocol = 'ipr';
    connection.events.connecting = function(sender, e) {
      changeState(states.Connecting);
      changeDisplayState(strings.ConnectingState)
    };
    connection.events.connected = function(sender, e) {
      resetKeepAliveTimer()
    };
    connection.events.disconnected = function(sender, e) {
      clearKeepAliveTimer();
      if (e.failed) {
        self.log("Connection", "Warn", e.reason);
        changeDisplayState(strings.ConnectionFailed);
        var callback = callbacks.login.shift();
        callback && callback({failed: true});
        return
      }
      if (e.clean) {
        self.log("Connection", "Info", "Disconnected");
        changeDisplayState(strings.NotLoggedInState)
      }
      else {
        self.log("Connection", "Warn", "Connection lost");
        changeDisplayState(strings.NotLoggedInState + " (" + strings.ConnectionLost + ")")
      }
      resetSessionData();
      const previousState = currentState;
      changeState(states.NotLoggedIn);
      if (previousState !== states.Connecting && previousState !== states.NotLoggedIn) {
        self.media.phone && self.media.phone.disconnect();
        self.media.xmpp && self.media.xmpp.disconnect()
      }
      updateRecordingButtons(0)
    };
    connection.events.binarymessage = function(sender, e) {
      var messageReader = e.reader,
        message = null,
        Messages = PhoneBar.Messages;
      for (var typename in Messages.PhonesToPhoneBarMessages) {
        if (messageReader.code === Messages.PhonesToPhoneBarMessages[typename]) {
          message = new Messages[typename](messageReader);
          message.typecode = messageReader.code;
          break
        }
      }
      if (message === null) {
        self.log("PhoneBar", "Warn", "Unknown message received:", messageReader.code);
        return
      }
      if (message.typecode === Messages.PhonesToPhoneBarMessages.KeepAliveRequest) {
        onKeepAliveMessage();
        connection.send(new Messages.KeepAliveReply);
        return
      }
      var callback,
        callId = message.callId;
      if (callId)
        self.log("PhoneBar", "Debug", "Got", typename, "message, callId", callId);
      else
        self.log("PhoneBar", "Debug", "Got", typename, "message");
      switch (message.typecode) {
        case Messages.PhonesToPhoneBarMessages.AssignmentRequest:
          var callData = new Ifm.Messaging.FPropertyList(message.callDataStr),
            externalParty = callData.get("ExternalParty") || '',
            mediatype = message.mediatype || Number(callData.get("_MediaType_")) || PhoneBar.Mediatypes.Voice,
            hideNumber = false;
          isBooked = false;
          if (mediatype === PhoneBar.Mediatypes.Voice) {
            if (newCallRequest) {
              hideNumber = newCallRequest.hideNumber;
              if (externalParty.endsWith(newCallRequest.externalParty)) {
                externalParty = newCallRequest.externalParty;
                callData.set("ExternalParty", externalParty)
              }
              newCallRequest = null
            }
            else if (!callData.get("DDI")) {
              var p = externalParty.lastIndexOf("+");
              if (p > 0) {
                externalParty = externalParty.substring(p);
                callData.set("ExternalParty", externalParty)
              }
            }
          }
          callData.save = function() {
            self.log("PhoneBar", "Debug", "Sending SetCallResultEvent message");
            connection.send(Messages.SetCallResultEvent(callId, callData.toString()))
          };
          var call = activeCalls[callId] = {
              callId: callId, callGuid: callData.get("GUID").toUpperCase(), timestamp: Date.now(), mediatype: mediatype, hideNumber: hideNumber, displayNumber: hideNumber ? "*****" : externalParty, campaignName: message.campaignName, callData: callData, otherData: {
                  serviceId: message.serviceId, campaignId: message.campaignId, scriptName: message.scriptName, scriptParameters: message.scriptParameters
                }, isRecording: message.recordingState & RecordingStates.RecordingActive ? true : false, recordingData: {
                  fileName: message.recordingFileName, settings: message.recordingSettings, rxChannelMuted: message.recordingState & RecordingStates.RxChannelMuted ? true : false, txChannelMuted: message.recordingState & RecordingStates.TxChannelMuted ? true : false
                }
            };
          self.log("PhoneBar", "Debug", "Incoming call on campaign", call.campaignName, "with calldata", call.callData);
          self.log("PhoneBar", "Debug", "Sending AssignmentReply message");
          connection.send(new Messages.AssignmentReply(callId, 1));
          changeState(states.Assigned);
          changeMediatypeEventDisplayState(strings.AssignedState, mediatype, message.campaignName);
          if (mediatype === PhoneBar.Mediatypes.Voice) {
            updateNumberInput(0, call.displayNumber)
          }
          updateRecordingButtons(callId);
          events.assignment.raise(self, call);
          if (message.scriptName && message.scriptName.length > 0) {
            self.log("PhoneBar", "Debug", "Script Type:", message.scriptName, "with parameters:", message.scriptParameters);
            switch (message.scriptName) {
              case"OLE2":
              case"Preloaded":
              case"PTT":
              case"PLUGIN":
                break;
              default:
                window.open(parseScriptName(message.scriptName, call))
            }
          }
          break;
        case Messages.PhonesToPhoneBarMessages.LoginReply:
          if (message.accepted === 0) {
            self.log("PhoneBar", "Warn", "Login request refused, cause", message.failureCause, Ifm.Enum.getName(PhoneBar.LoginReplyFailureCauses, message.failureCause));
            if (message.failureCause !== Ifm.PhoneBar.LoginReplyFailureCauses.WrongState) {
              changeDisplayState(strings.RequestRefused, 1000);
              connection.disconnect()
            }
            self.options.forgetPassword()
          }
          else {
            if (Ifm.Dom && Ifm.Dom.Photon) {
              Ifm.Dom.Photon.Cards.close("login-dialog")
            }
            self.agent.id = message.agentId;
            if (message.extension) {
              self.agent.extension = message.extension
            }
            if (message.username) {
              self.agent.firstName = message.firstName;
              self.agent.lastName = message.lastName;
              self.agent.username = message.username
            }
            self.agent.save()
          }
          callback = callbacks.login.shift();
          callback && callback(message);
          if (message.accepted !== 0) {
            changeState(states.LoggedIn);
            changeDisplayState(strings.LoggedInState);
            if (self.media.phone) {
              Ifm.PhoneBar.Media.Phone.events.connected.addHandler(function() {
                if (data.accessToken) {
                  self.media.phone.setAccessToken(data.accessToken)
                }
                self.media.phone.register()
              }, null, true);
              self.media.phone.connect()
            }
            if (self.options.autoConnectToXmpp() !== false) {
              self.media.xmpp && self.media.xmpp.connect()
            }
          }
          break;
        case Messages.PhonesToPhoneBarMessages.LogoutReply:
          if (message.accepted === 0) {
            self.log("PhoneBar", "Warn", "Logout request refused");
            changeDisplayState(strings.RequestRefused, 1000)
          }
          else {
            delete self.agent.id;
            self.options.forgetPassword();
            connection.disconnect();
            if (data.localOAuth2) {
              Ifm.Iam.OAuth2.logout()
            }
          }
          callback = callbacks.logout.shift();
          callback && callback(message);
          break;
        case Messages.PhonesToPhoneBarMessages.PauseReply:
          switch (message.accepted) {
            case 0:
              self.log("PhoneBar", "Warn", "Pause request refused");
              changeDisplayState(strings.RequestRefused, 1000);
              break;
            case 1:
              goPaused(message);
              break;
            case 2:
              self.log("PhoneBar", "Info", "Pause booked");
              changeDisplayState(strings.PauseBooked, 1000);
              events.pausebooked.raise(self, message);
              break
          }
          if (message.accepted === 3) {
            callback = callbacks.getPauseReasons.shift();
            callback && callback({reasons: message.reasons});
            sendNextPauseReasonListRequest()
          }
          else {
            callback = callbacks.pause.shift();
            callback && callback(message)
          }
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyReply:
          if (message.accepted === 0) {
            self.log("PhoneBar", "Warn", "Ready request refused");
            changeDisplayState(strings.RequestRefused, 1000)
          }
          else {
            if (callId && activeCalls[callId]) {
              activeCalls[callId].postcall = false;
              activeCalls[callId].terminated = true
            }
            if (currentState !== states.Ready) {
              events.ready.raise(self, {callId: callId})
            }
          }
          callback = callbacks.ready.shift();
          callback && callback(message);
          if (message.accepted === 1) {
            if (callId && activeCalls[callId]) {
              stopRecording(callId);
              delete activeCalls[callId];
              evalNextState()
            }
            else if (activeCalls.length > 0) {
              evalNextState()
            }
            else {
              goReady(true)
            }
          }
          break;
        case Messages.PhonesToPhoneBarMessages.NewCallReply:
          if (message.accepted === 0) {
            self.log("PhoneBar", "Warn", "New call request refused");
            changeDisplayState(strings.RequestRefused, 1000)
          }
          else {
            newCallRequest.callId = callId;
            self.log("PhoneBar", "Info", "New call request accepted, callId", callId);
            changeState(states.WaitingOutbound);
            changeDisplayState(strings.WaitingOutboundState)
          }
          callback = callbacks.make.shift();
          callback && callback(message);
          events.newcall.raise(self, {
            accepted: message.accepted, callId: message.callId, campaignName: newCallRequest.campaignName, hideNumber: newCallRequest.hideNumber
          });
          if (message.accepted === 0) {
            newCallRequest = null
          }
          break;
        case Messages.PhonesToPhoneBarMessages.AbortCallReply:
          if (message.accepted === 0) {
            self.log("PhoneBar", "Warn", "Abort call request refused");
            changeDisplayState(strings.RequestRefused, 1000)
          }
          else {
            if (newCallRequest && newCallRequest.callId === message.callId) {
              self.log("PhoneBar", "Info", "Abort call request accepted, callId", callId);
              message.campaign = newCallRequest.campaignName
            }
          }
          callback = callbacks.abort.shift();
          callback && callback(message);
          events.abortcall.raise(self, {
            accepted: message.accepted, callId: message.callId, campaignName: newCallRequest.campaignName, hideNumber: newCallRequest.hideNumber
          });
          break;
        case Messages.PhonesToPhoneBarMessages.TransferCallReply:
          if (message.accepted === 0) {
            self.log("PhoneBar", "Warn", "Transfer call request refused");
            changeDisplayState(strings.RequestRefused, 1000)
          }
          else {
            self.log("PhoneBar", "Info", "Transfer call request accepted, callId", callId);
            activeCalls[callId].transferred = true;
            if (activeCalls[callId].mediatype === PhoneBar.Mediatypes.Voice) {
              changeState(states.WaitingTransfer);
              changeDisplayState(strings.WaitingTransferState)
            }
            events.readyfortransfer.raise(self, message)
          }
          callback = callbacks.transfer.shift();
          callback && callback(message);
          break;
        case Messages.PhonesToPhoneBarMessages.AgentListReply:
          callback = callbacks.getAgentList.shift();
          callback && callback.callback(message);
          sendNextAgentListRequest();
          break;
        case Messages.PhonesToPhoneBarMessages.CampaignListReply:
          callback = callbacks.getCampaignList.shift();
          callback && callback.callback(message);
          sendNextCampaignListRequest();
          break;
        case Messages.PhonesToPhoneBarMessages.CampaignQueueInfoReply:
          message.avgTimestamp = message.avgTime;
          message.avgTime = friendlyTime(message.avgTime);
          message.maxTimestamp = message.maxTime;
          message.maxTime = friendlyTime(message.maxTime);
          for (var i = 0; i < message.campaigns.length; i++) {
            var c = message.campaigns[i];
            c.avgTimestamp = c.avgTime;
            c.avgTime = friendlyTime(c.avgTime);
            c.maxTimestamp = c.maxTime;
            c.maxTime = friendlyTime(c.maxTime)
          }
          callback = callbacks.getQueueInfo.shift();
          callback && callback.callback(message);
          sendNextQueueInfoRequest();
          break;
        case Messages.PhonesToPhoneBarMessages.BookedEvent:
          isBooked = true;
          changeMediatypeEventDisplayState(strings.AssignmentBooked, message.mediatype, message.campaignName);
          events.booked.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.AlertingEvent:
          changeState(states.Alerting);
          changeCallEventDisplayState(strings.AlertingState, message.callId);
          events.alerting.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.AnsweredEvent:
          changeState(states.Talking);
          changeCallEventDisplayState(strings.TalkingState, message.callId);
          events.answered.raise(self, message);
          if (activeCalls[callId] && activeCalls[callId].mediatype === Ifm.PhoneBar.Mediatypes.Voice) {
            self.callRegistry.addManagedCall(activeCalls[callId])
          }
          break;
        case Messages.PhonesToPhoneBarMessages.CallFailureEvent:
          self.log("PhoneBar", "Warn", "Call failure: callId", callId, "cause", message.cause, CallFailureCauses[message.cause], "ISDN cause", message.protocolTerminationCause, message.protocolTerminationDescription, "detected content cause", message.detectedContentCode, message.detectedContentDescription);
          message.description = strings[CallFailureCauseResources[message.cause]];
          if (!newCallRequest || newCallRequest.callId !== callId) {
            changeDisplayState(strings.CallFailure + " (" + message.description + ")", 3000)
          }
          if (activeCalls[callId]) {
            activeCalls[callId].terminated = true;
            stopRecording(callId);
            if (activeCalls[callId].mediatype === Ifm.PhoneBar.Mediatypes.Voice) {
              self.callRegistry.addFailedCall(activeCalls[callId])
            }
          }
          events.callfailure.raise(self, message);
          if (newCallRequest && newCallRequest.callId === callId) {
            newCallRequest = null
          }
          delete activeCalls[callId];
          evalNextState();
          break;
        case Messages.PhonesToPhoneBarMessages.OtherCallEvent:
          if (currentState !== states.WaitingOutbound) {
            changeState(states.OtherCall);
            changeDisplayState(strings.OtherCallState);
            events.othercall.raise(self, message)
          }
          break;
        case Messages.PhonesToPhoneBarMessages.PauseEvent:
          Object.values(activeCalls).forEach(function(c) {
            if (c.transferred) {
              stopRecording(c.callId);
              delete activeCalls[c.callId]
            }
          });
          goPaused(message);
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyEvent:
          Object.values(activeCalls).forEach(function(c) {
            c.terminated = true;
            stopRecording(c.callId);
            delete activeCalls[c.callId]
          });
          newCallRequest = null;
          goReady();
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyForDetachEvent:
          if (activeCalls[callId]) {
            activeCalls[callId].terminated = true;
            stopRecording(callId)
          }
          events.readyfordetach.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.ReadyForTransferEvent:
          events.readyfortransfer.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.SupervisorMessageEvent:
          events.supervisormessage.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.TerminatedEvent:
          activeCalls[callId].terminated = true;
          if (message.postCallWork) {
            activeCalls[callId].postcall = true
          }
          events.terminated.raise(self, message);
          if (activeCalls[callId].postcall) {
            updateRecordingButtons()
          }
          else {
            stopRecording(callId);
            delete activeCalls[callId]
          }
          evalNextState();
          break;
        case Messages.PhonesToPhoneBarMessages.PostCallWorkEvent:
          evalNextState();
          break;
        case Messages.PhonesToPhoneBarMessages.AudioRecordingStartedEvent:
          if (activeCalls[callId]) {
            activeCalls[callId].recordingData.fileName = message.fileName;
            updateRecordingButtons(callId);
            events.recordingstarted.raise(self, message)
          }
          break;
        case Messages.PhonesToPhoneBarMessages.AudioRecordingCompletedEvent:
          stopRecording(callId, message.result);
          break;
        case Messages.PhonesToPhoneBarMessages.AudioRecordingMutedEvent:
          activeCalls[callId].recordingData.rxChannelMuted = message.rxChannelMuted;
          activeCalls[callId].recordingData.txChannelMuted = message.txChannelMuted;
          updateRecordingButtons(callId);
          events.recordingmutechanged.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.MaskedDigitReceivedEvent:
          events.maskeddigitreceived.raise(self, message);
          break;
        case Messages.PhonesToPhoneBarMessages.MaskedPayloadReceivedEvent:
          events.maskedpayloadreceived.raise(self, message);
          break;
        default:
          self.log("PhoneBar", "Debug", "Not implemented:", typename);
          break
      }
    };
    function clearKeepAliveTimer() {
      if (_keepAliveTimerId > 0) {
        clearTimeout(_keepAliveTimerId);
        _lastKeepAliveTime = 0
      }
    }
    function resetKeepAliveTimer() {
      clearKeepAliveTimer();
      _lastKeepAliveTime = Date.now();
      _keepAliveTimerId = setTimeout(onKeepAliveTimerElapsed, 2 * 30000)
    }
    function onKeepAliveMessage() {
      resetKeepAliveTimer()
    }
    function onKeepAliveTimerElapsed() {
      self.log("Connection", "Warn", "Missed keep alive message");
      connection.disconnect({
        clean: false, failed: false, lost: true, reason: 'Connection lost'
      })
    }
    function resetSessionData() {
      activeCalls = {};
      callbacks = {
        login: [], logout: [], pause: [], ready: [], make: [], transfer: [], abort: [], getAgentList: [], getCampaignList: [], getPauseReasons: [], getQueueInfo: []
      };
      newCallRequest = null
    }
    function evalNextState() {
      if (currentState === states.Paused)
        return;
      if (Object.values(activeCalls).some(function(c) {
        return !c.terminated && !c.transferred
      })) {
        changeState(states.Talking);
        changeCallEventDisplayState(strings.TalkingState)
      }
      else if (Object.values(activeCalls).some(function(c) {
        return c.postcall
      })) {
        changeState(states.PostCall);
        changeCallEventDisplayState(strings.PostCallState)
      }
      else if (newCallRequest) {
        changeState(states.WaitingOutbound);
        changeDisplayState(strings.WaitingOutboundState)
      }
      else {
        goReady()
      }
    }
    function changeState(newState) {
      var oldState = currentState;
      if (newState === oldState && newState !== states.Paused)
        return;
      self.log("PhoneBar", "Debug", "Changing state, from", oldState, "to", newState);
      currentState = newState;
      var resettime = false,
        starttimer = false;
      switch (oldState) {
        case states.Alerting:
          jQuery(el.PickupButton).removeClass("highlight blink");
          break;
        case states.Talking:
          if (newState !== states.Talking) {
            jQuery(el.TransferButton).disable()
          }
          break;
        case states.Paused:
          if (newState !== states.Paused) {
            currentStateReasonId = 0;
            currentStateReason = ""
          }
          break;
        case states.WaitingOutbound:
          jQuery(el.AbortCallButton).disable().hide();
          if (newState === states.Ready || newState === states.Paused) {
            newCallRequest = null
          }
          break
      }
      switch (newState) {
        case states.NotLoggedIn:
          jQuery([el.PauseButton, el.ReadyButton, el.LogoutButton, el.NumberLabel, el.NumberInput, el.CallButton, el.TransferButton, el.CampaignListButton, el.QueueInfoButton, el.PanicButton, el.StartRecordingButton, el.StopRecordingButton, el.MuteRecordingButton, el.UnmuteRecordingButton].join(", ")).disable();
          jQuery(el.LoginButton).enable();
          jQuery(el.LoginOrReadyButton).enable();
          jQuery(el.NumberInput).val("").change();
          if (Ifm.Dom && Ifm.Dom.Photon) {
            Ifm.Dom.Photon.Cards.close('campaignlist-card');
            Ifm.Dom.Photon.Cards.close('queueinfo-card')
          }
          resettime = true;
          break;
        case states.Connecting:
          jQuery([el.LoginButton, el.LoginOrReadyButton].join(", ")).disable();
          break;
        case states.LoggedIn:
        case states.Ready:
          jQuery([el.PauseButton, el.LogoutButton, el.NumberLabel, el.NumberInput, el.CampaignListButton, el.QueueInfoButton, el.PanicButton].join(", ")).enable();
          jQuery([el.LoginButton, el.LoginOrReadyButton, el.ReadyButton].join(", ")).disable();
          resettime = true;
          break;
        case states.Paused:
          jQuery(el.PauseButton).disable();
          self.getPauseReasons(function(e) {
            if (e.reasons.length > 0)
              jQuery(el.PauseButton).enable()
          });
          jQuery([el.ReadyButton, el.LoginOrReadyButton].join(", ")).enable();
          resettime = true;
          starttimer = !self.options.hideClockInPause();
          break;
        case states.Talking:
          if (Object.values(activeCalls).some(function(call) {
            return call.mediatype === PhoneBar.Mediatypes.Voice
          })) {
            jQuery(el.TransferButton).enable()
          }
          resettime = true;
          starttimer = true;
          break;
        case states.PostCall:
          if (Object.values(activeCalls).some(function(call) {
            return call.mediatype === PhoneBar.Mediatypes.Voice
          })) {
            jQuery([el.ReadyButton, el.LoginOrReadyButton].join(", ")).enable()
          }
          resettime = true;
          starttimer = true;
          break;
        case states.OtherCall:
          if (!stateTimeTimer) {
            resettime = true;
            starttimer = true
          }
          break;
        case states.Assigned:
          resettime = true;
          starttimer = true;
          break;
        case states.Alerting:
          jQuery(el.PickupButton).addClass("highlight blink");
          break;
        case states.WaitingOutbound:
          jQuery([el.ReadyButton, el.LoginOrReadyButton].join(", ")).disable();
          jQuery(el.AbortCallButton).show().enable();
          resettime = true;
          starttimer = true;
          break;
        case states.WaitingTransfer:
          break;
        default:
          self.log("PhoneBar", "Debug", "Unexpected state", newState);
          return
      }
      updateCallButton();
      events.statechanged.raise(self, {
        currentState: newState, previousState: oldState
      });
      if (resettime) {
        currentStateTime = new Date;
        events.statetimechanged.raise(self, {
          stateTime: currentStateTime, startTimer: starttimer
        });
        if (stateTimeTimer) {
          stateTimeTimer = clearTimeout(stateTimeTimer)
        }
        if (starttimer) {
          stateTimeTimer = setInterval(function() {
            var dT = new Date - currentStateTime;
            jQuery(el.StateTimeText).html(friendlyTime(dT, true))
          }, 1000)
        }
        jQuery(el.StateTimeText).html("")
      }
    }
    function changeCallEventDisplayState(state, callId) {
      var additionalStateInfo = "";
      if (self.options.showCampaignNameForVoiceCalls()) {
        var call = callId && activeCalls[callId];
        if (!call || call.mediatype != PhoneBar.Mediatypes.Voice) {
          call = getAudioCall()
        }
        if (call) {
          additionalStateInfo = " (" + call.campaignName + ")"
        }
      }
      changeDisplayState(state + additionalStateInfo)
    }
    function changeMediatypeEventDisplayState(state, mediatype, campaignName) {
      var additionalStateInfo = "";
      if (self.options.showCampaignNameForVoiceCalls() && mediatype === PhoneBar.Mediatypes.Voice && campaignName.length > 0) {
        additionalStateInfo = " (" + campaignName + ")"
      }
      changeDisplayState(state + additionalStateInfo)
    }
    function changeDisplayState(label, timeout) {
      if (timeout) {
        isTemporaryDisplayState = true;
        jQuery(el.StateText).html(label);
        jQuery(el.StateText).addClass("phonebar-state-error-text");
        events.displayStateChanged.raise(self, {
          label: label, isTemporary: true
        });
        setTimeout(function() {
          jQuery(el.StateText).removeClass("phonebar-state-error-text");
          isTemporaryDisplayState = false;
          jQuery(el.StateText).html(lastDisplayState);
          events.displayStateChanged.raise(self, {
            label: lastDisplayState, isTemporary: false
          })
        }, timeout)
      }
      else {
        lastDisplayState = label;
        if (!isTemporaryDisplayState) {
          jQuery(el.StateText).html(label);
          events.displayStateChanged.raise(self, {
            label: label, isTemporary: false
          })
        }
      }
    }
    function getAudioCall() {
      return Object.values(activeCalls).find(function(c) {
          return c.mediatype === PhoneBar.Mediatypes.Voice
        }) || null
    }
    function goPaused(message) {
      var newStateReasonId = message.reasonId || 0;
      if (currentState !== PhoneBar.States.Paused || newStateReasonId !== currentStateReasonId) {
        changeState(PhoneBar.States.Paused);
        currentStateReasonId = newStateReasonId;
        if (currentStateReasonId === 0) {
          currentStateReason = "";
          changeDisplayState(strings.PausedState)
        }
        else {
          currentStateReason = message.reasonText;
          self.log("PhoneBar", "Debug", "Pause reason is", currentStateReason);
          changeDisplayState(strings.PausedState + " (" + currentStateReason + ")")
        }
        events.pause.raise(self, message)
      }
    }
    function goReady(dontRaiseEvent = false) {
      if ((currentState !== states.Ready) || isBooked) {
        isBooked = false;
        changeState(states.Ready);
        changeDisplayState(strings.ReadyState);
        !dontRaiseEvent && events.ready.raise(self, {callId: null})
      }
    }
    function tokenChangeCallback(authInfo) {
      if (authInfo.isRedirecting) {
        self.log("PhoneBar", "Info", "Redirecting to", _config.authorityUrl)
      }
      else {
        onTokenUpdated(authInfo.token, authInfo.username)
      }
    }
    function onTokenUpdated(token, username) {
      if (!token) {
        self.log("PhoneBar", "Error", "Missing access token")
      }
      data.accessToken = token || "";
      if (username && !self.agent.username !== username) {
        self.agent.username = username
      }
      self.log("PhoneBar", "Debug", "Access token updated");
      if (self.isLoggedIn()) {
        self.agent.password = token;
        self.agent.save();
        if (self.media.phone) {
          self.media.phone.setAccessToken(token)
        }
      }
    }
    function stopRecording(callId, result) {
      var call = activeCalls[callId];
      if (call && call.isRecording) {
        call.isRecording = false;
        updateRecordingButtons(callId);
        events.recordingstopped.raise(self, {
          callId: callId, result: result || 0
        })
      }
      else {
        updateRecordingButtons(0)
      }
    }
    function updateCallButton() {
      var states = PhoneBar.States;
      if (currentState === states.LoggedIn || currentState === states.Ready || currentState === states.Paused) {
        jQuery(el.CallButton).enabled(jQuery(el.NumberInput).val())
      }
      else {
        jQuery(el.CallButton).disable()
      }
    }
    function clearNumberInput(line) {
      delete _inputNumbers[line];
      const q = jQuery(el.NumberInput);
      q.attr("title", "");
      if (q.data("s")) {
        q.val("")
      }
      q.removeData(["n", "s"])
    }
    function updateNumberInput(line, displayNumber, displayName) {
      const t = _inputNumbers[line] || (_inputNumbers[line] = {});
      t.displayNumber = displayNumber || t.displayNumber;
      t.displayName = displayName || t.displayName;
      if (self.media.phone && self.media.phone.selectedLineId === line) {
        showLineNumberInput(line)
      }
    }
    function showLineNumberInput(line) {
      const q = jQuery(el.NumberInput);
      const t = _inputNumbers[line];
      if (t) {
        t.displayName && q.val(t.displayName);
        t.displayNumber && t.displayNumber !== t.displayName && (t.displayName ? q.attr("title", t.displayNumber) : q.val(t.displayNumber));
        if (t.displayName && t.displayNumber && t.displayNumber !== t.displayName) {
          q.data("s", 1);
          q.data("n", 1)
        }
        else {
          q.removeData(["n", "s"])
        }
      }
    }
    function updateRecordingButtons(callId) {
      var call = activeCalls[callId];
      if (call && call.mediatype !== PhoneBar.Mediatypes.Voice)
        return;
      if (!call || call.terminated || !call.isRecording) {
        jQuery([el.StartRecordingButton, el.StopRecordingButton, el.MuteRecordingButton, el.UnmuteRecordingButton].join(", ")).disable();
        jQuery(el.StopRecordingButton).hide();
        jQuery(el.UnmuteRecordingButton).hide();
        jQuery(el.StartRecordingButton).show();
        jQuery(el.MuteRecordingButton).show()
      }
      else if (call && call.isRecording) {
        jQuery(el.StartRecordingButton).disable();
        jQuery(el.StartRecordingButton).hide();
        jQuery(el.StopRecordingButton).enable();
        jQuery(el.StopRecordingButton).show();
        if (call.recordingData.rxChannelMuted || call.recordingData.txChannelMuted) {
          jQuery(el.MuteRecordingButton).disable();
          jQuery(el.MuteRecordingButton).hide();
          jQuery(el.UnmuteRecordingButton).enable();
          jQuery(el.UnmuteRecordingButton).show()
        }
        else {
          jQuery(el.MuteRecordingButton).enable();
          jQuery(el.MuteRecordingButton).show();
          jQuery(el.UnmuteRecordingButton).disable();
          jQuery(el.UnmuteRecordingButton).hide()
        }
      }
      if (call && !call.postcall && !call.terminated && !call.isRecording) {
        jQuery(el.StartRecordingButton).enable()
      }
    }
    function decrypt(text, seed) {
      if (text[0] === '\t') {
        var b64 = '',
          key = '';
        for (var i = 1; key.length < (1 + text.length) / 2; i++) {
          key += seed * i
        }
        for (var i = 0, j = 1; j < text.length; i++, j += 2) {
          var x = Number('0x' + text[j] + text[j + 1]) ^ key.charCodeAt(i);
          b64 += String.fromCharCode(x)
        }
        var s1 = seed.toString(),
          s2 = (seed * 2).toString();
        text = atob(b64);
        text = text.substr(s1.length, text.length - s1.length - s2.length)
      }
      return text
    }
    function encrypt(text, seed) {
      if (text[0] !== '\t') {
        var b64 = btoa(seed + text + seed * 2),
          key = '';
        for (var i = 1; key.length < b64.length; i++) {
          key += seed * i
        }
        for (var i = 0, text = '\t'; i < b64.length; i++) {
          var x = b64.charCodeAt(i) ^ key.charCodeAt(i);
          text += (x < 0x10 ? '0' : '') + x.toString(16)
        }
      }
      return text
    }
    function friendlyTime(dT, ms) {
      if (ms)
        dT = dT / 1000;
      var seconds = Math.floor(dT % 60);
      dT = dT / 60;
      var minutes = Math.floor(dT % 60);
      dT = dT / 60;
      var hours = Math.floor(dT % 24);
      var days = Math.floor(dT / 24);
      var timestr = "";
      if (days > 0)
        timestr += days + " d ";
      if (hours > 0)
        timestr += hours + " h ";
      if (minutes > 0)
        timestr += minutes + " m ";
      if (seconds > 0)
        timestr += seconds + " s ";
      return timestr
    }
    function getPropertyValue(propertyName, call) {
      switch (propertyName.toUpperCase()) {
        case"CALLID":
          return call.id;
        case"CAMPAIGNID":
          return call.otherData.campaignId;
        case"CAMPAIGNNAME":
          return call.campaignName;
        case"SERVICEID":
          return call.otherData.serviceId;
        case"AGENTID":
          return self.agent.id;
        case"AGENTNAME":
          return self.agent.firstName + " " + self.agent.lastName;
        case"AGENTFIRSTNAME":
          return self.agent.firstName;
        case"AGENTLASTNAME":
          return self.agent.lastName;
        case"EXTENSION":
          return self.agent.extension
      }
      return ""
    }
    function parseScriptName(scriptName, call) {
      var parsed = "";
      var keyName = "";
      var value = scriptName;
      do {
        var pos1 = value.indexOf("{$");
        var pos2 = value.indexOf("{%");
        if (pos1 === -1 && pos2 === -1) {
          parsed += value;
          value = ""
        }
        else if (pos1 >= 0 && pos2 === -1) {
          pos2 = value.indexOf("}", pos1 + 2);
          if (pos2 >= 0) {
            parsed += value.substr(0, pos1);
            keyName = value.substr(pos1 + 2, pos2 - pos1 - 2);
            if (call.callData.get(keyName)) {
              parsed += call.callData.get(keyName)
            }
            value = value.substr(pos2 + 1)
          }
          else {
            parsed += value;
            value = ""
          }
        }
        else if (pos1 === -1 && pos2 >= 0) {
          pos1 = pos2;
          pos2 = value.indexOf("}", pos1 + 2);
          if (pos2 >= 0) {
            keyName = value.substr(pos1 + 2, pos2 - pos1 - 2);
            parsed += (value.substr(0, pos1) + getPropertyValue(keyName, call));
            value = value.substr(pos2 + 1)
          }
          else {
            parsed += value;
            value = ""
          }
        }
        else if (pos1 < pos2) {
          pos2 = value.indexOf("}", pos1 + 2);
          if (pos2 >= 0) {
            parsed += value.substr(0, pos1);
            keyName = value.substr(pos1 + 2, pos2 - pos1 - 2);
            if (call.callData.get(keyName)) {
              parsed += call.callData.get(keyName)
            }
            value = value.substr(pos2 + 1)
          }
          else {
            parsed += value;
            value = ""
          }
        }
        else {
          pos1 = pos2;
          pos2 = value.indexOf("}", pos1 + 2);
          if (pos2 >= 0) {
            keyName = value.substr(pos1 + 2, pos2 - pos1 - 2);
            parsed += (value.substr(0, pos1) + getPropertyValue(keyName, call));
            value = value.substr(pos2 + 1)
          }
          else {
            parsed += value;
            value = ""
          }
        }
      } while (value.length > 0);
      return parsed
    }
    function applyLanguage() {
      jQuery(el.LoginButton).attr("title", strings.TooltipLogin);
      jQuery(el.LoginOrReadyButton).attr("title", strings.TooltipLoginOrReady);
      jQuery(el.ReadyButton).attr("title", strings.TooltipReady);
      jQuery(el.PauseButton).attr("title", strings.TooltipPause);
      jQuery(el.LogoutButton).attr("title", strings.TooltipLogout);
      jQuery(el.CallButton).attr("title", strings.TooltipCall);
      jQuery(el.TransferButton).attr("title", strings.TooltipTransfer);
      jQuery(el.CampaignListButton).attr("title", strings.TooltipCampaignList);
      jQuery(el.CallRegistryButton).attr("title", strings.TooltipCallRegistry);
      jQuery(el.QueueInfoButton).attr("title", strings.TooltipQueueInfo);
      jQuery(el.PanicButton).attr("title", strings.TooltipPanic);
      jQuery(el.MainMenuButton).attr("title", strings.TooltipMainMenu);
      jQuery(el.NumberLabel).attr("title", strings.TooltipPhoneNumber);
      jQuery(el.NumberInput).attr("placeholder", "   " + strings.TooltipPhoneNumber);
      jQuery(el.StartRecordingButton).attr("title", strings.TooltipStartRec);
      jQuery(el.StopRecordingButton).attr("title", strings.TooltipStopRec);
      jQuery(el.MuteRecordingButton).attr("title", strings.TooltipMuteRec);
      jQuery(el.UnmuteRecordingButton).attr("title", strings.TooltipUnmuteRec);
      jQuery(el.HangupButton).attr("title", strings.TooltipHangup);
      jQuery(el.PickupButton).attr("title", strings.TooltipPickup);
      jQuery(el.FlashButton).attr("title", strings.TooltipFlash);
      jQuery(el.ManualTransferButton).attr("title", strings.TooltipManualTransfer);
      jQuery(el.Line1Button).attr("title", strings.TooltipLine1);
      jQuery(el.Line2Button).attr("title", strings.TooltipLine2);
      jQuery(el.EnterConferenceButton).attr("title", strings.TooltipEnterConf);
      jQuery(el.LeaveConferenceButton).attr("title", strings.TooltipLeaveConf);
      jQuery(el.MicrophoneVULabel + ", " + el.MicrophoneVUMeter).attr("title", strings.TooltipMicVUMeter);
      jQuery(el.SpeakersVULabel + ", " + el.SpeakersVUMeter).attr("title", strings.TooltipSpkVUMeter);
      jQuery(el.MicrophoneOffButton).attr("title", strings.TooltipMicOff);
      jQuery(el.MicrophoneOnButton).attr("title", strings.TooltipMicOn)
    }
    function sendNextAgentListRequest() {
      if (callbacks.getAgentList.length) {
        var request = callbacks.getAgentList[0],
          campaignName = request.campaignName,
          mask = request.mask;
        self.log("PhoneBar", "Debug", "Sending AgentListRequest message");
        connection.send(new PhoneBar.Messages.AgentListRequest(campaignName, mask))
      }
    }
    function sendNextCampaignListRequest() {
      if (callbacks.getCampaignList.length) {
        var request = callbacks.getCampaignList[0],
          mask = request.mask,
          callId = request.callId,
          mediatype = request.mediatype;
        self.log("PhoneBar", "Debug", "Sending CampaignListRequest message");
        connection.send(new PhoneBar.Messages.CampaignListRequest(mask, callId, mediatype))
      }
    }
    function sendNextPauseReasonListRequest() {
      if (callbacks.getPauseReasons.length) {
        self.log("PhoneBar", "Debug", "Sending PauseReasonsRequest message");
        connection.send(new PhoneBar.Messages.PauseReasonsRequest)
      }
    }
    function sendNextQueueInfoRequest() {
      if (callbacks.getQueueInfo.length) {
        var campaignName = callbacks.getQueueInfo[0].campaignName;
        self.log("PhoneBar", "Debug", "Sending CampaignQueueInfoRequest message");
        connection.send(new PhoneBar.Messages.CampaignQueueInfoRequest(campaignName))
      }
    }
    instance = {
      calls: function(filter) {
        var predicate = typeof filter === "function" ? filter : null;
        if (arguments.length > 0 && predicate === null) {
          if (filter in activeCalls) {
            return activeCalls[filter]
          }
          else if (newCallRequest && newCallRequest.callId === filter) {
            return newCallRequest
          }
          else {
            return null
          }
        }
        var c = Object.values(activeCalls);
        if (predicate) {
          return c.filter(predicate)
        }
        return c
      }, currentState: function() {
          return currentState
        }, currentStateReason: function() {
          return currentStateReason
        }, currentStateReasonId: function() {
          return currentStateReasonId
        }, currentStateTime: function() {
          return currentStateTime
        }, getConfiguration: function() {
          return _settings
        }, getPhoneBarConfiguration: function() {
          return _config
        }, language: function(lang) {
          if (arguments.length === 0) {
            return data.language
          }
          if (lang && PhoneBar.Strings[lang]) {
            strings = PhoneBar.Strings[lang];
            data.language = lang;
            applyLanguage();
            self.log("PhoneBar", "Debug", "Language set to '" + lang + "'");
            events.languagechanged.raise(self, {language: lang})
          }
        }, isLoggedIn: function() {
          return self && self.connection && self.connection.isConnected() && currentState !== states.Initialization && currentState !== states.Connecting && currentState !== states.NotLoggedIn
        }, isOAuth2Enabled: function() {
          return data.localOAuth2
        }, isRedirectedAfterOAuth2Signin: function() {
          return data.loginRedirect
        }, isRedirectedAfterOAuth2Signout: function() {
          return data.logoutRedirect
        }, initialize: function(settings, options) {
          if (arguments.length == 1)
            options = settings.options;
          if (currentState !== PhoneBar.States.Initialization && currentState !== states.NotLoggedIn) {
            throw Ifm.Diagnostics.Errors.op("must be not logged in");
          }
          _settings = settings;
          _config = settings.config;
          if (!self) {
            if (!PhoneBar.canRun())
              throw Ifm.Diagnostics.Errors.browser();
            Ifm.version = PhoneBar.version + "; " + Ifm.version;
            self = this;
            events = PhoneBar.events,
            states = PhoneBar.States,
            el = PhoneBar.UI.Elements;
            self.log("PhoneBar", "Info", Ifm.version);
            window.addEventListener("pagehide", function() {
              self.media.phone && self.media.phone.disconnect();
              self.media.xmpp && self.media.xmpp.disconnect()
            });
            jQuery.fn.extend({
              enable: function() {
                return this.each(function() {
                    PhoneBar.UI.controlState(this, true)
                  })
              }, disable: function() {
                  return this.each(function() {
                      PhoneBar.UI.controlState(this, false)
                    })
                }, enabled: function(state) {
                  if (state === undefined)
                    return PhoneBar.UI.controlState(this);
                  return this.each(function() {
                      PhoneBar.UI.controlState(this, !!state)
                    })
                }
            });
            data.localOAuth2 = !!(Ifm.Iam && Ifm.Iam.OAuth2 && _config.enableOAuth2);
            if (data.localOAuth2) {
              data.loginRedirect = Ifm.Iam.OAuth2.isOAuth2Redirect();
              data.logoutRedirect = Ifm.Iam.OAuth2.isLogoutRedirect();
              Ifm.Iam.OAuth2.addLogCallback(self.log);
              Ifm.Iam.OAuth2.addTokenChangeCallback(tokenChangeCallback)
            }
            jQuery(el.NumberInput).attr("maxlength", 255).on("change input", function(e) {
              var filteredNumberInput = jQuery(el.NumberInput).val().replace(/([^0-9#*])/g, '');
              jQuery(el.NumberInput).val(filteredNumberInput);
              updateCallButton()
            });
            Ifm.PhoneBar.Media.Phone.events.calldisconnected = function(_, e) {
              clearNumberInput(e.lineId)
            };
            Ifm.PhoneBar.Media.Phone.events.lineselected = function(_, e) {
              showLineNumberInput(e.lineId)
            };
            Ifm.PhoneBar.Media.Phone.events.displayname = function(_, e) {
              if (e.displayName) {
                const call = getAudioCall();
                if (call) {
                  call.displayName = e.displayName
                }
                updateNumberInput(e.lineId, undefined, e.displayName)
              }
            }
          }
          else {
            if (!!(Ifm.Iam && Ifm.Iam.OAuth2 && _config.enableOAuth2) && !data.localOAuth2) {
              data.localOAuth2 = true;
              data.loginRedirect = Ifm.Iam.OAuth2.isOAuth2Redirect();
              data.logoutRedirect = Ifm.Iam.OAuth2.isLogoutRedirect();
              Ifm.Iam.OAuth2.addLogCallback(self.log);
              Ifm.Iam.OAuth2.addTokenChangeCallback(tokenChangeCallback)
            }
          }
          Ifm.Diagnostics.Debug.enabled = _config.debug || false;
          self.language(PhoneBar.Strings[_config.language] ? _config.language : "it");
          jQuery('[class^="phonebar-phone"]').disable().hide();
          jQuery(el.AbortCallButton).disable().hide();
          jQuery("#page-layout").show();
          if (self.media.phone) {
            self.media.phone.terminate();
            delete self.media.phone
          }
          let asyncPhoneInit,
            asyncXmppInit;
          return new Promise(function(resolve) {
              if (_config.phoneDevice && _config.phoneDevice !== 'NoDevice') {
                if (!(_config.phoneDevice in PhoneBar.Media)) {
                  self.log("PhoneBar", "Error", "Invalid configuration argument PhoneDevice:", _config.phoneDevice)
                }
                else {
                  self.media.phone = new PhoneBar.Media[_config.phoneDevice](self);
                  self.media.phone.updateCallButton = updateCallButton;
                  asyncPhoneInit = self.media.phone.initialize(settings)
                }
              }
              if (self.media.xmpp) {
                self.media.xmpp.terminate();
                delete self.media.xmpp
              }
              if (PhoneBar.Media.Xmpp.instance && settings.xmppconfig && settings.xmppconfig.service && settings.xmppconfig.useBuiltinXmppWindow !== false) {
                self.media.xmpp = PhoneBar.Media.Xmpp.instance;
                asyncXmppInit = self.media.xmpp.initialize(self, settings.xmppconfig)
              }
              resetSessionData();
              changeState(states.NotLoggedIn);
              changeDisplayState(strings.NotLoggedInState);
              updateRecordingButtons(0);
              self.agent.load();
              for (var option in options) {
                if (self.options[option])
                  self.options[option](options[option])
              }
              Promise.all([asyncPhoneInit, asyncXmppInit]).then(function() {
                events.initialized.raise(self, {
                  settings: settings, options: options
                });
                if (data.localOAuth2 && !data.logoutRedirect && data.loginRedirect) {
                  self.getToken(function(token) {
                    self.loginWithToken(token, self.agent.extension)
                  })
                }
                resolve()
              })
            })
        }, login: function(firstName, lastName, password, extension, callback) {
          if (arguments.length < 4 || arguments.length > 5)
            throw Ifm.Diagnostics.Errors.argsno("4 (+1)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          extension = extension != undefined && extension != null ? extension.toString() : "";
          var isLoginWithToken = firstName === "\t";
          if (!isLoginWithToken) {
            self.agent.firstName = firstName;
            self.agent.lastName = lastName
          }
          self.agent.password = password;
          self.agent.extension = extension;
          self.agent.save();
          var service = _config.service,
            protocol = _config.protocol || DefaultPhonesProtocol,
            flags = _config.flags || DefaultPhonesFlags;
          if (Ifm.Type.isString(extension) && extension.startsWith("@")) {
            service = _config.service_rop || _config.service;
            protocol = _config.protocol_rop || DefaultROPProtocol;
            flags = _config.flags_rop || DefaultROPFlags;
            extension = self.agent.extension = extension.slice(1)
          }
          if (!isLoginWithToken) {
            self.log("PhoneBar", "Info", "Loggin'in to", service, "as", firstName, lastName, "extension", extension || "(auto)")
          }
          else {
            var cloudService = (Ifm.Type.isArray(service) ? service[0] : service) || "";
            if (cloudService.startsWith("*")) {
              if (!self.agent.username) {
                if (data.localOAuth2) {
                  self.getToken(function(token) {
                    self.login(firstName, lastName, token, extension, callback)
                  });
                  return
                }
                else {
                  self.log("PhoneBar", "Error", "External token must specify a valid username for cloud-based login.")
                }
              }
              var userParts = self.agent.username.split('@');
              var userDomain = userParts.length == 2 ? userParts[1] : "";
              userDomain = userDomain.replace(/\./g, "-");
              service = cloudService.replace("*", "wss://" + userDomain + "-agents")
            }
            self.log("PhoneBar", "Info", "Loggin'in to", service, "via OAuth2 as", self.agent.username, "extension", extension || "(auto)")
          }
          callback && callbacks.login.push(callback);
          connection.connect(service, protocol, function onconnected() {
            self.log("PhoneBar", "Debug", "Sending LoginRequest message");
            connection.send(new PhoneBar.Messages.LoginRequest(firstName, lastName, password, extension, flags))
          })
        }, loginEx: function(firstName, lastName, oldPassword, newPassword, extension, callback) {
          if (arguments.length < 5 || arguments.length > 6)
            throw Ifm.Diagnostics.Errors.argsno("5 (+1)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          extension = extension != undefined && extension != null ? extension.toString() : "";
          self.agent.firstName = firstName;
          self.agent.lastName = lastName;
          self.agent.password = newPassword;
          self.agent.extension = extension;
          self.agent.save();
          var service = _config.service,
            protocol = _config.protocol || DefaultPhonesProtocol,
            flags = _config.flags || DefaultPhonesFlags;
          if (Ifm.Type.isString(extension) && extension.startsWith("@")) {
            service = _config.service_rop || _config.service;
            protocol = _config.protocol_rop || DefaultROPProtocol;
            flags = _config.flags_rop || DefaultROPFlags;
            extension = self.agent.extension = extension.slice(1)
          }
          self.log("PhoneBar", "Info", "Loggin'in to", service, "as", firstName, lastName, "extension", extension || "(auto)");
          callback && callbacks.login.push(callback);
          connection.connect(service, protocol, function onconnected() {
            self.log("PhoneBar", "Debug", "Sending LoginRequest message");
            connection.send(new PhoneBar.Messages.LoginExRequest(firstName, lastName, oldPassword, newPassword, extension, flags))
          })
        }, getToken: function(callback, username, authConfig) {
          if (arguments.length > 3)
            throw Ifm.Diagnostics.Errors.argsno("0 (+3)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (!authConfig && !data.localOAuth2)
            throw Ifm.Diagnostics.Errors.notsup("OAuth2");
          const cfg = authConfig ? {
              authorityUrl: authConfig.authorityurl, authorityIsAdfs: authConfig.isadfs, clientId: authConfig.clientid, scopes: authConfig.scopes
            } : _config;
          if (!('usePopup' in cfg)) {
            cfg.usePopup = (Ifm.Photon && Ifm.Photon.app.isHosted) || false
          }
          Ifm.Iam.OAuth2.getToken(cfg, username || self.agent.username).then(function(authInfo) {
            if (callback && authInfo.token) {
              callback(authInfo.token)
            }
          }).catch(function(error) {
            self.log("PhoneBar", "Error", error && (error.message || error.errorMessage) || error);
            callback(null)
          })
        }, loginWithToken: function(token, extension, username, callback) {
          if (arguments.length < 2 || arguments.length > 4)
            throw Ifm.Diagnostics.Errors.argsno("2 (+2)");
          onTokenUpdated(token, username);
          self.login("\t", "\t", token, extension, callback)
        }, updateToken: function(token, username) {
          if (arguments.length > 2)
            throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
          onTokenUpdated(token, username)
        }, logout: function(callback) {
          if (arguments.length > 1)
            throw Ifm.Diagnostics.Errors.argsno("0 (+1)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          callback && callbacks.logout.push(callback);
          self.log("PhoneBar", "Debug", "Sending LogoutRequest message");
          connection.send(new PhoneBar.Messages.LogoutRequest)
        }, pause: function(reasonId, callback) {
          if (arguments.length > 2)
            throw Ifm.Diagnostics.Errors.argsno("0 (+2)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          callback && callbacks.pause.push(callback);
          self.log("PhoneBar", "Debug", "Sending PauseRequest message");
          connection.send(new PhoneBar.Messages.PauseRequest(reasonId))
        }, ready: function(callId, callback) {
          if (arguments.length > 2)
            throw Ifm.Diagnostics.Errors.argsno("0 (+2)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          callback && callbacks.ready.push(callback);
          self.log("PhoneBar", "Debug", "Sending ReadyRequest message", callId ? "for call " + callId : "");
          connection.send(new PhoneBar.Messages.ReadyRequest(callId))
        }, makeCall: function(phoneNumber, campaignName, callingNumber, callback) {
          if (arguments.length < 2 || arguments.length > 4)
            throw Ifm.Diagnostics.Errors.argsno("2 (+1)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (newCallRequest)
            throw Ifm.Diagnostics.Errors.op("a previous request is pending");
          callback && callbacks.make.push(callback);
          let hiddenFlag = false;
          if (Ifm.Type.isString(phoneNumber)) {
            const parts = phoneNumber.split(';');
            if (parts.length > 1) {
              const flags = parts[1].split(',').filter(function(f) {
                  hiddenFlag |= f === 'H' || f === 'h';
                  return !hiddenFlag
                });
              phoneNumber = parts[0];
              if (flags.length > 0) {
                phoneNumber += ';' + flags.join(',')
              }
            }
          }
          newCallRequest = {
            mediatype: Ifm.PhoneBar.Mediatypes.Voice, campaignName: campaignName, externalParty: phoneNumber, hideNumber: hiddenFlag, displayNumber: hiddenFlag ? "*****" : phoneNumber
          };
          self.log("PhoneBar", "Debug", "Sending NewCallRequest message");
          connection.send(new PhoneBar.Messages.NewCallRequest(phoneNumber, campaignName, callingNumber || ""))
        }, abortCall: function(callback) {
          if (arguments.length > 1)
            throw Ifm.Diagnostics.Errors.argsno("0 (+1)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (newCallRequest) {
            callback && callbacks.abort.push(callback);
            self.log("PhoneBar", "Debug", "Sending AbortCallRequest messagefor call", newCallRequest.callId);
            connection.send(new PhoneBar.Messages.AbortCallRequest(newCallRequest.callId))
          }
          else {
            callback && callback({
              callId: 0, campaign: '', accepted: 0
            })
          }
        }, transferCall: function(callId, campaignName, agentFirstName, agentLastName, mandatory, mode, callback) {
          if (arguments.length < 2 || arguments.length > 7)
            throw Ifm.Diagnostics.Errors.argsno("2 (+5)");
          if (callback && !Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (activeCalls[callId] && activeCalls[callId].mediatype > PhoneBar.Mediatypes.Voice) {
            mode = 0
          }
          else {
            if (mode !== 0 && mode !== 2)
              mode = PhoneBar.TransferCallModes.Default
          }
          callback && callbacks.transfer.push(callback);
          events.transferinitiated.raise(self, {
            callId, campaignName
          });
          var callDataStr = activeCalls[callId] && activeCalls[callId].callData.toString();
          self.log("PhoneBar", "Debug", "Sending TransferCallRequest message for call", callId);
          connection.send(new PhoneBar.Messages.TransferCallRequest(callId, mode, campaignName, callDataStr, agentFirstName, agentLastName, mandatory))
        }, getAgentList: function(campaignName, mask, callback) {
          if (arguments.length !== 3)
            throw Ifm.Diagnostics.Errors.argsno("3");
          if (!Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (self.isLoggedIn()) {
            callbacks.getAgentList.push({
              campaignName: campaignName, mask: mask, callback: callback
            });
            if (callbacks.getAgentList.length === 1) {
              sendNextAgentListRequest()
            }
          }
        }, getTransferAgentList: function(campaignName, callback) {
          var mask = 1022;
          if (self.options.hidePausedAgents()) {
            mask = 990
          }
          return self.getAgentList(campaignName, mask, callback)
        }, getCampaignList: function(callId, mediatype, mask, callback) {
          if (arguments.length !== 4)
            throw Ifm.Diagnostics.Errors.argsno("4");
          if (!Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (self.isLoggedIn()) {
            callbacks.getCampaignList.push({
              callId: callId, mediatype: mediatype, mask: mask, callback: callback
            });
            if (callbacks.getCampaignList.length === 1) {
              sendNextCampaignListRequest()
            }
          }
        }, getAssignedCampaignList: function(callback) {
          const cp = Ifm.PhoneBar.CampaignInfoFlags;
          var mask = cp.AnyBoundness | cp.AnyStatus | cp.Assigned;
          return self.getCampaignList(0, 0, mask, callback)
        }, getOutboundCampaignList: function(callback) {
          const cp = Ifm.PhoneBar.CampaignInfoFlags;
          const mask = cp.Outbound | cp.Active | cp.Assigned;
          return self.getCampaignList(0, 0, mask, callback)
        }, getTransferCampaignList: function(callId, callback) {
          const cp = Ifm.PhoneBar.CampaignInfoFlags;
          const mask = cp.AnyBoundness | cp.Active | cp.AnyAssignment | cp.HideTransferNotAllowed;
          var mediatype = (callId && self.calls(callId)) ? self.calls(callId).mediatype : 0;
          return self.getCampaignList(callId, mediatype, mask, callback)
        }, getPauseReasons: function(callback) {
          if (arguments.length !== 1)
            throw Ifm.Diagnostics.Errors.argsno("1");
          if (!Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (self.isLoggedIn()) {
            callbacks.getPauseReasons.push(callback);
            if (callbacks.getPauseReasons.length === 1) {
              sendNextPauseReasonListRequest()
            }
          }
        }, getQueueInfo: function(campaignName, callback) {
          if (arguments.length !== 2)
            throw Ifm.Diagnostics.Errors.argsno("2");
          if (!Ifm.Type.isFunction(callback))
            throw Ifm.Diagnostics.Errors.func("callback");
          if (self.isLoggedIn()) {
            callbacks.getQueueInfo.push({
              campaignName: campaignName, callback: callback
            });
            if (callbacks.getQueueInfo.length === 1) {
              sendNextQueueInfoRequest()
            }
          }
        }, panic: function() {
          if (arguments.length !== 0)
            throw Ifm.Diagnostics.Errors.argsno("0");
          self.log("PhoneBar", "Debug", "Sending AgentPanicEvent message");
          connection.send(new PhoneBar.Messages.AgentPanicEvent)
        }, log: function(context, severity, message) {
          if (arguments.length < 3)
            throw Ifm.Diagnostics.Errors.argsno("3+");
          var line = "",
            now = new Date,
            timestamp = now.toLocaleTimeString() + "." + ("000" + now.getMilliseconds()).slice(-3);
          var method = severity.toLowerCase();
          if (isExtension && method !== "debug")
            method = "log";
          if (context)
            line += "[" + context + "] ";
          if (severity)
            line += "[" + severity + "] ";
          line += Array.prototype.splice.call(arguments, 2).join(" ");
          try {
            console[method](line)
          }
          catch(err) {
            console.log(line)
          }
          var views = jQuery(el.LogText);
          if (views.length) {
            line = line.replace(/\</g, "&lt;").replace(/\>/g, "&gt;");
            jQuery(el.LogText).append("<div class='phonebar-log-text-" + severity.toLowerCase() + "'>" + "<span class='phonebar-log-text-timestamp'>" + timestamp + " </span>" + "<span class='phonebar-log-text-line'>" + line + "</span>" + "</div>").parent().scrollTop(jQuery(el.LogText).height())
          }
        }, startRecording: function(callId, fileName, settings) {
          if (arguments.length < 1 || arguments.length > 3)
            throw Ifm.Diagnostics.Errors.argsno("1 (+2)");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
          if (!Ifm.Type.isString(fileName)) {
            fileName = _config.recordingsPath || "C:\\Recordings\\";
            if (!fileName.endsWith('\\'))
              fileName += '\\';
            var partNumber = self.calls(callId).lastRecordingPart = (self.calls(callId).lastRecordingPart || 0) + 1;
            var part = partNumber > 1 ? " (" + partNumber + ")" : '';
            fileName += (new Date).toISOLocaleDateString() + ' ' + callId + ' ' + self.agent.getName() + part + ".wav"
          }
          jQuery(el.StartRecordingButton).disable();
          self.calls(callId).isRecording = true;
          self.log("PhoneBar", "Debug", "Sending StartAudioRecordingRequest message for call", callId);
          connection.send(new PhoneBar.Messages.StartAudioRecordingRequest(callId, fileName, settings || 0))
        }, stopRecording: function(callId) {
          if (arguments.length !== 1)
            throw Ifm.Diagnostics.Errors.argsno("1");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
          jQuery(el.StopRecordingButton).disable();
          self.log("PhoneBar", "Debug", "Sending StopAudioRecordingRequest message for call", callId);
          connection.send(new PhoneBar.Messages.StopAudioRecordingRequest(callId))
        }, muteRecording: function(callId, muteRxChannel, muteTxChannel, tag) {
          if (arguments.length < 3 || arguments.length > 4)
            throw Ifm.Diagnostics.Errors.argsno("3 (+1)");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
          self.log("PhoneBar", "Debug", "Sending SetAudioRecordingMuteRequest message for call", callId);
          connection.send(new PhoneBar.Messages.SetAudioRecordingMuteRequest(callId, muteTxChannel, muteRxChannel, !!tag, tag || ""))
        }, tagRecording: function(callId, tag) {
          if (arguments.length !== 2)
            throw Ifm.Diagnostics.Errors.argsno("2");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support recording");
          self.log("PhoneBar", "Debug", "Sending AppendCueSheetEntryRequest message for call", callId);
          connection.send(new PhoneBar.Messages.AppendCueSheetEntryRequest(callId, tag || ""))
        }, startStreamingTo: function(callId, grpcUri, settings) {
          if (arguments.length < 1 || arguments.length > 3) {
            throw Ifm.Diagnostics.Errors.argsno("2 (+1)");
          }
          if (!callId || !self.calls(callId)) {
            throw Ifm.Diagnostics.Errors.arg("callId");
          }
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice) {
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support streaming");
          }
          self.log("PhoneBar", "Debug", "Sending StartAudioStreamingToRequest message for call", callId, "- gRPC Uri:", grpcUri, ", settings:", settings);
          const request = new PhoneBar.Messages.StartAudioStreamingToRequest(callId, grpcUri, settings || 0);
          connection.send(request)
        }, swapCall: function(callId) {
          if (arguments.length !== 1)
            throw Ifm.Diagnostics.Errors.argsno("1");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support swap");
          self.log("PhoneBar", "Debug", "Sending ConsultationCallControlRequest message for call", callId);
          connection.send(new PhoneBar.Messages.ConsultationCallControlRequest(callId, 1))
        }, startDTMFMasking: function(callId, numberOfDigits, terminationDigit) {
          if (arguments.length !== 3)
            throw Ifm.Diagnostics.Errors.argsno("3");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support DTMFMasking");
          self.log("PhoneBar", "Debug", "Sending StartDTMFMaskingRequest - callId:", callId, "numberOfDigits:", numberOfDigits, "terminationDigit:", terminationDigit);
          connection.send(new PhoneBar.Messages.StartDTMFMaskingRequest(callId, numberOfDigits, terminationDigit))
        }, stopDTMFMasking: function(callId) {
          if (arguments.length !== 1)
            throw Ifm.Diagnostics.Errors.argsno("1");
          if (!callId || !self.calls(callId))
            throw Ifm.Diagnostics.Errors.arg("callId");
          var mediatype = self.calls(callId).mediatype;
          if (mediatype !== PhoneBar.Mediatypes.Voice)
            throw Ifm.Diagnostics.Errors.op("this call's mediatype does not support DTMFMasking");
          self.log("PhoneBar", "Debug", "Sending StopDTMFMaskingRequest - callId:", callId);
          connection.send(new PhoneBar.Messages.StopDTMFMaskingRequest(callId))
        }, disableButton: function(indexOrSelector, forceDisabled = true) {
          if (arguments.length < 1 || arguments.length > 2)
            throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
          PhoneBar.UI.forceControlDisabled(indexOrSelector, !!forceDisabled)
        }, enableButton: function(indexOrSelector, forceDisabled = false) {
          if (arguments.length < 1 || arguments.length > 2)
            throw Ifm.Diagnostics.Errors.argsno("1 (+1)");
          PhoneBar.UI.forceControlDisabled(indexOrSelector, !!forceDisabled)
        }, canOverrideButton: function(indexOrSelector, owner) {
          if (arguments.length !== 2)
            throw Ifm.Diagnostics.Errors.argsno("2");
          return PhoneBar.UI.canOverrideButton(indexOrSelector, owner)
        }, overrideButton: function(indexOrSelector, owner, override) {
          if (arguments.length !== 3)
            throw Ifm.Diagnostics.Errors.argsno("3");
          return PhoneBar.UI.overrideButton(indexOrSelector, owner, override)
        }, agent: {
          firstName: "", lastName: "", password: "", extension: "", username: "", getName: function() {
              return this.firstName + ' ' + this.lastName
            }, load: function() {
              self.agent.extension = Ifm.Cookies.get(cookies.agent.extension);
              if (self.options.rememberCredentials()) {
                self.agent.firstName = Ifm.Cookies.get(cookies.agent.firstName);
                self.agent.lastName = Ifm.Cookies.get(cookies.agent.lastName);
                self.agent.username = Ifm.Cookies.get(cookies.agent.username);
                self.agent.password = Ifm.Cookies.get(cookies.agent.password)
              }
            }, save: function() {
              Ifm.Cookies.set(cookies.agent.extension, this.extension);
              if (self.options.rememberCredentials()) {
                Ifm.Cookies.set(cookies.agent.firstName, this.firstName);
                Ifm.Cookies.set(cookies.agent.lastName, this.lastName);
                Ifm.Cookies.set(cookies.agent.username, this.username)
              }
              if (self.options.rememberCredentials() === 2) {
                Ifm.Cookies.set(cookies.agent.password, this.password)
              }
            }
        }, callRegistry: (function() {
          const _this = {};
          _this.addManagedCall = function(call) {
            store(call, _managedCalls)
          };
          _this.addFailedCall = function(call) {
            store(call, _failedCalls)
          };
          _this.clear = function() {
            _managedCalls.length = 0;
            _failedCalls.length = 0;
            save()
          };
          _this.getManagedCalls = function() {
            return _managedCalls.slice()
          };
          _this.getFailedCalls = function() {
            return _failedCalls.slice()
          };
          _this.hasCalls = function() {
            return _managedCalls.length + _failedCalls.length > 0
          };
          function load() {
            const callRegistryData = localStorage.getItem('CallRegistry');
            if (callRegistryData) {
              const callRegistry = JSON.parse(callRegistryData);
              _managedCalls.length = 0;
              _managedCalls.push(...callRegistry.managedCalls);
              _failedCalls.length = 0;
              _failedCalls.push(...callRegistry.failedCalls)
            }
          }
          function save() {
            const callRegistry = {
                managedCalls: _managedCalls, failedCalls: _failedCalls
              };
            localStorage.setItem('CallRegistry', JSON.stringify(callRegistry))
          }
          function store(call, list) {
            const callReg = {
                mediatype: call.mediatype, timestamp: call.timestamp, campaignName: call.campaignName, displayNumber: call.displayNumber, displayName: call.displayName
              };
            list.unshift(callReg);
            if (list.length > MaxListCount) {
              list.pop()
            }
            save()
          }
          const MaxListCount = 50;
          const _managedCalls = [];
          const _failedCalls = [];
          load();
          return _this
        })(), config: {}, connection: {
          events: connection.events, isConnected: function() {
              return connection.isConnected()
            }, _getConnection: function() {
              return connection
            }
        }, media: {}, options: (function() {
          var _autoAnswerPhone = 1,
            _autoAnswerRings = 1,
            _callingNumber = "",
            _rememberCredentials = 1,
            _loginOnStart = 1,
            _popupIncomingCalls = 1,
            _hideClockInPause = false,
            _hidePausedAgents = false,
            _confirmNavigation = false,
            _preventBackspace = false,
            _preventHardRefresh = false,
            _preventRefresh = false,
            _preventRightClick = false,
            _autoConnectToXmpp = true,
            _showCampaignNameForVoiceCalls = false,
            _disableManualCall = false;
          var InputControlTypes = /INPUT|SELECT|TEXTAREA/i;
          jQuery(document).on('keydown keyup', function(e) {
            if (e.which === 8 && !e.ctrlKey && !e.shiftKey && !e.altkey && _preventBackspace) {
              var target = e.target;
              if (!InputControlTypes.test(target.tagName) || target.disabled || target.readOnly) {
                return false
              }
            }
            if (e.which === 82 && e.ctrlKey && _preventHardRefresh) {
              return false
            }
            if (e.which === 116) {
              if (!e.ctrlKey && _preventRefresh) {
                return false
              }
              if (e.ctrlKey && _preventHardRefresh) {
                return false
              }
            }
          });
          jQuery(document).on('contextmenu', function(e) {
            if (_preventRightClick && Ifm.PhoneBar.UI.Commands) {
              setTimeout(Ifm.PhoneBar.UI.Commands.showMenu, 0)
            }
            return !_preventRightClick
          });
          jQuery(window).on('beforeunload', function() {
            if (_confirmNavigation && PhoneBar.instance.isLoggedIn()) {
              return strings.UnloadPageConfirm
            }
          });
          return {
              autoAnswerPhone: function(value) {
                if (value === undefined) {
                  return _autoAnswerPhone
                }
                if (value >= 0 && value <= 3) {
                  _autoAnswerPhone = value
                }
              }, autoAnswerRings: function(value) {
                  if (value === undefined) {
                    return _autoAnswerRings
                  }
                  _autoAnswerRings = value
                }, autoConnectToXmpp: function(value) {
                  if (value === undefined) {
                    return _autoConnectToXmpp
                  }
                  _autoConnectToXmpp = value
                }, hideClockInPause: function(value) {
                  if (value === undefined) {
                    return _hideClockInPause
                  }
                  _hideClockInPause = !!value
                }, hidePausedAgents: function(value) {
                  if (value === undefined) {
                    return _hidePausedAgents
                  }
                  _hidePausedAgents = !!value
                }, callingNumber: function(value) {
                  if (value === undefined) {
                    return _callingNumber
                  }
                  _callingNumber = value
                }, rememberCredentials: function(value) {
                  if (value === undefined) {
                    return _rememberCredentials
                  }
                  if (value === 0 || value === 1 || value === 2) {
                    _rememberCredentials = value
                  }
                  if (value < 2) {
                    this.forgetPassword()
                  }
                  if (value < 1) {
                    Ifm.Cookies.delete(cookies.agent.firstName);
                    Ifm.Cookies.delete(cookies.agent.lastName);
                    Ifm.Cookies.delete(cookies.agent.username)
                  }
                }, loginOnStart: function(value) {
                  if (value === undefined) {
                    return _loginOnStart
                  }
                  if (value === 0 || value === 1 || value === 2) {
                    _loginOnStart = value
                  }
                }, popupIncomingCalls: function(value) {
                  if (value === undefined) {
                    return _popupIncomingCalls
                  }
                  if (Ifm.Type.isNumber(value)) {
                    _popupIncomingCalls = value
                  }
                }, confirmNavigation: function(value) {
                  if (value === undefined) {
                    return _confirmNavigation
                  }
                  _confirmNavigation = !!value
                }, preventBackspace: function(value) {
                  if (value === undefined) {
                    return _preventBackspace
                  }
                  _preventBackspace = !!value
                }, preventHardRefresh: function(value) {
                  if (value === undefined) {
                    return _preventHardRefresh
                  }
                  _preventHardRefresh = !!value
                }, preventRefresh: function(value) {
                  if (value === undefined) {
                    return _preventRefresh
                  }
                  _preventRefresh = !!value
                }, preventRightClick: function(value) {
                  if (value === undefined) {
                    return _preventRightClick
                  }
                  _preventRightClick = !!value
                }, showCampaignNameForVoiceCalls: function(value) {
                  if (value === undefined) {
                    return _showCampaignNameForVoiceCalls
                  }
                  _showCampaignNameForVoiceCalls = !!value
                }, disableManualCall: function(value) {
                  if (value === undefined) {
                    return _disableManualCall
                  }
                  _disableManualCall = !!value
                }, forgetPassword: function() {
                  Ifm.Cookies.delete(cookies.agent.password);
                  PhoneBar.instance.agent.password = ""
                }
            }
        })()
    };
    return instance
  })(Ifm.PhoneBar)
})(Ifm.PhoneBar);
namespace("Ifm.PhoneBar.UI");
(function(UI) {
  UI.events = defineEvents("overridablebuttonclick");
  UI.Elements = {
    MainToolbar: ".phonebar-toolbar", PhoneToolbar: ".phonebar-phone-toolbar", PhoneDialPad: ".phonebar-phone-dialpad", LogText: ".phonebar-log-text", StateText: ".phonebar-state-text", StateTimeText: ".phonebar-state-time-text", PhoneStateText: ".phonebar-phone-state-text", RecordingStateText: ".phonebar-recording-state-text", NumberLabel: ".phonebar-number-label", NumberInput: ".phonebar-number-input", LoginButton: ".phonebar-login-button", LoginOrReadyButton: ".phonebar-login-ready-button", ReadyButton: ".phonebar-ready-button", PauseButton: ".phonebar-pause-button", LogoutButton: ".phonebar-logout-button", CallButton: ".phonebar-call-button", AbortCallButton: ".phonebar-abort-call-button", TransferButton: ".phonebar-transfer-button", CampaignListButton: ".phonebar-campaignlist-button", CallRegistryButton: ".phonebar-callregistry-button", QueueInfoButton: ".phonebar-queueinfo-button", PanicButton: ".phonebar-panic-button", StartRecordingButton: ".phonebar-start-recording-button", StopRecordingButton: ".phonebar-stop-recording-button", MuteRecordingButton: ".phonebar-mute-recording-button", UnmuteRecordingButton: ".phonebar-unmute-recording-button", MainMenuButton: ".phonebar-mainmenu-button", HangupButton: ".phonebar-phone-hangup-button", PickupButton: ".phonebar-phone-pickup-button", FlashButton: ".phonebar-phone-flash-button", ManualTransferButton: ".phonebar-phone-manual-transfer-button", Line1Button: ".phonebar-phone-line1-button", Line2Button: ".phonebar-phone-line2-button", EnterConferenceButton: ".phonebar-phone-enter-conference-button", LeaveConferenceButton: ".phonebar-phone-leave-conference-button", MicrophoneVULabel: ".phonebar-phone-microphone-label", MicrophoneVUMeter: ".phonebar-phone-microphone-meter", SpeakersVULabel: ".phonebar-phone-speakers-label", SpeakersVUMeter: ".phonebar-phone-speakers-meter", MicrophoneOffButton: ".phonebar-phone-microphone-off-button", MicrophoneOnButton: ".phonebar-phone-microphone-on-button", HideDialPadButton: ".phonebar-phone-dialpad-hide-button", ShowDialPadButton: ".phonebar-phone-dialpad-show-button", ToggleDialPadButton: ".phonebar-phone-dialpad-toggle-button", DialPadDigit0Button: ".phonebar-phone-key-digit0", DialPadDigit1Button: ".phonebar-phone-key-digit1", DialPadDigit2Button: ".phonebar-phone-key-digit2", DialPadDigit3Button: ".phonebar-phone-key-digit3", DialPadDigit4Button: ".phonebar-phone-key-digit4", DialPadDigit5Button: ".phonebar-phone-key-digit5", DialPadDigit6Button: ".phonebar-phone-key-digit6", DialPadDigit7Button: ".phonebar-phone-key-digit7", DialPadDigit8Button: ".phonebar-phone-key-digit8", DialPadDigit9Button: ".phonebar-phone-key-digit9", DialPadHashButton: ".phonebar-phone-key-hash", DialPadStarButton: ".phonebar-phone-key-star", TransferCampaignList: ".phonebar-transfer-campaign-list", TransferAgentList: ".phonebar-transfer-agent-list", TransferMandatoryCheck: ".phonebar-transfer-mandatory-check"
  };
  UI.ControlIndex = {
    Login: 1, Pause: 2, Logout: 3, Call: 4, Transfer: 5, Assignment: 6, FlashDial: 7, Hookstate: 8, Flash: 9, Retake: 10, Mute: 11, Line1: 12, Line2: 13, Conference: 14, StartRecording: 15, StopRecording: 16, MuteRecording: 17, DialPad: 18, QueueInfo: 19, Panic: 20, ShowRecordingPanel: 21, AddCueSheet: 22, ExpandView: 23
  };
  UI.OverridableButtonIndex = {
    LoginButton: 1, ReadyButton: 2, PauseButton: 3, LogoutButton: 4, CallButton: 5, AbortCallButton: 6, TransferButton: 7, CampaignListButton: 8, QueueInfoButton: 9, PanicButton: 10, StartRecordingButton: 11, StopRecordingButton: 12, MuteRecordingButton: 13, UnmuteRecordingButton: 14, HangupButton: 19, PickupButton: 20, FlashButton: 21, ManualTransferButton: 22, Line1Button: 23, Line2Button: 24, EnterConferenceButton: 25, LeaveConferenceButton: 26, MicrophoneOffButton: 27, MicrophoneOnButton: 28
  };
  UI.controlState = function(indexOrSelector, enable) {
    var selector;
    if (indexOrSelector instanceof jQuery) {
      selector = indexOrSelector
    }
    else if (indexOrSelector instanceof HTMLElement) {
      selector = jQuery(indexOrSelector)
    }
    else {
      const selector = Ifm.Type.isString(indexOrSelector) ? indexOrSelector : getSelectorOfControlIndex(indexOrSelector);
      selector = jQuery(selector)
    }
    if (enable === undefined) {
      return !selector.prop("disabled")
    }
    selector.prop("disabled_state", !enable);
    updateControlState(selector)
  };
  UI.forceControlDisabled = function(indexOrSelector, forcedDisabled) {
    const phonebar = Ifm.PhoneBar.instance;
    const index = Number(indexOrSelector) || getControlIndexOfSelector(indexOrSelector);
    if (index === 0) {
      phonebar.log("PhoneBar.UI", "Warn", "Invalid index or selector:", indexOrSelector);
      return
    }
    if (forcedDisabled === undefined) {
      return index in _forcedControlStates
    }
    if (forcedDisabled) {
      _forcedControlStates[index] = true
    }
    else {
      delete _forcedControlStates[index]
    }
    updateControlState(index)
  };
  UI.canOverrideButton = function(indexOrSelector, owner) {
    const phonebar = Ifm.PhoneBar.instance;
    const buttonId = Number(indexOrSelector) ? getOverridableButtonIndex(indexOrSelector) : getOverridableButtonIndexOfSelector(indexOrSelector);
    if (buttonId === 0) {
      phonebar.log("PhoneBar.UI", "Warn", "Invalid index or selector:", indexOrSelector);
      return false
    }
    if (buttonId in _overriddenButtons) {
      const override = _overriddenButtons[buttonId];
      return override.owner === owner
    }
    return true
  };
  UI.isButtonOverridden = function(indexOrSelector) {
    const phonebar = Ifm.PhoneBar.instance;
    const buttonId = Number(indexOrSelector) ? getOverridableButtonIndex(indexOrSelector) : getOverridableButtonIndexOfSelector(indexOrSelector);
    if (buttonId === 0) {
      phonebar.log("PhoneBar.UI", "Warn", "Invalid index or selector:", indexOrSelector);
      return false
    }
    return buttonId in _overriddenButtons
  };
  UI.overrideButton = function(indexOrSelector, owner, override) {
    const phonebar = Ifm.PhoneBar.instance;
    const buttonId = Number(indexOrSelector) ? getOverridableButtonIndex(indexOrSelector) : getOverridableButtonIndexOfSelector(indexOrSelector);
    if (buttonId === 0) {
      phonebar.log("PhoneBar.UI", "Warn", "Invalid index or selector:", indexOrSelector);
      return false
    }
    if (!UI.canOverrideButton(indexOrSelector, owner)) {
      return false
    }
    if (override) {
      _overriddenButtons[buttonId] = {owner};
      return true
    }
    else {
      return delete _overriddenButtons[buttonId]
    }
  };
  UI.releasedOverriddenButtonsOf = function(owner) {
    for (let buttonId in _overriddenButtons) {
      if (_overriddenButtons[buttonId].owner === owner) {
        delete _overriddenButtons[buttonId]
      }
    }
  };
  UI.doOverridableButtonClick = function(selector, defaultAction, getParams) {
    const phonebar = Ifm.PhoneBar.instance;
    const buttonId = getOverridableButtonIndexOfSelector(selector);
    if (buttonId === 0) {
      phonebar.log("PhoneBar.UI", "Warn", "Invalid index or selector:", selector);
      return
    }
    jQuery(selector).disable();
    if (UI.isButtonOverridden(buttonId)) {
      const buttonName = Ifm.Enum.getName(UI.OverridableButtonIndex, buttonId);
      const requestId = Math.random().toString(16).substring(2).toUpperCase();
      const owner = _overriddenButtons[buttonId].owner;
      const params = Ifm.Type.isFunction(getParams) ? getParams() : undefined;
      try {
        UI.events.overridablebuttonclick.raise(phonebar, {
          buttonId, owner, requestId, details: params
        })
      }
      catch(err) {
        phonebar.log("PhoneBar.UI", "Warn", "The overriding method for", buttonName, "has thrown an error. Invoking default action...");
        defaultAction();
        jQuery(selector).enable();
        return
      }
      const clickTimeout = setTimeout(function() {
          phonebar.log("PhoneBar.UI", "Warn", "The overriding method for", buttonName, "did not complete in a timely fashion. Invoking default action...");
          defaultAction();
          jQuery(selector).enable();
          delete _overridableButtonClickRequests[requestId]
        }, OVERRIDABLE_BUTTON_WAIT_TIMEOUT);
      _overridableButtonClickRequests[requestId] = {
        clickTimeout, defaultAction, selector
      }
    }
    else {
      defaultAction();
      jQuery(selector).enable()
    }
  };
  UI.onOverridableButtonClickReply = function(buttonId, requestId, managed) {
    const phonebar = Ifm.PhoneBar.instance;
    buttonId = getOverridableButtonIndex(buttonId);
    if (buttonId === 0) {
      phonebar.log("PhoneBar.UI", "Warn", "Invalid index or selector:", buttonId);
      return
    }
    const buttonName = Ifm.Enum.getName(UI.OverridableButtonIndex, buttonId);
    const clickRequest = _overridableButtonClickRequests[requestId];
    if (!clickRequest) {
      phonebar.log("PhoneBar.UI", "Warn", "Unexpected click reply for", buttonName);
      return
    }
    clearTimeout(clickRequest.clickTimeout);
    if (!managed) {
      clickRequest.defaultAction()
    }
    jQuery(clickRequest.selector).enable();
    delete _overridableButtonClickRequests[requestId]
  };
  function getClassNamesOfSelector(selector) {
    const phonebar = Ifm.PhoneBar.instance;
    let classNames = [];
    if (selector instanceof jQuery) {
      if (selector.length != 1) {
        phonebar.log("PhoneBar.UI", "Warn", "Multiple selectors are not supported")
      }
      else {
        classNames = selector[0].classList
      }
    }
    else if (selector instanceof HTMLElement) {
      classNames = selector.classList
    }
    else if (Ifm.Type.isString(selector)) {
      if (selector.indexOf(',') > -1) {
        phonebar.log("PhoneBar.UI", "Warn", "Multiple selectors are not supported")
      }
      else {
        classNames = [selector]
      }
    }
    return classNames
  }
  function getControlIndexOfSelector(selector) {
    const classNames = getClassNamesOfSelector(selector);
    for (const className of classNames) {
      const classSelector = className.startsWith('.') ? className : '.' + className;
      switch (classSelector) {
        case UI.Elements.LoginButton:
        case UI.Elements.LoginOrReadyButton:
        case UI.Elements.ReadyButton:
          return UI.ControlIndex.Login;
        case UI.Elements.PauseButton:
          return UI.ControlIndex.Pause;
        case UI.Elements.LogoutButton:
          return UI.ControlIndex.Logout;
        case UI.Elements.AbortCallButton:
        case UI.Elements.CallButton:
          return UI.ControlIndex.Call;
        case UI.Elements.TransferButton:
          return UI.ControlIndex.Transfer;
        case UI.Elements.CampaignListButton:
          return UI.ControlIndex.Assignment;
        case UI.Elements.ManualTransferButton:
          return UI.ControlIndex.FlashDial;
        case UI.Elements.HangupButton:
        case UI.Elements.PickupButton:
          return UI.ControlIndex.Hookstate;
        case UI.Elements.FlashButton:
          return UI.ControlIndex.Flash;
        case UI.Elements.MicrophoneOffButton:
        case UI.Elements.MicrophoneOnButton:
          return UI.ControlIndex.Mute;
        case UI.Elements.Line1Button:
          return UI.ControlIndex.Line1;
        case UI.Elements.Line2Button:
          return UI.ControlIndex.Line2;
        case UI.Elements.EnterConferenceButton:
        case UI.Elements.LeaveConferenceButton:
          return UI.ControlIndex.Conference;
        case UI.Elements.StartRecordingButton:
          return UI.ControlIndex.StartRecording;
        case UI.Elements.StopRecordingButton:
          return UI.ControlIndex.StopRecording;
        case UI.Elements.MuteRecordingButton:
        case UI.Elements.UnmuteRecordingButton:
          return UI.ControlIndex.MuteRecording;
        case UI.Elements.HideDialPadButton:
        case UI.Elements.ShowDialPadButton:
        case UI.Elements.ToggleDialPadButton:
          return UI.ControlIndex.DialPad;
        case UI.Elements.QueueInfoButton:
          return UI.ControlIndex.QueueInfo;
        case UI.Elements.PanicButton:
          return UI.ControlIndex.Panic
      }
    }
    return 0
  }
  function getOverridableButtonIndex(index) {
    return Ifm.Enum.getName(UI.OverridableButtonIndex, index) ? index : 0
  }
  function getOverridableButtonIndexOfSelector(selector) {
    const classNames = getClassNamesOfSelector(selector);
    for (const className of classNames) {
      const classSelector = className.startsWith('.') ? className : '.' + className;
      const classSelectorName = Ifm.Enum.getName(UI.Elements, classSelector);
      if (classSelectorName && classSelectorName in UI.OverridableButtonIndex) {
        return UI.OverridableButtonIndex[classSelectorName]
      }
    }
    return 0
  }
  function getSelectorOfControlIndex(index) {
    switch (index) {
      case UI.ControlIndex.Login:
        return [UI.Elements.LoginButton, UI.Elements.LoginOrReadyButton, UI.Elements.ReadyButton].join(', ');
      case UI.ControlIndex.Pause:
        return UI.Elements.PauseButton;
      case UI.ControlIndex.Logout:
        return UI.Elements.LogoutButton;
      case UI.ControlIndex.Call:
        return [UI.Elements.AbortCallButton, UI.Elements.CallButton].join(', ');
      case UI.ControlIndex.Transfer:
        return UI.Elements.TransferButton;
      case UI.ControlIndex.Assignment:
        return UI.Elements.CampaignListButton;
      case UI.ControlIndex.FlashDial:
        return UI.Elements.ManualTransferButton;
      case UI.ControlIndex.Hookstate:
        return [UI.Elements.HangupButton, UI.Elements.PickupButton].join(', ');
      case UI.ControlIndex.Flash:
        return UI.Elements.FlashButton;
      case UI.ControlIndex.Mute:
        return [UI.Elements.MicrophoneOffButton, UI.Elements.MicrophoneOnButton].join(', ');
      case UI.ControlIndex.Line1:
        return UI.Elements.Line1Button;
      case UI.ControlIndex.Line2:
        return UI.Elements.Line2Button;
      case UI.ControlIndex.Conference:
        return [UI.Elements.EnterConferenceButton, UI.Elements.LeaveConferenceButton].join(', ');
      case UI.ControlIndex.StartRecording:
        return UI.Elements.StartRecordingButton;
      case UI.ControlIndex.StopRecording:
        return UI.Elements.StopRecordingButton;
      case UI.ControlIndex.MuteRecording:
        return [UI.Elements.MuteRecordingButton, UI.Elements.UnmuteRecordingButton].join(', ');
      case UI.ControlIndex.DialPad:
        return [UI.Elements.HideDialPadButton, UI.Elements.ShowDialPadButton, UI.Elements.ToggleDialPadButton].join(', ');
      case UI.ControlIndex.QueueInfo:
        return UI.Elements.QueueInfoButton;
      case UI.ControlIndex.Panic:
        return UI.Elements.PanicButton;
      default:
        return ''
    }
  }
  function updateControlState(indexOrSelector) {
    const index = Number(indexOrSelector) || getControlIndexOfSelector(indexOrSelector);
    const selector = Number(indexOrSelector) ? jQuery(getSelectorOfControlIndex(indexOrSelector)) : indexOrSelector;
    const forcedDisabled = index in _forcedControlStates;
    selector.each(function() {
      const disabledState = !!$(this).prop("disabled_state");
      $(this).prop("disabled", disabledState || forcedDisabled)
    })
  }
  ;
  const OVERRIDABLE_BUTTON_WAIT_TIMEOUT = 10000;
  const _forcedControlStates = {};
  const _overriddenButtons = {};
  const _overridableButtonClickRequests = {}
})(Ifm.PhoneBar.UI);
namespace("Ifm.PhoneBar.Media");
namespace("Ifm.PhoneBar.Media.Phone");
namespace("Ifm.PhoneBar.Media.Phone.events");
namespace("Ifm.PhoneBar.Media.Xmpp");
namespace("Ifm.PhoneBar.Media.Xmpp.events");
;
namespace("Ifm.PhoneBar.Messages");
(function() {
  this.PhonesToPhoneBarMessages = {
    AssignmentRequest: 0x3004, KeepAliveRequest: 0x30FF, LoginReply: 0x5000, LogoutReply: 0x5001, ReadyReply: 0x5002, PauseReply: 0x5003, NewCallReply: 0x5005, TransferCallReply: 0x5006, CampaignListReply: 0x5007, AgentListReply: 0x5008, CampaignQueueInfoReply: 0x5009, SetCampaignStatusReply: 0x500A, AbortCallReply: 0x500E, RetrieveCallReply: 0x500F, ReadyEvent: 0x9002, PauseEvent: 0x9003, AlertingEvent: 0x9800, AnsweredEvent: 0x9801, TerminatedEvent: 0x9802, CallFailureEvent: 0x9803, OtherCallEvent: 0x9804, PostCallWorkEvent: 0x9805, SupervisorMessageEvent: 0x9807, ReadyForTransferEvent: 0x9808, ReadyForDetachEvent: 0x9809, BookedEvent: 0x980C, AudioRecordingStartedEvent: 0x9815, AudioRecordingMutedEvent: 0x9816, AudioRecordingCompletedEvent: 0x9817, MaskedDigitReceivedEvent: 0x9818, MaskedPayloadReceivedEvent: 0x9819
  };
  this.AssignmentRequest = function(message) {
    this.callId = message.nextInt32();
    this.rejectable = message.nextByte();
    this.campaignName = message.nextString();
    this.scriptName = message.nextString();
    this.scriptParameters = message.nextString();
    this.callDataStr = message.nextString();
    this.dummy = message.nextByte();
    this.cfgVersion = message.nextString();
    this.serviceId = message.nextString();
    this.campaignId = message.nextString();
    this.recordingState = message.remainingBytes() >= 1 ? message.nextByte() : 0;
    this.recordingFileName = message.remainingBytes() >= 2 ? message.nextString() : '';
    this.recordingSettings = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.mediatype = message.remainingBytes() >= 4 ? message.nextInt32() : 0
  };
  this.KeepAliveRequest = function(message){};
  this.LoginReply = function(message) {
    this.accepted = message.nextByte();
    if (message.remainingBytes()) {
      this.agentId = message.nextString();
      message.nextString();
      this.failureCause = message.nextByte();
      this.extension = message.remainingBytes() >= 2 ? message.nextString() : null
    }
    if (message.remainingBytes()) {
      this.firstName = message.nextString();
      this.lastName = message.nextString();
      this.username = message.nextString()
    }
  };
  this.LogoutReply = function(message) {
    this.accepted = message.nextByte()
  };
  this.ReadyReply = function(message) {
    this.accepted = message.nextByte();
    this.callId = message.remainingBytes() >= 4 ? message.nextInt32() : null
  };
  this.PauseReply = function(message) {
    this.accepted = message.nextByte();
    if (this.accepted < 3 && message.remainingBytes()) {
      this.reasonId = message.nextInt32();
      this.reasonText = message.nextString()
    }
    else if (this.accepted === 3) {
      var number = message.nextInt32();
      this.reasons = [];
      for (var i = 0; i < number; i++) {
        var id = message.nextInt32();
        var text = message.nextString();
        this.reasons.push({
          id: id, text: text
        })
      }
    }
  };
  this.NewCallReply = function(message) {
    this.callId = message.nextInt32();
    this.accepted = message.nextByte()
  };
  this.TransferCallReply = function(message) {
    this.callId = message.nextInt32();
    this.accepted = message.nextByte()
  };
  this.CampaignListReply = function(message) {
    function unpack(c) {
      c.name = c.serviceName + '/' + c.campaignName;
      c.active = !!(mask & 0x2);
      c.status = mask & (0x1 | 0x2 | 0x4);
      c.boundness = mask & 0x8 ? "Inbound" : "Outbound";
      c.assigned = !!(mask & 0x40);
      c.transfer = !!(mask & 0x100);
      return c
    }
    var number = message.nextInt16();
    this.campaigns = [];
    for (var i = 0; i < number; i++) {
      var name = message.nextString();
      var mask = message.nextInt32() & 0x8000001F;
      if (mask & 0x80000000) {
        var names = name.split('\t');
        for (var j = 1; j < names.length; j++) {
          name = names[j].slice(0, -1);
          var m = names[j].slice(-1).charCodeAt(0) * 2;
          this.campaigns.push(unpack({
            campaignName: name, serviceName: names[0], flags: m + (mask & ~0x80000000)
          }))
        }
      }
      else {
        this.campaigns.push(unpack({
          campaignName: name.split("/")[1], serviceName: name.split("/")[0], flags: mask
        }))
      }
    }
    this.campaigns.sort(function compare(a, b) {
      var aName = a.name.toUpperCase(),
        bName = b.name.toUpperCase();
      if (aName < bName)
        return -1;
      if (aName > bName)
        return +1;
      return 0
    })
  };
  this.AgentListReply = function(message) {
    var number = message.nextInt16();
    this.agents = [];
    for (var i = 0; i < number; i++) {
      var first = message.nextString(),
        last = message.nextString();
      this.agents.push({
        firstName: first, lastName: last, name: first + ' ' + last, campaignName: message.nextString(), state: message.remainingBytes() >= 4 ? message.nextInt32() : 0, time: message.remainingBytes() >= 4 ? message.nextInt32() : 0
      })
    }
    this.agents.sort(function compare(a, b) {
      var aLF = (a.lastName + ' ' + a.firstName).toUpperCase(),
        bLF = (b.lastName + ' ' + b.firstName).toUpperCase();
      if (aLF < bLF)
        return -1;
      if (aLF > bLF)
        return +1;
      return 0
    })
  };
  this.CampaignQueueInfoReply = function(message) {
    var number = message.nextInt16();
    this.calls = 0;
    this.avgTime = 0;
    this.maxTime = 0;
    this.campaigns = [];
    for (var i = 0; i < number; i++) {
      var name = message.nextString(),
        calls = message.nextInt32(),
        maxTime = message.nextInt32(),
        avgTime = message.nextInt32();
      this.campaigns.push({
        name: name, calls: calls, avgTime: avgTime, maxTime: maxTime
      });
      if (this.calls + calls > 0) {
        this.avgTime = (this.avgTime * this.calls + avgTime * calls) / (this.calls + calls)
      }
      if (maxTime > this.maxTime) {
        this.maxTime = maxTime
      }
      this.calls += calls
    }
  };
  this.SetCampaignStatusReply = function(message){};
  this.AbortCallReply = function(message) {
    this.callId = message.nextInt32();
    this.accepted = message.nextByte()
  };
  this.RetrieveCallReply = function(message){};
  this.ReadyEvent = function(message){};
  this.PauseEvent = function(message) {
    if (message.remainingBytes()) {
      this.reasonId = message.nextInt32();
      this.reasonText = message.nextString()
    }
    else {
      this.reasonId = 0;
      this.reasonText = ''
    }
  };
  this.AlertingEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.AnsweredEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.TerminatedEvent = function(message) {
    this.callId = message.nextInt32();
    this.postCallWork = message.nextByte()
  };
  this.CallFailureEvent = function(message) {
    this.callId = message.nextInt32();
    this.cause = message.nextByte();
    this.protocolTerminationCause = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.protocolTerminationDescription = message.remainingBytes() >= 2 ? message.nextString() : "";
    this.detectedContentCode = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.detectedContentDescription = message.remainingBytes() >= 2 ? message.nextString() : ""
  };
  this.OtherCallEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.PostCallWorkEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.SupervisorMessageEvent = function(message) {
    this.severity = message.nextInt16();
    this.message = message.nextString()
  };
  this.ReadyForTransferEvent = function(message) {
    this.callId = message.nextInt32();
    this.campaignName = message.nextString();
    this.agentFirstName = message.nextString();
    this.agentLastName = message.nextString()
  };
  this.ReadyForDetachEvent = function(message) {
    this.callId = message.nextInt32();
    this.callTerminated = message.remainingBytes() >= 1 ? (message.nextByte() !== 0 ? true : false) : undefined;
    this.protocolTerminationCause = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.protocolTerminationDescription = message.remainingBytes() >= 2 ? message.nextString() : "";
    this.detectedContentCode = message.remainingBytes() >= 4 ? message.nextInt32() : 0;
    this.detectedContentDescription = message.remainingBytes() >= 2 ? message.nextString() : ""
  };
  this.BookedEvent = function(message) {
    this.campaignName = message.nextString();
    this.mediatype = message.remainingBytes() >= 4 ? message.nextInt32() : 0
  };
  this.AudioRecordingStartedEvent = function(message) {
    this.callId = message.nextInt32();
    this.fileName = message.nextString()
  };
  this.AudioRecordingMutedEvent = function(message) {
    this.callId = message.nextInt32();
    this.txChannelMuted = message.nextByte() !== 0 ? true : false;
    this.rxChannelMuted = message.nextByte() !== 0 ? true : false
  };
  this.AudioRecordingCompletedEvent = function(message) {
    this.callId = message.nextInt32();
    this.result = message.nextInt32()
  };
  this.MaskedDigitReceivedEvent = function(message) {
    this.callId = message.nextInt32()
  };
  this.MaskedPayloadReceivedEvent = function(message) {
    this.callId = message.nextInt32();
    this.payload = message.nextString();
    this.result = message.nextInt32()
  };
  this.PhoneBarToPhonesMessages = {
    LoginRequest: 0x2000, LogoutRequest: 0x2001, ReadyRequest: 0x2002, PauseRequest: 0x2003, NewCallRequest: 0x2005, TransferCallRequest: 0x2006, CampaignListRequest: 0x2007, AgentListRequest: 0x2008, CampaignQueueInfoRequest: 0x2009, SetCampaignStatusRequest: 0x200A, LoginExRequest: 0x200C, AbortCallRequest: 0x200E, RetrieveCallRequest: 0x200F, AssignmentReply: 0x4004, KeepAliveReply: 0x40FF, AgentPanicEvent: 0x800B, SetAgentScriptStateEvent: 0x880A, SetCallResultEvent: 0x880B, AgentNewCallEvent: 0x880D, RemoteOffHookEvent: 0x880E, RemoteOnHookEvent: 0x880F, RemoteRingingEvent: 0x8810, RemoteManualHangUpEvent: 0x8813, DelcoTunnelMessageEvent: 0x8814
  };
  this.DelcoTunnelMessages = {
    ConsultationCallControlRequest: 0x2402, StartAudioRecordingRequest: 0x2403, StopAudioRecordingRequest: 0x2404, SetAudioRecordingMuteRequest: 0x2405, AppendCueSheetEntryRequest: 0x2406, StartDTMFMaskingRequest: 0x2407, StopDTMFMaskingRequest: 0x2408, StartAudioStreamingToRequest: 0x2409
  };
  this.LoginRequest = function(firstName, lastName, password, extension, flags) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.LoginRequest);
    message.addString(firstName).addString(lastName).addString(password).addString(extension).addByte(flags || 0).end();
    return message
  };
  this.LogoutRequest = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.LogoutRequest);
    message.end();
    return message
  };
  this.ReadyRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.ReadyRequest);
    message.addInt32(callId !== undefined ? callId : -1).end();
    return message
  };
  this.PauseRequest = function(reasonId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.PauseRequest);
    if (reasonId) {
      message.addByte(1).addInt32(reasonId)
    }
    message.end();
    return message
  };
  this.PauseReasonsRequest = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.PauseRequest);
    message.addByte(3).addInt32(0).end();
    return message
  };
  this.NewCallRequest = function(phoneNumber, campaignName, callingNumber) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.NewCallRequest);
    message.addString(phoneNumber).addString(campaignName).addString(callingNumber).end();
    return message
  };
  this.TransferCallRequest = function(callId, mode, campaignName, callDataStr, firstName, lastName, mandatory) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.TransferCallRequest);
    message.addInt32(callId).addInt32(mode).addString(campaignName).addString(callDataStr).addString(firstName).addString(lastName).addByte(mandatory ? 1 : 0).end();
    return message
  };
  this.CampaignListRequest = function(mask, callId, mediatype) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.CampaignListRequest);
    message.addInt32(mask | 0x80000000).addInt32(mediatype).addInt32(callId).end();
    return message
  };
  this.AgentListRequest = function(campaignName, mask) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AgentListRequest);
    message.addString(campaignName).addInt32(mask).end();
    return message
  };
  this.CampaignQueueInfoRequest = function(campaignName) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.CampaignQueueInfoRequest);
    message.addString(campaignName).addInt32(campaignName ? 0 : 0x2).end();
    return message
  };
  this.SetCampaignStatusRequest = function(){};
  this.LoginExRequest = function(firstName, lastName, oldPassword, newPassword, extension, flags) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.LoginExRequest);
    message.addString(firstName).addString(lastName).addString(oldPassword).addString(newPassword).addString(extension).addByte(flags || 0).end();
    return message
  };
  this.AbortCallRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AbortCallRequest);
    message.addInt32(callId).end();
    return message
  };
  this.RetrieveCallRequest = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.RetrieveCallRequest);
    message.addInt32(callId).end();
    return message
  };
  this.AssignmentReply = function(callId, accept) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AssignmentReply);
    message.addInt32(callId).addByte(accept).end();
    return message
  };
  this.KeepAliveReply = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.KeepAliveReply);
    message.end();
    return message
  };
  this.AgentPanicEvent = function() {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.AgentPanicEvent);
    message.addByte(1).end();
    return message
  };
  this.SetAgentScriptStateEvent = function(callId, scriptState) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.SetAgentScriptStateEvent);
    message.addInt32(callId).addString((scriptState || 0) + 255).end();
    return message
  };
  this.SetCallResultEvent = function(callId, callDataStr) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.SetCallResultEvent);
    message.addInt32(callId).addString(callDataStr).end();
    return message
  };
  this.AgentNewCallEvent = function(){};
  this.RemoteOffHookEvent = function(){};
  this.RemoteOnHookEvent = function(){};
  this.RemoteRingingEvent = function(){};
  this.RemoteManualHangUpEvent = function(){};
  this.ConsultationCallControlRequest = function(callId, action) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(12).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.ConsultationCallControlRequest).addByte(1).addByte(1).addInt32(4).addInt32(action).end();
    return message
  };
  this.StartAudioRecordingRequest = function(callId, fileName, settings) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(19 + fileName.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StartAudioRecordingRequest).addByte(1).addByte(1).addInt32(2 + fileName.length * 2).addUniString(fileName).addByte(1).addInt32(4).addInt32(settings).end();
    return message
  };
  this.StartAudioStreamingToRequest = function(callId, grpcUri, settings) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(19 + grpcUri.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StartAudioStreamingToRequest).addByte(1).addByte(1).addInt32(2 + grpcUri.length * 2).addUniString(grpcUri).addByte(1).addInt32(4).addInt32(settings).end();
    return message
  };
  this.StopAudioRecordingRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(3).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StopAudioRecordingRequest).addByte(1).end();
    return message
  };
  this.SetAudioRecordingMuteRequest = function(callId, muteTxChannel, muteRxChannel, appendCueSheetEntry, cueSheetEntry) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(37 + cueSheetEntry.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.SetAudioRecordingMuteRequest).addByte(1).addByte(1).addInt32(4).addBool32(muteTxChannel).addByte(1).addInt32(4).addBool32(muteRxChannel).addByte(1).addInt32(4).addBool32(appendCueSheetEntry).addByte(1).addInt32(2 + cueSheetEntry.length * 2).addUniString(cueSheetEntry).end();
    return message
  };
  this.AppendCueSheetEntryRequest = function(callId, cueSheetEntry) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(10 + cueSheetEntry.length * 2).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.AppendCueSheetEntryRequest).addByte(1).addByte(1).addInt32(2 + cueSheetEntry.length * 2).addUniString(cueSheetEntry).end();
    return message
  };
  this.StartDTMFMaskingRequest = function(callId, numberOfDigits, terminationDigit) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(18).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StartDTMFMaskingRequest).addByte(1).addByte(1).addInt32(4).addInt32(numberOfDigits).addByte(1).addInt32(1).addByte(terminationDigit).end();
    return message
  };
  this.StopDTMFMaskingRequest = function(callId) {
    var message = new Ifm.Messaging.FMessageWriter(Ifm.PhoneBar.Messages.PhoneBarToPhonesMessages.DelcoTunnelMessageEvent);
    message.addInt32(callId).addInt32(3).addInt16(Ifm.PhoneBar.Messages.DelcoTunnelMessages.StopDTMFMaskingRequest).addByte(1).end();
    return message
  }
}).call(Ifm.PhoneBar.Messages);
;
(function() {
  var ns = namespace("Ifm.PhoneBar.Media");
  function Phone(phonebar) {
    if (!(this instanceof Phone))
      throw Ifm.Diagnostics.Errors.ctor();
    this.phonebar = phonebar;
    this._isConnected = false;
    this._isMuted = false;
    this._isRegistered = undefined;
    this._lineStates = [];
    for (var i = 0; i < this.numberOfLines; i++) {
      this._lineStates.push(Phone.States.Idle)
    }
    this._selectedLineId = 0;
    this._isInConference = false;
    this._accessToken = ""
  }
  Phone.events = defineEvents("initialized", "connected", "disconnected", "registeredstatechanged", "linestatechanged", "conferencestatechanged", "lineselected", "calling", "callconnected", "calldisconnected", "displayname", "incomingcall", "ringing", "mutechanged", "vumeter");
  Phone.States = {
    Idle: '[Idle]', Incoming: '[Incoming]', Calling: '[Calling]', Talking: '[Talking]'
  };
  Phone.prototype.numberOfLines = 1;
  Phone.prototype.supportsConference = false;
  Object.defineProperties(Phone.prototype, {
    isConnected: {get: function() {
        return this._isConnected
      }}, isInConference: {get: function() {
          return this._isInConference
        }}, isMuted: {get: function() {
          return this._isMuted
        }}, isRegistered: {get: function() {
          return this._isRegistered
        }}, selectedLineId: {get: function() {
          return this._selectedLineId
        }}, state: {get: function() {
          return this._lineStates[this._selectedLineId]
        }}
  });
  Phone.prototype.initialize = function(settings) {
    this.phonebar.log(THIS, DEBUG, "Initializing");
    this._settings = settings || {};
    const self = this;
    return new Promise(function(resolve) {
        Phone.events.initialized.addHandler(resolve, null, true);
        self._initializeElements();
        self._enableAllElements(false);
        self._initialize()
      })
  };
  Phone.prototype.connect = function() {
    this.phonebar.log(THIS, DEBUG, "Connecting");
    this._connect()
  };
  Phone.prototype.disconnect = function() {
    this.phonebar.log(THIS, DEBUG, "Disconnecting");
    this._disconnect()
  };
  Phone.prototype.setAccessToken = function(token) {
    this.phonebar.log(THIS, DEBUG, "Setting Access Token");
    this._accessToken = token;
    if (this._isConnected) {
      this._setAccessToken(token)
    }
  };
  Phone.prototype.terminate = function() {
    this.phonebar.log(THIS, DEBUG, "Terminating");
    this._terminate()
  };
  Phone.prototype.answer = function() {
    this.phonebar.log(THIS, DEBUG, "Answering");
    this._answer()
  };
  Phone.prototype.canConference = function() {
    if (!this.supportsConference) {
      return false
    }
    for (var i = 0, count = 0; i < this.numberOfLines; i++) {
      if (this._lineStates[i] === Phone.States.Talking)
        count++
    }
    return count > 1
  };
  Phone.prototype.dial = function(number) {
    if (!number && number !== 0) {
      this.phonebar.log(THIS, WARN, "No number to dial");
      return
    }
    if (this.state === Phone.States.Ringing) {
      this.phonebar.log(THIS, WARN, "Can't dial in current state");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Dialing number", number);
    if (this.state === Phone.States.Idle) {
      this._dial(number)
    }
    else {
      this._dtmf(number)
    }
  };
  Phone.prototype.dtmf = function(tones) {
    if (!tones && tones !== 0) {
      this.phonebar.log(THIS, WARN, "No dtmf to dial");
      return
    }
    if (this.state === Phone.States.Idle || this.state === Phone.States.Ringing) {
      this.phonebar.log(THIS, WARN, "Can't dial in current state");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Dialing tones", tones);
    this._dtmf(tones)
  };
  Phone.prototype.drop = function() {
    this.phonebar.log(THIS, DEBUG, "Dropping");
    this._drop()
  };
  Phone.prototype.enterConference = function() {
    if (!this.supportsConference) {
      this.phonebar.log(THIS, WARN, "Device doesn't support conference");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Entering conference");
    this._enterConference()
  };
  Phone.prototype.getLineState = function(lineId) {
    if (!(lineId >= 0 && lineId < this.numberOfLines)) {
      this.phonebar.log(THIS, WARN, "Invalid lineId specified:", lineId);
      return
    }
    return this._lineStates[lineId]
  };
  Phone.prototype.leaveConference = function() {
    if (!this.supportsConference) {
      this.phonebar.log(THIS, WARN, "Device doesn't support conference");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Leaving conference");
    this._leaveConference()
  };
  Phone.prototype.mute = function() {
    this.phonebar.log(THIS, DEBUG, "Muting microphone");
    this._mute()
  };
  Phone.prototype.register = function() {
    var domain = this.domain,
      extension = this.phonebar.agent.extension;
    this.phonebar.log(THIS, DEBUG, "Registering device to", domain, extension);
    this._register(domain, extension)
  };
  Phone.prototype.selectLine = function(lineId) {
    if (this.numberOfLines < 2) {
      this.phonebar.log(THIS, WARN, "Device doesn't support multiple lines");
      return
    }
    this.phonebar.log(THIS, DEBUG, "Selecting line", lineId);
    this._selectLine(lineId)
  };
  Phone.prototype.unmute = function() {
    this.phonebar.log(THIS, DEBUG, "Unmuting microphone");
    this._unmute()
  };
  Phone.prototype.unregister = function() {
    this.phonebar.log(THIS, DEBUG, "Unregistering device");
    this._unregister()
  };
  Phone.prototype._initialize = function(){};
  Phone.prototype._connect = function(){};
  Phone.prototype._disconnect = function(){};
  Phone.prototype._setAccessToken = function(token){};
  Phone.prototype._terminate = function(){};
  Phone.prototype._answer = function(){};
  Phone.prototype._dial = function(number){};
  Phone.prototype._dtmf = function(tones){};
  Phone.prototype._drop = function(){};
  Phone.prototype._enterConference = function(){};
  Phone.prototype._leaveConference = function(){};
  Phone.prototype._mute = function(){};
  Phone.prototype._register = function(domain, extension){};
  Phone.prototype._selectLine = function(lineId){};
  Phone.prototype._unmute = function(){};
  Phone.prototype._unregister = function(){};
  Phone.prototype._onInitialized = function() {
    this.phonebar.log(THIS, DEBUG, "Initialized");
    Phone.events.initialized.raise(this, {})
  };
  Phone.prototype._onConnected = function() {
    this.phonebar.log(THIS, DEBUG, "Connected");
    this._isConnected = true;
    this._enableAllElements(true);
    var E = Ifm.PhoneBar.UI.Elements;
    q(E.PhoneStateText).html("").removeClass("blink");
    Phone.events.connected.raise(this, {});
    if (this._accessToken) {
      this.setAccessToken(this._accessToken)
    }
  };
  Phone.prototype._onDisconnected = function(clean) {
    this.phonebar.log(THIS, DEBUG, "Disconnected");
    this._isConnected = false;
    this._enableAllElements(false);
    Phone.events.disconnected.raise(this, {clean: clean});
    if (this.phonebar.currentState() !== Ifm.PhoneBar.States.NotLoggedIn) {
      var E = Ifm.PhoneBar.UI.Elements;
      var S = Ifm.PhoneBar.Strings[this.phonebar.language()];
      q(E.PhoneStateText).html(S.PhoneNotConnected).addClass("blink");
      var self = this;
      setTimeout(function() {
        if (!self._isConnected && self.phonebar.currentState() !== Ifm.PhoneBar.States.NotLoggedIn) {
          self.connect()
        }
      }, 10000)
    }
  };
  Phone.prototype._onRegisteredStateChanged = function(isRegistered) {
    this.phonebar.log(THIS, INFO, "Device", isRegistered ? "is" : "is not", "registered");
    this._isRegistered = isRegistered;
    var E = Ifm.PhoneBar.UI.Elements;
    var S = Ifm.PhoneBar.Strings[this.phonebar.language()];
    if (isRegistered) {
      q(E.PhoneStateText).html("").removeClass("blink")
    }
    else if (this._isConnected) {
      var self = this;
      setTimeout(function() {
        if (self._isConnected && !self._isRegistered && self.phonebar.currentState() !== Ifm.PhoneBar.States.NotLoggedIn) {
          self.register();
          setTimeout(function() {
            if (self._isConnected && !self._isRegistered && self.phonebar.currentState() !== Ifm.PhoneBar.States.NotLoggedIn) {
              q(E.PhoneStateText).html(S.PhoneNotRegistered).addClass("blink")
            }
          }, 5000)
        }
      }, 5000)
    }
    Phone.events.registeredstatechanged.raise(this, {isRegistered: isRegistered})
  };
  Phone.prototype._onLineStateChanged = function(lineId, state) {
    this.phonebar.log(THIS, INFO, "Line", lineId + 1, "in state", state);
    this._lineStates[lineId] = state;
    this._updateLineSelectors(lineId, false, true);
    if (lineId === this._selectedLineId) {
      this._updateCurrentLineControls()
    }
    Phone.events.linestatechanged.raise(this, {
      lineId: lineId, state: state
    })
  };
  Phone.prototype._onConferenceStateChanged = function(inConference) {
    this.phonebar.log(THIS, DEBUG, "Lines are", inConference ? "" : "not", "in conference");
    this._isInConference = inConference;
    this._updateConferenceButtons(inConference);
    this._updateCurrentLineControls();
    Phone.events.conferencestatechanged.raise(this, {inConference: inConference})
  };
  Phone.prototype._onLineSelected = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Line", lineId + 1, "selected");
    this._selectedLineId = lineId;
    this._updateLineSelectors(lineId, true, false);
    Phone.events.lineselected.raise(this, {lineId: lineId})
  };
  Phone.prototype._onCalling = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Calling on line", lineId + 1);
    Phone.events.calling.raise(this, {lineId: lineId})
  };
  Phone.prototype._onCallConnected = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Call connected on line", lineId + 1);
    Phone.events.callconnected.raise(this, {lineId: lineId})
  };
  Phone.prototype._onCallDisconnected = function(lineId, sipCode, sipCause) {
    this.phonebar.log(THIS, DEBUG, "Call disconnected on line", lineId + 1, "; sip code:", sipCode, "sip cause:", sipCause);
    Phone.events.calldisconnected.raise(this, {
      lineId: lineId, sipCode: sipCode, sipCause: sipCause
    })
  };
  Phone.prototype._onDisplayName = function(lineId, displayName) {
    var call = this._getAudioCall();
    if (lineId === 0 && call && call.hideNumber) {
      displayName = call.displayNumber
    }
    this.phonebar.log(THIS, DEBUG, "Got display name", displayName, "for incoming call on line", lineId + 1);
    Phone.events.displayname.raise(this, {
      lineId: lineId, displayName: displayName
    })
  };
  Phone.prototype._onIncomingCall = function(lineId) {
    this.phonebar.log(THIS, DEBUG, "Incoming call on line", lineId + 1);
    Phone.events.incomingcall.raise(this, {lineId: lineId})
  };
  Phone.prototype._onRinging = function(lineId, rings) {
    this.phonebar.log(THIS, DEBUG, "Line", lineId + 1, "is ringing;", rings, "ring(s)");
    Phone.events.ringing.raise(this, {
      lineId: lineId, rings: rings
    });
    if (this.phonebar.options.autoAnswerPhone()) {
      var callType = 0;
      var call = this._getAudioCall();
      if (call === null)
        callType = 3;
      else if (call.callId < 32768)
        callType = 2;
      else
        callType = 1;
      if (callType <= this.phonebar.options.autoAnswerPhone() && rings >= this.phonebar.options.autoAnswerRings()) {
        this.phonebar.log(THIS, DEBUG, "Attempting autoanswer on line", lineId);
        this._answer()
      }
    }
  };
  Phone.prototype._onMuteChanged = function(isMuted) {
    this.phonebar.log(THIS, DEBUG, "Microphone is", isMuted ? "" : "not", "muted");
    this._isMuted = isMuted;
    this._updateMicMuteButtons(isMuted);
    Phone.events.mutechanged.raise(this, {isMuted: isMuted})
  };
  Phone.prototype._onVUMeter = function(microphone, speakers) {
    var E = Ifm.PhoneBar.UI.Elements;
    q(E.MicrophoneVUMeter).val(microphone);
    q(E.SpeakersVUMeter).val(speakers);
    Phone.events.vumeter.raise(this, {
      microphone: microphone, speakers: speakers
    })
  };
  Phone.prototype._getAudioCall = function() {
    return this.phonebar.calls(function(call) {
        return call.mediatype === Ifm.PhoneBar.Mediatypes.Voice
      })[0] || null
  };
  Phone.prototype._initializeElements = function() {
    var self = this;
    var E = Ifm.PhoneBar.UI.Elements;
    q('[class^="phonebar-phone"]').show();
    q(E.PhoneDialPad, E.HideDialPadButton).hide();
    q(E.ShowDialPadButton, E.ToggleDialPadButton).disable();
    q(E.NumberInput).on("change input", function(e) {
      self._updateCurrentLineFlashControls()
    });
    if (this.numberOfLines === 1) {
      q(E.Line1Button, E.Line2Button).remove()
    }
    else if (this.numberOfLines !== 2) {
      throw Error('Unsupported number of lines specified: ' + this.numberOfLines);
    }
    if (this.numberOfLines < 2 || !this.supportsConference) {
      q(E.EnterConferenceButton, E.LeaveConferenceButton).remove()
    }
  };
  Phone.prototype._enableAllElements = function(connected) {
    var E = Ifm.PhoneBar.UI.Elements;
    q(E.MicrophoneOnButton, E.MicrophoneOffButton, E.Line1Button, E.Line2Button).enabled(connected);
    q(E.MicrophoneOnButton).hide().enabled(connected);
    if (!connected) {
      q(E.PickupButton, E.LeaveConferenceButton).hide().disable();
      q(E.HangupButton, E.FlashButton, E.ManualTransferButton, E.EnterConferenceButton).disable();
      q(E.Line1Button, E.Line2Button).removeClass("selected");
      q(E.PhoneDialPad, E.HideDialPadButton).hide();
      q(E.HideDialPadButton, E.ShowDialPadButton, E.ToggleDialPadButton).disable();
      q('[class^="phonebar-phone-key"]').disable()
    }
    else {
      q(E.ShowDialPadButton, E.ToggleDialPadButton).enable();
      this._updateCurrentLineControls()
    }
  };
  Phone.prototype._updateCurrentLineControls = function() {
    var E = Ifm.PhoneBar.UI.Elements;
    switch (this.state) {
      case Phone.States.Incoming:
        q(E.HangupButton).hide().disable();
        q(E.PickupButton).show().enable();
        break;
      case Phone.States.Calling:
      case Phone.States.Talking:
        q(E.PickupButton).hide().disable();
        q(E.HangupButton).show().enable();
        break;
      default:
        q(E.PickupButton).hide().disable();
        q(E.HangupButton).show().disable();
        break
    }
    this._updateCurrentLineFlashControls()
  };
  Phone.prototype._updateCurrentLineFlashControls = function() {
    var E = Ifm.PhoneBar.UI.Elements;
    if (this.state === Phone.States.Talking) {
      q('[class^="phonebar-phone-key"]').enable();
      q(E.FlashButton).enabled(!this._isInConference);
      q(E.ManualTransferButton).enabled(!this._isInConference && q(E.NumberInput).val())
    }
    else {
      q('[class^="phonebar-phone-key"]', E.FlashButton, E.ManualTransferButton).disable()
    }
    if (this.phonebar.currentState() === Ifm.PhoneBar.States.WaitingOutbound && this._selectedLineId === 0) {
      q(E.CallButton).enabled(false)
    }
    else if (this._selectedLineId > 0) {
      q(E.CallButton).enabled(this.state === Phone.States.Idle && q(E.NumberInput).val())
    }
    else {
      this.updateCallButton()
    }
  };
  Phone.prototype._updateLineSelectors = function(lineId, updateSelection, updateState) {
    var E = Ifm.PhoneBar.UI.Elements;
    var t1 = lineId === 0 ? E.Line1Button : E.Line2Button,
      t2 = lineId === 1 ? E.Line1Button : E.Line2Button;
    if (updateSelection) {
      q(t2).removeClass("selected");
      q(t1).addClass("selected")
    }
    if (updateState) {
      switch (this._lineStates[lineId]) {
        case Phone.States.Idle:
          q(t1).removeClass("highlight blink");
          break;
        case Phone.States.Talking:
          q(t1).addClass("highlight").removeClass("blink");
          break;
        default:
          q(t1).addClass("highlight blink");
          break
      }
      if (this.supportsConference) {
        q(E.EnterConferenceButton).enabled(this.canConference())
      }
    }
    if (lineId === this._selectedLineId) {
      this._updateCurrentLineControls()
    }
  };
  Phone.prototype._updateConferenceButtons = function(inConference) {
    var E = Ifm.PhoneBar.UI.Elements;
    if (inConference) {
      q(E.EnterConferenceButton).hide().disable();
      q(E.LeaveConferenceButton).show().enable()
    }
    else {
      q(E.LeaveConferenceButton).hide().disable();
      q(E.EnterConferenceButton).show().disable();
      if (this.supportsConference && this.canConference()) {
        q(E.EnterConferenceButton).enable()
      }
    }
  };
  Phone.prototype._updateMicMuteButtons = function(isMuted) {
    var E = Ifm.PhoneBar.UI.Elements;
    var t1 = isMuted ? E.MicrophoneOffButton : E.MicrophoneOnButton,
      t2 = !isMuted ? E.MicrophoneOffButton : E.MicrophoneOnButton;
    q(t1).hide();
    q(t2).show()
  };
  Phone.prototype._updateVUMeterElements = function(microphone, speakers) {
    var E = Ifm.PhoneBar.UI.Elements;
    q(E.MicrophoneVUMeter).val(microphone);
    q(E.SpeakersVUMeter).val(speakers)
  };
  function q(args_selectors) {
    args_selectors = Array.prototype.slice.call(arguments);
    return jQuery(args_selectors.join(','))
  }
  var THIS = "PhoneBar.Media.Phone",
    DEBUG = 'Debug',
    INFO = 'Info',
    WARN = 'Warn';
  ns.Phone = Phone
})();
;
namespace("Ifm.PhoneBar.Strings", {en: {
    UnloadPageConfirm: "If you leave the page, you close any conversation open and you won't be able to receive new calls", NoBrowserSupport: "Your browser does not have the features needed to run the PhoneBar", Loading: "Loading", AccountLockedOut: "Your logon has been locked out. Contact the administrator", CantChangePassword: "You're not authorized to change your password", InvalidNewPassword: "The new password doesn't meet security requirements", PasswordExpired: "Your password has expired, change it to log in", PasswordsDontMatch: "The new passwords don't match", UserOrExtensionTaken: "Logon credentials or extension already taken", WrongCredentials: "Invalid logon credentials", InvalidExtension: "Invalid extension", ExtensionInUse: "Extension already taken", InvalidState: "Invalid state", TokenBasedLoginError: "Error occourred with domain authentication", NotLoggedInState: "Not available", ConnectingState: "Connecting", LoggedInState: "Available", PausedState: "Paused", ReadyState: "Available", TalkingState: "Talking", PostCallState: "In post-call", OtherCallState: "In manual conversation", AssignedState: "Assigned", AlertingState: "Incoming call", WaitingOutboundState: "Dialing call", WaitingTransferState: "Transferring", PhoneNotConnected: "Phone not connected", PhoneNotRegistered: "Phone not reachable", ConnectionFailed: "Connection failed", ConnectionLost: "Connection lost", AssignmentBooked: "Booked", PauseBooked: "Pause booked", RequestRefused: "Request refused", CallFailure: "Call failure", GenericBusyState: "Busy", CallFailureNoDialTone: "no dial tone", CallFailureNoRingback: "no ringback", CallFailureLineBusy: "number busy", CallFailureNoAnswer: "no answer", CallFailureFaxTone: "fax", CallFailureRemoteHangUp: "hangup", CallFailureAgentNoDialTone: "no dial tone by the agent", CallFailureAgentNoRingback: "no ringback by the agent", CallFailureAgentBusy: "agent busy", CallFailureAgentNoAnswer: "no answer by the agent", CallFailureUnknown: "unknown cause", OutboundManualCall: "Manual call", PauseGenericReason: "Generic pause", TooltipLogin: "Log in", TooltipLoginOrReady: "Ready", TooltipReady: "Ready", TooltipPause: "Pause", TooltipLogout: "Log out", TooltipCall: "Call", TooltipTransfer: "Transfer window", TooltipQueueInfo: "Display queue info", TooltipCampaignList: "Display assigned campaigns", TooltipCallRegistry: "Call Registry", TooltipPanic: "Request Assistance", TooltipMainMenu: "Menu", TooltipPhoneNumber: "Phone number", TooltipStartRec: "Start recording", TooltipStopRec: "Stop recording", TooltipMuteRec: "Suspend recording", TooltipUnmuteRec: "Resume recording", TooltipHangup: "Hang up", TooltipPickup: "Pick up", TooltipFlash: "Hold and retrieve", TooltipManualTransfer: "Manual transfer", TooltipMicVUMeter: "Microphone", TooltipSpkVUMeter: "Speakers", TooltipMicOff: "Turn microphone off", TooltipMicOn: "Turn microphone on", TooltipLine1: "Line 1", TooltipLine2: "Line 2", TooltipEnterConf: "Join conference", TooltipLeaveConf: "Leave conference", MenuItemAbout: "About PhoneBar", MenuItemCampaigns: "Assigned Campaigns", MenuItemDialpad: "Dialpad", MenuItemExit: "Exit", MenuItemPanic: "Request Assistance", MenuItemQueueInfo: "Queue State", MenuItemAutoHide: "Auto Hide", MenuItemDevTools: "Activate Debugger", MenuItemOptions: "Options", MenuItemRefresh: "Refresh", MenuItemReload: "Reload (no cache)", MenuItemReset: "Reset", MenuItemShowLogs: "Show Logs", ButtonOK: "OK", ButtonCancel: "Cancel", ButtonChangePassword: "Change Password...", ButtonRefresh: "Refresh", ButtonRetry: "Retry", ButtonTransfer: "Trasferisci", ButtonAnswer: "Answer", AssignmentsTitle: "Assigned Campaigns", CallRegistryTitle: "Call Registry", CallRegistryActiveTabTitle: "Active Calls", CallRegistryManagedTabTitle: "Managed Calls", CallRegistryFailedTabTitle: "Failed Calls", CallRegistryMediatypeHead: "Type", CallRegistryDateTimeHead: "Date/Time", CallRegistryCampaignHead: "Campaign", CallRegistryNumberHead: "Number", CallRegistryDisplayNameHead: "Name", IncomingCallText: "Incoming Call", UnknownCallingNumber: "Unknown Number", QueueInfoTitle: "Queue Info", QueuedAvgTimeText: "avg T", QueuedMaxTimeText: "max T", QueuedNumberText: "queued", LoginTitle: "Enter your credentials", LoginOAuth2Title: "Domain Authentication", LoginFirstName: "First name:", LoginLastName: "Last name:", LoginUsername: "Username:", LoginPassword: "Password:", LoginOldPassword: "Current password:", LoginNewPassword: "New password:", LoginConfirmPassword: "Confirm password:", LoginExtension: "Extension:", SupervisorTitle: "Supervisor Message", TransferTitle: "Call transfer", TransferCampaign: "Campaign:", TransferService: "Service:", TransferAnybody: "(Anybody)", TransferMandatory: "Transfer to the selected agent only", TransferSearchHelp: "Search for names...", DialpadTitle: "Dialpad", OptionsTitle: "Options & Preferences"
  }});
;
namespace("Ifm.PhoneBar.Strings", {it: {
    UnloadPageConfirm: "Se chiudi questa pagina, le conversazioni attive saranno perdute e non potrai ricevere nuove chiamate", NoBrowserSupport: "Questo browser non ha le funzioni necessarie per la PhoneBar", Loading: "Caricamento", AccountLockedOut: "Il tuo accesso \u00e8 stato sospeso. Contatta l'amministratore", CantChangePassword: "Non sei autorizzato a modificare la tua password", InvalidNewPassword: "La nuova password non soddisfa i criteri di sicurezza", PasswordExpired: "La tua password \u00e8 scaduta, cambiala per accedere", PasswordsDontMatch: "Le nuove password non corrispondono", UserOrExtensionTaken: "Credenziali di accesso o interno gi\u00e0 in uso", WrongCredentials: "Credenziali di accesso non valide", InvalidExtension: "Interno non valido", ExtensionInUse: "Interno gi\u00e0 in uso", InvalidState: "Stato non valido", TokenBasedLoginError: "Si \u00e8 verificato un errore con l'autenticazione di dominio", NotLoggedInState: "Non disponibile", ConnectingState: "Connessione in corso", LoggedInState: "Disponibile", PausedState: "In pausa", ReadyState: "Disponibile", TalkingState: "In conversazione", PostCallState: "In post-chiamata", OtherCallState: "In conversazione manuale", AssignedState: "In assegnazione", AlertingState: "Chiamata in arrivo", WaitingOutboundState: "In generazione chiamata", WaitingTransferState: "In trasferimento", PhoneNotConnected: "Telefono non collegato", PhoneNotRegistered: "Telefono non raggiungibile", ConnectionFailed: "Connessione fallita", ConnectionLost: "Caduta connessione", AssignmentBooked: "In pre-assegnazione", PauseBooked: "Pausa prenotata", RequestRefused: "Richiesta rifiutata", CallFailure: "Chiamata fallita", GenericBusyState: "Impegnato/a", CallFailureNoDialTone: "nessun tono di chiamata", CallFailureNoRingback: "nessuno squillo", CallFailureLineBusy: "numero occupato", CallFailureNoAnswer: "nessuna risposta", CallFailureFaxTone: "fax", CallFailureRemoteHangUp: "riaggancio", CallFailureAgentNoDialTone: "nessun tono di chiamata sull'operatore", CallFailureAgentNoRingback: "nessuno squillo sull'operatore", CallFailureAgentBusy: "operatore occupato", CallFailureAgentNoAnswer: "nessuna risposta da operatore", CallFailureUnknown: "causa sconosciuta", OutboundManualCall: "Chiamata manuale", PauseGenericReason: "Pausa generica", TooltipLogin: "Accesso", TooltipLoginOrReady: "Disponibile", TooltipReady: "Disponibile", TooltipPause: "Pause", TooltipLogout: "Logout", TooltipCall: "Chiama", TooltipTransfer: "Finestra di trasferimento", TooltipQueueInfo: "Mostra stato code", TooltipCampaignList: "Mostra campagne assegnate", TooltipCallRegistry: "Registro Chiamate", TooltipPanic: "Richiedi Assistenza", TooltipMainMenu: "Menu", TooltipPhoneNumber: "Numero di telefono", TooltipStartRec: "Avvia registrazione", TooltipStopRec: "Ferma registrazione", TooltipMuteRec: "Sospendi registrazione", TooltipUnmuteRec: "Riprendi registrazione", TooltipHangup: "Aggancia", TooltipPickup: "Rispondi", TooltipFlash: "In attesa e riprendi", TooltipManualTransfer: "Trasferimento manuale", TooltipMicVUMeter: "Microfono", TooltipSpkVUMeter: "Cuffie", TooltipMicOff: "Disattiva microfono", TooltipMicOn: "Attiva microfono", TooltipLine1: "Linea 1", TooltipLine2: "Linea 2", TooltipEnterConf: "Avvia conferenza", TooltipLeaveConf: "Chiudi conferenza", MenuItemAbout: "Info su PhoneBar", MenuItemCampaigns: "Campagne Assegnate", MenuItemDialpad: "Tastiera Virtuale", MenuItemExit: "Esci", MenuItemPanic: "Richiedi Assistenza", MenuItemQueueInfo: "Stato Code", MenuItemAutoHide: "Nascondi Automaticamente", MenuItemDevTools: "Attiva Debugger", MenuItemOptions: "Opzioni", MenuItemRefresh: "Ricarica", MenuItemReload: "Ricarica (no cache)", MenuItemReset: "Reimposta", MenuItemShowLogs: "Mostra Logs", ButtonOK: "OK", ButtonCancel: "Annulla", ButtonChangePassword: "Cambia Password...", ButtonRefresh: "Aggiorna", ButtonRetry: "Riprova", ButtonTransfer: "Trasferisci", ButtonAnswer: "Rispondi", AssignmentsTitle: "Assegnazioni", CallRegistryTitle: "Registro Chiamate", CallRegistryActiveTabTitle: "Chiamate Attive", CallRegistryManagedTabTitle: "Chiamate Gestite", CallRegistryFailedTabTitle: "Chiamate Fallite", CallRegistryMediatypeHead: "Tipo", CallRegistryDateTimeHead: "Data/Ora", CallRegistryCampaignHead: "Campagna", CallRegistryNumberHead: "Numero", CallRegistryDisplayNameHead: "Nome", IncomingCallText: "Chiamata in arrivo", UnknownCallingNumber: "Numero Sconosciuto", QueueInfoTitle: "Stato Code", QueuedAvgTimeText: "T medio", QueuedMaxTimeText: "T max", QueuedNumberText: "in coda", LoginTitle: "Inserisci le tue credenziali", LoginOAuth2Title: "Autenticazione di dominio", LoginFirstName: "Nome:", LoginLastName: "Cognome:", LoginUsername: "Username:", LoginPassword: "Password:", LoginOldPassword: "Password attuale:", LoginNewPassword: "Nuova password:", LoginConfirmPassword: "Conferma password:", LoginExtension: "Interno:", SupervisorTitle: "Messaggio del Supervisore", TransferTitle: "Trasferimento di chiamata", TransferCampaign: "Campagna:", TransferService: "Servizio:", TransferAnybody: "(Chiunque)", TransferMandatory: "Trasferisci solo all'agente selezionato", TransferSearchHelp: "Ricerca per nome...", DialpadTitle: "Tastiera Virtuale", OptionsTitle: "Opzioni & Preferenze"
  }})
