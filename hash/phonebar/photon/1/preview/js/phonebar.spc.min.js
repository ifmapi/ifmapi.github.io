
//============================================================================

// Copyright (c) Base Digitale Platform. All rights reserved.

//============================================================================

"use strict";
(function() {
  var ns = namespace("Ifm.SoftPhone");
  ns.about = {
    title: "softphone.js", version: "1.0.8-3420"
  };
  ns.instance = (function() {
    var instance = {};
    instance.events = defineEvents("connected", "disconnected", "readytogo", "registered", "notregistered", "bandwidth", "conference", "lineselected", "dnd", "mute", "linestate", "incomingcall", "ringing", "displayname", "calling", "callconnected", "calldisconnected", "vumeter");
    Object.defineProperties(instance, {
      domain: {get: function() {
          return domain
        }}, extension: {get: function() {
            return extension
          }}, lines: {value: []}, isInitialized: {get: function() {
            return isInitialized
          }}, isConnected: {get: function() {
            return ws && ws.isOpen
          }}, isRegistered: {get: function() {
            return isRegistered
          }}, inDND: {get: function() {
            return instance.lines[0].inDND && instance.lines[1].inDND
          }}, isMuted: {get: function() {
            return isMuted
          }}, inConference: {get: function() {
            return inConference
          }}, selectedLine: {get: function() {
            return selectedLine
          }}
    });
    instance.initialize = function() {
      instance.initialize = function(){};
      instance.lines.push(new ns.Line(0, sendMessage));
      instance.lines.push(new ns.Line(1, sendMessage));
      resetVuMeter();
      isInitialized = true
    };
    instance.connect = function(config) {
      var service = defaultServiceUrl;
      if (config && config.service) {
        if (Ifm.Type.isArray(config.service) && config.service.length > 0) {
          service = config.service[0]
        }
        else if (Ifm.Type.isString(config.service)) {
          service = config.service
        }
        else
          throw Ifm.Diagnostics.Errors.arg("config.service");
      }
      ws && ws.close();
      ws = Ifm.Net.WebSocket.create(service, "isp");
      ws.events.closed = function(s, e) {
        ws = null;
        if (!e.clean && Ifm.Type.isArray(config.service) && config.service.length > 1) {
          instance.connect({service: config.service.splice(1)})
        }
        else {
          instance.events.disconnected.raise(e)
        }
      };
      ws.events.open = function(s, e) {
        instance.events.connected.raise(e)
      };
      ws.events.receive = function(s, e) {
        if (e.type === Ifm.Net.WebSocket.MessageType.TEXT) {
          receiveMessage(e.message)
        }
      };
      ws.connect()
    };
    instance.disconnect = function() {
      ws && ws.close()
    };
    instance.register = function(domain, extension, callback) {
      sendMessage("#register", "|" + domain + "|" + extension, callback)
    };
    instance.unregister = function(callback) {
      sendMessage("#unregister", "", callback)
    };
    instance.setBandwidth = function(value, callback) {
      sendMessage("#setbandwidth", "|" + value, callback)
    };
    instance.selectLine = function(line, callback) {
      sendMessage("#selectline", "|" + line, callback)
    };
    instance.canConference = function(callback) {
      if (callback && !Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      sendMessage("#canconference", "", callback)
    };
    instance.enterConference = function(callback) {
      sendMessage("#enterconference", "", callback)
    };
    instance.leaveConference = function(callback) {
      sendMessage("#leaveconference", "", callback)
    };
    instance.toggleConference = function(callback) {
      if (inConference) {
        instance.leaveConference(callback)
      }
      else {
        instance.canConference(function(result) {
          if (result) {
            instance.enterConference(callback)
          }
        })
      }
    };
    instance.setDND = function(status, callback) {
      instance.lines[0].setDND(status, callback);
      instance.lines[1].setDND(status)
    };
    instance.canAnswer = function(callback) {
      instance.lines[selectedLine].canAnswer(callback)
    };
    instance.answer = function(callback) {
      instance.lines[selectedLine].answer(callback)
    };
    instance.canDial = function(callback) {
      instance.lines[selectedLine].canDial(callback)
    };
    instance.dial = function(number, callback) {
      instance.lines[selectedLine].dial(number, callback)
    };
    instance.canSendDigits = function(callback) {
      instance.lines[selectedLine].canSendDigits(callback)
    };
    instance.sendDigits = function(digits, callback) {
      instance.lines[selectedLine].sendDigits(digits, callback)
    };
    instance.canDrop = function(callback) {
      instance.lines[selectedLine].canDrop(callback)
    };
    instance.drop = function(callback) {
      instance.lines[selectedLine].drop(callback)
    };
    instance.setMute = function(status, callback) {
      sendMessage("#setmute", "|" + status, callback)
    };
    instance.toggleMic = function(callback) {
      sendMessage("#setmute", "|" + !isMuted, callback)
    };
    instance.soundcheck = function(callback) {
      sendMessage("#soundcheck", "", callback)
    };
    instance.stopSoundcheck = function(callback) {
      sendMessage("#stopsoundcheck", "", callback)
    };
    instance.playFile = function(file, callback) {
      instance.lines[selectedLine].playFile(file, callback)
    };
    instance.stopFile = function(callback) {
      instance.lines[selectedLine].stopFile(callback)
    };
    instance.setToken = function(token, callback) {
      sendMessage("#settoken", "|" + token, callback)
    };
    function receiveMessage(message) {
      try {
        onMessage(message)
      }
      catch(err) {
        console.error("Error processing message:", message, err)
      }
    }
    function onMessage(message) {
      var parts = message.split("|");
      switch (parts[0]) {
        case"#ready":
          break;
        case"#go":
          instance.events.readytogo.raise({});
          break;
        case"#audio":
          break;
        case"#registered":
          isRegistered = true;
          domain = parts[1];
          extension = parts[2];
          instance.events.registered.raise({
            domain: domain, extension: extension
          });
          break;
        case"#notregistered":
          isRegistered = false;
          domain = null;
          extension = null;
          instance.events.notregistered.raise({});
          break;
        case"#bandwidth":
          bandwidth = Number(parts[1]);
          instance.events.bandwidth.raise({bandwidth: bandwidth});
          break;
        case"#conference":
          inConference = parts[1] === "True";
          instance.events.conference.raise({inConference: inConference});
          break;
        case"#lineselected":
          selectedLine = Number(parts[1]);
          instance.events.lineselected.raise({line: selectedLine});
          break;
        case"#dnd":
          instance.lines[parts[1]]._updateDND(parts[2] === "True");
          break;
        case"#mute":
          isMuted = parts[1] === "True";
          Ifm.SoftPhone.instance.events.mute.raise({isMuted: isMuted});
          break;
        case"#linestate":
          instance.lines[parts[1]]._update(parts);
          break;
        case"#callrefused":
          break;
        case"#incomingcall":
          instance.events.incomingcall.raise({line: Number(parts[1])});
          break;
        case"#ringing":
          instance.events.ringing.raise({
            line: Number(parts[1]), rings: Number(parts[2])
          });
          break;
        case"#displayname":
          instance.events.displayname.raise({
            line: Number(parts[1]), displayName: parts[2]
          });
          break;
        case"#calling":
          instance.events.calling.raise({
            line: Number(parts[1]), displayName: parts[2]
          });
          break;
        case"#callprogress":
          break;
        case"#callconnected":
          instance.events.callconnected.raise({
            line: Number(parts[1]), displayName: parts[2]
          });
          break;
        case"#calldisconnected":
          var sipCode = Number(parts[3]);
          instance.events.calldisconnected.raise({
            line: Number(parts[1]), displayName: parts[2], sipCode: sipCode, sipCause: parts[4], wasByed: sipCode === 99, wasCanceled: sipCode === 98
          });
          break;
        case"#vumeter":
          var micvalue = Number(parts[1]),
            spkvalue = Number(parts[2]);
          vumic.shift();
          vumic.push(micvalue);
          vuspk.shift();
          vuspk.push(spkvalue);
          instance.events.vumeter.raise({
            microphone: micvalue, micdata: vumic, speakers: spkvalue, spkdata: vuspk
          });
          break;
        default:
          if (callbacks[parts[0]]) {
            var callback = callbacks[parts[0]].shift();
            callback && callback(Number(parts[1]))
          }
          else {
            console.warn("Unexpected notification:", parts[0])
          }
          break
      }
    }
    function sendMessage(request, message, callback) {
      if (!ws || !ws.isOpen || !request || !request.length) {
        console.warn("Unexpected or invalid sendMessage request");
        return
      }
      message = message || "";
      if (callbacks[request] === undefined) {
        callbacks[request] = []
      }
      callbacks[request].push(function(result) {
        if (result === 400) {
          console.error("Bad request:", request + message)
        }
        else if (result === 0) {
          console.debug("Request", request, "succeeded")
        }
        else if (result === 200 || result === 202) {
          result = result === 200 ? true : false;
          console.debug("Request", request, "succeeded, result:", result)
        }
        else {
          console.warn("Request", request, "failed:", result)
        }
        typeof callback === "function" && callback(result)
      });
      ws.send(request + message)
    }
    function resetVuMeter() {
      var i = vumemory;
      while (i--)
        vumic[i] = vuspk[i] = 0
    }
    var defaultServiceUrl = "ws://localhost:6080/";
    var ws,
      callbacks = [];
    var vumemory = 8;
    var vumic = new Array(vumemory),
      vuspk = new Array(vumemory);
    var domain = null,
      extension = null;
    var isInitialized = false,
      isRegistered = false,
      isMuted = false,
      inConference = false;
    var selectedLine = 0,
      bandwidth = 2;
    return instance
  })()
})();
;
(function() {
  var ns = namespace("Ifm.SoftPhone");
  ns.LineStates = {
    Idle: "Idle", Calling: "Calling", IncomingCall: "IncomingCall", Talking: "Talking"
  };
  ns.Line = (function(index, sendMessage) {
    var instance = {};
    Object.defineProperties(instance, {
      index: {value: index}, isSelected: {get: function() {
            return selectedLine === index
          }}, inDND: {get: function() {
            return inDND
          }}, isMuted: {get: function() {
            return Ifm.SoftPhone.instance.isMuted
          }}, state: {get: function() {
            return state
          }}, stateTime: {get: function() {
            return stateTime
          }}
    });
    instance.setDND = function(status, callback) {
      sendMessage("#setdnd", "|" + index + "|" + status, callback)
    };
    instance.canAnswer = function(callback) {
      if (callback && !Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      sendMessage("#cananswer", "|" + index, callback)
    };
    instance.answer = function(callback) {
      sendMessage("#answer", "|" + index, callback)
    };
    instance.canDial = function(callback) {
      if (callback && !Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      sendMessage("#candial", "|" + index, callback)
    };
    instance.dial = function(number, callback) {
      sendMessage("#dial", "|" + index + "|" + number, callback)
    };
    instance.canSendDigits = function(callback) {
      if (callback && !Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      sendMessage("#cansenddigits", "|" + index, callback)
    };
    instance.sendDigits = function(digits, callback) {
      sendMessage("#senddigits", "|" + index + "|" + digits, callback)
    };
    instance.canDrop = function(callback) {
      if (callback && !Ifm.Type.isFunction(callback)) {
        throw Ifm.Diagnostics.Errors.func("callback");
      }
      sendMessage("#candrop", "|" + index, callback)
    };
    instance.drop = function(callback) {
      sendMessage("#drop", "|" + index, callback)
    };
    instance.playFile = function(file, callback) {
      sendMessage("#playfile", "|" + index + "|" + file, callback)
    };
    instance.stopFile = function(callback) {
      sendMessage("#stopfile", "|" + index, callback)
    };
    instance._update = function(e) {
      state = e[2],
      stateTime = Number(e[3]);
      Ifm.SoftPhone.instance.events.linestate.raise({
        line: index, state: state, stateTime: stateTime
      })
    };
    instance._updateDND = function(status) {
      inDND = status;
      Ifm.SoftPhone.instance.events.dnd.raise({
        line: index, inDND: inDND
      })
    };
    var inDND,
      state,
      stateTime;
    return instance
  })
})();
;
(function() {
  var ns = namespace("Ifm.PhoneBar.Media");
  var Phone = ns.Phone;
  function SPC() {
    Phone.apply(this, arguments);
    this.phonebar.log(THIS, DEBUG, "Creating instance")
  }
  var base = inherits(SPC, Phone);
  SPC.prototype.numberOfLines = 2;
  SPC.prototype.supportsConference = true;
  SPC.prototype._initialize = function() {
    this.phonebar.log(THIS, DEBUG, "Initializing SoftPhone");
    this.domain = (this._settings.softphoneconfig && this._settings.softphoneconfig.domain) || '';
    this.softphone = Ifm.SoftPhone.instance;
    this.softphone.initialize();
    bindEvents(this);
    this._onInitialized()
  };
  SPC.prototype._connect = function() {
    this.phonebar.log(THIS, DEBUG, "Connecting to SoftPhone Controller service");
    this.softphone.connect(this._settings.softphoneconfig)
  };
  SPC.prototype._disconnect = function() {
    this.phonebar.log(THIS, DEBUG, "Disconnecting from SoftPhone Controller service");
    this.softphone.disconnect()
  };
  SPC.prototype._terminate = function() {
    this.phonebar.log(THIS, DEBUG, "Terminating SoftPhone");
    unbindEvents(this)
  };
  SPC.prototype._setAccessToken = function(token) {
    this.phonebar.log(THIS, DEBUG, "Setting Access Token");
    this.softphone.setToken(token)
  };
  SPC.prototype._answer = function() {
    this.phonebar.log(THIS, DEBUG, "Answering on line", this.softphone.selectedLine + 1);
    this.softphone.answer()
  };
  SPC.prototype._dial = function(number) {
    this.phonebar.log(THIS, DEBUG, "Dialing number", number, "on line", this.softphone.selectedLine + 1);
    this.softphone.dial(number)
  };
  SPC.prototype._dtmf = function(tones) {
    this.phonebar.log(THIS, DEBUG, "Dialing tones", tones, "on line", this.softphone.selectedLine + 1);
    this.softphone.sendDigits(tones)
  };
  SPC.prototype._drop = function() {
    this.phonebar.log(THIS, DEBUG, "Dropping on line", this.softphone.selectedLine + 1);
    this.softphone.drop()
  };
  SPC.prototype._enterConference = function() {
    this.softphone.enterConference()
  };
  SPC.prototype._leaveConference = function() {
    this.softphone.leaveConference()
  };
  SPC.prototype._mute = function() {
    this.softphone.setMute(true)
  };
  SPC.prototype._register = function(domain, extension) {
    if (!domain || !extension) {
      this.phonebar.log(THIS, WARN, "SoftPhone can't register without domain and extension");
      return
    }
    if (this.softphone.isRegistered && this.softphone.domain === domain && this.softphone.extension === extension) {
      this.phonebar.log(THIS, DEBUG, "SoftPhone already registered:", domain, extension);
      return
    }
    this.softphone.register(domain, extension)
  };
  SPC.prototype._selectLine = function(lineId) {
    if (this.softphone.selectedLine === lineId) {
      this.phonebar.log(THIS, DEBUG, "Line already selected:", lineId);
      return
    }
    this.softphone.selectLine(lineId)
  };
  SPC.prototype._unmute = function() {
    this.softphone.setMute(false)
  };
  SPC.prototype._unregister = function() {
    this.softphone.unregister()
  };
  SPC.prototype._onSoftPhoneConnected = function(e) {
    this.phonebar.log(THIS, INFO, "Connected to SoftPhone Controller service");
    this._onConnected()
  };
  SPC.prototype._onSoftPhoneDisconnected = function(e) {
    this.phonebar.log(THIS, INFO, e.reason || "Disconnected from SoftPhone Controller service");
    this._onDisconnected(e.clean)
  };
  SPC.prototype._onSoftPhoneReadyToGo = function(e) {
    this.phonebar.log(THIS, DEBUG, "Device ready to receive commands");
    this.softphone.setMute(false);
    if (this._selectedLineId > 0) {
      this.selectLine(0)
    }
    this.register()
  };
  SPC.prototype._onSoftPhoneRegistered = function(e) {
    this.phonebar.log(THIS, DEBUG, "SoftPhone registered to ", e.domain, e.extension);
    this._onRegisteredStateChanged(true)
  };
  SPC.prototype._onSoftPhoneNotRegistered = function(e) {
    this.phonebar.log(THIS, DEBUG, "SoftPhone not registered");
    this._onRegisteredStateChanged(false)
  };
  SPC.prototype._onSoftPhoneBandwidth = function(e) {
    this.phonebar.log(THIS, DEBUG, "Bandwidth set to ", e.bandwidth)
  };
  SPC.prototype._onSoftPhoneConference = function(e) {
    this._onConferenceStateChanged(e.inConference)
  };
  SPC.prototype._onSoftPhoneDND = function(e) {
    this.phonebar.log(THIS, DEBUG, "DND state changed for line ", e.line + 1, "; DND is", e.inDND ? "ON" : "OFF")
  };
  SPC.prototype._onSoftPhoneLineSelected = function(e) {
    this._onLineSelected(e.line)
  };
  SPC.prototype._onSoftPhoneLineState = function(e) {
    var LS = Ifm.SoftPhone.LineStates,
      state;
    if (e.state === LS.Calling) {
      state = Phone.States.Calling
    }
    else if (e.state === LS.IncomingCall) {
      state = Phone.States.Incoming
    }
    else if (e.state === LS.Talking) {
      state = Phone.States.Talking
    }
    else {
      state = Phone.States.Idle
    }
    this._onLineStateChanged(e.line, state)
  };
  SPC.prototype._onSoftPhoneCalling = function(e) {
    this._onCalling(e.line)
  };
  SPC.prototype._onSoftPhoneCallConnected = function(e) {
    this._onCallConnected(e.line)
  };
  SPC.prototype._onSoftPhoneCallDisconnected = function(e) {
    this._onCallDisconnected(e.line, e.sipCode, e.sipCause)
  };
  SPC.prototype._onSoftPhoneDisplayName = function(e) {
    this._onDisplayName(e.line, e.displayName)
  };
  SPC.prototype._onSoftPhoneIncomingCall = function(e) {
    this._onIncomingCall(e.line)
  };
  SPC.prototype._onSoftPhoneRinging = function(e) {
    this._onRinging(e.line, e.rings)
  };
  SPC.prototype._onSoftPhoneMute = function(e) {
    this._onMuteChanged(e.isMuted)
  };
  SPC.prototype._onSoftPhoneVUMeter = function(e) {
    this._onVUMeter(e.microphone, e.speakers)
  };
  function bindEvents(self) {
    var on = self.softphone.events;
    on.connected.addHandler(self._onSoftPhoneConnected, self);
    on.disconnected.addHandler(self._onSoftPhoneDisconnected, self);
    on.readytogo.addHandler(self._onSoftPhoneReadyToGo, self);
    on.registered.addHandler(self._onSoftPhoneRegistered, self);
    on.notregistered.addHandler(self._onSoftPhoneNotRegistered, self);
    on.bandwidth.addHandler(self._onSoftPhoneBandwidth, self);
    on.conference.addHandler(self._onSoftPhoneConference, self);
    on.dnd.addHandler(self._onSoftPhoneDND, self);
    on.lineselected.addHandler(self._onSoftPhoneLineSelected, self);
    on.linestate.addHandler(self._onSoftPhoneLineState, self);
    on.calling.addHandler(self._onSoftPhoneCalling, self);
    on.callconnected.addHandler(self._onSoftPhoneCallConnected, self);
    on.calldisconnected.addHandler(self._onSoftPhoneCallDisconnected, self);
    on.displayname.addHandler(self._onSoftPhoneDisplayName, self);
    on.incomingcall.addHandler(self._onSoftPhoneIncomingCall, self);
    on.ringing.addHandler(self._onSoftPhoneRinging, self);
    on.mute.addHandler(self._onSoftPhoneMute, self);
    on.vumeter.addHandler(self._onSoftPhoneVUMeter, self)
  }
  function unbindEvents(self) {
    var on = self.softphone.events;
    on.connected.removeHandler(self._onSoftPhoneConnected);
    on.disconnected.removeHandler(self._onSoftPhoneDisconnected);
    on.readytogo.removeHandler(self._onSoftPhoneReadyToGo);
    on.registered.removeHandler(self._onSoftPhoneRegistered);
    on.notregistered.removeHandler(self._onSoftPhoneNotRegistered);
    on.bandwidth.removeHandler(self._onSoftPhoneBandwidth);
    on.conference.removeHandler(self._onSoftPhoneConference);
    on.dnd.removeHandler(self._onSoftPhoneDND);
    on.lineselected.removeHandler(self._onSoftPhoneLineSelected);
    on.linestate.removeHandler(self._onSoftPhoneLineState);
    on.calling.removeHandler(self._onSoftPhoneCalling);
    on.callconnected.removeHandler(self._onSoftPhoneCallConnected);
    on.calldisconnected.removeHandler(self._onSoftPhoneCallDisconnected);
    on.displayname.removeHandler(self._onSoftPhoneDisplayName);
    on.incomingcall.removeHandler(self._onSoftPhoneIncomingCall);
    on.ringing.removeHandler(self._onSoftPhoneRinging);
    on.mute.removeHandler(self._onSoftPhoneMute);
    on.vumeter.removeHandler(self._onSoftPhoneVUMeter)
  }
  var THIS = "PhoneBar.Media.Phone.SPC",
    DEBUG = 'Debug',
    INFO = 'Info',
    WARN = 'Warn';
  ns.SPC = SPC
})()
